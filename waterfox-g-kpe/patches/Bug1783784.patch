From 6de6ae84f2b073f61c1f0f970569fe675e9f99b7 Mon Sep 17 00:00:00 2001
Date: Mon, 22 Aug 2022 19:41:23 +0200
Subject: [PATCH] Bug 1783784 - Update packed_simd_2 to 0.3.8.

---
 .cargo/config.in                              |   2 +-
 Cargo.lock                                    |  49 +-
 Cargo.toml                                    |   2 +-
 config/makefiles/rust.mk                      |   2 +-
 .../mozbuild/mozbuild/vendor/vendor_rust.py   |   7 +
 .../rust/encoding_rs/.cargo-checksum.json     |   2 +-
 third_party/rust/encoding_rs/CONTRIBUTING.md  |   5 +-
 third_party/rust/encoding_rs/COPYRIGHT        |   7 +-
 third_party/rust/encoding_rs/Cargo.toml       |  52 +-
 third_party/rust/encoding_rs/LICENSE-MIT      |   2 +-
 third_party/rust/encoding_rs/LICENSE-WHATWG   |  26 +
 third_party/rust/encoding_rs/README.md        | 109 ++-
 third_party/rust/encoding_rs/ci/miri.sh       |  14 +
 .../encoding_rs/generate-encoding-data.py     |  23 +-
 third_party/rust/encoding_rs/src/ascii.rs     |  41 +-
 third_party/rust/encoding_rs/src/big5.rs      |  40 +-
 third_party/rust/encoding_rs/src/data.rs      |   2 +-
 third_party/rust/encoding_rs/src/euc_jp.rs    |  13 +-
 third_party/rust/encoding_rs/src/euc_kr.rs    |  12 +-
 third_party/rust/encoding_rs/src/gb18030.rs   |  60 +-
 third_party/rust/encoding_rs/src/handles.rs   |  50 +-
 .../rust/encoding_rs/src/iso_2022_jp.rs       |  62 +-
 third_party/rust/encoding_rs/src/lib.rs       | 197 +++--
 third_party/rust/encoding_rs/src/macros.rs    |   6 +-
 third_party/rust/encoding_rs/src/mem.rs       | 115 +--
 .../rust/encoding_rs/src/replacement.rs       |   6 +-
 third_party/rust/encoding_rs/src/shift_jis.rs |  12 +-
 .../rust/encoding_rs/src/simd_funcs.rs        |  37 +-
 .../rust/encoding_rs/src/single_byte.rs       |  22 +-
 .../rust/encoding_rs/src/test_labels_names.rs |   9 +
 third_party/rust/encoding_rs/src/testing.rs   |  16 +-
 third_party/rust/encoding_rs/src/utf_16.rs    |   8 +-
 third_party/rust/encoding_rs/src/utf_8.rs     |  22 +-
 third_party/rust/encoding_rs/src/variant.rs   |   2 +-
 .../rust/encoding_rs/src/x_user_defined.rs    |   8 +-
 third_party/rust/packed_simd/build.rs         |  34 -
 third_party/rust/packed_simd/rustfmt.toml     |   7 -
 .../rust/packed_simd/src/api/cast/v128.rs     |  79 --
 .../rust/packed_simd/src/api/cast/v16.rs      |  17 -
 .../rust/packed_simd/src/api/cast/v256.rs     |  81 ---
 .../rust/packed_simd/src/api/cast/v32.rs      |  30 -
 .../rust/packed_simd/src/api/cast/v512.rs     |  68 --
 .../rust/packed_simd/src/api/cast/v64.rs      |  47 --
 .../packed_simd/src/api/into_bits/v128.rs     |  28 -
 .../packed_simd/src/api/into_bits/v256.rs     |  27 -
 .../packed_simd/src/api/into_bits/v512.rs     |  27 -
 .../rust/packed_simd/src/codegen/llvm.rs      | 128 ----
 .../packed_simd/src/codegen/math/float.rs     |  18 -
 .../src/codegen/pointer_sized_int.rs          |  28 -
 .../packed_simd/src/codegen/reductions.rs     |   1 -
 .../rust/packed_simd/src/testing/macros.rs    |  44 --
 .../.appveyor.yml                             |   0
 .../.cargo-checksum.json                      |   2 +-
 .../.travis.yml                               |  31 +-
 .../{packed_simd => packed_simd_2}/Cargo.toml |  34 +-
 .../LICENSE-APACHE                            |   0
 .../LICENSE-MIT                               |   0
 .../{packed_simd => packed_simd_2}/README.md  |  31 +-
 .../{packed_simd => packed_simd_2}/bors.toml  |   0
 third_party/rust/packed_simd_2/build.rs       |  11 +
 .../{packed_simd => packed_simd_2}/ci/all.sh  |   0
 .../ci/android-install-ndk.sh                 |   0
 .../ci/android-install-sdk.sh                 |   0
 .../ci/android-sysimage.sh                    |   0
 .../ci/benchmark.sh                           |   0
 .../ci/deploy_and_run_on_ios_simulator.rs     |   0
 .../docker/aarch64-linux-android/Dockerfile   |   0
 .../aarch64-unknown-linux-gnu/Dockerfile      |   0
 .../docker/arm-linux-androideabi/Dockerfile   |   0
 .../arm-unknown-linux-gnueabi/Dockerfile      |   0
 .../arm-unknown-linux-gnueabihf/Dockerfile    |   0
 .../armv7-unknown-linux-gnueabihf/Dockerfile  |   0
 .../docker/i586-unknown-linux-gnu/Dockerfile  |   0
 .../docker/i686-unknown-linux-gnu/Dockerfile  |   0
 .../docker/mips-unknown-linux-gnu/Dockerfile  |   0
 .../mips64-unknown-linux-gnuabi64/Dockerfile  |   0
 .../Dockerfile                                |   0
 .../mipsel-unknown-linux-musl/Dockerfile      |   0
 .../powerpc-unknown-linux-gnu/Dockerfile      |   0
 .../powerpc64-unknown-linux-gnu/Dockerfile    |   0
 .../powerpc64le-unknown-linux-gnu/Dockerfile  |   0
 .../docker/s390x-unknown-linux-gnu/Dockerfile |   0
 .../sparc64-unknown-linux-gnu/Dockerfile      |   0
 .../thumbv7neon-linux-androideabi/Dockerfile  |   0
 .../Dockerfile                                |   0
 .../docker/wasm32-unknown-unknown/Dockerfile  |   9 +-
 .../ci/docker/x86_64-linux-android/Dockerfile |   0
 .../Dockerfile                                |   0
 .../x86_64-unknown-linux-gnu/Dockerfile       |   0
 .../{packed_simd => packed_simd_2}/ci/dox.sh  |   0
 .../ci/linux-s390x.sh                         |   0
 .../ci/linux-sparc64.sh                       |   0
 .../ci/lld-shim.rs                            |   0
 .../ci/max_line_width.sh                      |   0
 .../ci/run-docker.sh                          |   0
 .../{packed_simd => packed_simd_2}/ci/run.sh  |   0
 .../ci/run_examples.sh                        |   0
 .../ci/runtest-android.rs                     |   0
 .../ci/setup_benchmarks.sh                    |   0
 .../ci/test-runner-linux                      |   0
 .../contributing.md                           |   2 +-
 .../perf-guide/.gitignore                     |   0
 .../perf-guide/book.toml                      |   0
 .../perf-guide/src/SUMMARY.md                 |   0
 .../perf-guide/src/ascii.css                  |   0
 .../perf-guide/src/bound_checks.md            |   0
 .../perf-guide/src/float-math/approx.md       |   0
 .../perf-guide/src/float-math/fma.md          |   0
 .../perf-guide/src/float-math/fp.md           |   0
 .../perf-guide/src/float-math/svml.md         |   0
 .../perf-guide/src/introduction.md            |   0
 .../perf-guide/src/prof/linux.md              |   0
 .../perf-guide/src/prof/mca.md                |   0
 .../perf-guide/src/prof/profiling.md          |   0
 .../src/target-feature/attribute.md           |   0
 .../perf-guide/src/target-feature/features.md |   0
 .../perf-guide/src/target-feature/inlining.md |   0
 .../perf-guide/src/target-feature/practice.md |   0
 .../perf-guide/src/target-feature/runtime.md  |   0
 .../src/target-feature/rustflags.md           |   6 +-
 .../perf-guide/src/vert-hor-ops.md            |   0
 third_party/rust/packed_simd_2/rustfmt.toml   |   5 +
 .../{packed_simd => packed_simd_2}/src/api.rs |   4 +-
 .../src/api/bit_manip.rs                      |   0
 .../src/api/bitmask.rs                        |   0
 .../src/api/cast.rs                           |   0
 .../src/api/cast/macros.rs                    |   0
 .../rust/packed_simd_2/src/api/cast/v128.rs   | 302 ++++++++
 .../rust/packed_simd_2/src/api/cast/v16.rs    |  68 ++
 .../rust/packed_simd_2/src/api/cast/v256.rs   | 298 ++++++++
 .../rust/packed_simd_2/src/api/cast/v32.rs    | 132 ++++
 .../rust/packed_simd_2/src/api/cast/v512.rs   | 209 ++++++
 .../rust/packed_simd_2/src/api/cast/v64.rs    | 208 ++++++
 .../src/api/cmp.rs                            |   0
 .../src/api/cmp/eq.rs                         |   0
 .../src/api/cmp/ord.rs                        |   0
 .../src/api/cmp/partial_eq.rs                 |   4 +-
 .../src/api/cmp/partial_ord.rs                |   8 +-
 .../src/api/cmp/vertical.rs                   |   0
 .../src/api/default.rs                        |   0
 .../src/api/fmt.rs                            |   0
 .../src/api/fmt/binary.rs                     |   4 +-
 .../src/api/fmt/debug.rs                      |   4 +-
 .../src/api/fmt/lower_hex.rs                  |   4 +-
 .../src/api/fmt/octal.rs                      |   4 +-
 .../src/api/fmt/upper_hex.rs                  |   4 +-
 .../src/api/from.rs                           |   0
 .../src/api/from/from_array.rs                |   0
 .../src/api/from/from_vector.rs               |   0
 .../src/api/hash.rs                           |   0
 .../src/api/into_bits.rs                      |   4 +-
 .../src/api/into_bits/arch_specific.rs        | 272 +++++--
 .../src/api/into_bits/macros.rs               |   2 +-
 .../packed_simd_2/src/api/into_bits/v128.rs   | 232 ++++++
 .../src/api/into_bits/v16.rs                  |   0
 .../packed_simd_2/src/api/into_bits/v256.rs   | 232 ++++++
 .../src/api/into_bits/v32.rs                  |   0
 .../packed_simd_2/src/api/into_bits/v512.rs   | 232 ++++++
 .../src/api/into_bits/v64.rs                  |   0
 .../src/api/math.rs                           |   0
 .../src/api/math/float.rs                     |   0
 .../src/api/math/float/abs.rs                 |   0
 .../src/api/math/float/consts.rs              |  36 +-
 .../src/api/math/float/cos.rs                 |   0
 .../src/api/math/float/exp.rs                 |   0
 .../src/api/math/float/ln.rs                  |   0
 .../src/api/math/float/mul_add.rs             |   0
 .../src/api/math/float/mul_adde.rs            |   0
 .../src/api/math/float/powf.rs                |   0
 .../src/api/math/float/recpre.rs              |   0
 .../src/api/math/float/rsqrte.rs              |   0
 .../src/api/math/float/sin.rs                 |   0
 .../src/api/math/float/sqrt.rs                |   0
 .../src/api/math/float/sqrte.rs               |   0
 .../src/api/minimal.rs                        |   0
 .../src/api/minimal/iuf.rs                    |   0
 .../src/api/minimal/mask.rs                   |   0
 .../src/api/minimal/ptr.rs                    |   0
 .../src/api/ops.rs                            |   0
 .../src/api/ops/scalar_arithmetic.rs          |   0
 .../src/api/ops/scalar_bitwise.rs             |   0
 .../src/api/ops/scalar_mask_bitwise.rs        |   0
 .../src/api/ops/scalar_shifts.rs              |   7 +-
 .../src/api/ops/vector_arithmetic.rs          |   0
 .../src/api/ops/vector_bitwise.rs             |   0
 .../src/api/ops/vector_float_min_max.rs       |   0
 .../src/api/ops/vector_int_min_max.rs         |   0
 .../src/api/ops/vector_mask_bitwise.rs        |   0
 .../src/api/ops/vector_neg.rs                 |   0
 .../src/api/ops/vector_rotates.rs             |   2 +
 .../src/api/ops/vector_shifts.rs              |   7 +-
 .../src/api/ptr.rs                            |   0
 .../src/api/ptr/gather_scatter.rs             |  21 +-
 .../src/api/reductions.rs                     |   0
 .../src/api/reductions/bitwise.rs             |   0
 .../src/api/reductions/float_arithmetic.rs    |   8 +-
 .../src/api/reductions/integer_arithmetic.rs  |   8 +-
 .../src/api/reductions/mask.rs                |   0
 .../src/api/reductions/min_max.rs             |  65 +-
 .../src/api/select.rs                         |   4 +-
 .../src/api/shuffle.rs                        |   8 +-
 .../src/api/shuffle1_dyn.rs                   |   0
 .../src/api/slice.rs                          |   0
 .../src/api/slice/from_slice.rs               |  28 +-
 .../src/api/slice/write_to_slice.rs           |  35 +-
 .../src/api/swap_bytes.rs                     |   0
 .../src/codegen.rs                            |  50 +-
 .../src/codegen/bit_manip.rs                  |  17 +-
 .../rust/packed_simd_2/src/codegen/llvm.rs    | 128 ++++
 .../src/codegen/math.rs                       |   2 +-
 .../packed_simd_2/src/codegen/math/float.rs   |  18 +
 .../src/codegen/math/float/abs.rs             |   2 +-
 .../src/codegen/math/float/cos.rs             |   2 +-
 .../src/codegen/math/float/cos_pi.rs          |   2 +-
 .../src/codegen/math/float/exp.rs             |   2 +-
 .../src/codegen/math/float/ln.rs              |   2 +-
 .../src/codegen/math/float/macros.rs          | 133 +---
 .../src/codegen/math/float/mul_add.rs         |   2 +-
 .../src/codegen/math/float/mul_adde.rs        |  10 +-
 .../src/codegen/math/float/powf.rs            |   2 +-
 .../src/codegen/math/float/sin.rs             |   2 +-
 .../src/codegen/math/float/sin_cos_pi.rs      |  23 +-
 .../src/codegen/math/float/sin_pi.rs          |   2 +-
 .../src/codegen/math/float/sqrt.rs            |   2 +-
 .../src/codegen/math/float/sqrte.rs           |   2 +-
 .../src/codegen/pointer_sized_int.rs          |  28 +
 .../packed_simd_2/src/codegen/reductions.rs   |   1 +
 .../src/codegen/reductions/mask.rs            |   6 +-
 .../src/codegen/reductions/mask/aarch64.rs    |  38 +-
 .../src/codegen/reductions/mask/arm.rs        |  26 +-
 .../src/codegen/reductions/mask/fallback.rs   |   4 +-
 .../codegen/reductions/mask/fallback_impl.rs  |   0
 .../src/codegen/reductions/mask/x86.rs        |  70 +-
 .../src/codegen/reductions/mask/x86/avx.rs    |  10 +-
 .../src/codegen/reductions/mask/x86/avx2.rs   |   0
 .../src/codegen/reductions/mask/x86/sse.rs    |   3 +-
 .../src/codegen/reductions/mask/x86/sse2.rs   |   6 +-
 .../src/codegen/shuffle.rs                    |   4 +-
 .../src/codegen/shuffle1_dyn.rs               |  19 +-
 .../src/codegen/swap_bytes.rs                 |  52 +-
 .../src/codegen/v128.rs                       |   0
 .../src/codegen/v16.rs                        |   0
 .../src/codegen/v256.rs                       |   0
 .../src/codegen/v32.rs                        |   0
 .../src/codegen/v512.rs                       |   0
 .../src/codegen/v64.rs                        |   0
 .../src/codegen/vPtr.rs                       |   2 +-
 .../src/codegen/vSize.rs                      |  33 +-
 .../{packed_simd => packed_simd_2}/src/lib.rs |  61 +-
 .../src/masks.rs                              |   8 +-
 .../src/sealed.rs                             |   0
 .../src/testing.rs                            |   2 +-
 .../rust/packed_simd_2/src/testing/macros.rs  |  44 ++
 .../src/testing/utils.rs                      |  34 +-
 .../src/v128.rs                               |   0
 .../{packed_simd => packed_simd_2}/src/v16.rs |   0
 .../src/v256.rs                               |   0
 .../{packed_simd => packed_simd_2}/src/v32.rs |   0
 .../src/v512.rs                               |   0
 .../{packed_simd => packed_simd_2}/src/v64.rs |   0
 .../src/vPtr.rs                               |   0
 .../src/vSize.rs                              |   0
 .../tests/endianness.rs                       |  10 +-
 .../rustc_version-0.2.3/.cargo-checksum.json  |   1 +
 .../rust/rustc_version-0.2.3/Cargo.toml       |  26 +
 .../rust/rustc_version-0.2.3/LICENSE-APACHE   | 201 ++++++
 .../rust/rustc_version-0.2.3/LICENSE-MIT      |  25 +
 .../rust/rustc_version-0.2.3/README.md        |  75 ++
 .../src/errors.rs                             |   0
 .../rust/rustc_version-0.2.3/src/lib.rs       | 347 +++++++++
 .../rust/rustc_version/.cargo-checksum.json   |   2 +-
 third_party/rust/rustc_version/Cargo.toml     |  13 +-
 third_party/rust/rustc_version/README.md      |  16 +-
 third_party/rust/rustc_version/deny.toml      |   3 +
 third_party/rust/rustc_version/src/lib.rs     | 502 +++++++------
 third_party/rust/rustc_version/tests/all.rs   | 456 ++++++++++++
 .../rust/semver-0.9.0/.cargo-checksum.json    |   1 +
 third_party/rust/semver-0.9.0/Cargo.toml      |  45 ++
 third_party/rust/semver-0.9.0/LICENSE-APACHE  | 201 ++++++
 third_party/rust/semver-0.9.0/LICENSE-MIT     |  25 +
 third_party/rust/semver-0.9.0/README.md       | 103 +++
 third_party/rust/semver-0.9.0/src/lib.rs      | 182 +++++
 .../{semver => semver-0.9.0}/src/version.rs   |   0
 .../src/version_req.rs                        |   0
 .../tests/deprecation.rs                      |   0
 .../tests/regression.rs                       |   0
 .../{semver => semver-0.9.0}/tests/serde.rs   |   0
 third_party/rust/semver/.cargo-checksum.json  |   2 +-
 third_party/rust/semver/Cargo.toml            |  58 +-
 third_party/rust/semver/LICENSE-MIT           |   2 -
 third_party/rust/semver/README.md             | 135 ++--
 third_party/rust/semver/benches/parse.rs      |  24 +
 third_party/rust/semver/build.rs              |  73 ++
 third_party/rust/semver/src/backport.rs       |  51 ++
 third_party/rust/semver/src/display.rs        | 165 +++++
 third_party/rust/semver/src/error.rs          | 124 ++++
 third_party/rust/semver/src/eval.rs           | 181 +++++
 third_party/rust/semver/src/identifier.rs     | 400 +++++++++++
 third_party/rust/semver/src/impls.rs          | 156 ++++
 third_party/rust/semver/src/lib.rs            | 677 ++++++++++++++----
 third_party/rust/semver/src/parse.rs          | 405 +++++++++++
 third_party/rust/semver/src/serde.rs          | 109 +++
 third_party/rust/semver/tests/node/mod.rs     |  43 ++
 .../rust/semver/tests/test_autotrait.rs       |  12 +
 .../rust/semver/tests/test_identifier.rs      |  45 ++
 third_party/rust/semver/tests/test_version.rs | 241 +++++++
 .../rust/semver/tests/test_version_req.rs     | 443 ++++++++++++
 third_party/rust/semver/tests/util/mod.rs     |  39 +
 308 files changed, 8564 insertions(+), 2202 deletions(-)
 create mode 100644 third_party/rust/encoding_rs/LICENSE-WHATWG
 create mode 100644 third_party/rust/encoding_rs/ci/miri.sh
 delete mode 100644 third_party/rust/packed_simd/build.rs
 delete mode 100644 third_party/rust/packed_simd/rustfmt.toml
 delete mode 100644 third_party/rust/packed_simd/src/api/cast/v128.rs
 delete mode 100644 third_party/rust/packed_simd/src/api/cast/v16.rs
 delete mode 100644 third_party/rust/packed_simd/src/api/cast/v256.rs
 delete mode 100644 third_party/rust/packed_simd/src/api/cast/v32.rs
 delete mode 100644 third_party/rust/packed_simd/src/api/cast/v512.rs
 delete mode 100644 third_party/rust/packed_simd/src/api/cast/v64.rs
 delete mode 100644 third_party/rust/packed_simd/src/api/into_bits/v128.rs
 delete mode 100644 third_party/rust/packed_simd/src/api/into_bits/v256.rs
 delete mode 100644 third_party/rust/packed_simd/src/api/into_bits/v512.rs
 delete mode 100644 third_party/rust/packed_simd/src/codegen/llvm.rs
 delete mode 100644 third_party/rust/packed_simd/src/codegen/math/float.rs
 delete mode 100644 third_party/rust/packed_simd/src/codegen/pointer_sized_int.rs
 delete mode 100644 third_party/rust/packed_simd/src/codegen/reductions.rs
 delete mode 100644 third_party/rust/packed_simd/src/testing/macros.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/.appveyor.yml (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/.cargo-checksum.json (57%)
 rename third_party/rust/{packed_simd => packed_simd_2}/.travis.yml (86%)
 rename third_party/rust/{packed_simd => packed_simd_2}/Cargo.toml (50%)
 rename third_party/rust/{packed_simd => packed_simd_2}/LICENSE-APACHE (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/LICENSE-MIT (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/README.md (85%)
 rename third_party/rust/{packed_simd => packed_simd_2}/bors.toml (100%)
 create mode 100644 third_party/rust/packed_simd_2/build.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/all.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/android-install-ndk.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/android-install-sdk.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/android-sysimage.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/benchmark.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/deploy_and_run_on_ios_simulator.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/aarch64-linux-android/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/aarch64-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/arm-linux-androideabi/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/arm-unknown-linux-gnueabi/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/i586-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/i686-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/mips-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/mipsel-unknown-linux-musl/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/powerpc-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/s390x-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/sparc64-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/thumbv7neon-linux-androideabi/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/wasm32-unknown-unknown/Dockerfile (77%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/x86_64-linux-android/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/x86_64-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/dox.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/linux-s390x.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/linux-sparc64.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/lld-shim.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/max_line_width.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/run-docker.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/run.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/run_examples.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/runtest-android.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/setup_benchmarks.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/test-runner-linux (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/contributing.md (99%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/.gitignore (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/book.toml (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/SUMMARY.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/ascii.css (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/bound_checks.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/float-math/approx.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/float-math/fma.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/float-math/fp.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/float-math/svml.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/introduction.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/prof/linux.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/prof/mca.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/prof/profiling.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/target-feature/attribute.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/target-feature/features.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/target-feature/inlining.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/target-feature/practice.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/target-feature/runtime.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/target-feature/rustflags.md (92%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/vert-hor-ops.md (100%)
 create mode 100644 third_party/rust/packed_simd_2/rustfmt.toml
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api.rs (99%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/bit_manip.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/bitmask.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/cast.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/cast/macros.rs (100%)
 create mode 100644 third_party/rust/packed_simd_2/src/api/cast/v128.rs
 create mode 100644 third_party/rust/packed_simd_2/src/api/cast/v16.rs
 create mode 100644 third_party/rust/packed_simd_2/src/api/cast/v256.rs
 create mode 100644 third_party/rust/packed_simd_2/src/api/cast/v32.rs
 create mode 100644 third_party/rust/packed_simd_2/src/api/cast/v512.rs
 create mode 100644 third_party/rust/packed_simd_2/src/api/cast/v64.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/cmp.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/cmp/eq.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/cmp/ord.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/cmp/partial_eq.rs (97%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/cmp/partial_ord.rs (98%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/cmp/vertical.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/default.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/fmt.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/fmt/binary.rs (94%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/fmt/debug.rs (95%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/fmt/lower_hex.rs (94%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/fmt/octal.rs (94%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/fmt/upper_hex.rs (94%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/from.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/from/from_array.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/from/from_vector.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/hash.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/into_bits.rs (90%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/into_bits/arch_specific.rs (54%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/into_bits/macros.rs (97%)
 create mode 100644 third_party/rust/packed_simd_2/src/api/into_bits/v128.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/into_bits/v16.rs (100%)
 create mode 100644 third_party/rust/packed_simd_2/src/api/into_bits/v256.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/into_bits/v32.rs (100%)
 create mode 100644 third_party/rust/packed_simd_2/src/api/into_bits/v512.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/into_bits/v64.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/abs.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/consts.rs (57%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/cos.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/exp.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/ln.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/mul_add.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/mul_adde.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/powf.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/recpre.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/rsqrte.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/sin.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/sqrt.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/sqrte.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/minimal.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/minimal/iuf.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/minimal/mask.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/minimal/ptr.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/scalar_arithmetic.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/scalar_bitwise.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/scalar_mask_bitwise.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/scalar_shifts.rs (94%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/vector_arithmetic.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/vector_bitwise.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/vector_float_min_max.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/vector_int_min_max.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/vector_mask_bitwise.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/vector_neg.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/vector_rotates.rs (96%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/vector_shifts.rs (94%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ptr.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ptr/gather_scatter.rs (94%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/reductions.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/reductions/bitwise.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/reductions/float_arithmetic.rs (97%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/reductions/integer_arithmetic.rs (96%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/reductions/mask.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/reductions/min_max.rs (86%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/select.rs (94%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/shuffle.rs (97%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/shuffle1_dyn.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/slice.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/slice/from_slice.rs (90%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/slice/write_to_slice.rs (88%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/swap_bytes.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen.rs (54%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/bit_manip.rs (96%)
 create mode 100644 third_party/rust/packed_simd_2/src/codegen/llvm.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math.rs (57%)
 create mode 100644 third_party/rust/packed_simd_2/src/codegen/math/float.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/abs.rs (99%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/cos.rs (99%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/cos_pi.rs (99%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/exp.rs (99%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/ln.rs (99%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/macros.rs (80%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/mul_add.rs (99%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/mul_adde.rs (88%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/powf.rs (99%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/sin.rs (99%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/sin_cos_pi.rs (87%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/sin_pi.rs (99%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/sqrt.rs (99%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/sqrte.rs (99%)
 create mode 100644 third_party/rust/packed_simd_2/src/codegen/pointer_sized_int.rs
 create mode 100644 third_party/rust/packed_simd_2/src/codegen/reductions.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask.rs (92%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/aarch64.rs (72%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/arm.rs (69%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/fallback.rs (68%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/fallback_impl.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/x86.rs (80%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/x86/avx.rs (91%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/x86/avx2.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/x86/sse.rs (92%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/x86/sse2.rs (92%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/shuffle.rs (99%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/shuffle1_dyn.rs (96%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/swap_bytes.rs (88%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/v128.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/v16.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/v256.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/v32.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/v512.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/v64.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/vPtr.rs (95%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/vSize.rs (55%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/lib.rs (85%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/masks.rs (92%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/sealed.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/testing.rs (80%)
 create mode 100644 third_party/rust/packed_simd_2/src/testing/macros.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/src/testing/utils.rs (83%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/v128.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/v16.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/v256.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/v32.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/v512.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/v64.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/vPtr.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/vSize.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/tests/endianness.rs (96%)
 create mode 100644 third_party/rust/rustc_version-0.2.3/.cargo-checksum.json
 create mode 100644 third_party/rust/rustc_version-0.2.3/Cargo.toml
 create mode 100644 third_party/rust/rustc_version-0.2.3/LICENSE-APACHE
 create mode 100644 third_party/rust/rustc_version-0.2.3/LICENSE-MIT
 create mode 100644 third_party/rust/rustc_version-0.2.3/README.md
 rename third_party/rust/{rustc_version => rustc_version-0.2.3}/src/errors.rs (100%)
 create mode 100644 third_party/rust/rustc_version-0.2.3/src/lib.rs
 create mode 100644 third_party/rust/rustc_version/deny.toml
 create mode 100644 third_party/rust/rustc_version/tests/all.rs
 create mode 100644 third_party/rust/semver-0.9.0/.cargo-checksum.json
 create mode 100644 third_party/rust/semver-0.9.0/Cargo.toml
 create mode 100644 third_party/rust/semver-0.9.0/LICENSE-APACHE
 create mode 100644 third_party/rust/semver-0.9.0/LICENSE-MIT
 create mode 100644 third_party/rust/semver-0.9.0/README.md
 create mode 100644 third_party/rust/semver-0.9.0/src/lib.rs
 rename third_party/rust/{semver => semver-0.9.0}/src/version.rs (100%)
 rename third_party/rust/{semver => semver-0.9.0}/src/version_req.rs (100%)
 rename third_party/rust/{semver => semver-0.9.0}/tests/deprecation.rs (100%)
 rename third_party/rust/{semver => semver-0.9.0}/tests/regression.rs (100%)
 rename third_party/rust/{semver => semver-0.9.0}/tests/serde.rs (100%)
 create mode 100644 third_party/rust/semver/benches/parse.rs
 create mode 100644 third_party/rust/semver/build.rs
 create mode 100644 third_party/rust/semver/src/backport.rs
 create mode 100644 third_party/rust/semver/src/display.rs
 create mode 100644 third_party/rust/semver/src/error.rs
 create mode 100644 third_party/rust/semver/src/eval.rs
 create mode 100644 third_party/rust/semver/src/identifier.rs
 create mode 100644 third_party/rust/semver/src/impls.rs
 create mode 100644 third_party/rust/semver/src/parse.rs
 create mode 100644 third_party/rust/semver/src/serde.rs
 create mode 100644 third_party/rust/semver/tests/node/mod.rs
 create mode 100644 third_party/rust/semver/tests/test_autotrait.rs
 create mode 100644 third_party/rust/semver/tests/test_identifier.rs
 create mode 100644 third_party/rust/semver/tests/test_version.rs
 create mode 100644 third_party/rust/semver/tests/test_version_req.rs
 create mode 100644 third_party/rust/semver/tests/util/mod.rs

diff --git a/.cargo/config.in b/.cargo/config.in
index 5560f944e386..079038b7165a 100644
--- a/.cargo/config.in
+++ b/.cargo/config.in
@@ -65,7 +65,7 @@ rev = "746743227485a83123784df0c53227ab466612ed"
 [source."https://github.com/hsivonen/packed_simd"]
 git = "https://github.com/hsivonen/packed_simd"
 replace-with = "vendored-sources"
-rev = "8b4bd7d8229660a749dbe419a57ea01df9de5453"
+rev = "90eebb82a107cbec1c8e406d9223819417e96de1"
 
 [source."https://github.com/hsivonen/chardetng_c"]
 git = "https://github.com/hsivonen/chardetng_c"
diff --git a/Cargo.lock b/Cargo.lock
index b2e20f5501ff..cc7efd9b3b0b 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -486,7 +486,7 @@ version = "0.2.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "cc38c385bfd7e444464011bb24820f40dd1c76bcdfa1b78611cb7c2e5cafab75"
 dependencies = [
- "rustc_version",
+ "rustc_version 0.2.3",
 ]
 
 [[package]]
@@ -1033,7 +1033,7 @@ dependencies = [
  "pulse",
  "pulse-ffi",
  "ringbuf",
- "semver",
+ "semver 0.9.0",
 ]
 
 [[package]]
@@ -1270,12 +1270,12 @@ dependencies = [
 
 [[package]]
 name = "encoding_rs"
-version = "0.8.22"
+version = "0.8.31"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cd8d03faa7fe0c1431609dfad7bbe827af30f82e1e2ae6f7ee4fca6bd764bc28"
+checksum = "9852635589dc9f9ea1b6fe9f05b50ef208c85c834a562f0c6abb1c475736ec2b"
 dependencies = [
- "cfg-if 0.1.10",
- "packed_simd",
+ "cfg-if 1.0.0",
+ "packed_simd_2",
 ]
 
 [[package]]
@@ -1969,7 +1969,7 @@ dependencies = [
  "rsdparsa_capi",
  "rusqlite",
  "rust_minidump_writer_linux",
- "rustc_version",
+ "rustc_version 0.2.3",
  "static_prefs",
  "storage",
  "unic-langid",
@@ -1987,7 +1987,7 @@ name = "gkrust_utils"
 version = "0.1.0"
 dependencies = [
  "nsstring",
- "semver",
+ "semver 0.9.0",
  "uuid",
 ]
 
@@ -3147,7 +3147,7 @@ version = "0.4.1"
 dependencies = [
  "regex",
  "rust-ini",
- "semver",
+ "semver 0.9.0",
 ]
 
 [[package]]
@@ -3540,12 +3540,12 @@ dependencies = [
 ]
 
 [[package]]
-name = "packed_simd"
-version = "0.3.4"
-source = "git+https://github.com/hsivonen/packed_simd?rev=8b4bd7d8229660a749dbe419a57ea01df9de5453#8b4bd7d8229660a749dbe419a57ea01df9de5453"
+name = "packed_simd_2"
+version = "0.3.8"
+source = "git+https://github.com/hsivonen/packed_simd?rev=90eebb82a107cbec1c8e406d9223819417e96de1#90eebb82a107cbec1c8e406d9223819417e96de1"
 dependencies = [
- "cfg-if 0.1.10",
- "rustc_version",
+ "cfg-if 1.0.0",
+ "rustc_version 0.4.0",
 ]
 
 [[package]]
@@ -3887,7 +3887,7 @@ name = "qcms"
 version = "0.2.0"
 dependencies = [
  "libc",
- "rustc_version",
+ "rustc_version 0.2.3",
 ]
 
 [[package]]
@@ -3981,7 +3981,7 @@ checksum = "beb71f708fe39b2c5e98076204c3cc094ee5a4c12c4cdb119a2b72dc34164f41"
 dependencies = [
  "bitflags",
  "cc",
- "rustc_version",
+ "rustc_version 0.2.3",
 ]
 
 [[package]]
@@ -4277,7 +4277,16 @@ version = "0.2.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a"
 dependencies = [
- "semver",
+ "semver 0.9.0",
+]
+
+[[package]]
+name = "rustc_version"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366"
+dependencies = [
+ "semver 1.0.13",
 ]
 
 [[package]]
@@ -4361,6 +4370,12 @@ dependencies = [
  "semver-parser",
 ]
 
+[[package]]
+name = "semver"
+version = "1.0.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "93f6841e709003d68bb2deee8c343572bf446003ec20a583e76f7b15cebf3711"
+
 [[package]]
 name = "semver-parser"
 version = "0.7.0"
diff --git a/Cargo.toml b/Cargo.toml
index 74658ce02ad8..06d64f3778d7 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -78,7 +78,7 @@ opt-level = 2
 chardetng = { git = "https://github.com/hsivonen/chardetng", rev="302c995f91f44cf26e77dc4758ad56c3ff0153ad" }
 chardetng_c = { git = "https://github.com/hsivonen/chardetng_c", rev="ed8a4c6f900a90d4dbc1d64b856e61490a1c3570" }
 libudev-sys = { path = "dom/webauthn/libudev-sys" }
-packed_simd = { git = "https://github.com/hsivonen/packed_simd", rev="8b4bd7d8229660a749dbe419a57ea01df9de5453" }
+packed_simd = { package = "packed_simd_2", git = "https://github.com/hsivonen/packed_simd", rev="90eebb82a107cbec1c8e406d9223819417e96de1" }
 rlbox_lucet_sandbox = { git = "https://github.com/PLSysSec/rlbox_lucet_sandbox/", rev="5c8e79048d3ff6f434109e19d4aee4ff8624d3d7" }
 nix = { git = "https://github.com/shravanrn/nix/", rev="4af6c367603869a30fddb5ffb0aba2b9477ba92e" }
 spirv_cross = { git = "https://github.com/kvark/spirv_cross", branch = "wgpu5" }
diff --git a/config/makefiles/rust.mk b/config/makefiles/rust.mk
index 401c2933bb63..54f252f18af4 100644
--- a/config/makefiles/rust.mk
+++ b/config/makefiles/rust.mk
@@ -238,7 +238,7 @@ endif
 ifndef RUSTC_BOOTSTRAP
 RUSTC_BOOTSTRAP := gkrust_shared,qcms
 ifdef MOZ_RUST_SIMD
-RUSTC_BOOTSTRAP := $(RUSTC_BOOTSTRAP),encoding_rs,packed_simd
+RUSTC_BOOTSTRAP := $(RUSTC_BOOTSTRAP),encoding_rs,packed_simd2
 endif
 export RUSTC_BOOTSTRAP
 endif
diff --git a/python/mozbuild/mozbuild/vendor/vendor_rust.py b/python/mozbuild/mozbuild/vendor/vendor_rust.py
index 2c38aa2e3731..39805228d927 100644
--- a/python/mozbuild/mozbuild/vendor/vendor_rust.py
+++ b/python/mozbuild/mozbuild/vendor/vendor_rust.py
@@ -292,6 +292,13 @@ Please commit or stash these changes before vendoring, or re-run with `--ignore-
         we will abort if that is detected. We'll handle `/` and OR as
         equivalent and approve is any is in our approved list."""
 
+        # This specific AND combination has been reviewed for encoding_rs.
+        if (
+            license_string == "(Apache-2.0 OR MIT) AND BSD-3-Clause"
+            and package == "encoding_rs"
+        ):
+            return True
+
         if re.search(r"\s+AND", license_string):
             return False
 
diff --git a/third_party/rust/encoding_rs/.cargo-checksum.json b/third_party/rust/encoding_rs/.cargo-checksum.json
index d009a2c7e818..925adb692537 100644
--- a/third_party/rust/encoding_rs/.cargo-checksum.json
+++ b/third_party/rust/encoding_rs/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"CONTRIBUTING.md":"06c26277e8dbd3f57be2eb51b5e3285dc1cbbf8c11326df413868ae702e6a61c","COPYRIGHT":"8b98376eb373dcf81950474efe34b5576a8171460dff500cc58a1ed8d160cd57","Cargo.toml":"99e8b29ff66a85a2961d2d70064c3a83dede337cdc18e149cfa59d4d59eb2991","Ideas.md":"b7452893f500163868d8de52c09addaf91e1632454ed02e892c467ed7ec39dbd","LICENSE-APACHE":"cfc7749b96f63bd31c3c42b5c471bf756814053e847c10f3eb003417bc523d30","LICENSE-MIT":"f2ad48641d9c997d9ae3b95d93d1cd6e1ab12ab4c44de89937c7bfabbd076a4a","README.md":"9351c79bd13e297091f745f6fb276a1f5113b5f644dc79eccb8ef09eb6cfa032","build.rs":"9276ee24ef71433d46323c15296b3fbbb29c0b37c4b1ca45416587f14ba8e777","doc/Big5.txt":"f73a2edc5cb6c2d140ba6e07f4542e1c4a234950378acde1df93480f0ca0be0b","doc/EUC-JP.txt":"ee2818b907d0137f40a9ab9fd525fc700a44dbdddb6cf0c157a656566bae4bf1","doc/EUC-KR.txt":"71d9e2ccf3b124e8bdfb433c8cf2773fd878077038d0cec3c7237a50f4a78a30","doc/GBK.txt":"c1b522b5a799884e5001da661f42c5a8f4d0acb9ef1d74b206f22b5f65365606","doc/IBM866.txt":"a5a433e804d0f83af785015179fbc1d9b0eaf1f7960efcd04093e136b51fbd0e","doc/ISO-2022-JP.txt":"af86684f5a8f0e2868d7b2c292860140c3d2e5527530ca091f1b28198e8e2fe6","doc/ISO-8859-10.txt":"6d3949ad7c81ca176895101ed81a1db7df1060d64e262880b94bd31bb344ab4d","doc/ISO-8859-13.txt":"3951dd89cf93f7729148091683cf8511f4529388b7dc8dcd0d62eaed55be93fa","doc/ISO-8859-14.txt":"3d330784a0374fd255a38b47949675cc7168c800530534b0a01cac6edc623adc","doc/ISO-8859-15.txt":"24b1084aab5127a85aab99153f86e24694d0a3615f53b5ce23683f97cf66c47a","doc/ISO-8859-16.txt":"ce0272559b92ba76d7a7e476f6424ae4a5cc72e75b183611b08392e44add4d25","doc/ISO-8859-2.txt":"18ceff88c13d1b5ba455a3919b1e3de489045c4c3d2dd7e8527c125c75d54aad","doc/ISO-8859-3.txt":"21798404c68f4f5db59223362f24999da96968c0628427321fccce7d2849a130","doc/ISO-8859-4.txt":"d27f6520c6c5bfbcc19176b71d081cdb3bccde1622bb3e420d5680e812632d53","doc/ISO-8859-5.txt":"a10ec8d6ea7a78ad15da7275f6cb1a3365118527e28f9af6d0d5830501303f3a","doc/ISO-8859-6.txt":"ccda8a2efc96115336bdd77776637b9712425e44fbcf745353b9057fbef144e7","doc/ISO-8859-7.txt":"17900fa1f27a445958f0a77d7d9056be375a6bd7ee4492aa680c7c1500bab85e","doc/ISO-8859-8-I.txt":"8357555646d54265a9b9ffa3e68b08d132312f1561c60108ff9b8b1167b6ecf2","doc/ISO-8859-8.txt":"72cd6f3afb7b4a9c16a66a362473315770b7755d72c86c870e52fc3eba86c8af","doc/KOI8-R.txt":"839cf19a38da994488004ed7814b1f6151640156a9a2af02bf2efca745fb5966","doc/KOI8-U.txt":"0cc76624ed1f024183e2298b7e019957da2c70c8ca06e0fc4e6f353f50a5054f","doc/Shift_JIS.txt":"34c49141818cb9ddbcf59cc858f78a79be8ad148d563f26415108ae1f148443f","doc/UTF-16BE.txt":"e2e280d8acbaa6d2a6b3569d60e17500a285f2baa0df3363dd85537cd5a1ef8f","doc/UTF-16LE.txt":"70bdc170e3fc5298ba68f10125fb5eeb8b077036cc96bb4416c4de396f6d76c1","doc/UTF-8.txt":"ea7bae742e613010ced002cf4b601a737d2203fad65e115611451bc4428f548a","doc/gb18030.txt":"dc71378a8f07a2d8659f69ee81fb8791fef56ba86f124b429978285237bb4a7b","doc/macintosh.txt":"57491e53866711b4672d9b9ff35380b9dac9e0d8e3d6c20bdd6140603687c023","doc/replacement.txt":"4b6c3bbd7999d9d4108a281594bd02d13607e334a95465afff8c2c08d395f0e4","doc/windows-1250.txt":"61296bb6a21cdab602300d32ecfba434cb82de5ac3bc88d58710d2f125e28d39","doc/windows-1251.txt":"7deea1c61dea1485c8ff02db2c7d578db7a9aab63ab1cfd02ec04b515864689e","doc/windows-1252.txt":"933ef3bdddfce5ee132b9f1a1aa8b47423d2587bbe475b19028d0a6d38e180b6","doc/windows-1253.txt":"1a38748b88e99071a5c7b3d5456ead4caedeabab50d50d658be105bc113714de","doc/windows-1254.txt":"f8372f86c6f8d642563cd6ddc025260553292a39423df1683a98670bd7bf2b47","doc/windows-1255.txt":"4e5852494730054e2da258a74e1b9d780abbcdd8ce22ebc218ca2efe9e90493d","doc/windows-1256.txt":"c0879c5172abedead302a406e8f60d9cd9598694a0ffa4fd288ffe4fef7b8ea1","doc/windows-1257.txt":"c28a0c9f964fcb2b46d21f537c402446501a2800670481d6abf9fd9e9018d523","doc/windows-1258.txt":"5019ae4d61805c79aacbf17c93793342dbb098d65a1837783bc3e2c6d6a23602","doc/windows-874.txt":"4ef0e4501c5feba8b17aee1818602ed44b36ca8475db771ce2fc16d392cabecc","doc/x-mac-cyrillic.txt":"58be154d8a888ca3d484b83b44f749823ef339ab27f14d90ca9a856f5050a8bd","doc/x-user-defined.txt":"f9cd07c4321bf5cfb0be4bdddd251072999b04a6cf7a6f5bc63709a84e2c1ffc","generate-encoding-data.py":"b523b9f00711976357db0b735d15863b9d0559c90946136e874bda0b68fd5479","rustfmt.toml":"85c1a3b4382fd89e991cbb81b70fb52780472edc064c963943cdaaa56e0a2030","src/ascii.rs":"800cfbe3036d0c97ce27e07a4fd05edbcb7354ebec20903d81c76136d734931c","src/big5.rs":"ae801a92f7b8218eb488ac030958c7b0e54b01bef1645a0f56f1c1172288fbd5","src/data.rs":"9544c019c7360a669bd3adaa90b70331124abd1df59841db66e74912bcdb96a5","src/euc_jp.rs":"881f670679362372ecb744f75533ca2c7020372abaf22ce1d8a57b5b3ecc4d81","src/euc_kr.rs":"f14f520134d2969361d7fe721cc1b4118660afe91d1972f9ee5518605084edbe","src/gb18030.rs":"15466e6f3d9a27d0f6ee41057977f6bc43d624c3267de56d8aefcbb8cbb883ad","src/handles.rs":"0646bd091892ff7a76f34efccda4e5ddabe1e624e890baa9fdc9d48011d2d38b","src/iso_2022_jp.rs":"4a9e0c9702e00d4df08cf4a090f23b314fe3548ca5634a21faa0e641fdda387e","src/lib.rs":"1df141d90ce5a7c8021dc56f3d19d936df38e3e7057d85fc9056e8d3567e9190","src/macros.rs":"c7a019fd81d31de77569036ac36fd4e404b3f20144bbf79747faf4ea21538d09","src/mem.rs":"ae6792b9be8b2103541cc789dfc8796e7f3307716d0ce918b563d61b000188ad","src/replacement.rs":"182c2093a6edb162183ca5990554fd7b199d3011924a8d80d894ba98ee7c479e","src/shift_jis.rs":"98decc3cc76f224adbe24b8114ff966cb48ac92abeee5c0ef81d28cec033df55","src/simd_funcs.rs":"63df317a3a8edac708196546d02b2070ecfb8d1d0a2aa16db33d13803572b2fc","src/single_byte.rs":"ddd8162b8d0f1256fd5da1d8e203110265887f8a3f75ebe6af9310a06a8cd39f","src/test_data/big5_in.txt":"4c5a8691f8dc717311889c63894026d2fb62725a86c4208ca274a9cc8d42a503","src/test_data/big5_in_ref.txt":"99d399e17750cf9c7cf30bb253dbfe35b81c4fcbdead93cfa48b1429213473c7","src/test_data/big5_out.txt":"6193ca97c297aa20e09396038d18e938bb7ea331c26f0f2454097296723a0b13","src/test_data/big5_out_ref.txt":"36567691f557df144f6cc520015a87038dfa156f296fcf103b56ae9a718be1fc","src/test_data/euc_kr_in.txt":"c86a7224f3215fa0d04e685622a752fdc72763e8ae076230c7fd62de57ec4074","src/test_data/euc_kr_in_ref.txt":"1f419f4ca47d708b54c73c461545a022ae2e20498fdbf8005a483d752a204883","src/test_data/euc_kr_out.txt":"e7f32e026f70be1e1b58e0047baf7d3d2c520269c4f9b9992e158b4decb0a1a3","src/test_data/euc_kr_out_ref.txt":"c9907857980b20b8e9e3b584482ed6567a2be6185d72237b6322f0404944924e","src/test_data/gb18030_in.txt":"ab7231b2d3e9afacdbd7d7f3b9e5361a7ff9f7e1cfdb4f3bd905b9362b309e53","src/test_data/gb18030_in_ref.txt":"dc5069421adca2043c55f5012b55a76fdff651d22e6e699fd0978f8d5706815c","src/test_data/gb18030_out.txt":"f0208d527f5ca63de7d9a0323be8d5cf12d8a104b2943d92c2701f0c3364dac1","src/test_data/gb18030_out_ref.txt":"6819fe47627e4ea01027003fc514b9f21a1322e732d7f1fb92cc6c5455bc6c07","src/test_data/iso_2022_jp_in.txt":"cd24bbdcb1834e25db54646fbf4c41560a13dc7540f6be3dba4f5d97d44513af","src/test_data/iso_2022_jp_in_ref.txt":"3dc4e6a5e06471942d086b16c9440945e78415f6f3f47e43717e4bc2eac2cdf5","src/test_data/iso_2022_jp_out.txt":"9b6f015329dda6c3f9ee5ce6dbd6fa9c89acc21283e886836c78b8d833480c21","src/test_data/iso_2022_jp_out_ref.txt":"78cb260093a20116ad9a42f43b05d1848c5ab100b6b9a850749809e943884b35","src/test_data/jis0208_in.txt":"6df3030553ffb0a6615bb33dc8ea9dca6d9623a9028e2ffec754ce3c3da824cc","src/test_data/jis0208_in_ref.txt":"3dc4e6a5e06471942d086b16c9440945e78415f6f3f47e43717e4bc2eac2cdf5","src/test_data/jis0208_out.txt":"4ec24477e1675ce750733bdc3c5add1cd27b6bd4ce1f09289564646e9654e857","src/test_data/jis0208_out_ref.txt":"c3e1cef5032b2b1d93a406f31ff940c4e2dfe8859b8b17ca2761fee7a75a0e48","src/test_data/jis0212_in.txt":"c011f0dd72bd7c8cd922df9374ef8d2769a77190514c77f6c62b415852eeb9fe","src/test_data/jis0212_in_ref.txt":"7d9458b3d2f73e7092a7f505c08ce1d233dde18aa679fbcf9889256239cc9e06","src/test_data/shift_jis_in.txt":"02e389ccef0dd2122e63f503899402cb7f797912c2444cc80ab93131116c5524","src/test_data/shift_jis_in_ref.txt":"512f985950ca902e643c88682dba9708b7c38d3c5ec2925168ab00ac94ab19f9","src/test_data/shift_jis_out.txt":"5fbc44da7bf639bf6cfe0fa1fd3eba7102b88f81919c9ea991302712f69426fb","src/test_data/shift_jis_out_ref.txt":"466322c6fed8286c64582731755290c2296508efdd258826e6279686649b481f","src/test_labels_names.rs":"c962c7aeac3d9ef2aca70c9e21983b231d4cf998cb06879374b0401e5149d1da","src/testing.rs":"b299d27055f3b068de66cc10a75c024b881c48bc093627c01e0b1f8bd7d94666","src/utf_16.rs":"08c1f5fbd968b04b1d6f61b3b21202a9a3a18ec4da2723914907429f4f6a09fc","src/utf_8.rs":"c3baecaf74cf005313f8029f621a5a93456bd19252aa668e522d44bee88bbe45","src/variant.rs":"3d81a104eb07a87efc9daf295a53bbe66b85b0df478c14d5aad216f0df5f5a28","src/x_user_defined.rs":"da51def859b870ced29cb87987f02d27b220eac0f222876cb72a1dc616f9d8ec"},"package":"cd8d03faa7fe0c1431609dfad7bbe827af30f82e1e2ae6f7ee4fca6bd764bc28"}
\ No newline at end of file
+{"files":{"CONTRIBUTING.md":"ca1901f3e8532fb4cec894fd3664f0eaa898c0c4b961d1b992d1ed54eacf362a","COPYRIGHT":"11789f45bb180841cd362a5eee6789c68ddb573a11105e30768c308a6add0190","Cargo.toml":"abf2c7d17500cfa1148b76b9a8a8574873a6f6de90d6110d0d8f6b519c8c99f6","Ideas.md":"b7452893f500163868d8de52c09addaf91e1632454ed02e892c467ed7ec39dbd","LICENSE-APACHE":"cfc7749b96f63bd31c3c42b5c471bf756814053e847c10f3eb003417bc523d30","LICENSE-MIT":"3fa4ca83dcc9237839b1bdeb2e6d16bdfb5ec0c5ce42b24694d8bbf0dcbef72c","LICENSE-WHATWG":"838118388fe5c2e7f1dbbaeed13e1c7f3ebf88be91319c7c1d77c18e987d1a50","README.md":"bcb4b59cfc5f48fbaba954b8ae4daa9eaecf9044afc89208a78a7e995c321b81","build.rs":"9276ee24ef71433d46323c15296b3fbbb29c0b37c4b1ca45416587f14ba8e777","ci/miri.sh":"43cb8d82f49e3bfe2d2274b6ccd6f0714a4188ccef0cecc040829883cfdbee25","doc/Big5.txt":"f73a2edc5cb6c2d140ba6e07f4542e1c4a234950378acde1df93480f0ca0be0b","doc/EUC-JP.txt":"ee2818b907d0137f40a9ab9fd525fc700a44dbdddb6cf0c157a656566bae4bf1","doc/EUC-KR.txt":"71d9e2ccf3b124e8bdfb433c8cf2773fd878077038d0cec3c7237a50f4a78a30","doc/GBK.txt":"c1b522b5a799884e5001da661f42c5a8f4d0acb9ef1d74b206f22b5f65365606","doc/IBM866.txt":"a5a433e804d0f83af785015179fbc1d9b0eaf1f7960efcd04093e136b51fbd0e","doc/ISO-2022-JP.txt":"af86684f5a8f0e2868d7b2c292860140c3d2e5527530ca091f1b28198e8e2fe6","doc/ISO-8859-10.txt":"6d3949ad7c81ca176895101ed81a1db7df1060d64e262880b94bd31bb344ab4d","doc/ISO-8859-13.txt":"3951dd89cf93f7729148091683cf8511f4529388b7dc8dcd0d62eaed55be93fa","doc/ISO-8859-14.txt":"3d330784a0374fd255a38b47949675cc7168c800530534b0a01cac6edc623adc","doc/ISO-8859-15.txt":"24b1084aab5127a85aab99153f86e24694d0a3615f53b5ce23683f97cf66c47a","doc/ISO-8859-16.txt":"ce0272559b92ba76d7a7e476f6424ae4a5cc72e75b183611b08392e44add4d25","doc/ISO-8859-2.txt":"18ceff88c13d1b5ba455a3919b1e3de489045c4c3d2dd7e8527c125c75d54aad","doc/ISO-8859-3.txt":"21798404c68f4f5db59223362f24999da96968c0628427321fccce7d2849a130","doc/ISO-8859-4.txt":"d27f6520c6c5bfbcc19176b71d081cdb3bccde1622bb3e420d5680e812632d53","doc/ISO-8859-5.txt":"a10ec8d6ea7a78ad15da7275f6cb1a3365118527e28f9af6d0d5830501303f3a","doc/ISO-8859-6.txt":"ccda8a2efc96115336bdd77776637b9712425e44fbcf745353b9057fbef144e7","doc/ISO-8859-7.txt":"17900fa1f27a445958f0a77d7d9056be375a6bd7ee4492aa680c7c1500bab85e","doc/ISO-8859-8-I.txt":"8357555646d54265a9b9ffa3e68b08d132312f1561c60108ff9b8b1167b6ecf2","doc/ISO-8859-8.txt":"72cd6f3afb7b4a9c16a66a362473315770b7755d72c86c870e52fc3eba86c8af","doc/KOI8-R.txt":"839cf19a38da994488004ed7814b1f6151640156a9a2af02bf2efca745fb5966","doc/KOI8-U.txt":"0cc76624ed1f024183e2298b7e019957da2c70c8ca06e0fc4e6f353f50a5054f","doc/Shift_JIS.txt":"34c49141818cb9ddbcf59cc858f78a79be8ad148d563f26415108ae1f148443f","doc/UTF-16BE.txt":"e2e280d8acbaa6d2a6b3569d60e17500a285f2baa0df3363dd85537cd5a1ef8f","doc/UTF-16LE.txt":"70bdc170e3fc5298ba68f10125fb5eeb8b077036cc96bb4416c4de396f6d76c1","doc/UTF-8.txt":"ea7bae742e613010ced002cf4b601a737d2203fad65e115611451bc4428f548a","doc/gb18030.txt":"dc71378a8f07a2d8659f69ee81fb8791fef56ba86f124b429978285237bb4a7b","doc/macintosh.txt":"57491e53866711b4672d9b9ff35380b9dac9e0d8e3d6c20bdd6140603687c023","doc/replacement.txt":"4b6c3bbd7999d9d4108a281594bd02d13607e334a95465afff8c2c08d395f0e4","doc/windows-1250.txt":"61296bb6a21cdab602300d32ecfba434cb82de5ac3bc88d58710d2f125e28d39","doc/windows-1251.txt":"7deea1c61dea1485c8ff02db2c7d578db7a9aab63ab1cfd02ec04b515864689e","doc/windows-1252.txt":"933ef3bdddfce5ee132b9f1a1aa8b47423d2587bbe475b19028d0a6d38e180b6","doc/windows-1253.txt":"1a38748b88e99071a5c7b3d5456ead4caedeabab50d50d658be105bc113714de","doc/windows-1254.txt":"f8372f86c6f8d642563cd6ddc025260553292a39423df1683a98670bd7bf2b47","doc/windows-1255.txt":"4e5852494730054e2da258a74e1b9d780abbcdd8ce22ebc218ca2efe9e90493d","doc/windows-1256.txt":"c0879c5172abedead302a406e8f60d9cd9598694a0ffa4fd288ffe4fef7b8ea1","doc/windows-1257.txt":"c28a0c9f964fcb2b46d21f537c402446501a2800670481d6abf9fd9e9018d523","doc/windows-1258.txt":"5019ae4d61805c79aacbf17c93793342dbb098d65a1837783bc3e2c6d6a23602","doc/windows-874.txt":"4ef0e4501c5feba8b17aee1818602ed44b36ca8475db771ce2fc16d392cabecc","doc/x-mac-cyrillic.txt":"58be154d8a888ca3d484b83b44f749823ef339ab27f14d90ca9a856f5050a8bd","doc/x-user-defined.txt":"f9cd07c4321bf5cfb0be4bdddd251072999b04a6cf7a6f5bc63709a84e2c1ffc","generate-encoding-data.py":"be989dd25c6b946e3e8745fdc8e8a80fcf24b3be99ad0b4b78153ba3f6ab6310","rustfmt.toml":"85c1a3b4382fd89e991cbb81b70fb52780472edc064c963943cdaaa56e0a2030","src/ascii.rs":"5c94c74e9b3f48706a4a6dc2d860702a991687a2ac314319cf38cb6d8fb1eabe","src/big5.rs":"ec6e2913011a38e9a3e825a1731f139a7ca1d5b264fefae51a3cc1a68a57cef9","src/data.rs":"8a617cc57032092d65850eb27e00de687c80aea3299e839a1f58b42d0b35abf3","src/euc_jp.rs":"32047f5b540188c4cb19c07165f846b9786a09f18e315ed3e9bda1293dae52aa","src/euc_kr.rs":"9b25afc72d9378700eecfac58d55ad1c5946d6cd0ccde2c29c08200ef2de6bb9","src/gb18030.rs":"808587168d73f0c80f8520f0ca9b161866ed2efeb17a05e85fdf3b8efe7ba28a","src/handles.rs":"cc83dc0754751d67f5688a65c5e0191cba02f6bacce81a0813a243cba55eef7a","src/iso_2022_jp.rs":"9bb485e82574f4b7d4b2364f0ff276acb6a0bc111758420a3b0ec5e04c196652","src/lib.rs":"a64116a6d46ab30ce91deabdb4c5388f03be632326e8a00110bfb0c598474a0a","src/macros.rs":"200997f8870de8bfd8cdc475e92115df42108c0df661e49d3d1cbc32056e1d99","src/mem.rs":"e33f94f18a9dc53f0425c14de238dca22ff028baff4e9bca89d780ac6d581d71","src/replacement.rs":"7660b34a53f8c1ca2bdfa0e51e843ec28326950952ad8bc96569feb93ac62308","src/shift_jis.rs":"6951ae67e36b1a12fa3a30734957f444d8b1b4ae0e2bde52060b29bd0f16d9d9","src/simd_funcs.rs":"103ab4f21229270f97f5ca639ad4f8d82e0d5099974b63db4b3faa486012064b","src/single_byte.rs":"3c9e9c1f946ae622c725ba9421240c1faa9a05e95fa10dd4642a25cb276a1edc","src/test_data/big5_in.txt":"4c5a8691f8dc717311889c63894026d2fb62725a86c4208ca274a9cc8d42a503","src/test_data/big5_in_ref.txt":"99d399e17750cf9c7cf30bb253dbfe35b81c4fcbdead93cfa48b1429213473c7","src/test_data/big5_out.txt":"6193ca97c297aa20e09396038d18e938bb7ea331c26f0f2454097296723a0b13","src/test_data/big5_out_ref.txt":"36567691f557df144f6cc520015a87038dfa156f296fcf103b56ae9a718be1fc","src/test_data/euc_kr_in.txt":"c86a7224f3215fa0d04e685622a752fdc72763e8ae076230c7fd62de57ec4074","src/test_data/euc_kr_in_ref.txt":"1f419f4ca47d708b54c73c461545a022ae2e20498fdbf8005a483d752a204883","src/test_data/euc_kr_out.txt":"e7f32e026f70be1e1b58e0047baf7d3d2c520269c4f9b9992e158b4decb0a1a3","src/test_data/euc_kr_out_ref.txt":"c9907857980b20b8e9e3b584482ed6567a2be6185d72237b6322f0404944924e","src/test_data/gb18030_in.txt":"ab7231b2d3e9afacdbd7d7f3b9e5361a7ff9f7e1cfdb4f3bd905b9362b309e53","src/test_data/gb18030_in_ref.txt":"dc5069421adca2043c55f5012b55a76fdff651d22e6e699fd0978f8d5706815c","src/test_data/gb18030_out.txt":"f0208d527f5ca63de7d9a0323be8d5cf12d8a104b2943d92c2701f0c3364dac1","src/test_data/gb18030_out_ref.txt":"6819fe47627e4ea01027003fc514b9f21a1322e732d7f1fb92cc6c5455bc6c07","src/test_data/iso_2022_jp_in.txt":"cd24bbdcb1834e25db54646fbf4c41560a13dc7540f6be3dba4f5d97d44513af","src/test_data/iso_2022_jp_in_ref.txt":"3dc4e6a5e06471942d086b16c9440945e78415f6f3f47e43717e4bc2eac2cdf5","src/test_data/iso_2022_jp_out.txt":"9b6f015329dda6c3f9ee5ce6dbd6fa9c89acc21283e886836c78b8d833480c21","src/test_data/iso_2022_jp_out_ref.txt":"78cb260093a20116ad9a42f43b05d1848c5ab100b6b9a850749809e943884b35","src/test_data/jis0208_in.txt":"6df3030553ffb0a6615bb33dc8ea9dca6d9623a9028e2ffec754ce3c3da824cc","src/test_data/jis0208_in_ref.txt":"3dc4e6a5e06471942d086b16c9440945e78415f6f3f47e43717e4bc2eac2cdf5","src/test_data/jis0208_out.txt":"4ec24477e1675ce750733bdc3c5add1cd27b6bd4ce1f09289564646e9654e857","src/test_data/jis0208_out_ref.txt":"c3e1cef5032b2b1d93a406f31ff940c4e2dfe8859b8b17ca2761fee7a75a0e48","src/test_data/jis0212_in.txt":"c011f0dd72bd7c8cd922df9374ef8d2769a77190514c77f6c62b415852eeb9fe","src/test_data/jis0212_in_ref.txt":"7d9458b3d2f73e7092a7f505c08ce1d233dde18aa679fbcf9889256239cc9e06","src/test_data/shift_jis_in.txt":"02e389ccef0dd2122e63f503899402cb7f797912c2444cc80ab93131116c5524","src/test_data/shift_jis_in_ref.txt":"512f985950ca902e643c88682dba9708b7c38d3c5ec2925168ab00ac94ab19f9","src/test_data/shift_jis_out.txt":"5fbc44da7bf639bf6cfe0fa1fd3eba7102b88f81919c9ea991302712f69426fb","src/test_data/shift_jis_out_ref.txt":"466322c6fed8286c64582731755290c2296508efdd258826e6279686649b481f","src/test_labels_names.rs":"23a2e11b02b3b8d15fb5613a625e3edb2c61e70e3c581abfd638719a4088200d","src/testing.rs":"f59e671e95a98a56f6b573e8c6be4d71e670bf52f7e20eb1605d990aafa1894e","src/utf_16.rs":"c071a147fad38d750c2c247e141b76b929a48007b99f26b2922b9caecdaf2f25","src/utf_8.rs":"4bbda750d4cfcc1031d42b358955a5ef94381dbaf9c8820cfa7354fad2ede4a7","src/variant.rs":"1fab5363588a1554a7169de8731ea9cded7ac63ea35caabdd1c27a8dde68c27b","src/x_user_defined.rs":"c9c010730dfb9f141d4fed19350c08a21af240913a54bb64f5ca89ff93b6b7d1"},"package":"9852635589dc9f9ea1b6fe9f05b50ef208c85c834a562f0c6abb1c475736ec2b"}
\ No newline at end of file
diff --git a/third_party/rust/encoding_rs/CONTRIBUTING.md b/third_party/rust/encoding_rs/CONTRIBUTING.md
index ef268e308fca..e05207ed6626 100644
--- a/third_party/rust/encoding_rs/CONTRIBUTING.md
+++ b/third_party/rust/encoding_rs/CONTRIBUTING.md
@@ -29,8 +29,9 @@ Please do not contribute implementations of encodings that are not specified
 in the [Encoding Standard](https://encoding.spec.whatwg.org/).
 
 For example, an implementation of UTF-7 is explicitly out of scope for this
-crate and is, therefore, provided by the [charset](https://crates.io/crates/charset)
-crate instead.
+crate and is, therefore, provided by the [`charset`](https://crates.io/crates/charset)
+crate instead. For single-byte DOS encodings, please see the
+[`oem_cp`](https://crates.io/crates/oem_cp) crate.
 
 ## Compatibility with Stable Rust
 
diff --git a/third_party/rust/encoding_rs/COPYRIGHT b/third_party/rust/encoding_rs/COPYRIGHT
index 607467e3aab3..83d3ece14099 100644
--- a/third_party/rust/encoding_rs/COPYRIGHT
+++ b/third_party/rust/encoding_rs/COPYRIGHT
@@ -1,4 +1,4 @@
-encoding_rs is copyright 2013-2016 Mozilla Foundation.
+encoding_rs is copyright Mozilla Foundation.
 
 Licensed under the Apache License, Version 2.0
 <LICENSE-APACHE or
@@ -8,5 +8,10 @@ at your option. All files in the project carrying such
 notice may not be copied, modified, or distributed except
 according to those terms.
 
+This crate includes data derived from the data files supplied
+with the WHATWG Encoding Standard, which, when incorporated into
+source code, are licensed under the BSD 3-Clause License
+<LICENSE-WHATWG>.
+
 Test code within encoding_rs is dedicated to the Public Domain when so
 designated (see the individual files for PD/CC0-dedicated sections).
diff --git a/third_party/rust/encoding_rs/Cargo.toml b/third_party/rust/encoding_rs/Cargo.toml
index 9497c8c07e18..5fafdfa9aea5 100644
--- a/third_party/rust/encoding_rs/Cargo.toml
+++ b/third_party/rust/encoding_rs/Cargo.toml
@@ -3,37 +3,51 @@
 # When uploading crates to the registry Cargo will automatically
 # "normalize" Cargo.toml files for maximal compatibility
 # with all versions of Cargo and also rewrite `path` dependencies
-# to registry (e.g., crates.io) dependencies
+# to registry (e.g., crates.io) dependencies.
 #
-# If you believe there's an error in this file please file an
-# issue against the rust-lang/cargo repository. If you're
-# editing this file be aware that the upstream Cargo.toml
-# will likely look very different (and much more reasonable)
+# If you are reading this file be aware that the original Cargo.toml
+# will likely look very different (and much more reasonable).
+# See Cargo.toml.orig for the original contents.
 
 [package]
+edition = "2018"
 name = "encoding_rs"
-version = "0.8.22"
+version = "0.8.31"
 authors = ["Henri Sivonen <hsivonen@hsivonen.fi>"]
 description = "A Gecko-oriented implementation of the Encoding Standard"
 homepage = "https://docs.rs/encoding_rs/"
 documentation = "https://docs.rs/encoding_rs/"
 readme = "README.md"
-keywords = ["encoding", "web", "unicode", "charset"]
-categories = ["text-processing", "encoding", "web-programming", "internationalization"]
-license = "MIT/Apache-2.0"
+keywords = [
+    "encoding",
+    "web",
+    "unicode",
+    "charset",
+]
+categories = [
+    "text-processing",
+    "encoding",
+    "web-programming",
+    "internationalization",
+]
+license = "(Apache-2.0 OR MIT) AND BSD-3-Clause"
 repository = "https://github.com/hsivonen/encoding_rs"
+
 [profile.release]
 lto = true
+
 [dependencies.cfg-if]
-version = "0.1.0"
+version = "1.0"
 
 [dependencies.packed_simd]
-version = "0.3.3"
+version = "0.3.4"
 optional = true
+package = "packed_simd_2"
 
 [dependencies.serde]
 version = "1.0"
 optional = true
+
 [dev-dependencies.bincode]
 version = "1.0"
 
@@ -44,15 +58,27 @@ version = "1.0"
 version = "1.0"
 
 [features]
+alloc = []
+default = ["alloc"]
 fast-big5-hanzi-encode = []
 fast-gb-hanzi-encode = []
 fast-hangul-encode = []
 fast-hanja-encode = []
 fast-kanji-encode = []
-fast-legacy-encode = ["fast-hangul-encode", "fast-hanja-encode", "fast-kanji-encode", "fast-gb-hanzi-encode", "fast-big5-hanzi-encode"]
+fast-legacy-encode = [
+    "fast-hangul-encode",
+    "fast-hanja-encode",
+    "fast-kanji-encode",
+    "fast-gb-hanzi-encode",
+    "fast-big5-hanzi-encode",
+]
 less-slow-big5-hanzi-encode = []
 less-slow-gb-hanzi-encode = []
 less-slow-kanji-encode = []
-simd-accel = ["packed_simd", "packed_simd/into_bits"]
+simd-accel = [
+    "packed_simd",
+    "packed_simd/into_bits",
+]
+
 [badges.travis-ci]
 repository = "hsivonen/encoding_rs"
diff --git a/third_party/rust/encoding_rs/LICENSE-MIT b/third_party/rust/encoding_rs/LICENSE-MIT
index ede86d4596eb..3317c82e2f67 100644
--- a/third_party/rust/encoding_rs/LICENSE-MIT
+++ b/third_party/rust/encoding_rs/LICENSE-MIT
@@ -1,4 +1,4 @@
-Copyright (c) 2013-2016 Mozilla Foundation
+Copyright Mozilla Foundation
 
 Permission is hereby granted, free of charge, to any
 person obtaining a copy of this software and associated
diff --git a/third_party/rust/encoding_rs/LICENSE-WHATWG b/third_party/rust/encoding_rs/LICENSE-WHATWG
new file mode 100644
index 000000000000..f690e7196590
--- /dev/null
+++ b/third_party/rust/encoding_rs/LICENSE-WHATWG
@@ -0,0 +1,26 @@
+Copyright © WHATWG (Apple, Google, Mozilla, Microsoft).
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, this
+   list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice,
+   this list of conditions and the following disclaimer in the documentation
+   and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its
+   contributors may be used to endorse or promote products derived from
+   this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/third_party/rust/encoding_rs/README.md b/third_party/rust/encoding_rs/README.md
index 0f4d2e695ad5..d75d77d9a161 100644
--- a/third_party/rust/encoding_rs/README.md
+++ b/third_party/rust/encoding_rs/README.md
@@ -1,13 +1,18 @@
 # encoding_rs
 
 [![Build Status](https://travis-ci.org/hsivonen/encoding_rs.svg?branch=master)](https://travis-ci.org/hsivonen/encoding_rs)
-[![crates.io](https://meritbadge.herokuapp.com/encoding_rs)](https://crates.io/crates/encoding_rs)
+[![crates.io](https://img.shields.io/crates/v/encoding_rs.svg)](https://crates.io/crates/encoding_rs)
 [![docs.rs](https://docs.rs/encoding_rs/badge.svg)](https://docs.rs/encoding_rs/)
-[![Apache 2 / MIT dual-licensed](https://img.shields.io/badge/license-Apache%202%20%2F%20MIT-blue.svg)](https://github.com/hsivonen/encoding_rs/blob/master/COPYRIGHT)
 
 encoding_rs an implementation of the (non-JavaScript parts of) the
-[Encoding Standard](https://encoding.spec.whatwg.org/) written in Rust and
-used in Gecko (starting with Firefox 56).
+[Encoding Standard](https://encoding.spec.whatwg.org/) written in Rust.
+
+The Encoding Standard defines the Web-compatible set of character encodings,
+which means this crate can be used to decode Web content. encoding_rs is
+used in Gecko starting with Firefox 56. Due to the notable overlap between
+the legacy encodings on the Web and the legacy encodings used on Windows,
+this crate may be of use for non-Web-related situations as well; see below
+for links to adjacent crates.
 
 Additionally, the `mem` module provides various operations for dealing with
 in-RAM text (as opposed to data that's coming from or going to an IO boundary).
@@ -75,6 +80,13 @@ a `std::io::Read`, decode it into UTF-8 and presenting the result via
 `std::io::Read`. The [`encoding_rs_io`](https://crates.io/crates/encoding_rs_io)
 crate provides that capability.
 
+## `no_std` Environment
+
+The crate works in a `no_std` environment. By default, the `alloc` feature,
+which assumes that an allocator is present is enabled. For a no-allocator
+environment, the default features (i.e. `alloc`) can be turned off. This
+makes the part of the API that returns `Vec`/`String`/`Cow` unavailable.
+
 ## Decoding Email
 
 For decoding character encodings that occur in email, use the
@@ -86,6 +98,11 @@ one directly. (It wraps this crate and adds UTF-7 decoding.)
 For mappings to and from Windows code page identifiers, use the
 [`codepage`](https://crates.io/crates/codepage) crate.
 
+## DOS Encodings
+
+This crate does not support single-byte DOS encodings that aren't required by
+the Web Platform, but the [`oem_cp`](https://crates.io/crates/oem_cp) crate does.
+
 ## Preparing Text for the Encoders
 
 Normalizing text into Unicode Normalization Form C prior to encoding text into
@@ -100,9 +117,20 @@ characters. Vietnamese tone marks can be decomposed using the
 
 ## Licensing
 
+TL;DR: `(Apache-2.0 OR MIT) AND BSD-3-Clause` for the code and data combination.
+
 Please see the file named
 [COPYRIGHT](https://github.com/hsivonen/encoding_rs/blob/master/COPYRIGHT).
 
+The non-test code that isn't generated from the WHATWG data in this crate is
+under Apache-2.0 OR MIT. Test code is under CC0.
+
+This crate contains code/data generated from WHATWG-supplied data. The WHATWG
+upstream changed its license for portions of specs incorporated into source code
+from CC0 to BSD-3-Clause between the initial release of this crate and the present
+version of this crate. The in-source licensing legends have been updated for the
+parts of the generated code that have changed since the upstream license change.
+
 ## Documentation
 
 Generated [API documentation](https://docs.rs/encoding_rs/) is available
@@ -139,7 +167,7 @@ There are currently these optional cargo features:
 
 ### `simd-accel`
 
-Enables SIMD acceleration using the nightly-dependent `packed_simd` crate.
+Enables SIMD acceleration using the nightly-dependent `packed_simd_2` crate.
 
 This is an opt-in feature, because enabling this feature _opts out_ of Rust's
 guarantees of future compilers compiling old code (aka. "stability story").
@@ -160,7 +188,7 @@ feature.
 _Note!_ If you are compiling for a target that does not have 128-bit SIMD
 enabled as part of the target definition and you are enabling 128-bit SIMD
 using `-C target_feature`, you need to enable the `core_arch` Cargo feature
-for `packed_simd` to compile a crates.io snapshot of `core_arch` instead of
+for `packed_simd_2` to compile a crates.io snapshot of `core_arch` instead of
 using the standard-library copy of `core::arch`, because the `core::arch`
 module of the pre-compiled standard library has been compiled with the
 assumption that the CPU doesn't have 128-bit SIMD. At present this applies
@@ -345,16 +373,16 @@ A framework for measuring performance is [available separately][2].
 ## Rust Version Compatibility
 
 It is a goal to support the latest stable Rust, the latest nightly Rust and
-the version of Rust that's used for Firefox Nightly (currently 1.29.0).
-These are tested on Travis.
+the version of Rust that's used for Firefox Nightly.
+
+At this time, there is no firm commitment to support a version older than
+what's required by Firefox, and there is no commitment to treat MSRV changes
+as semver-breaking, because this crate depends on `cfg-if`, which doesn't
+appear to treat MSRV changes as semver-breaking, so it would be useless for
+this crate to treat MSRV changes as semver-breaking.
 
-Additionally, beta and the oldest known to work Rust version (currently
-1.29.0) are tested on Travis. The oldest Rust known to work is tested as
-a canary so that when the oldest known to work no longer works, the change
-can be documented here. At this time, there is no firm commitment to support
-a version older than what's required by Firefox. The oldest supported Rust
-is expected to move forward rapidly when `packed_simd` can replace the `simd`
-crate without performance regression.
+As of 2021-02-04, MSRV appears to be Rust 1.36.0 for using the crate and
+1.42.0 for doc tests to pass without errors about the global allocator.
 
 ## Compatibility with rust-encoding
 
@@ -376,7 +404,10 @@ To regenerate the generated code:
    next to the `encoding_rs` directory.
  * Clone [`https://github.com/whatwg/encoding`](https://github.com/whatwg/encoding)
    next to the `encoding_rs` directory.
- * Checkout revision `f381389` of the `encoding` repo.
+ * Checkout revision `be3337450e7df1c49dca7872153c4c4670dd8256` of the `encoding` repo.
+   (Note: `f381389` was the revision of `encoding` used from before the `encoding` repo
+   license change. So far, only output changed since then has been updated to
+   the new license legend.)
  * With the `encoding_rs` directory as the working directory, run
    `python generate-encoding-data.py`.
 
@@ -414,14 +445,56 @@ To regenerate the generated code:
       adapted to Rust in rust-encoding.~
 - [x] Add actually fast CJK encode options.
 - [ ] ~Investigate [Bob Steagall's lookup table acceleration for UTF-8](https://github.com/BobSteagall/CppNow2018/blob/master/FastConversionFromUTF-8/Fast%20Conversion%20From%20UTF-8%20with%20C%2B%2B%2C%20DFAs%2C%20and%20SSE%20Intrinsics%20-%20Bob%20Steagall%20-%20C%2B%2BNow%202018.pdf).~
+- [ ] Provide a build mode that works without `alloc` (with lesser API surface).
+- [ ] Migrate to `std::simd` once it is stable and declare 1.0.
 
 ## Release Notes
 
-## 0.8.22
+### 0.8.31
+
+* Use SPDX with parentheses now that crates.io supports parentheses.
+
+### 0.8.30
+
+* Update the licensing information to take into account the WHATWG data license change.
+
+### 0.8.29
+
+* Make the parts that use an allocator optional.
+
+### 0.8.28
+
+* Fix error in Serde support introduced as part of `no_std` support.
+
+### 0.8.27
+
+* Make the crate works in a `no_std` environment (with `alloc`).
+
+### 0.8.26
+
+* Fix oversights in edition 2018 migration that broke the `simd-accel` feature.
+
+### 0.8.25
+
+* Do pointer alignment checks in a way where intermediate steps aren't defined to be Undefined Behavior.
+* Update the `packed_simd` dependency to `packed_simd_2`.
+* Update the `cfg-if` dependency to 1.0.
+* Address warnings that have been introduced by newer Rust versions along the way.
+* Update to edition 2018, since even prior to 1.0 `cfg-if` updated to edition 2018 without a semver break.
+
+### 0.8.24
+
+* Avoid computing an intermediate (not dereferenced) pointer value in a manner designated as Undefined Behavior when computing pointer alignment.
+
+### 0.8.23
+
+* Remove year from copyright notices. (No features or bug fixes.)
+
+### 0.8.22
 
 * Formatting fix and new unit test. (No features or bug fixes.)
 
-## 0.8.21
+### 0.8.21
 
 * Fixed a panic with invalid UTF-16[BE|LE] input at the end of the stream.
 
diff --git a/third_party/rust/encoding_rs/ci/miri.sh b/third_party/rust/encoding_rs/ci/miri.sh
new file mode 100644
index 000000000000..8bf217fecd8d
--- /dev/null
+++ b/third_party/rust/encoding_rs/ci/miri.sh
@@ -0,0 +1,14 @@
+set -ex
+
+# Install Miri.
+MIRI_NIGHTLY=nightly-$(curl -s https://rust-lang.github.io/rustup-components-history/x86_64-unknown-linux-gnu/miri)
+echo "Installing latest nightly with Miri: $MIRI_NIGHTLY"
+rustup default "$MIRI_NIGHTLY"
+rustup component add miri
+
+# Run tests.
+# Stacked Borrows is disabled as it costs too much RAM (due to our large tables).
+MIRIFLAGS="-Zmiri-disable-stacked-borrows" cargo miri test
+
+# Restore old state in case Travis uses this cache for other jobs.
+rustup default nightly
diff --git a/third_party/rust/encoding_rs/generate-encoding-data.py b/third_party/rust/encoding_rs/generate-encoding-data.py
index cecb88e684de..99cec1adc5af 100644
--- a/third_party/rust/encoding_rs/generate-encoding-data.py
+++ b/third_party/rust/encoding_rs/generate-encoding-data.py
@@ -1,6 +1,6 @@
 #!/usr/bin/python
 
-# Copyright 2013-2016 Mozilla Foundation. See the COPYRIGHT
+# Copyright Mozilla Foundation. See the COPYRIGHT
 # file at the top-level directory of this distribution.
 #
 # Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -1171,7 +1171,7 @@ data_file.close()
 # Variant
 
 variant_file = open("src/variant.rs", "w")
-variant_file.write('''// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+variant_file.write('''// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -1446,12 +1446,20 @@ single_byte_file.write("""
     #[test]
     fn test_single_byte_decode() {""")
 
+idx = 0 # for Miri, return after 2nd test
 for name in preferred:
   if name == u"ISO-8859-8-I":
     continue;
   if is_single_byte(name):
     single_byte_file.write("""
         decode_single_byte(%s, &data::SINGLE_BYTE_DATA.%s);""" % (to_constant_name(name), to_snake_name(name)))
+    idx += 1
+    if idx == 2:
+      single_byte_file.write("""
+        if cfg!(miri) {
+            // Miri is too slow
+            return;
+        }""")
 
 single_byte_file.write("""
     }
@@ -1459,12 +1467,21 @@ single_byte_file.write("""
     #[test]
     fn test_single_byte_encode() {""")
 
+
+idx = 0 # for Miri, return after 2nd test
 for name in preferred:
   if name == u"ISO-8859-8-I":
     continue;
   if is_single_byte(name):
     single_byte_file.write("""
         encode_single_byte(%s, &data::SINGLE_BYTE_DATA.%s);""" % (to_constant_name(name), to_snake_name(name)))
+    idx += 1
+    if idx == 2:
+      single_byte_file.write("""
+        if cfg!(miri) {
+            // Miri is too slow
+            return;
+        }""")
 
 
 single_byte_file.write("""
@@ -1476,7 +1493,7 @@ single_byte_file.close()
 
 static_file = open("../encoding_c/include/encoding_rs_statics.h", "w")
 
-static_file.write("""// Copyright 2016 Mozilla Foundation. See the COPYRIGHT
+static_file.write("""// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
diff --git a/third_party/rust/encoding_rs/src/ascii.rs b/third_party/rust/encoding_rs/src/ascii.rs
index 96ee179b67cb..b8fb250ca241 100644
--- a/third_party/rust/encoding_rs/src/ascii.rs
+++ b/third_party/rust/encoding_rs/src/ascii.rs
@@ -1,4 +1,4 @@
-// Copyright 2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -29,14 +29,14 @@
         all(target_endian = "little", target_feature = "neon")
     )
 ))]
-use simd_funcs::*;
+use crate::simd_funcs::*;
 
 cfg_if! {
     if #[cfg(feature = "simd-accel")] {
         #[allow(unused_imports)]
-        use ::std::intrinsics::unlikely;
+        use ::core::intrinsics::unlikely;
         #[allow(unused_imports)]
-        use ::std::intrinsics::likely;
+        use ::core::intrinsics::likely;
     } else {
         #[allow(dead_code)]
         #[inline(always)]
@@ -103,7 +103,7 @@ macro_rules! ascii_alu {
                 let mut until_alignment = {
                     // Check if the other unit aligns if we move the narrower unit
                     // to alignment.
-                    //               if ::std::mem::size_of::<$src_unit>() == ::std::mem::size_of::<$dst_unit>() {
+                    //               if ::core::mem::size_of::<$src_unit>() == ::core::mem::size_of::<$dst_unit>() {
                     // ascii_to_ascii
                     let src_alignment = (src as usize) & ALU_ALIGNMENT_MASK;
                     let dst_alignment = (dst as usize) & ALU_ALIGNMENT_MASK;
@@ -111,7 +111,7 @@ macro_rules! ascii_alu {
                         break;
                     }
                     (ALU_ALIGNMENT - src_alignment) & ALU_ALIGNMENT_MASK
-                    //               } else if ::std::mem::size_of::<$src_unit>() < ::std::mem::size_of::<$dst_unit>() {
+                    //               } else if ::core::mem::size_of::<$src_unit>() < ::core::mem::size_of::<$dst_unit>() {
                     // ascii_to_basic_latin
                     //                   let src_until_alignment = (ALIGNMENT - ((src as usize) & ALIGNMENT_MASK)) & ALIGNMENT_MASK;
                     //                   if (dst.add(src_until_alignment) as usize) & ALIGNMENT_MASK != 0 {
@@ -197,7 +197,7 @@ macro_rules! basic_latin_alu {
                 let mut until_alignment = {
                     // Check if the other unit aligns if we move the narrower unit
                     // to alignment.
-                    //               if ::std::mem::size_of::<$src_unit>() == ::std::mem::size_of::<$dst_unit>() {
+                    //               if ::core::mem::size_of::<$src_unit>() == ::core::mem::size_of::<$dst_unit>() {
                     // ascii_to_ascii
                     //                   let src_alignment = (src as usize) & ALIGNMENT_MASK;
                     //                   let dst_alignment = (dst as usize) & ALIGNMENT_MASK;
@@ -206,12 +206,14 @@ macro_rules! basic_latin_alu {
                     //                   }
                     //                   (ALIGNMENT - src_alignment) & ALIGNMENT_MASK
                     //               } else
-                    if ::std::mem::size_of::<$src_unit>() < ::std::mem::size_of::<$dst_unit>() {
+                    if ::core::mem::size_of::<$src_unit>() < ::core::mem::size_of::<$dst_unit>() {
                         // ascii_to_basic_latin
                         let src_until_alignment = (ALU_ALIGNMENT
                             - ((src as usize) & ALU_ALIGNMENT_MASK))
                             & ALU_ALIGNMENT_MASK;
-                        if (dst.add(src_until_alignment) as usize) & ALU_ALIGNMENT_MASK != 0 {
+                        if (dst.wrapping_add(src_until_alignment) as usize) & ALU_ALIGNMENT_MASK
+                            != 0
+                        {
                             break;
                         }
                         src_until_alignment
@@ -220,7 +222,9 @@ macro_rules! basic_latin_alu {
                         let dst_until_alignment = (ALU_ALIGNMENT
                             - ((dst as usize) & ALU_ALIGNMENT_MASK))
                             & ALU_ALIGNMENT_MASK;
-                        if (src.add(dst_until_alignment) as usize) & ALU_ALIGNMENT_MASK != 0 {
+                        if (src.wrapping_add(dst_until_alignment) as usize) & ALU_ALIGNMENT_MASK
+                            != 0
+                        {
                             break;
                         }
                         dst_until_alignment
@@ -286,12 +290,14 @@ macro_rules! latin1_alu {
             // This loop is only broken out of as a `goto` forward
             loop {
                 let mut until_alignment = {
-                    if ::std::mem::size_of::<$src_unit>() < ::std::mem::size_of::<$dst_unit>() {
+                    if ::core::mem::size_of::<$src_unit>() < ::core::mem::size_of::<$dst_unit>() {
                         // unpack
                         let src_until_alignment = (ALU_ALIGNMENT
                             - ((src as usize) & ALU_ALIGNMENT_MASK))
                             & ALU_ALIGNMENT_MASK;
-                        if (dst.add(src_until_alignment) as usize) & ALU_ALIGNMENT_MASK != 0 {
+                        if (dst.wrapping_add(src_until_alignment) as usize) & ALU_ALIGNMENT_MASK
+                            != 0
+                        {
                             break;
                         }
                         src_until_alignment
@@ -300,7 +306,9 @@ macro_rules! latin1_alu {
                         let dst_until_alignment = (ALU_ALIGNMENT
                             - ((dst as usize) & ALU_ALIGNMENT_MASK))
                             & ALU_ALIGNMENT_MASK;
-                        if (src.add(dst_until_alignment) as usize) & ALU_ALIGNMENT_MASK != 0 {
+                        if (src.wrapping_add(dst_until_alignment) as usize) & ALU_ALIGNMENT_MASK
+                            != 0
+                        {
                             break;
                         }
                         dst_until_alignment
@@ -439,7 +447,7 @@ macro_rules! ascii_simd_check_align_unrolled {
             dst: *mut $dst_unit,
             len: usize,
         ) -> Option<($src_unit, usize)> {
-            let unit_size = ::std::mem::size_of::<$src_unit>();
+            let unit_size = ::core::mem::size_of::<$src_unit>();
             let mut offset = 0usize;
             // This loop is only broken out of as a goto forward without
             // actually looping
@@ -621,7 +629,7 @@ macro_rules! latin1_simd_check_align_unrolled {
     ) => {
         #[inline(always)]
         pub unsafe fn $name(src: *const $src_unit, dst: *mut $dst_unit, len: usize) {
-            let unit_size = ::std::mem::size_of::<$src_unit>();
+            let unit_size = ::core::mem::size_of::<$src_unit>();
             let mut offset = 0usize;
             if SIMD_STRIDE_SIZE <= len {
                 let mut until_alignment = ((SIMD_STRIDE_SIZE
@@ -1500,9 +1508,10 @@ pub fn iso_2022_jp_ascii_valid_up_to(bytes: &[u8]) -> usize {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::*;
+    use alloc::vec::Vec;
 
     macro_rules! test_ascii {
         ($test_name:ident, $fn_tested:ident, $src_unit:ty, $dst_unit:ty) => {
diff --git a/third_party/rust/encoding_rs/src/big5.rs b/third_party/rust/encoding_rs/src/big5.rs
index ff4e13055c12..5c72c5ef9c81 100644
--- a/third_party/rust/encoding_rs/src/big5.rs
+++ b/third_party/rust/encoding_rs/src/big5.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,9 +8,9 @@
 // except according to those terms.
 
 use super::*;
-use data::*;
-use handles::*;
-use variant::*;
+use crate::data::*;
+use crate::handles::*;
+use crate::variant::*;
 // Rust 1.14.0 requires the following despite the asterisk above.
 use super::in_inclusive_range32;
 
@@ -263,7 +263,7 @@ impl Big5Encoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
@@ -365,18 +365,21 @@ mod tests {
         // ASCII
         encode_big5("\u{0061}\u{0062}", b"\x61\x62");
 
-        // Edge cases
-        encode_big5("\u{9EA6}\u{0061}", b"&#40614;\x61");
-        encode_big5("\u{2626B}\u{0061}", b"&#156267;\x61");
-        encode_big5("\u{3000}", b"\xA1\x40");
-        encode_big5("\u{20AC}", b"\xA3\xE1");
-        encode_big5("\u{4E00}", b"\xA4\x40");
-        encode_big5("\u{27607}", b"\xC8\xA4");
-        encode_big5("\u{FFE2}", b"\xC8\xCD");
-        encode_big5("\u{79D4}", b"\xFE\xFE");
-
-        // Not in index
-        encode_big5("\u{2603}\u{0061}", b"&#9731;\x61");
+        if !cfg!(miri) {
+            // Miri is too slow
+            // Edge cases
+            encode_big5("\u{9EA6}\u{0061}", b"&#40614;\x61");
+            encode_big5("\u{2626B}\u{0061}", b"&#156267;\x61");
+            encode_big5("\u{3000}", b"\xA1\x40");
+            encode_big5("\u{20AC}", b"\xA3\xE1");
+            encode_big5("\u{4E00}", b"\xA4\x40");
+            encode_big5("\u{27607}", b"\xC8\xA4");
+            encode_big5("\u{FFE2}", b"\xC8\xCD");
+            encode_big5("\u{79D4}", b"\xFE\xFE");
+
+            // Not in index
+            encode_big5("\u{2603}\u{0061}", b"&#9731;\x61");
+        }
 
         // duplicate low bits
         encode_big5("\u{203B5}", b"\xFD\x6A");
@@ -387,6 +390,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_big5_decode_all() {
         let input = include_bytes!("test_data/big5_in.txt");
         let expectation = include_str!("test_data/big5_in_ref.txt");
@@ -396,6 +400,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_big5_encode_all() {
         let input = include_str!("test_data/big5_out.txt");
         let expectation = include_bytes!("test_data/big5_out_ref.txt");
@@ -406,6 +411,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_big5_encode_from_two_low_surrogates() {
         let expectation = b"&#65533;&#65533;";
         let mut output = [0u8; 40];
diff --git a/third_party/rust/encoding_rs/src/data.rs b/third_party/rust/encoding_rs/src/data.rs
index 32e700bb8c08..c1ae89e15bfc 100644
--- a/third_party/rust/encoding_rs/src/data.rs
+++ b/third_party/rust/encoding_rs/src/data.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
diff --git a/third_party/rust/encoding_rs/src/euc_jp.rs b/third_party/rust/encoding_rs/src/euc_jp.rs
index c2f3ad307e50..18d1e11ad939 100644
--- a/third_party/rust/encoding_rs/src/euc_jp.rs
+++ b/third_party/rust/encoding_rs/src/euc_jp.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,9 +8,9 @@
 // except according to those terms.
 
 use super::*;
-use data::*;
-use handles::*;
-use variant::*;
+use crate::data::*;
+use crate::handles::*;
+use crate::variant::*;
 // Rust 1.14.0 requires the following despite the asterisk above.
 use super::in_inclusive_range16;
 
@@ -346,7 +346,7 @@ impl EucJpEncoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
@@ -437,6 +437,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_jis0208_decode_all() {
         let input = include_bytes!("test_data/jis0208_in.txt");
         let expectation = include_str!("test_data/jis0208_in_ref.txt");
@@ -446,6 +447,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_jis0208_encode_all() {
         let input = include_str!("test_data/jis0208_out.txt");
         let expectation = include_bytes!("test_data/jis0208_out_ref.txt");
@@ -456,6 +458,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_jis0212_decode_all() {
         let input = include_bytes!("test_data/jis0212_in.txt");
         let expectation = include_str!("test_data/jis0212_in_ref.txt");
diff --git a/third_party/rust/encoding_rs/src/euc_kr.rs b/third_party/rust/encoding_rs/src/euc_kr.rs
index e9a8398f59ef..6487d45993b6 100644
--- a/third_party/rust/encoding_rs/src/euc_kr.rs
+++ b/third_party/rust/encoding_rs/src/euc_kr.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,9 +8,9 @@
 // except according to those terms.
 
 use super::*;
-use data::*;
-use handles::*;
-use variant::*;
+use crate::data::*;
+use crate::handles::*;
+use crate::variant::*;
 // Rust 1.14.0 requires the following despite the asterisk above.
 use super::in_inclusive_range16;
 use super::in_range16;
@@ -362,7 +362,7 @@ impl EucKrEncoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
@@ -406,6 +406,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_euc_kr_decode_all() {
         let input = include_bytes!("test_data/euc_kr_in.txt");
         let expectation = include_str!("test_data/euc_kr_in_ref.txt");
@@ -415,6 +416,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_euc_kr_encode_all() {
         let input = include_str!("test_data/euc_kr_out.txt");
         let expectation = include_bytes!("test_data/euc_kr_out_ref.txt");
diff --git a/third_party/rust/encoding_rs/src/gb18030.rs b/third_party/rust/encoding_rs/src/gb18030.rs
index b2184516a53d..a0b3bd7f03de 100644
--- a/third_party/rust/encoding_rs/src/gb18030.rs
+++ b/third_party/rust/encoding_rs/src/gb18030.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,9 +8,9 @@
 // except according to those terms.
 
 use super::*;
-use data::*;
-use handles::*;
-use variant::*;
+use crate::data::*;
+use crate::handles::*;
+use crate::variant::*;
 // Rust 1.14.0 requires the following despite the asterisk above.
 use super::in_inclusive_range16;
 use super::in_range16;
@@ -571,7 +571,7 @@ impl Gb18030Encoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
@@ -653,12 +653,15 @@ mod tests {
         // two bytes
         encode_gb18030("\u{4E02}", b"\x81\x40");
         encode_gb18030("\u{4E8A}", b"\x81\x7E");
-        encode_gb18030("\u{4E90}", b"\x81\x80");
-        encode_gb18030("\u{4FA2}", b"\x81\xFE");
-        encode_gb18030("\u{FA0C}", b"\xFE\x40");
-        encode_gb18030("\u{E843}", b"\xFE\x7E");
-        encode_gb18030("\u{4723}", b"\xFE\x80");
-        encode_gb18030("\u{E4C5}", b"\xFE\xFE");
+        if !cfg!(miri) {
+            // Miri is too slow
+            encode_gb18030("\u{4E90}", b"\x81\x80");
+            encode_gb18030("\u{4FA2}", b"\x81\xFE");
+            encode_gb18030("\u{FA0C}", b"\xFE\x40");
+            encode_gb18030("\u{E843}", b"\xFE\x7E");
+            encode_gb18030("\u{4723}", b"\xFE\x80");
+            encode_gb18030("\u{E4C5}", b"\xFE\xFE");
+        }
 
         // The difference from the original GB18030
         encode_gb18030("\u{E5E5}", b"&#58853;");
@@ -667,9 +670,12 @@ mod tests {
         // Four bytes
         encode_gb18030("\u{0080}", b"\x81\x30\x81\x30");
         encode_gb18030("\u{E7C7}", b"\x81\x35\xF4\x37");
-        encode_gb18030("\u{2603}", b"\x81\x37\xA3\x30");
-        encode_gb18030("\u{1F4A9}", b"\x94\x39\xDA\x33");
-        encode_gb18030("\u{10FFFF}", b"\xE3\x32\x9A\x35");
+        if !cfg!(miri) {
+            // Miri is too slow
+            encode_gb18030("\u{2603}", b"\x81\x37\xA3\x30");
+            encode_gb18030("\u{1F4A9}", b"\x94\x39\xDA\x33");
+            encode_gb18030("\u{10FFFF}", b"\xE3\x32\x9A\x35");
+        }
 
         // Edge cases
         encode_gb18030("\u{00F7}", b"\xA1\xC2");
@@ -689,12 +695,15 @@ mod tests {
         // two bytes
         encode_gbk("\u{4E02}", b"\x81\x40");
         encode_gbk("\u{4E8A}", b"\x81\x7E");
-        encode_gbk("\u{4E90}", b"\x81\x80");
-        encode_gbk("\u{4FA2}", b"\x81\xFE");
-        encode_gbk("\u{FA0C}", b"\xFE\x40");
-        encode_gbk("\u{E843}", b"\xFE\x7E");
-        encode_gbk("\u{4723}", b"\xFE\x80");
-        encode_gbk("\u{E4C5}", b"\xFE\xFE");
+        if !cfg!(miri) {
+            // Miri is too slow
+            encode_gbk("\u{4E90}", b"\x81\x80");
+            encode_gbk("\u{4FA2}", b"\x81\xFE");
+            encode_gbk("\u{FA0C}", b"\xFE\x40");
+            encode_gbk("\u{E843}", b"\xFE\x7E");
+            encode_gbk("\u{4723}", b"\xFE\x80");
+            encode_gbk("\u{E4C5}", b"\xFE\xFE");
+        }
 
         // The difference from the original gb18030
         encode_gbk("\u{E5E5}", b"&#58853;");
@@ -703,15 +712,19 @@ mod tests {
         // Four bytes
         encode_gbk("\u{0080}", b"&#128;");
         encode_gbk("\u{E7C7}", b"&#59335;");
-        encode_gbk("\u{2603}", b"&#9731;");
-        encode_gbk("\u{1F4A9}", b"&#128169;");
-        encode_gbk("\u{10FFFF}", b"&#1114111;");
+        if !cfg!(miri) {
+            // Miri is too slow
+            encode_gbk("\u{2603}", b"&#9731;");
+            encode_gbk("\u{1F4A9}", b"&#128169;");
+            encode_gbk("\u{10FFFF}", b"&#1114111;");
+        }
 
         // Edge cases
         encode_gbk("\u{00F7}", b"\xA1\xC2");
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_gb18030_decode_all() {
         let input = include_bytes!("test_data/gb18030_in.txt");
         let expectation = include_str!("test_data/gb18030_in_ref.txt");
@@ -721,6 +734,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_gb18030_encode_all() {
         let input = include_str!("test_data/gb18030_out.txt");
         let expectation = include_bytes!("test_data/gb18030_out_ref.txt");
diff --git a/third_party/rust/encoding_rs/src/handles.rs b/third_party/rust/encoding_rs/src/handles.rs
index 08da62d20051..b5404c01d9bd 100644
--- a/third_party/rust/encoding_rs/src/handles.rs
+++ b/third_party/rust/encoding_rs/src/handles.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -24,7 +24,7 @@
         all(target_endian = "little", target_feature = "neon")
     )
 ))]
-use simd_funcs::*;
+use crate::simd_funcs::*;
 
 #[cfg(all(
     feature = "simd-accel",
@@ -38,9 +38,9 @@ use packed_simd::u16x8;
 
 use super::DecoderResult;
 use super::EncoderResult;
-use ascii::*;
-use utf_8::convert_utf8_to_utf16_up_to_invalid;
-use utf_8::utf8_valid_up_to;
+use crate::ascii::*;
+use crate::utf_8::convert_utf8_to_utf16_up_to_invalid;
+use crate::utf_8::utf8_valid_up_to;
 
 pub enum Space<T> {
     Available(T),
@@ -108,11 +108,13 @@ impl UnalignedU16Slice {
 
     #[inline(always)]
     pub fn at(&self, i: usize) -> u16 {
+        use core::mem::MaybeUninit;
+
         assert!(i < self.len);
         unsafe {
-            let mut u: u16 = ::std::mem::uninitialized();
-            ::std::ptr::copy_nonoverlapping(self.ptr.add(i * 2), &mut u as *mut u16 as *mut u8, 2);
-            u
+            let mut u: MaybeUninit<u16> = MaybeUninit::uninit();
+            ::core::ptr::copy_nonoverlapping(self.ptr.add(i * 2), u.as_mut_ptr() as *mut u8, 2);
+            u.assume_init()
         }
     }
 
@@ -193,7 +195,7 @@ fn copy_unaligned_basic_latin_to_ascii_alu<E: Endian>(
     dst: &mut [u8],
     offset: usize,
 ) -> CopyAsciiResult<usize, (u16, usize)> {
-    let len = ::std::cmp::min(src.len(), dst.len());
+    let len = ::core::cmp::min(src.len(), dst.len());
     let mut i = 0usize;
     loop {
         if i == len {
@@ -232,7 +234,7 @@ fn copy_unaligned_basic_latin_to_ascii<E: Endian>(
     src: UnalignedU16Slice,
     dst: &mut [u8],
 ) -> CopyAsciiResult<usize, (u16, usize)> {
-    let len = ::std::cmp::min(src.len(), dst.len());
+    let len = ::core::cmp::min(src.len(), dst.len());
     let mut offset = 0;
     if SIMD_STRIDE_SIZE <= len {
         let len_minus_stride = len - SIMD_STRIDE_SIZE;
@@ -734,7 +736,7 @@ impl<'a> Utf16Destination<'a> {
         let mut src_unaligned = unsafe {
             UnalignedU16Slice::new(
                 src_remaining.as_ptr(),
-                ::std::cmp::min(src_remaining.len() / 2, dst_remaining.len()),
+                ::core::cmp::min(src_remaining.len() / 2, dst_remaining.len()),
             )
         };
         if src_unaligned.len() == 0 {
@@ -1078,7 +1080,7 @@ impl<'a> Utf8Destination<'a> {
     pub fn copy_utf8_up_to_invalid_from(&mut self, source: &mut ByteSource) {
         let src_remaining = &source.slice[source.pos..];
         let dst_remaining = &mut self.slice[self.pos..];
-        let min_len = ::std::cmp::min(src_remaining.len(), dst_remaining.len());
+        let min_len = ::core::cmp::min(src_remaining.len(), dst_remaining.len());
         // Validate first, then memcpy to let memcpy do its thing even for
         // non-ASCII. (And potentially do something better than SSE2 for ASCII.)
         let valid_len = utf8_valid_up_to(&src_remaining[..min_len]);
@@ -1154,7 +1156,7 @@ impl<'a> Utf16Source<'a> {
         self.pos += 1;
         let unit_minus_surrogate_start = unit.wrapping_sub(0xD800);
         if unit_minus_surrogate_start > (0xDFFF - 0xD800) {
-            return unsafe { ::std::char::from_u32_unchecked(u32::from(unit)) };
+            return unsafe { ::core::char::from_u32_unchecked(u32::from(unit)) };
         }
         if unit_minus_surrogate_start <= (0xDBFF - 0xD800) {
             // high surrogate
@@ -1165,7 +1167,7 @@ impl<'a> Utf16Source<'a> {
                     // The next code unit is a low surrogate. Advance position.
                     self.pos += 1;
                     return unsafe {
-                        ::std::char::from_u32_unchecked(
+                        ::core::char::from_u32_unchecked(
                             (u32::from(unit) << 10) + u32::from(second)
                                 - (((0xD800u32 << 10) - 0x10000u32) + 0xDC00u32),
                         )
@@ -1202,7 +1204,7 @@ impl<'a> Utf16Source<'a> {
                     // The next code unit is a low surrogate. Advance position.
                     self.pos += 1;
                     return Unicode::NonAscii(NonAscii::Astral(unsafe {
-                        ::std::char::from_u32_unchecked(
+                        ::core::char::from_u32_unchecked(
                             (u32::from(unit) << 10) + u32::from(second)
                                 - (((0xD800u32 << 10) - 0x10000u32) + 0xDC00u32),
                         )
@@ -1266,7 +1268,7 @@ impl<'a> Utf16Source<'a> {
                                     // The next code unit is a low surrogate. Advance position.
                                     self.pos += 1;
                                     NonAscii::Astral(unsafe {
-                                        ::std::char::from_u32_unchecked(
+                                        ::core::char::from_u32_unchecked(
                                             (u32::from(unit) << 10) + u32::from(second)
                                                 - (((0xD800u32 << 10) - 0x10000u32) + 0xDC00u32),
                                         )
@@ -1339,7 +1341,7 @@ impl<'a> Utf16Source<'a> {
                                     // The next code unit is a low surrogate. Advance position.
                                     self.pos += 1;
                                     NonAscii::Astral(unsafe {
-                                        ::std::char::from_u32_unchecked(
+                                        ::core::char::from_u32_unchecked(
                                             (u32::from(unit) << 10) + u32::from(second)
                                                 - (((0xD800u32 << 10) - 0x1_0000u32) + 0xDC00u32),
                                         )
@@ -1467,21 +1469,21 @@ impl<'a> Utf8Source<'a> {
             let point =
                 ((u32::from(unit) & 0x1F) << 6) | (u32::from(self.slice[self.pos + 1]) & 0x3F);
             self.pos += 2;
-            return unsafe { ::std::char::from_u32_unchecked(point) };
+            return unsafe { ::core::char::from_u32_unchecked(point) };
         }
         if unit < 0xF0 {
             let point = ((u32::from(unit) & 0xF) << 12)
                 | ((u32::from(self.slice[self.pos + 1]) & 0x3F) << 6)
                 | (u32::from(self.slice[self.pos + 2]) & 0x3F);
             self.pos += 3;
-            return unsafe { ::std::char::from_u32_unchecked(point) };
+            return unsafe { ::core::char::from_u32_unchecked(point) };
         }
         let point = ((u32::from(unit) & 0x7) << 18)
             | ((u32::from(self.slice[self.pos + 1]) & 0x3F) << 12)
             | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)
             | (u32::from(self.slice[self.pos + 3]) & 0x3F);
         self.pos += 4;
-        unsafe { ::std::char::from_u32_unchecked(point) }
+        unsafe { ::core::char::from_u32_unchecked(point) }
     }
     #[inline(always)]
     fn read_enum(&mut self) -> Unicode {
@@ -1510,7 +1512,7 @@ impl<'a> Utf8Source<'a> {
             | (u32::from(self.slice[self.pos + 3]) & 0x3F);
         self.pos += 4;
         Unicode::NonAscii(NonAscii::Astral(unsafe {
-            ::std::char::from_u32_unchecked(point)
+            ::core::char::from_u32_unchecked(point)
         }))
     }
     #[inline(always)]
@@ -1565,7 +1567,7 @@ impl<'a> Utf8Source<'a> {
                             | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)
                             | (u32::from(self.slice[self.pos + 3]) & 0x3F);
                         self.pos += 4;
-                        NonAscii::Astral(unsafe { ::std::char::from_u32_unchecked(point) })
+                        NonAscii::Astral(unsafe { ::core::char::from_u32_unchecked(point) })
                     }
                 }
             }
@@ -1615,7 +1617,7 @@ impl<'a> Utf8Source<'a> {
                                 | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)
                                 | (u32::from(self.slice[self.pos + 3]) & 0x3F);
                             self.pos += 4;
-                            NonAscii::Astral(unsafe { ::std::char::from_u32_unchecked(point) })
+                            NonAscii::Astral(unsafe { ::core::char::from_u32_unchecked(point) })
                         }
                     } else {
                         return CopyAsciiResult::Stop((
@@ -1672,7 +1674,7 @@ impl<'a> Utf8Source<'a> {
                                 | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)
                                 | (u32::from(self.slice[self.pos + 3]) & 0x3F);
                             self.pos += 4;
-                            NonAscii::Astral(unsafe { ::std::char::from_u32_unchecked(point) })
+                            NonAscii::Astral(unsafe { ::core::char::from_u32_unchecked(point) })
                         }
                     } else {
                         return CopyAsciiResult::Stop((
diff --git a/third_party/rust/encoding_rs/src/iso_2022_jp.rs b/third_party/rust/encoding_rs/src/iso_2022_jp.rs
index ab364951549e..d71111a6cece 100644
--- a/third_party/rust/encoding_rs/src/iso_2022_jp.rs
+++ b/third_party/rust/encoding_rs/src/iso_2022_jp.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,9 +8,9 @@
 // except according to those terms.
 
 use super::*;
-use data::*;
-use handles::*;
-use variant::*;
+use crate::data::*;
+use crate::handles::*;
+use crate::variant::*;
 // Rust 1.14.0 requires the following despite the asterisk above.
 use super::in_inclusive_range16;
 
@@ -754,7 +754,7 @@ impl Iso2022JpEncoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
@@ -863,6 +863,11 @@ mod tests {
         decode_iso_2022_jp(b"\x1B$@\x80\x54\x64", "\u{FFFD}\u{58FA}");
         decode_iso_2022_jp(b"\x1B$B\x28\x80", "\u{FFFD}");
 
+        if cfg!(miri) {
+            // Miri is too slow
+            return;
+        }
+
         // Transitions
         decode_iso_2022_jp(b"\x1B(B\x5C\x1B(J\x5C", "\u{005C}\u{00A5}");
         decode_iso_2022_jp(b"\x1B(B\x5C\x1B(I\x21", "\u{005C}\u{FF61}");
@@ -938,35 +943,45 @@ mod tests {
         // Roman
         encode_iso_2022_jp("a\u{00A5}b", b"a\x1B(J\x5Cb\x1B(B");
         encode_iso_2022_jp("a\u{203E}b", b"a\x1B(J\x7Eb\x1B(B");
-        encode_iso_2022_jp("a\u{00A5}b\x5C", b"a\x1B(J\x5Cb\x1B(B\x5C");
-        encode_iso_2022_jp("a\u{203E}b\x7E", b"a\x1B(J\x7Eb\x1B(B\x7E");
-        encode_iso_2022_jp("\u{00A5}\u{1F4A9}", b"\x1B(J\x5C&#128169;\x1B(B");
-        encode_iso_2022_jp("\u{00A5}\x1B", b"\x1B(J\x5C&#65533;\x1B(B");
-        encode_iso_2022_jp("\u{00A5}\x0E", b"\x1B(J\x5C&#65533;\x1B(B");
-        encode_iso_2022_jp("\u{00A5}\x0F", b"\x1B(J\x5C&#65533;\x1B(B");
-        encode_iso_2022_jp("\u{00A5}\u{58FA}", b"\x1B(J\x5C\x1B$B\x54\x64\x1B(B");
+        if !cfg!(miri) {
+            // Miri is too slow
+            encode_iso_2022_jp("a\u{00A5}b\x5C", b"a\x1B(J\x5Cb\x1B(B\x5C");
+            encode_iso_2022_jp("a\u{203E}b\x7E", b"a\x1B(J\x7Eb\x1B(B\x7E");
+            encode_iso_2022_jp("\u{00A5}\u{1F4A9}", b"\x1B(J\x5C&#128169;\x1B(B");
+            encode_iso_2022_jp("\u{00A5}\x1B", b"\x1B(J\x5C&#65533;\x1B(B");
+            encode_iso_2022_jp("\u{00A5}\x0E", b"\x1B(J\x5C&#65533;\x1B(B");
+            encode_iso_2022_jp("\u{00A5}\x0F", b"\x1B(J\x5C&#65533;\x1B(B");
+            encode_iso_2022_jp("\u{00A5}\u{58FA}", b"\x1B(J\x5C\x1B$B\x54\x64\x1B(B");
+        }
 
         // Half-width Katakana
         encode_iso_2022_jp("\u{FF61}", b"\x1B$B\x21\x23\x1B(B");
         encode_iso_2022_jp("\u{FF65}", b"\x1B$B\x21\x26\x1B(B");
-        encode_iso_2022_jp("\u{FF66}", b"\x1B$B\x25\x72\x1B(B");
-        encode_iso_2022_jp("\u{FF70}", b"\x1B$B\x21\x3C\x1B(B");
-        encode_iso_2022_jp("\u{FF9D}", b"\x1B$B\x25\x73\x1B(B");
-        encode_iso_2022_jp("\u{FF9E}", b"\x1B$B\x21\x2B\x1B(B");
-        encode_iso_2022_jp("\u{FF9F}", b"\x1B$B\x21\x2C\x1B(B");
+        if !cfg!(miri) {
+            // Miri is too slow
+            encode_iso_2022_jp("\u{FF66}", b"\x1B$B\x25\x72\x1B(B");
+            encode_iso_2022_jp("\u{FF70}", b"\x1B$B\x21\x3C\x1B(B");
+            encode_iso_2022_jp("\u{FF9D}", b"\x1B$B\x25\x73\x1B(B");
+            encode_iso_2022_jp("\u{FF9E}", b"\x1B$B\x21\x2B\x1B(B");
+            encode_iso_2022_jp("\u{FF9F}", b"\x1B$B\x21\x2C\x1B(B");
+        }
 
         // 0208
         encode_iso_2022_jp("\u{58FA}", b"\x1B$B\x54\x64\x1B(B");
         encode_iso_2022_jp("\u{58FA}\u{250F}", b"\x1B$B\x54\x64\x28\x2E\x1B(B");
-        encode_iso_2022_jp("\u{58FA}\u{1F4A9}", b"\x1B$B\x54\x64\x1B(B&#128169;");
-        encode_iso_2022_jp("\u{58FA}\x1B", b"\x1B$B\x54\x64\x1B(B&#65533;");
-        encode_iso_2022_jp("\u{58FA}\x0E", b"\x1B$B\x54\x64\x1B(B&#65533;");
-        encode_iso_2022_jp("\u{58FA}\x0F", b"\x1B$B\x54\x64\x1B(B&#65533;");
-        encode_iso_2022_jp("\u{58FA}\u{00A5}", b"\x1B$B\x54\x64\x1B(J\x5C\x1B(B");
-        encode_iso_2022_jp("\u{58FA}a", b"\x1B$B\x54\x64\x1B(Ba");
+        if !cfg!(miri) {
+            // Miri is too slow
+            encode_iso_2022_jp("\u{58FA}\u{1F4A9}", b"\x1B$B\x54\x64\x1B(B&#128169;");
+            encode_iso_2022_jp("\u{58FA}\x1B", b"\x1B$B\x54\x64\x1B(B&#65533;");
+            encode_iso_2022_jp("\u{58FA}\x0E", b"\x1B$B\x54\x64\x1B(B&#65533;");
+            encode_iso_2022_jp("\u{58FA}\x0F", b"\x1B$B\x54\x64\x1B(B&#65533;");
+            encode_iso_2022_jp("\u{58FA}\u{00A5}", b"\x1B$B\x54\x64\x1B(J\x5C\x1B(B");
+            encode_iso_2022_jp("\u{58FA}a", b"\x1B$B\x54\x64\x1B(Ba");
+        }
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_iso_2022_jp_decode_all() {
         let input = include_bytes!("test_data/iso_2022_jp_in.txt");
         let expectation = include_str!("test_data/iso_2022_jp_in_ref.txt");
@@ -976,6 +991,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_iso_2022_jp_encode_all() {
         let input = include_str!("test_data/iso_2022_jp_out.txt");
         let expectation = include_bytes!("test_data/iso_2022_jp_out_ref.txt");
diff --git a/third_party/rust/encoding_rs/src/lib.rs b/third_party/rust/encoding_rs/src/lib.rs
index 73f5ec2cca09..bce2738ae152 100644
--- a/third_party/rust/encoding_rs/src/lib.rs
+++ b/third_party/rust/encoding_rs/src/lib.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -11,7 +11,6 @@
     feature = "cargo-clippy",
     allow(doc_markdown, inline_always, new_ret_no_self)
 )]
-#![doc(html_root_url = "https://docs.rs/encoding_rs/0.8.22")]
 
 //! encoding_rs is a Gecko-oriented Free Software / Open Source implementation
 //! of the [Encoding Standard](https://encoding.spec.whatwg.org/) in Rust.
@@ -60,6 +59,7 @@
 //! Decode using the non-streaming API:
 //!
 //! ```
+//! #[cfg(feature = "alloc")] {
 //! use encoding_rs::*;
 //!
 //! let expectation = "\u{30CF}\u{30ED}\u{30FC}\u{30FB}\u{30EF}\u{30FC}\u{30EB}\u{30C9}";
@@ -69,6 +69,7 @@
 //! assert_eq!(&cow[..], expectation);
 //! assert_eq!(encoding_used, SHIFT_JIS);
 //! assert!(!had_errors);
+//! }
 //! ```
 //!
 //! Decode using the streaming API with minimal `unsafe`:
@@ -248,6 +249,9 @@
 //! [charset](https://crates.io/crates/charset) wraps encoding_rs and adds
 //! UTF-7 decoding for email purposes.
 //!
+//! For single-byte DOS encodings beyond the ones supported by the Encoding
+//! Standard, there is the [`oem_cp`](https://crates.io/crates/oem_cp) crate.
+//!
 //! # Preparing Text for the Encoders
 //!
 //! Normalizing text into Unicode Normalization Form C prior to encoding text
@@ -677,8 +681,14 @@
 //! See the section [_UTF-16LE, UTF-16BE and Unicode Encoding Schemes_](#utf-16le-utf-16be-and-unicode-encoding-schemes)
 //! for discussion about the UTF-16 family.
 
+#![no_std]
 #![cfg_attr(feature = "simd-accel", feature(stdsimd, core_intrinsics))]
 
+#[cfg(feature = "alloc")]
+#[cfg_attr(test, macro_use)]
+extern crate alloc;
+
+extern crate core;
 #[macro_use]
 extern crate cfg_if;
 
@@ -717,7 +727,7 @@ mod macros;
 ))]
 mod simd_funcs;
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod testing;
 
 mod big5;
@@ -739,15 +749,20 @@ mod variant;
 
 pub mod mem;
 
-use ascii::ascii_valid_up_to;
-use ascii::iso_2022_jp_ascii_valid_up_to;
-use utf_8::utf8_valid_up_to;
-use variant::*;
-
-use std::borrow::Cow;
-use std::cmp::Ordering;
-use std::hash::Hash;
-use std::hash::Hasher;
+use crate::ascii::ascii_valid_up_to;
+use crate::ascii::iso_2022_jp_ascii_valid_up_to;
+use crate::utf_8::utf8_valid_up_to;
+use crate::variant::*;
+
+#[cfg(feature = "alloc")]
+use alloc::borrow::Cow;
+#[cfg(feature = "alloc")]
+use alloc::string::String;
+#[cfg(feature = "alloc")]
+use alloc::vec::Vec;
+use core::cmp::Ordering;
+use core::hash::Hash;
+use core::hash::Hasher;
 
 #[cfg(feature = "serde")]
 use serde::de::Visitor;
@@ -2129,7 +2144,7 @@ pub static X_USER_DEFINED_INIT: Encoding = Encoding {
 /// `static`.
 pub static X_USER_DEFINED: &'static Encoding = &X_USER_DEFINED_INIT;
 
-static LABELS_SORTED: [&'static str; 219] = [
+static LABELS_SORTED: [&'static str; 228] = [
     "l1",
     "l2",
     "l3",
@@ -2145,6 +2160,7 @@ static LABELS_SORTED: [&'static str; 219] = [
     "utf8",
     "koi8",
     "sjis",
+    "ucs-2",
     "ms932",
     "cp866",
     "utf-8",
@@ -2189,6 +2205,7 @@ static LABELS_SORTED: [&'static str; 219] = [
     "gb_2312",
     "dos-874",
     "cn-big5",
+    "unicode",
     "chinese",
     "logical",
     "cskoi8r",
@@ -2241,6 +2258,7 @@ static LABELS_SORTED: [&'static str; 219] = [
     "iso8859-8",
     "iso-ir-58",
     "iso8859-9",
+    "csunicode",
     "macintosh",
     "shift-jis",
     "shift_jis",
@@ -2300,6 +2318,8 @@ static LABELS_SORTED: [&'static str; 219] = [
     "csisolatin9",
     "csiso88596e",
     "csiso88598e",
+    "unicodefffe",
+    "unicodefeff",
     "csmacintosh",
     "csiso88596i",
     "csiso88598i",
@@ -2326,12 +2346,15 @@ static LABELS_SORTED: [&'static str; 219] = [
     "iso-8859-8-i",
     "sun_eu_greek",
     "csksc56011987",
+    "unicode20utf8",
+    "unicode11utf8",
     "ks_c_5601-1987",
     "ansi_x3.4-1968",
     "ks_c_5601-1989",
     "x-mac-cyrillic",
     "x-user-defined",
     "csiso58gb231280",
+    "iso-10646-ucs-2",
     "iso_8859-1:1987",
     "iso_8859-2:1987",
     "iso_8859-6:1987",
@@ -2340,6 +2363,7 @@ static LABELS_SORTED: [&'static str; 219] = [
     "iso_8859-4:1988",
     "iso_8859-5:1988",
     "iso_8859-8:1988",
+    "x-unicode20utf8",
     "iso_8859-9:1989",
     "csisolatingreek",
     "x-mac-ukrainian",
@@ -2351,7 +2375,7 @@ static LABELS_SORTED: [&'static str; 219] = [
     "cseucpkdfmtjapanese",
 ];
 
-static ENCODINGS_IN_LABEL_SORT: [&'static Encoding; 219] = [
+static ENCODINGS_IN_LABEL_SORT: [&'static Encoding; 228] = [
     &WINDOWS_1252_INIT,
     &ISO_8859_2_INIT,
     &ISO_8859_3_INIT,
@@ -2367,6 +2391,7 @@ static ENCODINGS_IN_LABEL_SORT: [&'static Encoding; 219] = [
     &UTF_8_INIT,
     &KOI8_R_INIT,
     &SHIFT_JIS_INIT,
+    &UTF_16LE_INIT,
     &SHIFT_JIS_INIT,
     &IBM866_INIT,
     &UTF_8_INIT,
@@ -2411,6 +2436,7 @@ static ENCODINGS_IN_LABEL_SORT: [&'static Encoding; 219] = [
     &GBK_INIT,
     &WINDOWS_874_INIT,
     &BIG5_INIT,
+    &UTF_16LE_INIT,
     &GBK_INIT,
     &ISO_8859_8_I_INIT,
     &KOI8_R_INIT,
@@ -2463,6 +2489,7 @@ static ENCODINGS_IN_LABEL_SORT: [&'static Encoding; 219] = [
     &ISO_8859_8_INIT,
     &GBK_INIT,
     &WINDOWS_1254_INIT,
+    &UTF_16LE_INIT,
     &MACINTOSH_INIT,
     &SHIFT_JIS_INIT,
     &SHIFT_JIS_INIT,
@@ -2522,6 +2549,8 @@ static ENCODINGS_IN_LABEL_SORT: [&'static Encoding; 219] = [
     &ISO_8859_15_INIT,
     &ISO_8859_6_INIT,
     &ISO_8859_8_INIT,
+    &UTF_16BE_INIT,
+    &UTF_16LE_INIT,
     &MACINTOSH_INIT,
     &ISO_8859_6_INIT,
     &ISO_8859_8_I_INIT,
@@ -2548,12 +2577,15 @@ static ENCODINGS_IN_LABEL_SORT: [&'static Encoding; 219] = [
     &ISO_8859_8_I_INIT,
     &ISO_8859_7_INIT,
     &EUC_KR_INIT,
+    &UTF_8_INIT,
+    &UTF_8_INIT,
     &EUC_KR_INIT,
     &WINDOWS_1252_INIT,
     &EUC_KR_INIT,
     &X_MAC_CYRILLIC_INIT,
     &X_USER_DEFINED_INIT,
     &GBK_INIT,
+    &UTF_16LE_INIT,
     &WINDOWS_1252_INIT,
     &ISO_8859_2_INIT,
     &ISO_8859_6_INIT,
@@ -2562,6 +2594,7 @@ static ENCODINGS_IN_LABEL_SORT: [&'static Encoding; 219] = [
     &ISO_8859_4_INIT,
     &ISO_8859_5_INIT,
     &ISO_8859_8_INIT,
+    &UTF_8_INIT,
     &WINDOWS_1254_INIT,
     &ISO_8859_7_INIT,
     &X_MAC_CYRILLIC_INIT,
@@ -2664,6 +2697,20 @@ impl Encoding {
     /// on it.)
     ///
     /// Available via the C wrapper.
+    ///
+    /// # Example
+    /// ```
+    /// use encoding_rs::Encoding;
+    ///
+    /// assert_eq!(Some(encoding_rs::UTF_8), Encoding::for_label(b"utf-8"));
+    /// assert_eq!(Some(encoding_rs::UTF_8), Encoding::for_label(b"unicode11utf8"));
+    ///
+    /// assert_eq!(Some(encoding_rs::ISO_8859_2), Encoding::for_label(b"latin2"));
+    ///
+    /// assert_eq!(Some(encoding_rs::UTF_16BE), Encoding::for_label(b"utf-16be"));
+    ///
+    /// assert_eq!(None, Encoding::for_label(b"unrecognized label"));
+    /// ```
     pub fn for_label(label: &[u8]) -> Option<&'static Encoding> {
         let mut trimmed = [0u8; LONGEST_LABEL_LENGTH];
         let mut trimmed_pos = 0usize;
@@ -2683,12 +2730,12 @@ impl Encoding {
                         0x09u8 | 0x0Au8 | 0x0Cu8 | 0x0Du8 | 0x20u8 => {
                             continue;
                         }
-                        b'A'...b'Z' => {
+                        b'A'..=b'Z' => {
                             trimmed[trimmed_pos] = *byte + 0x20u8;
                             trimmed_pos = 1usize;
                             break;
                         }
-                        b'a'...b'z' | b'0'...b'9' | b'-' | b'_' | b':' | b'.' => {
+                        b'a'..=b'z' | b'0'..=b'9' | b'-' | b'_' | b':' | b'.' => {
                             trimmed[trimmed_pos] = *byte;
                             trimmed_pos = 1usize;
                             break;
@@ -2711,7 +2758,7 @@ impl Encoding {
                         0x09u8 | 0x0Au8 | 0x0Cu8 | 0x0Du8 | 0x20u8 => {
                             break;
                         }
-                        b'A'...b'Z' => {
+                        b'A'..=b'Z' => {
                             if trimmed_pos == LONGEST_LABEL_LENGTH {
                                 // There's no encoding with a label this long
                                 return None;
@@ -2720,7 +2767,7 @@ impl Encoding {
                             trimmed_pos += 1usize;
                             continue;
                         }
-                        b'a'...b'z' | b'0'...b'9' | b'-' | b'_' | b':' | b'.' => {
+                        b'a'..=b'z' | b'0'..=b'9' | b'-' | b'_' | b':' | b'.' => {
                             if trimmed_pos == LONGEST_LABEL_LENGTH {
                                 // There's no encoding with a label this long
                                 return None;
@@ -2868,6 +2915,7 @@ impl Encoding {
 
     /// Checks whether the bytes 0x00...0x7F map mostly to the characters
     /// U+0000...U+007F and vice versa.
+    #[cfg(feature = "alloc")]
     #[inline]
     fn is_potentially_borrowable(&'static self) -> bool {
         !(self == REPLACEMENT || self == UTF_16BE || self == UTF_16LE)
@@ -2919,7 +2967,9 @@ impl Encoding {
     /// If the size calculation for a heap-allocated backing buffer overflows
     /// `usize`.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     #[inline]
     pub fn decode<'a>(&'static self, bytes: &'a [u8]) -> (Cow<'a, str>, &'static Encoding, bool) {
         let (encoding, without_bom) = match Encoding::for_bom(bytes) {
@@ -2962,7 +3012,9 @@ impl Encoding {
     /// If the size calculation for a heap-allocated backing buffer overflows
     /// `usize`.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     #[inline]
     pub fn decode_with_bom_removal<'a>(&'static self, bytes: &'a [u8]) -> (Cow<'a, str>, bool) {
         let without_bom = if self == UTF_8 && bytes.starts_with(b"\xEF\xBB\xBF") {
@@ -3009,7 +3061,9 @@ impl Encoding {
     /// If the size calculation for a heap-allocated backing buffer overflows
     /// `usize`.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     pub fn decode_without_bom_handling<'a>(&'static self, bytes: &'a [u8]) -> (Cow<'a, str>, bool) {
         let (mut decoder, mut string, mut total_read) = if self.is_potentially_borrowable() {
             let valid_up_to = if self == UTF_8 {
@@ -3020,7 +3074,7 @@ impl Encoding {
                 ascii_valid_up_to(bytes)
             };
             if valid_up_to == bytes.len() {
-                let str: &str = unsafe { std::str::from_utf8_unchecked(bytes) };
+                let str: &str = unsafe { core::str::from_utf8_unchecked(bytes) };
                 return (Cow::Borrowed(str), false);
             }
             let decoder = self.new_decoder_without_bom_handling();
@@ -3039,7 +3093,7 @@ impl Encoding {
             unsafe {
                 let vec = string.as_mut_vec();
                 vec.set_len(valid_up_to);
-                std::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);
+                core::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);
             }
             (decoder, string, valid_up_to)
         } else {
@@ -3104,7 +3158,9 @@ impl Encoding {
     /// If the size calculation for a heap-allocated backing buffer overflows
     /// `usize`.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     pub fn decode_without_bom_handling_and_without_replacement<'a>(
         &'static self,
         bytes: &'a [u8],
@@ -3112,7 +3168,7 @@ impl Encoding {
         if self == UTF_8 {
             let valid_up_to = utf8_valid_up_to(bytes);
             if valid_up_to == bytes.len() {
-                let str: &str = unsafe { std::str::from_utf8_unchecked(bytes) };
+                let str: &str = unsafe { core::str::from_utf8_unchecked(bytes) };
                 return Some(Cow::Borrowed(str));
             }
             return None;
@@ -3124,7 +3180,7 @@ impl Encoding {
                 ascii_valid_up_to(bytes)
             };
             if valid_up_to == bytes.len() {
-                let str: &str = unsafe { std::str::from_utf8_unchecked(bytes) };
+                let str: &str = unsafe { core::str::from_utf8_unchecked(bytes) };
                 return Some(Cow::Borrowed(str));
             }
             let decoder = self.new_decoder_without_bom_handling();
@@ -3138,7 +3194,7 @@ impl Encoding {
             unsafe {
                 let vec = string.as_mut_vec();
                 vec.set_len(valid_up_to);
-                std::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);
+                core::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);
             }
             (decoder, string, &bytes[valid_up_to..])
         } else {
@@ -3199,7 +3255,9 @@ impl Encoding {
     /// If the size calculation for a heap-allocated backing buffer overflows
     /// `usize`.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     pub fn encode<'a>(&'static self, string: &'a str) -> (Cow<'a, [u8]>, &'static Encoding, bool) {
         let output_encoding = self.output_encoding();
         if output_encoding == UTF_8 {
@@ -3226,7 +3284,7 @@ impl Encoding {
         );
         unsafe {
             vec.set_len(valid_up_to);
-            std::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);
+            core::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);
         }
         let mut total_read = valid_up_to;
         let mut total_had_errors = false;
@@ -3355,6 +3413,20 @@ impl PartialEq for Encoding {
 
 impl Eq for Encoding {}
 
+#[cfg(test)]
+impl PartialOrd for Encoding {
+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
+        (self as *const Encoding as usize).partial_cmp(&(other as *const Encoding as usize))
+    }
+}
+
+#[cfg(test)]
+impl Ord for Encoding {
+    fn cmp(&self, other: &Self) -> Ordering {
+        (self as *const Encoding as usize).cmp(&(other as *const Encoding as usize))
+    }
+}
+
 impl Hash for Encoding {
     #[inline]
     fn hash<H: Hasher>(&self, state: &mut H) {
@@ -3362,9 +3434,9 @@ impl Hash for Encoding {
     }
 }
 
-impl std::fmt::Debug for Encoding {
+impl core::fmt::Debug for Encoding {
     #[inline]
-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
         write!(f, "Encoding {{ {} }}", self.name)
     }
 }
@@ -3387,7 +3459,7 @@ struct EncodingVisitor;
 impl<'de> Visitor<'de> for EncodingVisitor {
     type Value = &'static Encoding;
 
-    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
+    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
         formatter.write_str("a valid encoding label")
     }
 
@@ -3398,7 +3470,10 @@ impl<'de> Visitor<'de> for EncodingVisitor {
         if let Some(enc) = Encoding::for_label(value.as_bytes()) {
             Ok(enc)
         } else {
-            Err(E::custom(format!("invalid encoding label: {}", value)))
+            Err(E::custom(alloc::format!(
+                "invalid encoding label: {}",
+                value
+            )))
         }
     }
 }
@@ -3672,7 +3747,7 @@ impl Decoder {
                         1,
                         checked_mul(3, checked_div(byte_length.checked_add(1), 2)),
                     ) {
-                        let utf_bom = std::cmp::max(utf8_bom, utf16_bom);
+                        let utf_bom = core::cmp::max(utf8_bom, utf16_bom);
                         let encoding = self.encoding();
                         if encoding == UTF_8 || encoding == UTF_16LE || encoding == UTF_16BE {
                             // No need to consider the internal state of the underlying decoder,
@@ -3681,7 +3756,7 @@ impl Decoder {
                         } else if let Some(non_bom) =
                             self.variant.max_utf8_buffer_length(byte_length)
                         {
-                            return Some(std::cmp::max(utf_bom, non_bom));
+                            return Some(core::cmp::max(utf_bom, non_bom));
                         }
                     }
                 }
@@ -3699,7 +3774,7 @@ impl Decoder {
                             // because it is at start, because no data has reached it yet.
                             return Some(utf8_bom);
                         } else if let Some(non_bom) = self.variant.max_utf8_buffer_length(sum) {
-                            return Some(std::cmp::max(utf8_bom, non_bom));
+                            return Some(core::cmp::max(utf8_bom, non_bom));
                         }
                     }
                 }
@@ -3725,7 +3800,7 @@ impl Decoder {
                             // because it is at start, because no data has reached it yet.
                             return Some(utf16_bom);
                         } else if let Some(non_bom) = self.variant.max_utf8_buffer_length(sum) {
-                            return Some(std::cmp::max(utf16_bom, non_bom));
+                            return Some(core::cmp::max(utf16_bom, non_bom));
                         }
                     }
                 }
@@ -3764,7 +3839,7 @@ impl Decoder {
                         1,
                         checked_mul(3, checked_div(byte_length.checked_add(1), 2)),
                     ) {
-                        let utf_bom = std::cmp::max(utf8_bom, utf16_bom);
+                        let utf_bom = core::cmp::max(utf8_bom, utf16_bom);
                         let encoding = self.encoding();
                         if encoding == UTF_8 || encoding == UTF_16LE || encoding == UTF_16BE {
                             // No need to consider the internal state of the underlying decoder,
@@ -3774,7 +3849,7 @@ impl Decoder {
                             .variant
                             .max_utf8_buffer_length_without_replacement(byte_length)
                         {
-                            return Some(std::cmp::max(utf_bom, non_bom));
+                            return Some(core::cmp::max(utf_bom, non_bom));
                         }
                     }
                 }
@@ -3794,7 +3869,7 @@ impl Decoder {
                         } else if let Some(non_bom) =
                             self.variant.max_utf8_buffer_length_without_replacement(sum)
                         {
-                            return Some(std::cmp::max(utf8_bom, non_bom));
+                            return Some(core::cmp::max(utf8_bom, non_bom));
                         }
                     }
                 }
@@ -3822,7 +3897,7 @@ impl Decoder {
                         } else if let Some(non_bom) =
                             self.variant.max_utf8_buffer_length_without_replacement(sum)
                         {
-                            return Some(std::cmp::max(utf16_bom, non_bom));
+                            return Some(core::cmp::max(utf16_bom, non_bom));
                         }
                     }
                 }
@@ -3916,7 +3991,7 @@ impl Decoder {
         // bytes of trailing garbage. No need to optimize non-ASCII-compatible
         // encodings to avoid overwriting here.
         if self.encoding != UTF_8 {
-            let max = std::cmp::min(len, trail + ascii::MAX_STRIDE_SIZE);
+            let max = core::cmp::min(len, trail + ascii::MAX_STRIDE_SIZE);
             while trail < max {
                 bytes[trail] = 0;
                 trail += 1;
@@ -3945,7 +4020,9 @@ impl Decoder {
     /// See the documentation of the struct for documentation for `decode_*`
     /// methods collectively.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     pub fn decode_to_string(
         &mut self,
         src: &[u8],
@@ -4006,7 +4083,7 @@ impl Decoder {
         // bytes of trailing garbage. No need to optimize non-ASCII-compatible
         // encodings to avoid overwriting here.
         if self.encoding != UTF_8 {
-            let max = std::cmp::min(len, trail + ascii::MAX_STRIDE_SIZE);
+            let max = core::cmp::min(len, trail + ascii::MAX_STRIDE_SIZE);
             while trail < max {
                 bytes[trail] = 0;
                 trail += 1;
@@ -4033,7 +4110,9 @@ impl Decoder {
     /// See the documentation of the struct for documentation for `decode_*`
     /// methods collectively.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     pub fn decode_to_string_without_replacement(
         &mut self,
         src: &[u8],
@@ -4079,7 +4158,7 @@ impl Decoder {
                     if let Some(utf16_bom) =
                         checked_add(1, checked_div(byte_length.checked_add(1), 2))
                     {
-                        let utf_bom = std::cmp::max(utf8_bom, utf16_bom);
+                        let utf_bom = core::cmp::max(utf8_bom, utf16_bom);
                         let encoding = self.encoding();
                         if encoding == UTF_8 || encoding == UTF_16LE || encoding == UTF_16BE {
                             // No need to consider the internal state of the underlying decoder,
@@ -4088,7 +4167,7 @@ impl Decoder {
                         } else if let Some(non_bom) =
                             self.variant.max_utf16_buffer_length(byte_length)
                         {
-                            return Some(std::cmp::max(utf_bom, non_bom));
+                            return Some(core::cmp::max(utf_bom, non_bom));
                         }
                     }
                 }
@@ -4106,7 +4185,7 @@ impl Decoder {
                             // because it is at start, because no data has reached it yet.
                             return Some(utf8_bom);
                         } else if let Some(non_bom) = self.variant.max_utf16_buffer_length(sum) {
-                            return Some(std::cmp::max(utf8_bom, non_bom));
+                            return Some(core::cmp::max(utf8_bom, non_bom));
                         }
                     }
                 }
@@ -4130,7 +4209,7 @@ impl Decoder {
                             // because it is at start, because no data has reached it yet.
                             return Some(utf16_bom);
                         } else if let Some(non_bom) = self.variant.max_utf16_buffer_length(sum) {
-                            return Some(std::cmp::max(utf16_bom, non_bom));
+                            return Some(core::cmp::max(utf16_bom, non_bom));
                         }
                     }
                 }
@@ -4265,7 +4344,7 @@ pub enum EncoderResult {
 
 impl EncoderResult {
     fn unmappable_from_bmp(bmp: u16) -> EncoderResult {
-        EncoderResult::Unmappable(::std::char::from_u32(u32::from(bmp)).unwrap())
+        EncoderResult::Unmappable(::core::char::from_u32(u32::from(bmp)).unwrap())
     }
 }
 
@@ -4532,7 +4611,9 @@ impl Encoder {
     /// See the documentation of the struct for documentation for `encode_*`
     /// methods collectively.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     pub fn encode_from_utf8_to_vec(
         &mut self,
         src: &str,
@@ -4570,7 +4651,9 @@ impl Encoder {
     /// See the documentation of the struct for documentation for `encode_*`
     /// methods collectively.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     pub fn encode_from_utf8_to_vec_without_replacement(
         &mut self,
         src: &str,
@@ -4836,16 +4919,18 @@ fn checked_div(opt: Option<usize>, num: usize) -> Option<usize> {
     }
 }
 
+#[cfg(feature = "alloc")]
 #[inline(always)]
 fn checked_next_power_of_two(opt: Option<usize>) -> Option<usize> {
     opt.map(|n| n.next_power_of_two())
 }
 
+#[cfg(feature = "alloc")]
 #[inline(always)]
 fn checked_min(one: Option<usize>, other: Option<usize>) -> Option<usize> {
     if let Some(a) = one {
         if let Some(b) = other {
-            Some(::std::cmp::min(a, b))
+            Some(::core::cmp::min(a, b))
         } else {
             Some(a)
         }
@@ -4867,10 +4952,10 @@ struct Demo {
 #[cfg(test)]
 mod test_labels_names;
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::*;
-    use std::borrow::Cow;
+    use alloc::borrow::Cow;
 
     fn sniff_to_utf16(
         initial_encoding: &'static Encoding,
@@ -5623,7 +5708,7 @@ mod tests {
 
     #[test]
     fn test_hash() {
-        let mut encodings = ::std::collections::HashSet::new();
+        let mut encodings = ::alloc::collections::btree_set::BTreeSet::new();
         encodings.insert(UTF_8);
         encodings.insert(ISO_2022_JP);
         assert!(encodings.contains(UTF_8));
diff --git a/third_party/rust/encoding_rs/src/macros.rs b/third_party/rust/encoding_rs/src/macros.rs
index 135ddd664866..d3bb5e9ed018 100644
--- a/third_party/rust/encoding_rs/src/macros.rs
+++ b/third_party/rust/encoding_rs/src/macros.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -571,7 +571,7 @@ macro_rules! gb18030_decoder_function {
                                     }
                                     Space::Available(destination_handle) => {
                                         let (b, _) = source_handle.read();
-                                        'innermost: loop {
+                                        loop {
                                             if b > 127 {
                                                 $non_ascii = b;
                                                 $handle = destination_handle;
@@ -875,7 +875,7 @@ macro_rules! euc_jp_decoder_function {
                                     }
                                     Space::Available(destination_handle) => {
                                         let (b, _) = source_handle.read();
-                                        'innermost: loop {
+                                        loop {
                                             if b > 127 {
                                                 $non_ascii = b;
                                                 $handle = destination_handle;
diff --git a/third_party/rust/encoding_rs/src/mem.rs b/third_party/rust/encoding_rs/src/mem.rs
index 8c82704d7e04..3330619310df 100644
--- a/third_party/rust/encoding_rs/src/mem.rs
+++ b/third_party/rust/encoding_rs/src/mem.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -24,7 +24,12 @@
 //! The FFI binding for this module are in the
 //! [encoding_c_mem crate](https://github.com/hsivonen/encoding_c_mem).
 
-use std::borrow::Cow;
+#[cfg(feature = "alloc")]
+use alloc::borrow::Cow;
+#[cfg(feature = "alloc")]
+use alloc::string::String;
+#[cfg(feature = "alloc")]
+use alloc::vec::Vec;
 
 use super::in_inclusive_range16;
 use super::in_inclusive_range32;
@@ -32,8 +37,8 @@ use super::in_inclusive_range8;
 use super::in_range16;
 use super::in_range32;
 use super::DecoderResult;
-use ascii::*;
-use utf_8::*;
+use crate::ascii::*;
+use crate::utf_8::*;
 
 macro_rules! non_fuzz_debug_assert {
     ($($arg:tt)*) => (if !cfg!(fuzzing) { debug_assert!($($arg)*); })
@@ -41,8 +46,8 @@ macro_rules! non_fuzz_debug_assert {
 
 cfg_if! {
     if #[cfg(feature = "simd-accel")] {
-        use ::std::intrinsics::likely;
-        use ::std::intrinsics::unlikely;
+        use ::core::intrinsics::likely;
+        use ::core::intrinsics::unlikely;
     } else {
         #[inline(always)]
         // Unsafe to match the intrinsic, which is needlessly unsafe.
@@ -85,7 +90,7 @@ macro_rules! by_unit_check_alu {
         fn $name(buffer: &[$unit]) -> bool {
             let mut offset = 0usize;
             let mut accu = 0usize;
-            let unit_size = ::std::mem::size_of::<$unit>();
+            let unit_size = ::core::mem::size_of::<$unit>();
             let len = buffer.len();
             if len >= ALU_ALIGNMENT / unit_size {
                 // The most common reason to return `false` is for the first code
@@ -157,7 +162,7 @@ macro_rules! by_unit_check_simd {
         fn $name(buffer: &[$unit]) -> bool {
             let mut offset = 0usize;
             let mut accu = 0usize;
-            let unit_size = ::std::mem::size_of::<$unit>();
+            let unit_size = ::core::mem::size_of::<$unit>();
             let len = buffer.len();
             if len >= SIMD_STRIDE_SIZE / unit_size {
                 // The most common reason to return `false` is for the first code
@@ -230,7 +235,7 @@ macro_rules! by_unit_check_simd {
 
 cfg_if! {
     if #[cfg(all(feature = "simd-accel", any(target_feature = "sse2", all(target_endian = "little", target_arch = "aarch64"), all(target_endian = "little", target_feature = "neon"))))] {
-        use simd_funcs::*;
+        use crate::simd_funcs::*;
         use packed_simd::u8x16;
         use packed_simd::u16x8;
 
@@ -248,7 +253,7 @@ cfg_if! {
             // only aligned SIMD (perhaps misguidedly) and needs to deal with
             // the last code unit in a SIMD stride being part of a valid
             // surrogate pair.
-            let unit_size = ::std::mem::size_of::<u16>();
+            let unit_size = ::core::mem::size_of::<u16>();
             let src = buffer.as_ptr();
             let len = buffer.len();
             let mut offset = 0usize;
@@ -276,7 +281,7 @@ cfg_if! {
                     offset = offset_plus_until_alignment;
                 }
                 let len_minus_stride = len - SIMD_STRIDE_SIZE / unit_size;
-                'inner: loop {
+                loop {
                     let offset_plus_stride = offset + SIMD_STRIDE_SIZE / unit_size;
                     if contains_surrogates(unsafe { *(src.add(offset) as *const u16x8) }) {
                         if offset_plus_stride == len {
@@ -740,13 +745,13 @@ pub fn is_utf8_bidi(buffer: &[u8]) -> bool {
                 'inner: loop {
                     // At this point, `byte` is not included in `read`.
                     match byte {
-                        0...0x7F => {
+                        0..=0x7F => {
                             // ASCII: go back to SIMD.
                             read += 1;
                             src = &src[read..];
                             continue 'outer;
                         }
-                        0xC2...0xD5 => {
+                        0xC2..=0xD5 => {
                             // Two-byte
                             let second = unsafe { *(src.get_unchecked(read + 1)) };
                             if !in_inclusive_range8(second, 0x80, 0xBF) {
@@ -767,7 +772,7 @@ pub fn is_utf8_bidi(buffer: &[u8]) -> bool {
                             read += 2;
                         }
                         // two-byte starting with 0xD7 and above is bidi
-                        0xE1 | 0xE3...0xEC | 0xEE => {
+                        0xE1 | 0xE3..=0xEC | 0xEE => {
                             // Three-byte normal
                             let second = unsafe { *(src.get_unchecked(read + 1)) };
                             let third = unsafe { *(src.get_unchecked(read + 2)) };
@@ -876,7 +881,7 @@ pub fn is_utf8_bidi(buffer: &[u8]) -> bool {
                             }
                             read += 3;
                         }
-                        0xF1...0xF4 => {
+                        0xF1..=0xF4 => {
                             // Four-byte normal
                             let second = unsafe { *(src.get_unchecked(read + 1)) };
                             let third = unsafe { *(src.get_unchecked(read + 2)) };
@@ -939,13 +944,13 @@ pub fn is_utf8_bidi(buffer: &[u8]) -> bool {
 
             // At this point, `byte` is not included in `read`.
             match byte {
-                0...0x7F => {
+                0..=0x7F => {
                     // ASCII: go back to SIMD.
                     read += 1;
                     src = &src[read..];
                     continue 'outer;
                 }
-                0xC2...0xD5 => {
+                0xC2..=0xD5 => {
                     // Two-byte
                     let new_read = read + 2;
                     if new_read > src.len() {
@@ -982,7 +987,7 @@ pub fn is_utf8_bidi(buffer: &[u8]) -> bool {
                     continue 'outer;
                 }
                 // two-byte starting with 0xD7 and above is bidi
-                0xE1 | 0xE3...0xEC | 0xEE => {
+                0xE1 | 0xE3..=0xEC | 0xEE => {
                     // Three-byte normal
                     let new_read = read + 3;
                     if new_read > src.len() {
@@ -1781,7 +1786,7 @@ pub fn convert_latin1_to_utf8_partial(src: &[u8], dst: &mut [u8]) -> (usize, usi
         // src can't advance more than dst
         let src_left = src_len - total_read;
         let dst_left = dst_len - total_written;
-        let min_left = ::std::cmp::min(src_left, dst_left);
+        let min_left = ::core::cmp::min(src_left, dst_left);
         if let Some((non_ascii, consumed)) = unsafe {
             ascii_to_ascii(
                 src_ptr.add(total_read),
@@ -1850,7 +1855,7 @@ pub fn convert_latin1_to_str_partial(src: &[u8], dst: &mut str) -> (usize, usize
     let (read, written) = convert_latin1_to_utf8_partial(src, bytes);
     let len = bytes.len();
     let mut trail = written;
-    let max = ::std::cmp::min(len, trail + MAX_STRIDE_SIZE);
+    let max = ::core::cmp::min(len, trail + MAX_STRIDE_SIZE);
     while trail < max {
         bytes[trail] = 0;
         trail += 1;
@@ -1986,12 +1991,15 @@ pub fn convert_utf16_to_latin1_lossy(src: &[u16], dst: &mut [u8]) {
 ///
 /// Borrows if input is ASCII-only. Performs a single heap allocation
 /// otherwise.
+///
+/// Only available if the `alloc` feature is enabled (enabled by default).
+#[cfg(feature = "alloc")]
 pub fn decode_latin1<'a>(bytes: &'a [u8]) -> Cow<'a, str> {
     let up_to = ascii_valid_up_to(bytes);
     // >= makes later things optimize better than ==
     if up_to >= bytes.len() {
         debug_assert_eq!(up_to, bytes.len());
-        let s: &str = unsafe { ::std::str::from_utf8_unchecked(bytes) };
+        let s: &str = unsafe { ::core::str::from_utf8_unchecked(bytes) };
         return Cow::Borrowed(s);
     }
     let (head, tail) = bytes.split_at(up_to);
@@ -2020,6 +2028,9 @@ pub fn decode_latin1<'a>(bytes: &'a [u8]) -> Cow<'a, str> {
 ///
 /// Borrows if input is ASCII-only. Performs a single heap allocation
 /// otherwise.
+///
+/// Only available if the `alloc` feature is enabled (enabled by default).
+#[cfg(feature = "alloc")]
 pub fn encode_latin1_lossy<'a>(string: &'a str) -> Cow<'a, [u8]> {
     let bytes = string.as_bytes();
     let up_to = ascii_valid_up_to(bytes);
@@ -2056,7 +2067,7 @@ pub fn utf8_latin1_up_to(buffer: &[u8]) -> usize {
 /// Returns the index of first byte that starts a non-Latin1 byte
 /// sequence, or the length of the string if there are none.
 pub fn str_latin1_up_to(buffer: &str) -> usize {
-    is_str_latin1_impl(buffer).unwrap_or(buffer.len())
+    is_str_latin1_impl(buffer).unwrap_or_else(|| buffer.len())
 }
 
 /// Replaces unpaired surrogates in the input with the REPLACEMENT CHARACTER.
@@ -2153,7 +2164,7 @@ pub fn copy_basic_latin_to_ascii(src: &[u16], dst: &mut [u8]) -> usize {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::*;
 
@@ -2231,8 +2242,9 @@ mod tests {
 
     #[test]
     fn test_is_utf16_latin1_fail() {
-        let mut src: Vec<u16> = Vec::with_capacity(256);
-        src.resize(256, 0);
+        let len = if cfg!(miri) { 64 } else { 256 }; // Miri is too slow
+        let mut src: Vec<u16> = Vec::with_capacity(len);
+        src.resize(len, 0);
         for i in 0..src.len() {
             src[i] = i as u16;
         }
@@ -2248,8 +2260,9 @@ mod tests {
 
     #[test]
     fn test_is_str_latin1_success() {
-        let mut src: Vec<u16> = Vec::with_capacity(256);
-        src.resize(256, 0);
+        let len = if cfg!(miri) { 64 } else { 256 }; // Miri is too slow
+        let mut src: Vec<u16> = Vec::with_capacity(len);
+        src.resize(len, 0);
         for i in 0..src.len() {
             src[i] = i as u16;
         }
@@ -2262,8 +2275,9 @@ mod tests {
 
     #[test]
     fn test_is_str_latin1_fail() {
-        let mut src: Vec<u16> = Vec::with_capacity(256);
-        src.resize(256, 0);
+        let len = if cfg!(miri) { 32 } else { 256 }; // Miri is too slow
+        let mut src: Vec<u16> = Vec::with_capacity(len);
+        src.resize(len, 0);
         for i in 0..src.len() {
             src[i] = i as u16;
         }
@@ -2280,8 +2294,9 @@ mod tests {
 
     #[test]
     fn test_is_utf8_latin1_success() {
-        let mut src: Vec<u16> = Vec::with_capacity(256);
-        src.resize(256, 0);
+        let len = if cfg!(miri) { 64 } else { 256 }; // Miri is too slow
+        let mut src: Vec<u16> = Vec::with_capacity(len);
+        src.resize(len, 0);
         for i in 0..src.len() {
             src[i] = i as u16;
         }
@@ -2297,8 +2312,9 @@ mod tests {
 
     #[test]
     fn test_is_utf8_latin1_fail() {
-        let mut src: Vec<u16> = Vec::with_capacity(256);
-        src.resize(256, 0);
+        let len = if cfg!(miri) { 32 } else { 256 }; // Miri is too slow
+        let mut src: Vec<u16> = Vec::with_capacity(len);
+        src.resize(len, 0);
         for i in 0..src.len() {
             src[i] = i as u16;
         }
@@ -3112,11 +3128,11 @@ mod tests {
     #[inline(always)]
     pub fn reference_is_char_bidi(c: char) -> bool {
         match c {
-            '\u{0590}'...'\u{08FF}'
-            | '\u{FB1D}'...'\u{FDFF}'
-            | '\u{FE70}'...'\u{FEFE}'
-            | '\u{10800}'...'\u{10FFF}'
-            | '\u{1E800}'...'\u{1EFFF}'
+            '\u{0590}'..='\u{08FF}'
+            | '\u{FB1D}'..='\u{FDFF}'
+            | '\u{FE70}'..='\u{FEFE}'
+            | '\u{10800}'..='\u{10FFF}'
+            | '\u{1E800}'..='\u{1EFFF}'
             | '\u{200F}'
             | '\u{202B}'
             | '\u{202E}'
@@ -3128,9 +3144,9 @@ mod tests {
     #[inline(always)]
     pub fn reference_is_utf16_code_unit_bidi(u: u16) -> bool {
         match u {
-            0x0590...0x08FF
-            | 0xFB1D...0xFDFF
-            | 0xFE70...0xFEFE
+            0x0590..=0x08FF
+            | 0xFB1D..=0xFDFF
+            | 0xFE70..=0xFEFE
             | 0xD802
             | 0xD803
             | 0xD83A
@@ -3144,18 +3160,20 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_is_char_bidi_thoroughly() {
         for i in 0..0xD800u32 {
-            let c: char = ::std::char::from_u32(i).unwrap();
+            let c: char = ::core::char::from_u32(i).unwrap();
             assert_eq!(is_char_bidi(c), reference_is_char_bidi(c));
         }
         for i in 0xE000..0x110000u32 {
-            let c: char = ::std::char::from_u32(i).unwrap();
+            let c: char = ::core::char::from_u32(i).unwrap();
             assert_eq!(is_char_bidi(c), reference_is_char_bidi(c));
         }
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_is_utf16_code_unit_bidi_thoroughly() {
         for i in 0..0x10000u32 {
             let u = i as u16;
@@ -3167,17 +3185,18 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_is_str_bidi_thoroughly() {
         let mut buf = [0; 4];
         for i in 0..0xD800u32 {
-            let c: char = ::std::char::from_u32(i).unwrap();
+            let c: char = ::core::char::from_u32(i).unwrap();
             assert_eq!(
                 is_str_bidi(c.encode_utf8(&mut buf[..])),
                 reference_is_char_bidi(c)
             );
         }
         for i in 0xE000..0x110000u32 {
-            let c: char = ::std::char::from_u32(i).unwrap();
+            let c: char = ::core::char::from_u32(i).unwrap();
             assert_eq!(
                 is_str_bidi(c.encode_utf8(&mut buf[..])),
                 reference_is_char_bidi(c)
@@ -3186,10 +3205,11 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_is_utf8_bidi_thoroughly() {
         let mut buf = [0; 8];
         for i in 0..0xD800u32 {
-            let c: char = ::std::char::from_u32(i).unwrap();
+            let c: char = ::core::char::from_u32(i).unwrap();
             let expect = reference_is_char_bidi(c);
             {
                 let len = {
@@ -3207,7 +3227,7 @@ mod tests {
             assert_eq!(is_utf8_bidi(&buf[..]), expect);
         }
         for i in 0xE000..0x110000u32 {
-            let c: char = ::std::char::from_u32(i).unwrap();
+            let c: char = ::core::char::from_u32(i).unwrap();
             let expect = reference_is_char_bidi(c);
             {
                 let len = {
@@ -3227,6 +3247,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_is_utf16_bidi_thoroughly() {
         let mut buf = [0; 32];
         for i in 0..0x10000u32 {
diff --git a/third_party/rust/encoding_rs/src/replacement.rs b/third_party/rust/encoding_rs/src/replacement.rs
index e3c8974312ae..3d1bcc1f57cc 100644
--- a/third_party/rust/encoding_rs/src/replacement.rs
+++ b/third_party/rust/encoding_rs/src/replacement.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,7 +8,7 @@
 // except according to those terms.
 
 use super::*;
-use variant::*;
+use crate::variant::*;
 
 pub struct ReplacementDecoder {
     emitted: bool,
@@ -73,7 +73,7 @@ impl ReplacementDecoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
diff --git a/third_party/rust/encoding_rs/src/shift_jis.rs b/third_party/rust/encoding_rs/src/shift_jis.rs
index 16a2a8eec277..eb1b0f0ca9ac 100644
--- a/third_party/rust/encoding_rs/src/shift_jis.rs
+++ b/third_party/rust/encoding_rs/src/shift_jis.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,9 +8,9 @@
 // except according to those terms.
 
 use super::*;
-use data::*;
-use handles::*;
-use variant::*;
+use crate::data::*;
+use crate::handles::*;
+use crate::variant::*;
 // Rust 1.14.0 requires the following despite the asterisk above.
 use super::in_inclusive_range;
 use super::in_inclusive_range16;
@@ -305,7 +305,7 @@ impl ShiftJisEncoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
@@ -385,6 +385,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_shift_jis_decode_all() {
         let input = include_bytes!("test_data/shift_jis_in.txt");
         let expectation = include_str!("test_data/shift_jis_in_ref.txt");
@@ -394,6 +395,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_shift_jis_encode_all() {
         let input = include_str!("test_data/shift_jis_out.txt");
         let expectation = include_bytes!("test_data/shift_jis_out_ref.txt");
diff --git a/third_party/rust/encoding_rs/src/simd_funcs.rs b/third_party/rust/encoding_rs/src/simd_funcs.rs
index 8f9746fe9caf..08e627b6309e 100644
--- a/third_party/rust/encoding_rs/src/simd_funcs.rs
+++ b/third_party/rust/encoding_rs/src/simd_funcs.rs
@@ -1,4 +1,4 @@
-// Copyright 2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -16,8 +16,8 @@ use packed_simd::FromBits;
 
 #[inline(always)]
 pub unsafe fn load16_unaligned(ptr: *const u8) -> u8x16 {
-    let mut simd = ::std::mem::uninitialized();
-    ::std::ptr::copy_nonoverlapping(ptr, &mut simd as *mut u8x16 as *mut u8, 16);
+    let mut simd = ::core::mem::uninitialized();
+    ::core::ptr::copy_nonoverlapping(ptr, &mut simd as *mut u8x16 as *mut u8, 16);
     simd
 }
 
@@ -29,7 +29,7 @@ pub unsafe fn load16_aligned(ptr: *const u8) -> u8x16 {
 
 #[inline(always)]
 pub unsafe fn store16_unaligned(ptr: *mut u8, s: u8x16) {
-    ::std::ptr::copy_nonoverlapping(&s as *const u8x16 as *const u8, ptr, 16);
+    ::core::ptr::copy_nonoverlapping(&s as *const u8x16 as *const u8, ptr, 16);
 }
 
 #[allow(dead_code)]
@@ -40,8 +40,8 @@ pub unsafe fn store16_aligned(ptr: *mut u8, s: u8x16) {
 
 #[inline(always)]
 pub unsafe fn load8_unaligned(ptr: *const u16) -> u16x8 {
-    let mut simd = ::std::mem::uninitialized();
-    ::std::ptr::copy_nonoverlapping(ptr as *const u8, &mut simd as *mut u16x8 as *mut u8, 16);
+    let mut simd = ::core::mem::uninitialized();
+    ::core::ptr::copy_nonoverlapping(ptr as *const u8, &mut simd as *mut u16x8 as *mut u8, 16);
     simd
 }
 
@@ -53,7 +53,7 @@ pub unsafe fn load8_aligned(ptr: *const u16) -> u16x8 {
 
 #[inline(always)]
 pub unsafe fn store8_unaligned(ptr: *mut u16, s: u16x8) {
-    ::std::ptr::copy_nonoverlapping(&s as *const u16x8 as *const u8, ptr as *mut u8, 16);
+    ::core::ptr::copy_nonoverlapping(&s as *const u16x8 as *const u8, ptr as *mut u8, 16);
 }
 
 #[allow(dead_code)]
@@ -64,18 +64,18 @@ pub unsafe fn store8_aligned(ptr: *mut u16, s: u16x8) {
 
 cfg_if! {
     if #[cfg(all(target_feature = "sse2", target_arch = "x86_64"))] {
-        use std::arch::x86_64::__m128i;
-        use std::arch::x86_64::_mm_movemask_epi8;
-        use std::arch::x86_64::_mm_packus_epi16;
+        use core::arch::x86_64::__m128i;
+        use core::arch::x86_64::_mm_movemask_epi8;
+        use core::arch::x86_64::_mm_packus_epi16;
     } else if #[cfg(all(target_feature = "sse2", target_arch = "x86"))] {
-        use std::arch::x86::__m128i;
-        use std::arch::x86::_mm_movemask_epi8;
-        use std::arch::x86::_mm_packus_epi16;
+        use core::arch::x86::__m128i;
+        use core::arch::x86::_mm_movemask_epi8;
+        use core::arch::x86::_mm_packus_epi16;
     } else if #[cfg(target_arch = "aarch64")]{
-        use std::arch::aarch64::uint8x16_t;
-        use std::arch::aarch64::uint16x8_t;
-        use std::arch::aarch64::vmaxvq_u8;
-        use std::arch::aarch64::vmaxvq_u16;
+        use core::arch::aarch64::uint8x16_t;
+        use core::arch::aarch64::uint16x8_t;
+        use core::arch::aarch64::vmaxvq_u8;
+        use core::arch::aarch64::vmaxvq_u16;
     } else {
 
     }
@@ -327,6 +327,7 @@ cfg_if! {
 #[cfg(test)]
 mod tests {
     use super::*;
+    use alloc::vec::Vec;
 
     #[test]
     fn test_unpack() {
@@ -446,7 +447,7 @@ mod tests {
         ];
         let mut alu = 0u64;
         unsafe {
-            ::std::ptr::copy_nonoverlapping(input.as_ptr(), &mut alu as *mut u64 as *mut u8, 8);
+            ::core::ptr::copy_nonoverlapping(input.as_ptr(), &mut alu as *mut u64 as *mut u8, 8);
         }
         let masked = alu & 0x8080808080808080;
         assert_eq!(masked.trailing_zeros(), 39);
diff --git a/third_party/rust/encoding_rs/src/single_byte.rs b/third_party/rust/encoding_rs/src/single_byte.rs
index a8a99cde78cf..b3b6089d318b 100644
--- a/third_party/rust/encoding_rs/src/single_byte.rs
+++ b/third_party/rust/encoding_rs/src/single_byte.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,10 +8,10 @@
 // except according to those terms.
 
 use super::*;
-use ascii::*;
-use data::position;
-use handles::*;
-use variant::*;
+use crate::ascii::*;
+use crate::data::position;
+use crate::handles::*;
+use crate::variant::*;
 
 pub struct SingleByteDecoder {
     table: &'static [u16; 128],
@@ -432,7 +432,7 @@ impl SingleByteEncoder {
                                     }
                                     // The next code unit is a low surrogate.
                                     let astral: char = unsafe {
-                                        ::std::char::from_u32_unchecked(
+                                        ::core::char::from_u32_unchecked(
                                             (u32::from(non_ascii) << 10) + second
                                                 - (((0xD800u32 << 10) - 0x1_0000u32) + 0xDC00u32),
                                         )
@@ -503,7 +503,7 @@ impl SingleByteEncoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
@@ -645,6 +645,10 @@ mod tests {
     fn test_single_byte_decode() {
         decode_single_byte(IBM866, &data::SINGLE_BYTE_DATA.ibm866);
         decode_single_byte(ISO_8859_10, &data::SINGLE_BYTE_DATA.iso_8859_10);
+        if cfg!(miri) {
+            // Miri is too slow
+            return;
+        }
         decode_single_byte(ISO_8859_13, &data::SINGLE_BYTE_DATA.iso_8859_13);
         decode_single_byte(ISO_8859_14, &data::SINGLE_BYTE_DATA.iso_8859_14);
         decode_single_byte(ISO_8859_15, &data::SINGLE_BYTE_DATA.iso_8859_15);
@@ -676,6 +680,10 @@ mod tests {
     fn test_single_byte_encode() {
         encode_single_byte(IBM866, &data::SINGLE_BYTE_DATA.ibm866);
         encode_single_byte(ISO_8859_10, &data::SINGLE_BYTE_DATA.iso_8859_10);
+        if cfg!(miri) {
+            // Miri is too slow
+            return;
+        }
         encode_single_byte(ISO_8859_13, &data::SINGLE_BYTE_DATA.iso_8859_13);
         encode_single_byte(ISO_8859_14, &data::SINGLE_BYTE_DATA.iso_8859_14);
         encode_single_byte(ISO_8859_15, &data::SINGLE_BYTE_DATA.iso_8859_15);
diff --git a/third_party/rust/encoding_rs/src/test_labels_names.rs b/third_party/rust/encoding_rs/src/test_labels_names.rs
index 5aeb5ab54d6d..ac3b3d9e836b 100644
--- a/third_party/rust/encoding_rs/src/test_labels_names.rs
+++ b/third_party/rust/encoding_rs/src/test_labels_names.rs
@@ -23,6 +23,7 @@ fn test_all_labels() {
     assert_eq!(Encoding::for_label(b"utf8"), Some(UTF_8));
     assert_eq!(Encoding::for_label(b"koi8"), Some(KOI8_R));
     assert_eq!(Encoding::for_label(b"sjis"), Some(SHIFT_JIS));
+    assert_eq!(Encoding::for_label(b"ucs-2"), Some(UTF_16LE));
     assert_eq!(Encoding::for_label(b"ms932"), Some(SHIFT_JIS));
     assert_eq!(Encoding::for_label(b"cp866"), Some(IBM866));
     assert_eq!(Encoding::for_label(b"utf-8"), Some(UTF_8));
@@ -67,6 +68,7 @@ fn test_all_labels() {
     assert_eq!(Encoding::for_label(b"gb_2312"), Some(GBK));
     assert_eq!(Encoding::for_label(b"dos-874"), Some(WINDOWS_874));
     assert_eq!(Encoding::for_label(b"cn-big5"), Some(BIG5));
+    assert_eq!(Encoding::for_label(b"unicode"), Some(UTF_16LE));
     assert_eq!(Encoding::for_label(b"chinese"), Some(GBK));
     assert_eq!(Encoding::for_label(b"logical"), Some(ISO_8859_8_I));
     assert_eq!(Encoding::for_label(b"cskoi8r"), Some(KOI8_R));
@@ -119,6 +121,7 @@ fn test_all_labels() {
     assert_eq!(Encoding::for_label(b"iso8859-8"), Some(ISO_8859_8));
     assert_eq!(Encoding::for_label(b"iso-ir-58"), Some(GBK));
     assert_eq!(Encoding::for_label(b"iso8859-9"), Some(WINDOWS_1254));
+    assert_eq!(Encoding::for_label(b"csunicode"), Some(UTF_16LE));
     assert_eq!(Encoding::for_label(b"macintosh"), Some(MACINTOSH));
     assert_eq!(Encoding::for_label(b"shift-jis"), Some(SHIFT_JIS));
     assert_eq!(Encoding::for_label(b"shift_jis"), Some(SHIFT_JIS));
@@ -178,6 +181,8 @@ fn test_all_labels() {
     assert_eq!(Encoding::for_label(b"csisolatin9"), Some(ISO_8859_15));
     assert_eq!(Encoding::for_label(b"csiso88596e"), Some(ISO_8859_6));
     assert_eq!(Encoding::for_label(b"csiso88598e"), Some(ISO_8859_8));
+    assert_eq!(Encoding::for_label(b"unicodefffe"), Some(UTF_16BE));
+    assert_eq!(Encoding::for_label(b"unicodefeff"), Some(UTF_16LE));
     assert_eq!(Encoding::for_label(b"csmacintosh"), Some(MACINTOSH));
     assert_eq!(Encoding::for_label(b"csiso88596i"), Some(ISO_8859_6));
     assert_eq!(Encoding::for_label(b"csiso88598i"), Some(ISO_8859_8_I));
@@ -204,12 +209,15 @@ fn test_all_labels() {
     assert_eq!(Encoding::for_label(b"iso-8859-8-i"), Some(ISO_8859_8_I));
     assert_eq!(Encoding::for_label(b"sun_eu_greek"), Some(ISO_8859_7));
     assert_eq!(Encoding::for_label(b"csksc56011987"), Some(EUC_KR));
+    assert_eq!(Encoding::for_label(b"unicode20utf8"), Some(UTF_8));
+    assert_eq!(Encoding::for_label(b"unicode11utf8"), Some(UTF_8));
     assert_eq!(Encoding::for_label(b"ks_c_5601-1987"), Some(EUC_KR));
     assert_eq!(Encoding::for_label(b"ansi_x3.4-1968"), Some(WINDOWS_1252));
     assert_eq!(Encoding::for_label(b"ks_c_5601-1989"), Some(EUC_KR));
     assert_eq!(Encoding::for_label(b"x-mac-cyrillic"), Some(X_MAC_CYRILLIC));
     assert_eq!(Encoding::for_label(b"x-user-defined"), Some(X_USER_DEFINED));
     assert_eq!(Encoding::for_label(b"csiso58gb231280"), Some(GBK));
+    assert_eq!(Encoding::for_label(b"iso-10646-ucs-2"), Some(UTF_16LE));
     assert_eq!(Encoding::for_label(b"iso_8859-1:1987"), Some(WINDOWS_1252));
     assert_eq!(Encoding::for_label(b"iso_8859-2:1987"), Some(ISO_8859_2));
     assert_eq!(Encoding::for_label(b"iso_8859-6:1987"), Some(ISO_8859_6));
@@ -218,6 +226,7 @@ fn test_all_labels() {
     assert_eq!(Encoding::for_label(b"iso_8859-4:1988"), Some(ISO_8859_4));
     assert_eq!(Encoding::for_label(b"iso_8859-5:1988"), Some(ISO_8859_5));
     assert_eq!(Encoding::for_label(b"iso_8859-8:1988"), Some(ISO_8859_8));
+    assert_eq!(Encoding::for_label(b"x-unicode20utf8"), Some(UTF_8));
     assert_eq!(Encoding::for_label(b"iso_8859-9:1989"), Some(WINDOWS_1254));
     assert_eq!(Encoding::for_label(b"csisolatingreek"), Some(ISO_8859_7));
     assert_eq!(
diff --git a/third_party/rust/encoding_rs/src/testing.rs b/third_party/rust/encoding_rs/src/testing.rs
index 5e00431d3bd2..e2ca55c90dad 100644
--- a/third_party/rust/encoding_rs/src/testing.rs
+++ b/third_party/rust/encoding_rs/src/testing.rs
@@ -1,4 +1,4 @@
-// Copyright 2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -12,7 +12,12 @@ use super::*;
 pub fn decode(encoding: &'static Encoding, bytes: &[u8], expect: &str) {
     let mut vec = Vec::with_capacity(bytes.len() + 32);
     let mut string = String::with_capacity(expect.len() + 32);
-    for i in 0usize..32usize {
+    let range = if cfg!(miri) {
+        0usize..4usize
+    } else {
+        0usize..32usize
+    };
+    for i in range {
         vec.clear();
         string.clear();
         for j in 0usize..i {
@@ -44,7 +49,12 @@ fn decode_without_padding_impl(
 pub fn encode(encoding: &'static Encoding, str: &str, expect: &[u8]) {
     let mut vec = Vec::with_capacity(expect.len() + 32);
     let mut string = String::with_capacity(str.len() + 32);
-    for i in 0usize..32usize {
+    let range = if cfg!(miri) {
+        0usize..4usize
+    } else {
+        0usize..32usize
+    };
+    for i in range {
         vec.clear();
         string.clear();
         for j in 0usize..i {
diff --git a/third_party/rust/encoding_rs/src/utf_16.rs b/third_party/rust/encoding_rs/src/utf_16.rs
index b95c284fe888..c4428b39ce0a 100644
--- a/third_party/rust/encoding_rs/src/utf_16.rs
+++ b/third_party/rust/encoding_rs/src/utf_16.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,8 +8,8 @@
 // except according to those terms.
 
 use super::*;
-use handles::*;
-use variant::*;
+use crate::handles::*;
+use crate::variant::*;
 
 pub struct Utf16Decoder {
     lead_surrogate: u16, // If non-zero and pending_bmp == false, a pending lead surrogate
@@ -200,7 +200,7 @@ impl Utf16Decoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
diff --git a/third_party/rust/encoding_rs/src/utf_8.rs b/third_party/rust/encoding_rs/src/utf_8.rs
index da8be91a5236..2f72cc091d5e 100644
--- a/third_party/rust/encoding_rs/src/utf_8.rs
+++ b/third_party/rust/encoding_rs/src/utf_8.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,17 +8,17 @@
 // except according to those terms.
 
 use super::*;
-use ascii::ascii_to_basic_latin;
-use ascii::basic_latin_to_ascii;
-use ascii::validate_ascii;
-use handles::*;
-use mem::convert_utf16_to_utf8_partial;
-use variant::*;
+use crate::ascii::ascii_to_basic_latin;
+use crate::ascii::basic_latin_to_ascii;
+use crate::ascii::validate_ascii;
+use crate::handles::*;
+use crate::mem::convert_utf16_to_utf8_partial;
+use crate::variant::*;
 
 cfg_if! {
     if #[cfg(feature = "simd-accel")] {
-        use ::std::intrinsics::unlikely;
-        use ::std::intrinsics::likely;
+        use ::core::intrinsics::unlikely;
+        use ::core::intrinsics::likely;
     } else {
         #[inline(always)]
         // Unsafe to match the intrinsic, which is needlessly unsafe.
@@ -236,7 +236,7 @@ pub fn convert_utf8_to_utf16_up_to_invalid(src: &[u8], dst: &mut [u16]) -> (usiz
         let mut byte = {
             let src_remaining = &src[read..];
             let dst_remaining = &mut dst[written..];
-            let length = ::std::cmp::min(src_remaining.len(), dst_remaining.len());
+            let length = ::core::cmp::min(src_remaining.len(), dst_remaining.len());
             match unsafe {
                 ascii_to_basic_latin(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)
             } {
@@ -886,7 +886,7 @@ impl Utf8Encoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
diff --git a/third_party/rust/encoding_rs/src/variant.rs b/third_party/rust/encoding_rs/src/variant.rs
index 6c1dfeb6333e..dffaf053e37d 100644
--- a/third_party/rust/encoding_rs/src/variant.rs
+++ b/third_party/rust/encoding_rs/src/variant.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
diff --git a/third_party/rust/encoding_rs/src/x_user_defined.rs b/third_party/rust/encoding_rs/src/x_user_defined.rs
index 2d2076987984..103c9afba9eb 100644
--- a/third_party/rust/encoding_rs/src/x_user_defined.rs
+++ b/third_party/rust/encoding_rs/src/x_user_defined.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,8 +8,8 @@
 // except according to those terms.
 
 use super::*;
-use handles::*;
-use variant::*;
+use crate::handles::*;
+use crate::variant::*;
 
 cfg_if! {
     if #[cfg(feature = "simd-accel")] {
@@ -196,7 +196,7 @@ impl UserDefinedEncoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
diff --git a/third_party/rust/packed_simd/build.rs b/third_party/rust/packed_simd/build.rs
deleted file mode 100644
index 571139204e8f..000000000000
--- a/third_party/rust/packed_simd/build.rs
+++ /dev/null
@@ -1,34 +0,0 @@
-use rustc_version::{version_meta, Channel, Version};
-
-fn main() {
-    println!("cargo:rustc-env=RUSTC_BOOTSTRAP=1");
-    let target = std::env::var("TARGET")
-        .expect("TARGET environment variable not defined");
-    if target.contains("neon") {
-        println!("cargo:rustc-cfg=libcore_neon");
-    }
-    let ver_meta = version_meta().unwrap();
-    let old_const_generics =
-        if ver_meta.semver < Version::parse("1.56.0-alpha").unwrap() {
-            true
-        } else if ver_meta.semver >= Version::parse("1.57.0-alpha").unwrap() {
-            false
-        } else {
-            match ver_meta.channel {
-                Channel::Stable | Channel::Beta => false,
-                Channel::Nightly | Channel::Dev
-                    if ver_meta
-                        .commit_date
-                        .as_deref()
-                        .map(|d| d < "2021-08-31")
-                        .unwrap_or(false) =>
-                {
-                    true
-                }
-                _ => false,
-            }
-        };
-    if old_const_generics {
-        println!("cargo:rustc-cfg=const_generics");
-    }
-}
diff --git a/third_party/rust/packed_simd/rustfmt.toml b/third_party/rust/packed_simd/rustfmt.toml
deleted file mode 100644
index 5b400a4ce440..000000000000
--- a/third_party/rust/packed_simd/rustfmt.toml
+++ /dev/null
@@ -1,7 +0,0 @@
-max_width = 79
-use_small_heuristics = "Max"
-wrap_comments = true
-comment_width = 79
-fn_args_density = "Compressed"
-edition = "2018"
-error_on_line_overflow = true
\ No newline at end of file
diff --git a/third_party/rust/packed_simd/src/api/cast/v128.rs b/third_party/rust/packed_simd/src/api/cast/v128.rs
deleted file mode 100644
index ab47ddc006d6..000000000000
--- a/third_party/rust/packed_simd/src/api/cast/v128.rs
+++ /dev/null
@@ -1,79 +0,0 @@
-//! `FromCast` and `IntoCast` implementations for portable 128-bit wide vectors
-#[rustfmt::skip]
-
-use crate::*;
-
-impl_from_cast!(
-    i8x16[test_v128]: u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16, m32x16
-);
-impl_from_cast!(
-    u8x16[test_v128]: i8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16, m32x16
-);
-impl_from_cast_mask!(
-    m8x16[test_v128]: i8x16, u8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16, m32x16
-);
-
-impl_from_cast!(
-    i16x8[test_v128]: i8x8, u8x8, m8x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast!(
-    u16x8[test_v128]: i8x8, u8x8, m8x8, i16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast_mask!(
-    m16x8[test_v128]: i8x8, u8x8, m8x8, i16x8, u16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-
-impl_from_cast!(
-    i32x4[test_v128]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast!(
-    u32x4[test_v128]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast!(
-    f32x4[test_v128]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast_mask!(
-    m32x4[test_v128]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-
-impl_from_cast!(
-    i64x2[test_v128]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast!(
-    u64x2[test_v128]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast!(
-    f64x2[test_v128]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast_mask!(
-    m64x2[test_v128]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-
-impl_from_cast!(
-    isizex2[test_v128]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, usizex2, msizex2
-);
-impl_from_cast!(
-    usizex2[test_v128]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, msizex2
-);
-impl_from_cast_mask!(
-    msizex2[test_v128]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2
-);
-
-// FIXME[test_v128]: 64-bit single element vectors into_cast impls
-impl_from_cast!(i128x1[test_v128]: u128x1, m128x1);
-impl_from_cast!(u128x1[test_v128]: i128x1, m128x1);
-impl_from_cast!(m128x1[test_v128]: i128x1, u128x1);
diff --git a/third_party/rust/packed_simd/src/api/cast/v16.rs b/third_party/rust/packed_simd/src/api/cast/v16.rs
deleted file mode 100644
index cf974bb08e70..000000000000
--- a/third_party/rust/packed_simd/src/api/cast/v16.rs
+++ /dev/null
@@ -1,17 +0,0 @@
-//! `FromCast` and `IntoCast` implementations for portable 16-bit wide vectors
-#[rustfmt::skip]
-
-use crate::*;
-
-impl_from_cast!(
-    i8x2[test_v16]: u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast!(
-    u8x2[test_v16]: i8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast_mask!(
-    m8x2[test_v16]: i8x2, u8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
diff --git a/third_party/rust/packed_simd/src/api/cast/v256.rs b/third_party/rust/packed_simd/src/api/cast/v256.rs
deleted file mode 100644
index 9389dcb4c7f7..000000000000
--- a/third_party/rust/packed_simd/src/api/cast/v256.rs
+++ /dev/null
@@ -1,81 +0,0 @@
-//! `FromCast` and `IntoCast` implementations for portable 256-bit wide vectors
-#[rustfmt::skip]
-
-use crate::*;
-
-impl_from_cast!(i8x32[test_v256]: u8x32, m8x32, i16x32, u16x32, m16x32);
-impl_from_cast!(u8x32[test_v256]: i8x32, m8x32, i16x32, u16x32, m16x32);
-impl_from_cast_mask!(m8x32[test_v256]: i8x32, u8x32, i16x32, u16x32, m16x32);
-
-impl_from_cast!(
-    i16x16[test_v256]: i8x16, u8x16, m8x16, u16x16, m16x16,
-    i32x16, u32x16, f32x16, m32x16
-);
-impl_from_cast!(
-    u16x16[test_v256]: i8x16, u8x16, m8x16, i16x16, m16x16,
-    i32x16, u32x16, f32x16, m32x16
-);
-impl_from_cast_mask!(
-    m16x16[test_v256]: i8x16, u8x16, m8x16, i16x16, u16x16,
-    i32x16, u32x16, f32x16, m32x16
-);
-
-impl_from_cast!(
-    i32x8[test_v256]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast!(
-    u32x8[test_v256]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast!(
-    f32x8[test_v256]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast_mask!(
-    m32x8[test_v256]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-
-impl_from_cast!(
-    i64x4[test_v256]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast!(
-    u64x4[test_v256]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast!(
-    f64x4[test_v256]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast_mask!(
-    m64x4[test_v256]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-
-impl_from_cast!(
-    i128x2[test_v256]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast!(
-    u128x2[test_v256]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast_mask!(
-    m128x2[test_v256]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, m64x2, f64x2, i128x2, u128x2, isizex2, usizex2, msizex2
-);
-
-impl_from_cast!(
-    isizex4[test_v256]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, usizex4, msizex4
-);
-impl_from_cast!(
-    usizex4[test_v256]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, msizex4
-);
-impl_from_cast_mask!(
-    msizex4[test_v256]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4
-);
diff --git a/third_party/rust/packed_simd/src/api/cast/v32.rs b/third_party/rust/packed_simd/src/api/cast/v32.rs
deleted file mode 100644
index 2b254ba0cf12..000000000000
--- a/third_party/rust/packed_simd/src/api/cast/v32.rs
+++ /dev/null
@@ -1,30 +0,0 @@
-//! `FromCast` and `IntoCast` implementations for portable 32-bit wide vectors
-#[rustfmt::skip]
-
-use crate::*;
-
-impl_from_cast!(
-    i8x4[test_v32]: u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast!(
-    u8x4[test_v32]: i8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast_mask!(
-    m8x4[test_v32]: i8x4, u8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-
-impl_from_cast!(
-    i16x2[test_v32]: i8x2, u8x2, m8x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast!(
-    u16x2[test_v32]: i8x2, u8x2, m8x2, i16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast_mask!(
-    m16x2[test_v32]: i8x2, u8x2, m8x2, i16x2, u16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
diff --git a/third_party/rust/packed_simd/src/api/cast/v512.rs b/third_party/rust/packed_simd/src/api/cast/v512.rs
deleted file mode 100644
index 5a10ab066677..000000000000
--- a/third_party/rust/packed_simd/src/api/cast/v512.rs
+++ /dev/null
@@ -1,68 +0,0 @@
-//! `FromCast` and `IntoCast` implementations for portable 512-bit wide vectors
-#[rustfmt::skip]
-
-use crate::*;
-
-impl_from_cast!(i8x64[test_v512]: u8x64, m8x64);
-impl_from_cast!(u8x64[test_v512]: i8x64, m8x64);
-impl_from_cast_mask!(m8x64[test_v512]: i8x64, u8x64);
-
-impl_from_cast!(i16x32[test_v512]: i8x32, u8x32, m8x32, u16x32, m16x32);
-impl_from_cast!(u16x32[test_v512]: i8x32, u8x32, m8x32, i16x32, m16x32);
-impl_from_cast_mask!(m16x32[test_v512]: i8x32, u8x32, m8x32, i16x32, u16x32);
-
-impl_from_cast!(
-    i32x16[test_v512]: i8x16, u8x16, m8x16, i16x16, u16x16, m16x16, u32x16, f32x16, m32x16
-);
-impl_from_cast!(
-    u32x16[test_v512]: i8x16, u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, f32x16, m32x16
-);
-impl_from_cast!(
-    f32x16[test_v512]: i8x16, u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, m32x16
-);
-impl_from_cast_mask!(
-    m32x16[test_v512]: i8x16, u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16
-);
-
-impl_from_cast!(
-    i64x8[test_v512]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast!(
-    u64x8[test_v512]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast!(
-    f64x8[test_v512]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast_mask!(
-    m64x8[test_v512]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, isizex8, usizex8, msizex8
-);
-
-impl_from_cast!(
-    i128x4[test_v512]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast!(
-    u128x4[test_v512]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast_mask!(
-    m128x4[test_v512]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, m64x4, f64x4, i128x4, u128x4, isizex4, usizex4, msizex4
-);
-
-impl_from_cast!(
-    isizex8[test_v512]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, usizex8, msizex8
-);
-impl_from_cast!(
-    usizex8[test_v512]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, msizex8
-);
-impl_from_cast_mask!(
-    msizex8[test_v512]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8
-);
diff --git a/third_party/rust/packed_simd/src/api/cast/v64.rs b/third_party/rust/packed_simd/src/api/cast/v64.rs
deleted file mode 100644
index 192a4638a362..000000000000
--- a/third_party/rust/packed_simd/src/api/cast/v64.rs
+++ /dev/null
@@ -1,47 +0,0 @@
-//! `FromCast` and `IntoCast` implementations for portable 64-bit wide vectors
-#[rustfmt::skip]
-
-use crate::*;
-
-impl_from_cast!(
-    i8x8[test_v64]: u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast!(
-    u8x8[test_v64]: i8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast_mask!(
-    m8x8[test_v64]: i8x8, u8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-
-impl_from_cast!(
-    i16x4[test_v64]: i8x4, u8x4, m8x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast!(
-    u16x4[test_v64]: i8x4, u8x4, m8x4, i16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast_mask!(
-    m16x4[test_v64]: i8x4, u8x4, m8x4, i16x4, u16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-
-impl_from_cast!(
-    i32x2[test_v64]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast!(
-    u32x2[test_v64]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast!(
-    f32x2[test_v64]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast_mask!(
-    m32x2[test_v64]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v128.rs b/third_party/rust/packed_simd/src/api/into_bits/v128.rs
deleted file mode 100644
index e32cd7f9f099..000000000000
--- a/third_party/rust/packed_simd/src/api/into_bits/v128.rs
+++ /dev/null
@@ -1,28 +0,0 @@
-//! `FromBits` and `IntoBits` implementations for portable 128-bit wide vectors
-#[rustfmt::skip]
-
-#[allow(unused)]  // wasm_bindgen_test
-use crate::*;
-
-impl_from_bits!(i8x16[test_v128]: u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(u8x16[test_v128]: i8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(m8x16[test_v128]: m16x8, m32x4, m64x2, m128x1);
-
-impl_from_bits!(i16x8[test_v128]: i8x16, u8x16, m8x16, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(u16x8[test_v128]: i8x16, u8x16, m8x16, i16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(m16x8[test_v128]: m32x4, m64x2, m128x1);
-
-impl_from_bits!(i32x4[test_v128]: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, u32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(u32x4[test_v128]: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(f32x4[test_v128]: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(m32x4[test_v128]: m64x2, m128x1);
-
-impl_from_bits!(i64x2[test_v128]: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(u64x2[test_v128]: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(f64x2[test_v128]: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, u64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(m64x2[test_v128]: m128x1);
-
-impl_from_bits!(i128x1[test_v128]: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, u128x1, m128x1);
-impl_from_bits!(u128x1[test_v128]: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, m128x1);
-// note: m128x1 cannot be constructed from all the other masks bit patterns in here
-
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v256.rs b/third_party/rust/packed_simd/src/api/into_bits/v256.rs
deleted file mode 100644
index c4c373e0d0b8..000000000000
--- a/third_party/rust/packed_simd/src/api/into_bits/v256.rs
+++ /dev/null
@@ -1,27 +0,0 @@
-//! `FromBits` and `IntoBits` implementations for portable 256-bit wide vectors
-#[rustfmt::skip]
-
-#[allow(unused)]  // wasm_bindgen_test
-use crate::*;
-
-impl_from_bits!(i8x32[test_v256]: u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(u8x32[test_v256]: i8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(m8x32[test_v256]: m16x16, m32x8, m64x4, m128x2);
-
-impl_from_bits!(i16x16[test_v256]: i8x32, u8x32, m8x32, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(u16x16[test_v256]: i8x32, u8x32, m8x32, i16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(m16x16[test_v256]: m32x8, m64x4, m128x2);
-
-impl_from_bits!(i32x8[test_v256]: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16, u32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(u32x8[test_v256]: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(f32x8[test_v256]: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(m32x8[test_v256]: m64x4, m128x2);
-
-impl_from_bits!(i64x4[test_v256]: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(u64x4[test_v256]: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(f64x4[test_v256]: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, u64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(m64x4[test_v256]: m128x2);
-
-impl_from_bits!(i128x2[test_v256]: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, u128x2, m128x2);
-impl_from_bits!(u128x2[test_v256]: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, m128x2);
-// note: m128x2 cannot be constructed from all the other masks bit patterns in here
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v512.rs b/third_party/rust/packed_simd/src/api/into_bits/v512.rs
deleted file mode 100644
index 4a771962c348..000000000000
--- a/third_party/rust/packed_simd/src/api/into_bits/v512.rs
+++ /dev/null
@@ -1,27 +0,0 @@
-//! `FromBits` and `IntoBits` implementations for portable 512-bit wide vectors
-#[rustfmt::skip]
-
-#[allow(unused)]  // wasm_bindgen_test
-use crate::*;
-
-impl_from_bits!(i8x64[test_v512]: u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(u8x64[test_v512]: i8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(m8x64[test_v512]: m16x32, m32x16, m64x8, m128x4);
-
-impl_from_bits!(i16x32[test_v512]: i8x64, u8x64, m8x64, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(u16x32[test_v512]: i8x64, u8x64, m8x64, i16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(m16x32[test_v512]: m32x16, m64x8, m128x4);
-
-impl_from_bits!(i32x16[test_v512]: i8x64, u8x64, m8x64, i16x32, u16x32, m16x32, u32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(u32x16[test_v512]: i8x64, u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(f32x16[test_v512]: i8x64, u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(m32x16[test_v512]: m64x8, m128x4);
-
-impl_from_bits!(i64x8[test_v512]: i8x64, u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(u64x8[test_v512]: i8x64, u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(f64x8[test_v512]: i8x64, u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, u64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(m64x8[test_v512]: m128x4);
-
-impl_from_bits!(i128x4[test_v512]: i8x64, u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, u128x4, m128x4);
-impl_from_bits!(u128x4[test_v512]: i8x64, u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, m128x4);
-// note: m128x4 cannot be constructed from all the other masks bit patterns in here
diff --git a/third_party/rust/packed_simd/src/codegen/llvm.rs b/third_party/rust/packed_simd/src/codegen/llvm.rs
deleted file mode 100644
index 52b11a95b917..000000000000
--- a/third_party/rust/packed_simd/src/codegen/llvm.rs
+++ /dev/null
@@ -1,128 +0,0 @@
-//! LLVM's platform intrinsics
-#![allow(dead_code)]
-
-use crate::sealed::Shuffle;
-#[allow(unused_imports)] // FIXME: spurious warning?
-use crate::sealed::Simd;
-
-// Shuffle intrinsics: expanded in users' crates, therefore public.
-extern "platform-intrinsic" {
-    pub fn simd_shuffle2<T, U>(x: T, y: T, idx: [u32; 2]) -> U;
-    pub fn simd_shuffle4<T, U>(x: T, y: T, idx: [u32; 4]) -> U;
-    pub fn simd_shuffle8<T, U>(x: T, y: T, idx: [u32; 8]) -> U;
-    pub fn simd_shuffle16<T, U>(x: T, y: T, idx: [u32; 16]) -> U;
-    pub fn simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U;
-    pub fn simd_shuffle64<T, U>(x: T, y: T, idx: [u32; 64]) -> U;
-}
-
-#[allow(clippy::missing_safety_doc)]
-#[inline]
-pub unsafe fn __shuffle_vector2<const IDX: [u32; 2], T, U>(x: T, y: T) -> U
-where
-    T: Simd,
-    <T as Simd>::Element: Shuffle<[u32; 2], Output = U>,
-{
-    simd_shuffle2(x, y, IDX)
-}
-
-#[allow(clippy::missing_safety_doc)]
-#[inline]
-pub unsafe fn __shuffle_vector4<const IDX: [u32; 4], T, U>(x: T, y: T) -> U
-where
-    T: Simd,
-    <T as Simd>::Element: Shuffle<[u32; 4], Output = U>,
-{
-    simd_shuffle4(x, y, IDX)
-}
-
-#[allow(clippy::missing_safety_doc)]
-#[inline]
-pub unsafe fn __shuffle_vector8<const IDX: [u32; 8], T, U>(x: T, y: T) -> U
-where
-    T: Simd,
-    <T as Simd>::Element: Shuffle<[u32; 8], Output = U>,
-{
-    simd_shuffle8(x, y, IDX)
-}
-
-#[allow(clippy::missing_safety_doc)]
-#[inline]
-pub unsafe fn __shuffle_vector16<const IDX: [u32; 16], T, U>(x: T, y: T) -> U
-where
-    T: Simd,
-    <T as Simd>::Element: Shuffle<[u32; 16], Output = U>,
-{
-    simd_shuffle16(x, y, IDX)
-}
-
-#[allow(clippy::missing_safety_doc)]
-#[inline]
-pub unsafe fn __shuffle_vector32<const IDX: [u32; 32], T, U>(x: T, y: T) -> U
-where
-    T: Simd,
-    <T as Simd>::Element: Shuffle<[u32; 32], Output = U>,
-{
-    simd_shuffle32(x, y, IDX)
-}
-
-#[allow(clippy::missing_safety_doc)]
-#[inline]
-pub unsafe fn __shuffle_vector64<const IDX: [u32; 64], T, U>(x: T, y: T) -> U
-where
-    T: Simd,
-    <T as Simd>::Element: Shuffle<[u32; 64], Output = U>,
-{
-    simd_shuffle64(x, y, IDX)
-}
-
-extern "platform-intrinsic" {
-    crate fn simd_eq<T, U>(x: T, y: T) -> U;
-    crate fn simd_ne<T, U>(x: T, y: T) -> U;
-    crate fn simd_lt<T, U>(x: T, y: T) -> U;
-    crate fn simd_le<T, U>(x: T, y: T) -> U;
-    crate fn simd_gt<T, U>(x: T, y: T) -> U;
-    crate fn simd_ge<T, U>(x: T, y: T) -> U;
-
-    crate fn simd_insert<T, U>(x: T, idx: u32, val: U) -> T;
-    crate fn simd_extract<T, U>(x: T, idx: u32) -> U;
-
-    crate fn simd_cast<T, U>(x: T) -> U;
-
-    crate fn simd_add<T>(x: T, y: T) -> T;
-    crate fn simd_sub<T>(x: T, y: T) -> T;
-    crate fn simd_mul<T>(x: T, y: T) -> T;
-    crate fn simd_div<T>(x: T, y: T) -> T;
-    crate fn simd_rem<T>(x: T, y: T) -> T;
-    crate fn simd_shl<T>(x: T, y: T) -> T;
-    crate fn simd_shr<T>(x: T, y: T) -> T;
-    crate fn simd_and<T>(x: T, y: T) -> T;
-    crate fn simd_or<T>(x: T, y: T) -> T;
-    crate fn simd_xor<T>(x: T, y: T) -> T;
-
-    crate fn simd_reduce_add_unordered<T, U>(x: T) -> U;
-    crate fn simd_reduce_mul_unordered<T, U>(x: T) -> U;
-    crate fn simd_reduce_add_ordered<T, U>(x: T, acc: U) -> U;
-    crate fn simd_reduce_mul_ordered<T, U>(x: T, acc: U) -> U;
-    crate fn simd_reduce_min<T, U>(x: T) -> U;
-    crate fn simd_reduce_max<T, U>(x: T) -> U;
-    crate fn simd_reduce_min_nanless<T, U>(x: T) -> U;
-    crate fn simd_reduce_max_nanless<T, U>(x: T) -> U;
-    crate fn simd_reduce_and<T, U>(x: T) -> U;
-    crate fn simd_reduce_or<T, U>(x: T) -> U;
-    crate fn simd_reduce_xor<T, U>(x: T) -> U;
-    crate fn simd_reduce_all<T>(x: T) -> bool;
-    crate fn simd_reduce_any<T>(x: T) -> bool;
-
-    crate fn simd_select<M, T>(m: M, a: T, b: T) -> T;
-
-    crate fn simd_fmin<T>(a: T, b: T) -> T;
-    crate fn simd_fmax<T>(a: T, b: T) -> T;
-
-    crate fn simd_fsqrt<T>(a: T) -> T;
-    crate fn simd_fma<T>(a: T, b: T, c: T) -> T;
-
-    crate fn simd_gather<T, P, M>(value: T, pointers: P, mask: M) -> T;
-    crate fn simd_scatter<T, P, M>(value: T, pointers: P, mask: M);
-
-    crate fn simd_bitmask<T, U>(value: T) -> U;
-}
diff --git a/third_party/rust/packed_simd/src/codegen/math/float.rs b/third_party/rust/packed_simd/src/codegen/math/float.rs
deleted file mode 100644
index 5e89bf6ae6b0..000000000000
--- a/third_party/rust/packed_simd/src/codegen/math/float.rs
+++ /dev/null
@@ -1,18 +0,0 @@
-//! Vertical floating-point math operations.
-#![allow(clippy::useless_transmute)]
-
-#[macro_use]
-crate mod macros;
-crate mod abs;
-crate mod cos;
-crate mod cos_pi;
-crate mod exp;
-crate mod ln;
-crate mod mul_add;
-crate mod mul_adde;
-crate mod powf;
-crate mod sin;
-crate mod sin_cos_pi;
-crate mod sin_pi;
-crate mod sqrt;
-crate mod sqrte;
diff --git a/third_party/rust/packed_simd/src/codegen/pointer_sized_int.rs b/third_party/rust/packed_simd/src/codegen/pointer_sized_int.rs
deleted file mode 100644
index 39f493d3b17f..000000000000
--- a/third_party/rust/packed_simd/src/codegen/pointer_sized_int.rs
+++ /dev/null
@@ -1,28 +0,0 @@
-//! Provides `isize` and `usize`
-
-use cfg_if::cfg_if;
-
-cfg_if! {
-    if #[cfg(target_pointer_width = "8")] {
-        crate type isize_ = i8;
-        crate type usize_ = u8;
-    } else if #[cfg(target_pointer_width = "16")] {
-        crate type isize_ = i16;
-        crate type usize_ = u16;
-    } else if #[cfg(target_pointer_width = "32")] {
-        crate type isize_ = i32;
-        crate type usize_ = u32;
-
-    } else if #[cfg(target_pointer_width = "64")] {
-        crate type isize_ = i64;
-        crate type usize_ = u64;
-    } else if #[cfg(target_pointer_width = "64")] {
-        crate type isize_ = i64;
-        crate type usize_ = u64;
-    } else if #[cfg(target_pointer_width = "128")] {
-        crate type isize_ = i128;
-        crate type usize_ = u128;
-    } else {
-        compile_error!("unsupported target_pointer_width");
-    }
-}
diff --git a/third_party/rust/packed_simd/src/codegen/reductions.rs b/third_party/rust/packed_simd/src/codegen/reductions.rs
deleted file mode 100644
index 7be4f5fabbea..000000000000
--- a/third_party/rust/packed_simd/src/codegen/reductions.rs
+++ /dev/null
@@ -1 +0,0 @@
-crate mod mask;
diff --git a/third_party/rust/packed_simd/src/testing/macros.rs b/third_party/rust/packed_simd/src/testing/macros.rs
deleted file mode 100644
index 6008634c76ce..000000000000
--- a/third_party/rust/packed_simd/src/testing/macros.rs
+++ /dev/null
@@ -1,44 +0,0 @@
-//! Testing macros
-
-macro_rules! test_if {
-    ($cfg_tt:tt: $it:item) => {
-        #[cfg(any(
-                            // Test everything if:
-                            //
-                            // * tests are enabled,
-                            // * no features about exclusively testing
-                            //   specific vector classes are enabled
-                            all(test, not(any(
-                                test_v16,
-                                test_v32,
-                                test_v64,
-                                test_v128,
-                                test_v256,
-                                test_v512,
-                                test_none,  // disables all tests
-                            ))),
-                            // Test if:
-                            //
-                            // * tests are enabled
-                            // * a particular cfg token tree returns true
-                            all(test, $cfg_tt),
-                        ))]
-        $it
-    };
-}
-
-#[cfg(test)]
-#[allow(unused)]
-macro_rules! ref_ {
-    ($anything:tt) => {
-        &$anything
-    };
-}
-
-#[cfg(test)]
-#[allow(unused)]
-macro_rules! ref_mut_ {
-    ($anything:tt) => {
-        &mut $anything
-    };
-}
diff --git a/third_party/rust/packed_simd/.appveyor.yml b/third_party/rust/packed_simd_2/.appveyor.yml
similarity index 100%
rename from third_party/rust/packed_simd/.appveyor.yml
rename to third_party/rust/packed_simd_2/.appveyor.yml
diff --git a/third_party/rust/packed_simd/.cargo-checksum.json b/third_party/rust/packed_simd_2/.cargo-checksum.json
similarity index 57%
rename from third_party/rust/packed_simd/.cargo-checksum.json
rename to third_party/rust/packed_simd_2/.cargo-checksum.json
index 51a1cee537e3..d61a3b677a32 100644
--- a/third_party/rust/packed_simd/.cargo-checksum.json
+++ b/third_party/rust/packed_simd_2/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{".appveyor.yml":"f1ed01850e0d725f9498f52a1a63ddf40702ad6e0bf5b2d7c4c04d76e96794a3",".travis.yml":"d56de6531d3c4880e3aada85ac8e6d7388e5d781871e181cb8ade2a746d5d5f5","Cargo.toml":"b6f063e65c1f8d71c51204444d4e93cd514cb310dedfd1e85b731c1acc63ab4a","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"6485b8ed310d3f0340bf1ad1f47645069ce4069dcc6bb46c7d5c6faf41de1fdb","README.md":"49d01e49a33393af64fa6c813b6a724f68a4d1abfbedcb96413651ed105aa820","bors.toml":"dee881dc69b9b7834e4eba5d95c3ed5a416d4628815a167d6a22d4cb4fb064b8","build.rs":"9d7f69238f5dfefa3c49744159c2f484feb4c32c9aefe79696ebe97a89b2957f","ci/all.sh":"2ae6b2445b4db83833e40b37efd0016c6b9879ee988b9b3ef94db5439a3e1606","ci/android-install-ndk.sh":"0f1746108cc30bf9b9ba45bcde7b19fc1a8bdf5b0258035b4eb8dc69b75efac4","ci/android-install-sdk.sh":"3490432022c5c8f5a115c084f7a9aca1626f96c0c87ffb62019228c4346b47e4","ci/android-sysimage.sh":"ebf4e5daa1f0fe1b2092b79f0f3f161c4c4275cb744e52352c4d81ab451e4c5a","ci/benchmark.sh":"b61d19ef6b90deba8fb79dee74c8b062d94844676293da346da87bb78a9a49a4","ci/deploy_and_run_on_ios_simulator.rs":"ec8ecf82d92072676aa47f0d1a3d021b60a7ae3531153ef12d2ff4541fc294dc","ci/docker/aarch64-linux-android/Dockerfile":"ace2e7d33c87bc0f6d3962a4a3408c04557646f7f51ab99cfbf574906796b016","ci/docker/aarch64-unknown-linux-gnu/Dockerfile":"da88c0d50f16dc08448c7fdf1fa5ed2cbe576acf9e7dd85b5b818621b2a8c702","ci/docker/arm-linux-androideabi/Dockerfile":"370e55d3330a413a3ccf677b3afb3e0ef9018a5fab263faa97ae8ac017fc2286","ci/docker/arm-unknown-linux-gnueabi/Dockerfile":"bb5f8ae890707c128652290ffc544447643bf12037ddd73c6ad6989f848cb380","ci/docker/arm-unknown-linux-gnueabihf/Dockerfile":"1afaefcbc05b740859acd4e067bc92439be6bcbe8f2e9678474fb434bcd398d9","ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile":"8282ea707a94109beed47a57574755e2d58401735904a03f85fb64c578c53b4f","ci/docker/i586-unknown-linux-gnu/Dockerfile":"49792922269f371bd29da4727e9085101b27be67a6b97755d0196c63317f7abb","ci/docker/i686-unknown-linux-gnu/Dockerfile":"49792922269f371bd29da4727e9085101b27be67a6b97755d0196c63317f7abb","ci/docker/mips-unknown-linux-gnu/Dockerfile":"b2ebc25797612c4f8395fe9d407725156044955bfbcf442036b7f55b43a5f9da","ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile":"b0c1692ac65bc56dd30494b1993d8e929c48cc9c4b92029b7c7592af6d4f9220","ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile":"4e9249c179300138141d0b2b7401b11897f64aed69f541f078c1db4594df2827","ci/docker/mipsel-unknown-linux-musl/Dockerfile":"3164c52b0dcbb01afa78292b15b5c43503ccf0491cf6eb801ec2bf22ae274e52","ci/docker/powerpc-unknown-linux-gnu/Dockerfile":"786f799d0b56eb54d7b6c4b00e1aed4ce81776e14e44767e083c89d014b72004","ci/docker/powerpc64-unknown-linux-gnu/Dockerfile":"e8bc363837cd9c2d8b22402acb8c1c329efc11ba5d12170603d2fe2eae9da059","ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile":"47998d45b781d797b9e6085ebe898d90de0c952b54537a8db4e8d7503eb032d9","ci/docker/s390x-unknown-linux-gnu/Dockerfile":"93fb44df3d7fd31ead158570667c97b5076a05c3d968af4a84bc13819a8f2db8","ci/docker/sparc64-unknown-linux-gnu/Dockerfile":"da1c39a3ff1fe22e41395fa7c8934e90b4c1788e551b9aec6e38bfd94effc437","ci/docker/thumbv7neon-linux-androideabi/Dockerfile":"c2decd5591bd7a09378901bef629cd944acf052eb55e4f35b79eb9cb4d62246a","ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile":"51955a8bf3c4d440f47382af6f5426ebff94ab01a04da36175babda9a057740f","ci/docker/wasm32-unknown-unknown/Dockerfile":"3e5f294bc1e004aa599086c2af49d6f3e7459fa250f5fbdd60cf67d53db78758","ci/docker/x86_64-linux-android/Dockerfile":"685040273cf350d5509e580ac451555efa19790c8723ca2af066adadc6880ad2","ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile":"44b6203d9290bfdc53d81219f0937e1110847a23dd982ec8c4de388354f01536","ci/docker/x86_64-unknown-linux-gnu/Dockerfile":"7f4e3ca5fa288ea70edb4d1f75309708cd30b192e2e4444e61c4d5b3b58f89cf","ci/dox.sh":"434e9611c52e389312d2b03564adf09429f10cc76fe66a8644adb104903b87b7","ci/linux-s390x.sh":"d6b732d7795b4ba131326aff893bca6228a7d2eb0e9402f135705413dbbe0dce","ci/linux-sparc64.sh":"c92966838b1ab7ad3b7a344833ee726aba6b647cf5952e56f0ad1ba420b13325","ci/lld-shim.rs":"3d7f71ec23a49e2b67f694a0168786f9a954dda15f5a138815d966643fd3fcc3","ci/max_line_width.sh":"0a1518bba4c9ecaa55694cb2e9930d0e19c265baabf73143f17f9cf285aaa5bb","ci/run-docker.sh":"92e036390ad9b0d16f109579df1b5ced2e72e9afea40c7d011400ebd3a2a90de","ci/run.sh":"41dd6a60efaaeae9661a01370cce98b631f78392859a0cf68c946c0a16edf5f7","ci/run_examples.sh":"d1a23c6c35374a0678ba5114b9b8fefd8be0a79e774872a8bf0898d1baca18d0","ci/runtest-android.rs":"145a8e9799a5223975061fe7e586ade5669ee4877a7d7a4cf6b4ab48e8e36c7c","ci/setup_benchmarks.sh":"fae3960023f6f3d1388cd2ad22fdbab4b075f1f29dd4292d7994a20783beb6cf","ci/test-runner-linux":"c8aa6025cff5306f4f31d0c61dc5f9d4dd5a1d189ab613ef8d4c367c694d9ccd","contributing.md":"2cc8c9c560ae17867e69b06d09b758dbf7bc39eb774ada50a743724b10acc0a2","perf-guide/.gitignore":"fe82c7da551079d832cf74200b0b359b4df9828cb4a0416fa7384f07a2ae6a13","perf-guide/book.toml":"115a98284126c6b180178b44713314cc494f08a71662ee2ce15cf67f17a51064","perf-guide/src/SUMMARY.md":"3e03bffc991fdc2050f3d51842d72d9d21ea6abab56a3baf3b2d5973a78b89e1","perf-guide/src/ascii.css":"29afb08833b2fe2250f0412e1fa1161a2432a0820a14953c87124407417c741a","perf-guide/src/bound_checks.md":"5e4991ff58a183ef0cd9fdc1feb4cd12d083b44bdf87393bbb0927808ef3ce7d","perf-guide/src/float-math/approx.md":"8c09032fa2d795a0c5db1775826c850d28eb2627846d0965c60ee72de63735ad","perf-guide/src/float-math/fma.md":"311076ba4b741d604a82e74b83a8d7e8c318fcbd7f64c4392d1cf5af95c60243","perf-guide/src/float-math/fp.md":"04153e775ab6e4f0d7837bcc515230d327b04edfa34c84ce9c9e10ebaeef2be8","perf-guide/src/float-math/svml.md":"0798873b8eedaeda5fed62dc91645b57c20775a02d3cd74d8bd06958f1516506","perf-guide/src/introduction.md":"9f5a19e9e6751f25d2daad39891a0cc600974527ec4c8305843f9618910671bd","perf-guide/src/prof/linux.md":"447731eb5de7d69166728fdbc5ecb0c0c9db678ea493b45a592d67dd002184c0","perf-guide/src/prof/mca.md":"f56d54f3d20e7aa4d32052186e8237b03d65971eb5d112802b442570ff11d344","perf-guide/src/prof/profiling.md":"8a650c0fd6ede0964789bb6577557eeef1d8226a896788602ce61528e260e43c","perf-guide/src/target-feature/attribute.md":"615f88dca0a707b6c416fa605435dd6e1fb5361cc639429cbf68cd87624bd78b","perf-guide/src/target-feature/features.md":"17077760ff24c006b606dd21889c53d87228f4311f3ba3a574f9afdeacd86165","perf-guide/src/target-feature/inlining.md":"7ed1d7068d8173a00d84c16cfe5871cd68b9f04f8d0cca2d01ebc84957ebf2f6","perf-guide/src/target-feature/practice.md":"c4b371842e0086df178488fec97f20def8f0c62ee588bcd25fd948b9b1fa227e","perf-guide/src/target-feature/runtime.md":"835425f5ee597fb3e51d36e725a81ebee29f4561231d19563cd4da81dbb1cfcb","perf-guide/src/target-feature/rustflags.md":"ab49712e9293a65d74d540ba4784fcb57ff1119ec05a575d895c071f1a620f64","perf-guide/src/vert-hor-ops.md":"c6211c0ee91e60552ec592d89d9d957eedc21dee3cbd89e1ad6765ea06a27471","rustfmt.toml":"de6101d0670bad65fb3b337d56957d2a024e017e5ab146ec784d77312daaf8ff","src/api.rs":"f6e92f056565e6fd93f98829a408aee9e790251e0cbd8a8bc30c8662b4d6fabb","src/api/bit_manip.rs":"c47a4d0f7451f7e35d07715e4f39a472e07457fd456fdb726864a4f6887252a3","src/api/bitmask.rs":"6d2beefd62ee5d9c8eb060bee6abc641616bf828c99f82abf97b21bf004e894b","src/api/cast.rs":"03b94a3d316ac7b7be7068810044911e965e889a0ace7bae762749ca74a92747","src/api/cast/macros.rs":"b0a14d0c83ad2ebb7a275180f6d9e3f2bc312ba57a7d3d6c39fad4e0f20f9408","src/api/cast/v128.rs":"2107ea6a426a0fe37a0aa6a03a579ff0bdeb5a1599ea76e2d81734a82f41276d","src/api/cast/v16.rs":"d785cf93b8e61200c9ae1c32b9f5e9d9518e87c261c56bcaf92f2e47b0009eb4","src/api/cast/v256.rs":"b81fcfd367a5de532d922dedf18579e53666facef7957c0e1bc827825e500ae6","src/api/cast/v32.rs":"2aac9ec0a67a97328ba908b13a1ff98da3dcd7781910d592d31f9207cbd9a7d2","src/api/cast/v512.rs":"33b33de818f8d4eccc982bc2f3951a8b3d03e9762ec02789b3df82e3f5ed3fc3","src/api/cast/v64.rs":"ec878917d52a8c952633251b3a938a2cbe0a63fee6d12c15840d9f1343d1f394","src/api/cmp.rs":"357c3a2a09c6d4611c32dd7fa95be2fae933d513e229026ec9b44451a77b884e","src/api/cmp/eq.rs":"60f70f355bae4cb5b17db53204cacc3890f70670611c17df638d4c04f7cc8075","src/api/cmp/ord.rs":"589f7234761c294fa5df8f525bc4acd5a47cdb602207d524a0d4e19804cd9695","src/api/cmp/partial_eq.rs":"3ed23d2a930b0f9750c3a5309da766b03dc4f9c4d375b42ad3c50fe732693d15","src/api/cmp/partial_ord.rs":"e16b11805c94048acd058c93994b5bc74bb187f8d7e3b86a87df60e1601467f9","src/api/cmp/vertical.rs":"de3d62f38eba817299aa16f1e1939954c9a447e316509397465c2830852ba053","src/api/default.rs":"67bf21c134127d12a7028c8b88a57f0ceee8ccbd74976da8ca74eb9f16a174d5","src/api/fmt.rs":"67fb804bb86b6cd77cf8cd492b5733ce437071b66fe3297278b8a6552c325dda","src/api/fmt/binary.rs":"35cb5c266197d6224d598fb3d286e5fe48ef0c01ed356c2ff6fe9ba946f96a92","src/api/fmt/debug.rs":"aa18eea443bf353fea3db8b1a025132bbcaf91e747ecfa43b8d9fce9af395a0c","src/api/fmt/lower_hex.rs":"69d5be366631af309f214e8031c8c20267fcc27a695eac6f45c6bc1df72a67e6","src/api/fmt/octal.rs":"9eb11ba3d990213f3c7f1ec25edba7ce997cb1320e16d308c83498ba6b9bfbd9","src/api/fmt/upper_hex.rs":"a4637d085b7bb20e759ce58e08435b510a563ba3dd468af2b03560fdc5511562","src/api/from.rs":"2e599d8329cb05eaf06224cc441355c4b7b51254fc19256619333be8c149d444","src/api/from/from_array.rs":"dd3fc64fb17d6184bb60343f8da26a05edf0e5f3c14caf55d49fa15e21d948dc","src/api/from/from_vector.rs":"9764371aa9e6005aace74dea14f59e5611a095b7cf42707940924749282c52f0","src/api/hash.rs":"5076ece87969592c876486f5b1ea8affbeaec379d1a14a30859e0aa5592019de","src/api/into_bits.rs":"82297f0697d67b5a015e904e7e6e7b2a7066ba825bc54b94b4ff3e22d7a1eefb","src/api/into_bits/arch_specific.rs":"4acab22af90112072a2608fafc66fccf18cbf2e641b72af28404d30833cfe5c6","src/api/into_bits/macros.rs":"d762406de25aedff88d460dec7a80dc8e825a2a419d53218ce007efa6a1d3e04","src/api/into_bits/v128.rs":"3c502b9ce85bfcc727d6f053d49030b0ba9f46bd8e9fa5aa109382a2033f9f87","src/api/into_bits/v16.rs":"f4f4f61ba88aa51b158ec56ca3dce234349aea0daf2b3029a14ab5125d1e41e5","src/api/into_bits/v256.rs":"c24c3676707a0feb868dabe00766d74deab176794f905f79056337198c7cf790","src/api/into_bits/v32.rs":"905ba683d342fa32f4202b80bb46530807bd0a5b588f6c2e8c9f475223c47775","src/api/into_bits/v512.rs":"7cd89005215a9326eed8a742125dcbf981cba1aca72a313478eabf3df71b1160","src/api/into_bits/v64.rs":"d6238022ccff7b92e55b3f6017fc269acb6f36330a6d7e8fb389853a0f1b6478","src/api/math.rs":"8b2a2fc651917a850539f993aa0b9e5bf4da67b11685285b8de8cdca311719ec","src/api/math/float.rs":"61d2794d68262a1090ae473bd30793b5f65cf732f32a6694a3af2ce5d9225616","src/api/math/float/abs.rs":"5b6b2701e2e11135b7ce58a05052ea8120e10e4702c95d046b9d21b827b26bf8","src/api/math/float/consts.rs":"78acba000d3fa527111300b6327c1932de9c4c1e02d4174e1a5615c01463d38c","src/api/math/float/cos.rs":"4c2dd7173728ef189314f1576c9486e03be21b7da98843b2f9011282a7979e31","src/api/math/float/exp.rs":"7c6d5f1e304f498a01cfa23b92380c815d7da0ad94eae3483783bc377d287eef","src/api/math/float/ln.rs":"54c7583f3df793b39ff57534fade27b41bb992439e5dc178252f5ca3190a3e54","src/api/math/float/mul_add.rs":"62cac77660d20159276d4c9ef066eb90c81cbddb808e8e157182c607625ad2eb","src/api/math/float/mul_adde.rs":"bae056ee9f3a70df39ec3c3b2f6437c65303888a7b843ef1a5bcf1f5aca0e602","src/api/math/float/powf.rs":"9ddb938984b36d39d82a82f862f80df8f7fb013f1d222d45698d41d88472f568","src/api/math/float/recpre.rs":"589225794ff1dbf31158dff660e6d4509ecc8befbb57c633900dea5ac0b840d6","src/api/math/float/rsqrte.rs":"a32abdcc318d7ccc8448231f54d75b884b7cbeb03a7d595713ab6243036f4dbf","src/api/math/float/sin.rs":"cbd3622b7df74f19691743001c8cf747a201f8977ad90542fee915f37dcd1e49","src/api/math/float/sqrt.rs":"0c66d5d63fb08e4d99c6b82a8828e41173aff1ac9fa1a2764a11fac217ccf2ac","src/api/math/float/sqrte.rs":"731e1c9f321b662accdd27dacb3aac2e8043b7aecb2f2161dde733bd9f025362","src/api/minimal.rs":"1f22bcc528555444e76de569ec0ae2029b9ae9d04805efeafa93369c8098036b","src/api/minimal/iuf.rs":"819cff26d3e196f807645bcc1d79eb27d9f175edb89910f2274d52a1e913cd11","src/api/minimal/mask.rs":"0cae10ae1fc65f5070e686c0c79bfba27b86b33d6c399367bd4848fb367dcec4","src/api/minimal/ptr.rs":"f65ebf21866a863485344432d9a7a9b7418f7fad5fdf841a4e2fa56ec0766ad0","src/api/ops.rs":"3e273b277a0f3019d42c3c59ca94a5afd4885d5ae6d2182e5089bbeec9de42ee","src/api/ops/scalar_arithmetic.rs":"d2d5ad897a59dd0787544f927e0e7ca4072c3e58b0f4a2324083312b0d5a21d7","src/api/ops/scalar_bitwise.rs":"482204e459ca6be79568e1c9f70adbe2d2151412ddf122fb2161be8ebb51c40c","src/api/ops/scalar_mask_bitwise.rs":"c250f52042e37b22d57256c80d4604104cfd2fbe2a2e127c676267270ca5d350","src/api/ops/scalar_shifts.rs":"987f8fdebeedc16e3d77c1b732e7826ef70633c541d16dfa290845d5c6289150","src/api/ops/vector_arithmetic.rs":"ddca15d09ddeef502c2ed66117a62300ca65d87e959e8b622d767bdf1c307910","src/api/ops/vector_bitwise.rs":"b3968f7005b649edcc22a54e2379b14d5ee19045f2e784029805781ae043b5ee","src/api/ops/vector_float_min_max.rs":"76bf8cb607e2c442923c1da1061a6b80d742d607408033c2a3761161114cf2a0","src/api/ops/vector_int_min_max.rs":"a378789c6ff9b32a51fbd0a97ffd36ed102cd1fe6a067d2b02017c1df342def6","src/api/ops/vector_mask_bitwise.rs":"5052d18517d765415d40327e6e8e55a312daaca0a5e2aec959bfa54b1675f9c8","src/api/ops/vector_neg.rs":"5c62f6b0221983cdbd23cd0a3af3672e6ba1255f0dfe8b19aae6fbd6503e231b","src/api/ops/vector_rotates.rs":"03cbe8a400fd7c688e4ee771a990a6754f2031b1a59b19ae81158b21471167e5","src/api/ops/vector_shifts.rs":"9bf69d0087268f61009e39aea52e03a90f378910206b6a28e8393178b6a5d0e0","src/api/ptr.rs":"8a793251bed6130dcfb2f1519ceaa18b751bbb15875928d0fb6deb5a5e07523a","src/api/ptr/gather_scatter.rs":"138b02b0fa1fdd785b95fc7048488be7e3ef277e0bc6ac5affb26af6a11d41a6","src/api/reductions.rs":"ae5baca81352ecd44526d6c30c0a1feeda475ec73ddd3c3ec6b14e944e5448ee","src/api/reductions/bitwise.rs":"8bf910ae226188bd15fc7e125f058cd2566b6186fcd0cd8fd020f352c39ce139","src/api/reductions/float_arithmetic.rs":"3997125f87c7bac07fffda3a1d814e0e6c77ca83099546a9e2fb8dc92231129f","src/api/reductions/integer_arithmetic.rs":"47471da1c5f859489680bb5d34ced3d3aa20081c16053a3af121a4496fcb57bf","src/api/reductions/mask.rs":"db83327a950e33a317f37fd33ca4e20c347fb415975ec024f3e23da8509425af","src/api/reductions/min_max.rs":"d40ccad10220ae5982785015bef92e4b0749583c2b060cad0aa4f92d99491c3b","src/api/select.rs":"a98e2ccf9fc6bdeed32d337c8675bc96c2fbe2cc34fbf149ad6047fb8e749774","src/api/shuffle.rs":"6d1e5970b9fc8555a667c2924151070dd21584e81da8a9668d6bfe16f4a0db82","src/api/shuffle1_dyn.rs":"bfea5a91905b31444e9ef7ca6eddb7a9606b7e22d3f71bb842eb2795a0346620","src/api/slice.rs":"ee87484e8af329547b9a5d4f2a69e8bed6ea10bbd96270d706083843d4eea2ac","src/api/slice/from_slice.rs":"53691dc9958dec4180004a42d140552b405e8cd875caa282e89af378dd63c8bc","src/api/slice/write_to_slice.rs":"3dd2e511af43dc6fa911dd0b12f6f00323e0acd1202a01365db400557d52a89b","src/api/swap_bytes.rs":"4a6792a2e49a77475e1b237592b4b2804dbddb79c474331acd0dd71b36934259","src/codegen.rs":"a29d38fa0a85eaf787fb49989e625bf64effd5f39c126fbb2a24be206d2a3917","src/codegen/bit_manip.rs":"17ecebcff1f080e712fea5eb51602a73f4201ed56a198220342c8eb55bb92692","src/codegen/llvm.rs":"5bc6751293f9f184cf23d5df448c7d58b58b799e41c7a91f8ca41a5ba56e64ec","src/codegen/math.rs":"35f96e37a78fcf0cdb02146b7f27a45108fe06a37fc2a54d8851ce131a326178","src/codegen/math/float.rs":"dd86c0449e576c83b719700962ac017c332987fac08d91f2b7a2b1b883598170","src/codegen/math/float/abs.rs":"f56e2b4b8055ea861c1f5cbc6b6e1d8e7e5af163b62c13574ddee4e09513bfbc","src/codegen/math/float/cos.rs":"ef3b511a24d23045b310315e80348a9b7fedb576fc2de52d74290616a0abeb2a","src/codegen/math/float/cos_pi.rs":"4e7631a5d73dac21531e09ef1802d1180f8997509c2c8fa9f67f322194263a97","src/codegen/math/float/exp.rs":"61b691598c41b5622f24e4320c1bdd08701e612a516438bdddcc728fc3405c8c","src/codegen/math/float/ln.rs":"46b718b1ba8c9d99e1ad40f53d20dfde08a3063ca7bd2a9fdd6698e060da687e","src/codegen/math/float/macros.rs":"dd42135fff13f9aca4fd3a1a4e14c7e6c31aadc6d817d63b0d2fb9e62e062744","src/codegen/math/float/mul_add.rs":"a37bf764345d4b1714f97e83897b7cf0855fc2811704bcbc0012db91825339e1","src/codegen/math/float/mul_adde.rs":"c75702bfcb361de45964a93caf959a695ef2376bd069227600b8c6872665c755","src/codegen/math/float/powf.rs":"642346e982bc4c39203de0864d2149c4179cd7b21cf67a2951687932b4675872","src/codegen/math/float/sin.rs":"9d68164c90cdca6a85155040cdac42e27342ebe0b925273ef1593df721af4258","src/codegen/math/float/sin_cos_pi.rs":"9be02ad48585a1e8d99129382fbffbaed47852f15459256a708850b6b7a75405","src/codegen/math/float/sin_pi.rs":"9890347905b4d4a3c7341c3eb06406e46e60582bcf6960688bd727e5dadc6c57","src/codegen/math/float/sqrt.rs":"e3c60dcfb0c6d2fc62adabcc931b2d4040b83cab294dea36443fb4b89eb79e34","src/codegen/math/float/sqrte.rs":"f0f4ef9eb475ae41bcc7ec6a95ad744ba6b36925faa8b2c2814004396d196b63","src/codegen/pointer_sized_int.rs":"a70697169c28218b56fd2e8d5353f2e00671d1150d0c8cef77d613bdfacd84cb","src/codegen/reductions.rs":"645e2514746d01387ddd07f0aa4ffd8430cc9ab428d4fb13773ea319fa25dd95","src/codegen/reductions/mask.rs":"8f1afe6aabf096a3278e1fc3a30f736e04aa8b9ce96373cee22162d18cfe2702","src/codegen/reductions/mask/aarch64.rs":"cba6e17603d39795dcfe8339b6b7d8714c3e162a1f0a635979f037aa24fe4206","src/codegen/reductions/mask/arm.rs":"9447904818aa2c7c25d0963eead452a639a11ca7dbd6d21eedbfcaade07a0f33","src/codegen/reductions/mask/fallback.rs":"7a0ef9f7fd03ae318b495b95e121350cd61caffc5cc6ee17fabf130d5d933453","src/codegen/reductions/mask/fallback_impl.rs":"76547f396e55ef403327c77c314cf8db8c7a5c9b9819bfb925abeacf130249e5","src/codegen/reductions/mask/x86.rs":"4c0457b6276f9809223590092a4c77e73812330326cdabd28df06820de10a310","src/codegen/reductions/mask/x86/avx.rs":"b4913d87844c522903641cbbf10db4551addb1ce5e9e78278e21612fa65c733b","src/codegen/reductions/mask/x86/avx2.rs":"677aed3f056285285daa3adff8bc65e739630b4424defa6d9665e160f027507e","src/codegen/reductions/mask/x86/sse.rs":"5a827c6f8e1074e324f6e4c778942badb6c09d747a7142de01cadec1240b3428","src/codegen/reductions/mask/x86/sse2.rs":"bc38e6c31cb4b3d62147eba6cac264e519e2a48e0f7ce9010cfa9ef0cf0ec9fd","src/codegen/shuffle.rs":"99a0b52c2470097b028af134221099baba383446a01c7dc3ae560209880bcdb7","src/codegen/shuffle1_dyn.rs":"abbc95305dad815ab2ded3e8357791bcff080414668b55a4d397558a1d202d01","src/codegen/swap_bytes.rs":"1d6cdc716eadddc92b4fd506b2445a821caa8dc00860447de09d7ebd69c2087f","src/codegen/v128.rs":"94226b31ec403d18d9d2fe06713f147c9c79e9b5f9105089088266313f843185","src/codegen/v16.rs":"ddec4ffb66b6f7aaffb9a1780c5ddba82557abd74f45073d335047e04cf74924","src/codegen/v256.rs":"6b63917f0444118d6b1595bff2045e59b97c4d24012bd575f69f1f0efc5a0241","src/codegen/v32.rs":"3477b3c5540aed86e61e2f5807dd31db947413cec9181c587d93ed6ec74f0eba","src/codegen/v512.rs":"5854f99d3aabc4cd42b28a20d9ce447756dc2ba024a409a69b6a8ae1f1842fc5","src/codegen/v64.rs":"e9e89caebfe63d10c0cbca61e4dfdba3b7e02ee0989170f80beed23237ddd950","src/codegen/vPtr.rs":"711c753a08d53a2879c4fb87a0762c46ce4e34c22f0ca88d2e4c557a0f679969","src/codegen/vSize.rs":"eeee9858749aa82142b27bc120d1989bb74a6b82e1e4efbbeaccc9634dc9acfc","src/lib.rs":"41c2a5c5fb42225ce9c6a267653870fdb8af30f933b3b8534d57a15fb96ebb39","src/masks.rs":"be05e923ac58fe6eb61311561b5583cd306574f206dc09fe8e3c7de3dd0c1433","src/sealed.rs":"ae7fdeaf5d84cd7710ed730ca72ca7eaba93df6cb0acb183e5c0a7327acf197f","src/testing.rs":"1d3a7862ef625e235a5734ad7204e68d350f902c0695182b1f08a0552432416e","src/testing/macros.rs":"6378856d7a40ba5ec5c7c0dad6327d79f0c77266921c24296d10aed6c68e9b98","src/testing/utils.rs":"5ec6a47b836f364ec6dede19750a19eaac704162327d03041eb0f007d5f8d75c","src/v128.rs":"16cf9a8e7156b899ee9b9cd3f2dba9d13ec63289bea8c3ee9ae2e43ad9510288","src/v16.rs":"cb6465cf1e00bf530183af1819b9fe3d7eec978f8765d5e85d9b58a39a4b4045","src/v256.rs":"fe235017da18c7f3c361831c60e3173ad304d8ea1e95d64ebebc79da2d708511","src/v32.rs":"145d347855bac59b2de6508f9e594654e6c330423af9edc0e2ac8f4d1abdf45e","src/v512.rs":"f372f277f3e62eb5c945bb1c460333fdb17b6974fcc876633788ff53bded9599","src/v64.rs":"0b8079881b71575e3414be0b7f8f7eaba65281ba6732f2b2f61f73e95b6f48f7","src/vPtr.rs":"8b3e433d487180bb4304ff71245ecad90f0010f43e139a72027b672abe58facc","src/vSize.rs":"eda5aa020706cbf94d15bada41a0c2a35fc8f3f37cb7c2cd6f34d201399a495e","tests/endianness.rs":"7db22078f31fe1421fc2d21f2e6b9df5eb0bdc99c10f6985d3a74c0df8f205dc"},"package":null}
\ No newline at end of file
+{"files":{".appveyor.yml":"f1ed01850e0d725f9498f52a1a63ddf40702ad6e0bf5b2d7c4c04d76e96794a3",".travis.yml":"30a61a5ec53355fc1f3585e1690280308c2b7961701abc11e8389b235b647178","Cargo.toml":"2cab084b3d55d0b307788b02a6206a3ec39fee027535dc62d6421bce70e2e2c1","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"6485b8ed310d3f0340bf1ad1f47645069ce4069dcc6bb46c7d5c6faf41de1fdb","README.md":"fa4dd64f66972217d35b7653338c9e2011ccd8f3008ae7c0103272d4287f9b1d","bors.toml":"dee881dc69b9b7834e4eba5d95c3ed5a416d4628815a167d6a22d4cb4fb064b8","build.rs":"a766fba121243a9b617432c592873801adb74c3a2f4a24d9d45859b8ce9357fc","ci/all.sh":"2ae6b2445b4db83833e40b37efd0016c6b9879ee988b9b3ef94db5439a3e1606","ci/android-install-ndk.sh":"0f1746108cc30bf9b9ba45bcde7b19fc1a8bdf5b0258035b4eb8dc69b75efac4","ci/android-install-sdk.sh":"3490432022c5c8f5a115c084f7a9aca1626f96c0c87ffb62019228c4346b47e4","ci/android-sysimage.sh":"ebf4e5daa1f0fe1b2092b79f0f3f161c4c4275cb744e52352c4d81ab451e4c5a","ci/benchmark.sh":"b61d19ef6b90deba8fb79dee74c8b062d94844676293da346da87bb78a9a49a4","ci/deploy_and_run_on_ios_simulator.rs":"ec8ecf82d92072676aa47f0d1a3d021b60a7ae3531153ef12d2ff4541fc294dc","ci/docker/aarch64-linux-android/Dockerfile":"ace2e7d33c87bc0f6d3962a4a3408c04557646f7f51ab99cfbf574906796b016","ci/docker/aarch64-unknown-linux-gnu/Dockerfile":"da88c0d50f16dc08448c7fdf1fa5ed2cbe576acf9e7dd85b5b818621b2a8c702","ci/docker/arm-linux-androideabi/Dockerfile":"370e55d3330a413a3ccf677b3afb3e0ef9018a5fab263faa97ae8ac017fc2286","ci/docker/arm-unknown-linux-gnueabi/Dockerfile":"bb5f8ae890707c128652290ffc544447643bf12037ddd73c6ad6989f848cb380","ci/docker/arm-unknown-linux-gnueabihf/Dockerfile":"1afaefcbc05b740859acd4e067bc92439be6bcbe8f2e9678474fb434bcd398d9","ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile":"8282ea707a94109beed47a57574755e2d58401735904a03f85fb64c578c53b4f","ci/docker/i586-unknown-linux-gnu/Dockerfile":"49792922269f371bd29da4727e9085101b27be67a6b97755d0196c63317f7abb","ci/docker/i686-unknown-linux-gnu/Dockerfile":"49792922269f371bd29da4727e9085101b27be67a6b97755d0196c63317f7abb","ci/docker/mips-unknown-linux-gnu/Dockerfile":"b2ebc25797612c4f8395fe9d407725156044955bfbcf442036b7f55b43a5f9da","ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile":"b0c1692ac65bc56dd30494b1993d8e929c48cc9c4b92029b7c7592af6d4f9220","ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile":"4e9249c179300138141d0b2b7401b11897f64aed69f541f078c1db4594df2827","ci/docker/mipsel-unknown-linux-musl/Dockerfile":"3164c52b0dcbb01afa78292b15b5c43503ccf0491cf6eb801ec2bf22ae274e52","ci/docker/powerpc-unknown-linux-gnu/Dockerfile":"786f799d0b56eb54d7b6c4b00e1aed4ce81776e14e44767e083c89d014b72004","ci/docker/powerpc64-unknown-linux-gnu/Dockerfile":"e8bc363837cd9c2d8b22402acb8c1c329efc11ba5d12170603d2fe2eae9da059","ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile":"47998d45b781d797b9e6085ebe898d90de0c952b54537a8db4e8d7503eb032d9","ci/docker/s390x-unknown-linux-gnu/Dockerfile":"93fb44df3d7fd31ead158570667c97b5076a05c3d968af4a84bc13819a8f2db8","ci/docker/sparc64-unknown-linux-gnu/Dockerfile":"da1c39a3ff1fe22e41395fa7c8934e90b4c1788e551b9aec6e38bfd94effc437","ci/docker/thumbv7neon-linux-androideabi/Dockerfile":"c2decd5591bd7a09378901bef629cd944acf052eb55e4f35b79eb9cb4d62246a","ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile":"51955a8bf3c4d440f47382af6f5426ebff94ab01a04da36175babda9a057740f","ci/docker/wasm32-unknown-unknown/Dockerfile":"5a022299f56730cf8c432a07391e95e199cfa36dc8da2a96c9d185c8de93e913","ci/docker/x86_64-linux-android/Dockerfile":"685040273cf350d5509e580ac451555efa19790c8723ca2af066adadc6880ad2","ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile":"44b6203d9290bfdc53d81219f0937e1110847a23dd982ec8c4de388354f01536","ci/docker/x86_64-unknown-linux-gnu/Dockerfile":"7f4e3ca5fa288ea70edb4d1f75309708cd30b192e2e4444e61c4d5b3b58f89cf","ci/dox.sh":"434e9611c52e389312d2b03564adf09429f10cc76fe66a8644adb104903b87b7","ci/linux-s390x.sh":"d6b732d7795b4ba131326aff893bca6228a7d2eb0e9402f135705413dbbe0dce","ci/linux-sparc64.sh":"c92966838b1ab7ad3b7a344833ee726aba6b647cf5952e56f0ad1ba420b13325","ci/lld-shim.rs":"3d7f71ec23a49e2b67f694a0168786f9a954dda15f5a138815d966643fd3fcc3","ci/max_line_width.sh":"0a1518bba4c9ecaa55694cb2e9930d0e19c265baabf73143f17f9cf285aaa5bb","ci/run-docker.sh":"92e036390ad9b0d16f109579df1b5ced2e72e9afea40c7d011400ebd3a2a90de","ci/run.sh":"41dd6a60efaaeae9661a01370cce98b631f78392859a0cf68c946c0a16edf5f7","ci/run_examples.sh":"d1a23c6c35374a0678ba5114b9b8fefd8be0a79e774872a8bf0898d1baca18d0","ci/runtest-android.rs":"145a8e9799a5223975061fe7e586ade5669ee4877a7d7a4cf6b4ab48e8e36c7c","ci/setup_benchmarks.sh":"fae3960023f6f3d1388cd2ad22fdbab4b075f1f29dd4292d7994a20783beb6cf","ci/test-runner-linux":"c8aa6025cff5306f4f31d0c61dc5f9d4dd5a1d189ab613ef8d4c367c694d9ccd","contributing.md":"2d2629310ad4d464c482bdbb5819f0d6ce223c576aeef2cdce6a1f6857085ea5","perf-guide/.gitignore":"fe82c7da551079d832cf74200b0b359b4df9828cb4a0416fa7384f07a2ae6a13","perf-guide/book.toml":"115a98284126c6b180178b44713314cc494f08a71662ee2ce15cf67f17a51064","perf-guide/src/SUMMARY.md":"3e03bffc991fdc2050f3d51842d72d9d21ea6abab56a3baf3b2d5973a78b89e1","perf-guide/src/ascii.css":"29afb08833b2fe2250f0412e1fa1161a2432a0820a14953c87124407417c741a","perf-guide/src/bound_checks.md":"5e4991ff58a183ef0cd9fdc1feb4cd12d083b44bdf87393bbb0927808ef3ce7d","perf-guide/src/float-math/approx.md":"8c09032fa2d795a0c5db1775826c850d28eb2627846d0965c60ee72de63735ad","perf-guide/src/float-math/fma.md":"311076ba4b741d604a82e74b83a8d7e8c318fcbd7f64c4392d1cf5af95c60243","perf-guide/src/float-math/fp.md":"04153e775ab6e4f0d7837bcc515230d327b04edfa34c84ce9c9e10ebaeef2be8","perf-guide/src/float-math/svml.md":"0798873b8eedaeda5fed62dc91645b57c20775a02d3cd74d8bd06958f1516506","perf-guide/src/introduction.md":"9f5a19e9e6751f25d2daad39891a0cc600974527ec4c8305843f9618910671bd","perf-guide/src/prof/linux.md":"447731eb5de7d69166728fdbc5ecb0c0c9db678ea493b45a592d67dd002184c0","perf-guide/src/prof/mca.md":"f56d54f3d20e7aa4d32052186e8237b03d65971eb5d112802b442570ff11d344","perf-guide/src/prof/profiling.md":"8a650c0fd6ede0964789bb6577557eeef1d8226a896788602ce61528e260e43c","perf-guide/src/target-feature/attribute.md":"615f88dca0a707b6c416fa605435dd6e1fb5361cc639429cbf68cd87624bd78b","perf-guide/src/target-feature/features.md":"17077760ff24c006b606dd21889c53d87228f4311f3ba3a574f9afdeacd86165","perf-guide/src/target-feature/inlining.md":"7ed1d7068d8173a00d84c16cfe5871cd68b9f04f8d0cca2d01ebc84957ebf2f6","perf-guide/src/target-feature/practice.md":"c4b371842e0086df178488fec97f20def8f0c62ee588bcd25fd948b9b1fa227e","perf-guide/src/target-feature/runtime.md":"835425f5ee597fb3e51d36e725a81ebee29f4561231d19563cd4da81dbb1cfcb","perf-guide/src/target-feature/rustflags.md":"01197acf6f0adec8db32b8591811f69cecb6555a2b05dc5d5ec27d0e3f7b065e","perf-guide/src/vert-hor-ops.md":"c6211c0ee91e60552ec592d89d9d957eedc21dee3cbd89e1ad6765ea06a27471","rustfmt.toml":"d99a43f3f8ef9e425cf01c333fba9f0051f888f5d87ab4e8f63c2f7d0fe6620f","src/api.rs":"bb1795e9657a8298d37d2349b45443f08e9e455399ad4b727018600728478c10","src/api/bit_manip.rs":"c47a4d0f7451f7e35d07715e4f39a472e07457fd456fdb726864a4f6887252a3","src/api/bitmask.rs":"6d2beefd62ee5d9c8eb060bee6abc641616bf828c99f82abf97b21bf004e894b","src/api/cast.rs":"03b94a3d316ac7b7be7068810044911e965e889a0ace7bae762749ca74a92747","src/api/cast/macros.rs":"b0a14d0c83ad2ebb7a275180f6d9e3f2bc312ba57a7d3d6c39fad4e0f20f9408","src/api/cast/v128.rs":"edd0994efac4379dff26e178423a52dbb3ffeb38b1fc97cae975d744c00b4fb6","src/api/cast/v16.rs":"96bd98c2d21b0663abe6c0ab33005b1fa693f3db7ee6795351391343863484da","src/api/cast/v256.rs":"8c31fe91f5e78ef737dfba6979cc1240210cb094a89d284fe459bf8a991ca24b","src/api/cast/v32.rs":"a99a79dd84d2a5e6adf9db98705675915bd03fd1287d489c7fe38e84d7e4a086","src/api/cast/v512.rs":"c0dd526f41ed7b8a71c3743d91267554ec0a0c75834ccc2e3ecb0ef3004af642","src/api/cast/v64.rs":"6572fdba2a1241a6cd666d3f0cce3306cd2cb7e5e236172e59d5d4351c8a88af","src/api/cmp.rs":"357c3a2a09c6d4611c32dd7fa95be2fae933d513e229026ec9b44451a77b884e","src/api/cmp/eq.rs":"60f70f355bae4cb5b17db53204cacc3890f70670611c17df638d4c04f7cc8075","src/api/cmp/ord.rs":"589f7234761c294fa5df8f525bc4acd5a47cdb602207d524a0d4e19804cd9695","src/api/cmp/partial_eq.rs":"902ccb8aa01fd5738b30ba0b712669c21d4801958907e03bad23432c7dba0198","src/api/cmp/partial_ord.rs":"9db0c37d7434cdfc62d8d66912e972fa3d8c115ab2af051a6f45e414bd3e4f1c","src/api/cmp/vertical.rs":"de3d62f38eba817299aa16f1e1939954c9a447e316509397465c2830852ba053","src/api/default.rs":"67bf21c134127d12a7028c8b88a57f0ceee8ccbd74976da8ca74eb9f16a174d5","src/api/fmt.rs":"67fb804bb86b6cd77cf8cd492b5733ce437071b66fe3297278b8a6552c325dda","src/api/fmt/binary.rs":"02b2b287f7404f8a983813cf70c87108c8da3835578b63ab303116885f609413","src/api/fmt/debug.rs":"56e1c3bdc092747344fffaafff9da7163ee7827857f6fb7cb1c9923eca4f6fa0","src/api/fmt/lower_hex.rs":"558fd592f7f485712fb051509cecc7174a21e6bf62e5ce64766e75afc97bb8e1","src/api/fmt/octal.rs":"3b2e70877a4f368c7704f8e254236c014c365c74d93371c1feb5f030e6c66422","src/api/fmt/upper_hex.rs":"2a442f666bc80e22d41f903f881238fe114dd49344c3ed69849250e853cafc5d","src/api/from.rs":"2e599d8329cb05eaf06224cc441355c4b7b51254fc19256619333be8c149d444","src/api/from/from_array.rs":"dd3fc64fb17d6184bb60343f8da26a05edf0e5f3c14caf55d49fa15e21d948dc","src/api/from/from_vector.rs":"9764371aa9e6005aace74dea14f59e5611a095b7cf42707940924749282c52f0","src/api/hash.rs":"5076ece87969592c876486f5b1ea8affbeaec379d1a14a30859e0aa5592019de","src/api/into_bits.rs":"1ee15923352786b9ab4a31fa506762297116b18cfdb8e72853abc8ad001651d2","src/api/into_bits/arch_specific.rs":"e7445021f3908326bfee758835e5fc5ad56aa1baa77fc1c58abe4350c66c670a","src/api/into_bits/macros.rs":"bb4fe99be2af6a21d805efab44c8e4e61a7b2adb42a65504a0cf26d13efdadcd","src/api/into_bits/v128.rs":"145a44922b09a5ca5b62d88a461d327d399a997a15db4b11d7b17e554a9fa4c0","src/api/into_bits/v16.rs":"f4f4f61ba88aa51b158ec56ca3dce234349aea0daf2b3029a14ab5125d1e41e5","src/api/into_bits/v256.rs":"8cea9c5d9809f11323cb7cdc53b83df593fd17caf926251e412ae9777bed547f","src/api/into_bits/v32.rs":"905ba683d342fa32f4202b80bb46530807bd0a5b588f6c2e8c9f475223c47775","src/api/into_bits/v512.rs":"e25afa1fbf088a5d58e7d75d197b6cd4c56637ea28542ba18e46a451f29d04e7","src/api/into_bits/v64.rs":"d6238022ccff7b92e55b3f6017fc269acb6f36330a6d7e8fb389853a0f1b6478","src/api/math.rs":"8b2a2fc651917a850539f993aa0b9e5bf4da67b11685285b8de8cdca311719ec","src/api/math/float.rs":"61d2794d68262a1090ae473bd30793b5f65cf732f32a6694a3af2ce5d9225616","src/api/math/float/abs.rs":"5b6b2701e2e11135b7ce58a05052ea8120e10e4702c95d046b9d21b827b26bf8","src/api/math/float/consts.rs":"6302c9261da4291d144d5bb53493cdd073498feb40955fb6860ea3c4d06c978a","src/api/math/float/cos.rs":"4c2dd7173728ef189314f1576c9486e03be21b7da98843b2f9011282a7979e31","src/api/math/float/exp.rs":"7c6d5f1e304f498a01cfa23b92380c815d7da0ad94eae3483783bc377d287eef","src/api/math/float/ln.rs":"54c7583f3df793b39ff57534fade27b41bb992439e5dc178252f5ca3190a3e54","src/api/math/float/mul_add.rs":"62cac77660d20159276d4c9ef066eb90c81cbddb808e8e157182c607625ad2eb","src/api/math/float/mul_adde.rs":"bae056ee9f3a70df39ec3c3b2f6437c65303888a7b843ef1a5bcf1f5aca0e602","src/api/math/float/powf.rs":"9ddb938984b36d39d82a82f862f80df8f7fb013f1d222d45698d41d88472f568","src/api/math/float/recpre.rs":"589225794ff1dbf31158dff660e6d4509ecc8befbb57c633900dea5ac0b840d6","src/api/math/float/rsqrte.rs":"a32abdcc318d7ccc8448231f54d75b884b7cbeb03a7d595713ab6243036f4dbf","src/api/math/float/sin.rs":"cbd3622b7df74f19691743001c8cf747a201f8977ad90542fee915f37dcd1e49","src/api/math/float/sqrt.rs":"0c66d5d63fb08e4d99c6b82a8828e41173aff1ac9fa1a2764a11fac217ccf2ac","src/api/math/float/sqrte.rs":"731e1c9f321b662accdd27dacb3aac2e8043b7aecb2f2161dde733bd9f025362","src/api/minimal.rs":"1f22bcc528555444e76de569ec0ae2029b9ae9d04805efeafa93369c8098036b","src/api/minimal/iuf.rs":"819cff26d3e196f807645bcc1d79eb27d9f175edb89910f2274d52a1e913cd11","src/api/minimal/mask.rs":"0cae10ae1fc65f5070e686c0c79bfba27b86b33d6c399367bd4848fb367dcec4","src/api/minimal/ptr.rs":"f65ebf21866a863485344432d9a7a9b7418f7fad5fdf841a4e2fa56ec0766ad0","src/api/ops.rs":"3e273b277a0f3019d42c3c59ca94a5afd4885d5ae6d2182e5089bbeec9de42ee","src/api/ops/scalar_arithmetic.rs":"d2d5ad897a59dd0787544f927e0e7ca4072c3e58b0f4a2324083312b0d5a21d7","src/api/ops/scalar_bitwise.rs":"482204e459ca6be79568e1c9f70adbe2d2151412ddf122fb2161be8ebb51c40c","src/api/ops/scalar_mask_bitwise.rs":"c250f52042e37b22d57256c80d4604104cfd2fbe2a2e127c676267270ca5d350","src/api/ops/scalar_shifts.rs":"c4773d435c3f9da4454327e6fbb2b5b41a1c0ebb1cca7372e69dc7a344a1b6e4","src/api/ops/vector_arithmetic.rs":"ddca15d09ddeef502c2ed66117a62300ca65d87e959e8b622d767bdf1c307910","src/api/ops/vector_bitwise.rs":"b3968f7005b649edcc22a54e2379b14d5ee19045f2e784029805781ae043b5ee","src/api/ops/vector_float_min_max.rs":"76bf8cb607e2c442923c1da1061a6b80d742d607408033c2a3761161114cf2a0","src/api/ops/vector_int_min_max.rs":"a378789c6ff9b32a51fbd0a97ffd36ed102cd1fe6a067d2b02017c1df342def6","src/api/ops/vector_mask_bitwise.rs":"5052d18517d765415d40327e6e8e55a312daaca0a5e2aec959bfa54b1675f9c8","src/api/ops/vector_neg.rs":"5c62f6b0221983cdbd23cd0a3af3672e6ba1255f0dfe8b19aae6fbd6503e231b","src/api/ops/vector_rotates.rs":"ee319eaaa449dc50ea8ef05b89d38519c6faa6753dfdce432ea7bb8520e4e8e7","src/api/ops/vector_shifts.rs":"e510be14127c0ffd58a2573a39701da3557d66bedec09837ac8bbd44d579da00","src/api/ptr.rs":"8a793251bed6130dcfb2f1519ceaa18b751bbb15875928d0fb6deb5a5e07523a","src/api/ptr/gather_scatter.rs":"3d614f9d5b4ca201a9f7e46af4405e1d2c28ecee1620297c23b52e37b92cc0ea","src/api/reductions.rs":"ae5baca81352ecd44526d6c30c0a1feeda475ec73ddd3c3ec6b14e944e5448ee","src/api/reductions/bitwise.rs":"8bf910ae226188bd15fc7e125f058cd2566b6186fcd0cd8fd020f352c39ce139","src/api/reductions/float_arithmetic.rs":"47a5679896db2cbb56c31372fe42143da015b6beae7db5d2f3a0309ddf427ae1","src/api/reductions/integer_arithmetic.rs":"c2df3cf7493cca4174f2c65aea422a3d20d8a23af03f8d57cef72c19fee8f20d","src/api/reductions/mask.rs":"db83327a950e33a317f37fd33ca4e20c347fb415975ec024f3e23da8509425af","src/api/reductions/min_max.rs":"6af8c9aa45c69961b1b6fc205395f4767d4421869fb105fb3d563c5605fc13cd","src/api/select.rs":"6b07e7e8026df561f7307221a896f0fbb272536f41b9109040ac094c24c69331","src/api/shuffle.rs":"26458aec2557bfab41b7765f72aefbff3a7ee08cdc689981a81f133f58ee368b","src/api/shuffle1_dyn.rs":"bfea5a91905b31444e9ef7ca6eddb7a9606b7e22d3f71bb842eb2795a0346620","src/api/slice.rs":"ee87484e8af329547b9a5d4f2a69e8bed6ea10bbd96270d706083843d4eea2ac","src/api/slice/from_slice.rs":"9b6f01ace2d12ef45c84608bb7aad3a122e2cc319b2d99170fc332a568b8de63","src/api/slice/write_to_slice.rs":"244b6bd6ccffa6e5a195f8b1abc66d94251b6d16b2ec3fe4d76d32caec68261e","src/api/swap_bytes.rs":"4a6792a2e49a77475e1b237592b4b2804dbddb79c474331acd0dd71b36934259","src/codegen.rs":"db4f232fb9f5728db310b87dc8c4733be48afacab1053798c06106bef9a42b05","src/codegen/bit_manip.rs":"525ea6ff7ad1e043b6f6136992166f1803ed5563b7f6fc292c1c40257d20e264","src/codegen/llvm.rs":"b4ccbc0bad90038f00fc3c158736462d01d0053df3afa00f9169e67d1a264444","src/codegen/math.rs":"dfcf02ad34e2fdfe22c3f1cc2822001cc895e65031b4d06e585e5047839febb7","src/codegen/math/float.rs":"2c1cbce155bc527ce34d472c0fef6bc3dadb79cd7a357dd7aa5b1ebeb1d77a13","src/codegen/math/float/abs.rs":"d5aaadcf540bdb9b4264dca6471a255fd7bf509e763bef0239c0144a68466fea","src/codegen/math/float/cos.rs":"17f28d2900c852dca221fa9c92a9cd5fe7fd2df8d427bbc60216c749b2be013d","src/codegen/math/float/cos_pi.rs":"dbaf9f443f9846a491d4ec52210a7b5835dd593b03366e3135b05c37d70f9d6c","src/codegen/math/float/exp.rs":"d300058a4bcc7ae7976f216f81902cd73a9e603ad63880dff3bbc866c27a9f37","src/codegen/math/float/ln.rs":"c851e211e43f8256093ba75b03ae0c307c9962ee66d94f09b4dd80068190cbdf","src/codegen/math/float/macros.rs":"fc9924869ed85e4795983af228cacf23158f4f35919adce16c920ad4a3f0a009","src/codegen/math/float/mul_add.rs":"041a5b69d5991d93ef795351b17560c10faf80b78fd26ad7df42a239b32cf9de","src/codegen/math/float/mul_adde.rs":"d71d5f0f3333b62a7439b823cb7adf5340ea1555ce820fb4a3f4cb922f73f5f5","src/codegen/math/float/powf.rs":"9742c3877f1a5509ca5c9492a40884b6579ba6dd11c26b7112e63f70666b395d","src/codegen/math/float/sin.rs":"0e9868d35531566509f3a01d85d5253045eb4afa8525d8407dcc1f5f33c56036","src/codegen/math/float/sin_cos_pi.rs":"8e6b6142d7dd240cdb36669722e82ab9810a2261e86e659f7d97a942ad8b1258","src/codegen/math/float/sin_pi.rs":"bb6d39db8f921e03a301fc5206ac1a61a97def8a2cb83b87ccf189f3fc48d548","src/codegen/math/float/sqrt.rs":"e6ebb0c5f428efad1f672b9a8fe4e58534dbf1ea5a8fe092ce5ce76b52fe89cb","src/codegen/math/float/sqrte.rs":"23acfaea38d0e081a6d9021c1094e813d0cfd12c58c1eca9662aade5e625d51c","src/codegen/pointer_sized_int.rs":"6ca13c214b6cf7e0929dbe18e96a16fc0bb7d8799608df29c4c8115490f99e01","src/codegen/reductions.rs":"8eb18ebac76985d2aa30262a2edd8cb004230b511a765d657525f677a585c12c","src/codegen/reductions/mask.rs":"e67f35a1f4d156a4894a2d6ea5a935b4d898cf70eefb2715f5c1cc165e776c11","src/codegen/reductions/mask/aarch64.rs":"84b101c17cad1ede4eb6d38cada0ac7da239dba8cea3badd3829b967e558431f","src/codegen/reductions/mask/arm.rs":"aaa07129bd078ae7e677cf8b8e67ec9f30536606a0c7ed1baaa18fd1793bb218","src/codegen/reductions/mask/fallback.rs":"3eb9319d2c7cf19216b607b8459612c4e027b643cf11b036937d36896bf76786","src/codegen/reductions/mask/fallback_impl.rs":"76547f396e55ef403327c77c314cf8db8c7a5c9b9819bfb925abeacf130249e5","src/codegen/reductions/mask/x86.rs":"36dcd8af4ab99730a078ed113d3955f74eb1a2876e2e6d9f224e0ff462c216d1","src/codegen/reductions/mask/x86/avx.rs":"3a40868b38c86e35aefb96d7578de6322efe89d8135e0366359b54ddd06f861a","src/codegen/reductions/mask/x86/avx2.rs":"677aed3f056285285daa3adff8bc65e739630b4424defa6d9665e160f027507e","src/codegen/reductions/mask/x86/sse.rs":"8522f6ed03f6c32dd577d4298df477c08aeaaa38563706f29096e1911ed731f2","src/codegen/reductions/mask/x86/sse2.rs":"54ec56e49b0c6841eccb719e4f310d65fe767c04136b2ec20bd8b9d7d9897b9e","src/codegen/shuffle.rs":"1ec2930f4e1acc43ac30b518af298d466a79e9e75734a51c380b7810efd1a27f","src/codegen/shuffle1_dyn.rs":"3f13ca1597378758d05106bf5ff3715eee531f3cb6d88f48b9182bd6c9386b51","src/codegen/swap_bytes.rs":"c67c86e91ca3fc77539e0efcea081a3c62548cccf503963ae408f2e86f4e6a21","src/codegen/v128.rs":"94226b31ec403d18d9d2fe06713f147c9c79e9b5f9105089088266313f843185","src/codegen/v16.rs":"ddec4ffb66b6f7aaffb9a1780c5ddba82557abd74f45073d335047e04cf74924","src/codegen/v256.rs":"6b63917f0444118d6b1595bff2045e59b97c4d24012bd575f69f1f0efc5a0241","src/codegen/v32.rs":"3477b3c5540aed86e61e2f5807dd31db947413cec9181c587d93ed6ec74f0eba","src/codegen/v512.rs":"5854f99d3aabc4cd42b28a20d9ce447756dc2ba024a409a69b6a8ae1f1842fc5","src/codegen/v64.rs":"e9e89caebfe63d10c0cbca61e4dfdba3b7e02ee0989170f80beed23237ddd950","src/codegen/vPtr.rs":"f0753b405cdc865bdf8e82c6505f299ea1f96136239ebbaf7f9ce93d310764b8","src/codegen/vSize.rs":"c89f5fdeb28ac4c8272ed1816fce03d9d95308cc32bb2533bd8b20cd5ac102ac","src/lib.rs":"b6f846d5d30cf6b035a2d18039aba7b2045cf89384733d643572bd68873ae064","src/masks.rs":"70fc0abe4c2907ce2a491c574e1cfb9f3423385da2e1a923a48c9c13f8ba6ed8","src/sealed.rs":"ae7fdeaf5d84cd7710ed730ca72ca7eaba93df6cb0acb183e5c0a7327acf197f","src/testing.rs":"896669c08d8c801448a4d2fadc9d633eda0fbe879d229997e2a182e31278e469","src/testing/macros.rs":"403bbc5ecb7c786fe36156df302d0c07a8122408dbb15f7474d7682224ba1106","src/testing/utils.rs":"41912a92266dfe884647fc035e4242fd746100df8e839808ae0397af3759a3c8","src/v128.rs":"16cf9a8e7156b899ee9b9cd3f2dba9d13ec63289bea8c3ee9ae2e43ad9510288","src/v16.rs":"cb6465cf1e00bf530183af1819b9fe3d7eec978f8765d5e85d9b58a39a4b4045","src/v256.rs":"fe235017da18c7f3c361831c60e3173ad304d8ea1e95d64ebebc79da2d708511","src/v32.rs":"145d347855bac59b2de6508f9e594654e6c330423af9edc0e2ac8f4d1abdf45e","src/v512.rs":"f372f277f3e62eb5c945bb1c460333fdb17b6974fcc876633788ff53bded9599","src/v64.rs":"0b8079881b71575e3414be0b7f8f7eaba65281ba6732f2b2f61f73e95b6f48f7","src/vPtr.rs":"8b3e433d487180bb4304ff71245ecad90f0010f43e139a72027b672abe58facc","src/vSize.rs":"eda5aa020706cbf94d15bada41a0c2a35fc8f3f37cb7c2cd6f34d201399a495e","tests/endianness.rs":"2783d727e8ff8789211e03120634cd3ad9f8972fc484012681b5b63cf89408a7"},"package":null}
\ No newline at end of file
diff --git a/third_party/rust/packed_simd/.travis.yml b/third_party/rust/packed_simd_2/.travis.yml
similarity index 86%
rename from third_party/rust/packed_simd/.travis.yml
rename to third_party/rust/packed_simd_2/.travis.yml
index be3fb2369341..0ffc06afdda7 100644
--- a/third_party/rust/packed_simd/.travis.yml
+++ b/third_party/rust/packed_simd_2/.travis.yml
@@ -20,9 +20,6 @@ jobs:
     - env: TARGET=arm-linux-androideabi
       name: "arm-linux-androideabi"
       stage: build-test-verify
-    - env: TARGET=arm-linux-androideabi RUSTFLAGS="-C target-feature=+v7,+neon"
-      name: "arm-linux-androideabi + NEON"
-      stage: build-test-verify
     - name: "aarch64-unknown-linux-android + NEON"
       env: TARGET=aarch64-linux-android RUSTFLAGS="-C target-feature=+neon"
       stage: build-test-verify
@@ -50,21 +47,13 @@ jobs:
       stage: 32bit-tier1
     - env: TARGET=x86_64-unknown-linux-gnu RUSTFLAGS="-C target-feature=+sse4.2"
       name: "x86_64-unknown-linux-gnu + SSE4.2"
-      install: rustup component add rustfmt-preview
       stage: build-test-verify
     - env: TARGET=x86_64-unknown-linux-gnu RUSTFLAGS="-C target-feature=+avx2"
       name: "x86_64-unknown-linux-gnu + AVX2"
-      install: rustup component add rustfmt-preview
-      stage: build-test-verify
-    - env: TARGET=arm-unknown-linux-gnueabi RUSTFLAGS="-C target-feature=+v7,+neon"
-      name: "arm-unknown-linux-gnueabi + NEON"
       stage: build-test-verify
     - env: TARGET=arm-unknown-linux-gnueabihf
       name: "arm-unknown-linux-gnueabihf"
       stage: build-test-verify
-    - env: TARGET=arm-unknown-linux-gnueabihf RUSTFLAGS="-C target-feature=+v7,+neon"
-      name: "arm-unknown-linux-gnueabihf + NEON"
-      stage: build-test-verify
     - env: TARGET=armv7-unknown-linux-gnueabihf
       name: "armv7-unknown-linux-gnueabihf"
       stage: build-test-verify
@@ -181,16 +170,8 @@ jobs:
     - name: "rustfmt"
       install: true
       script: |
-        if rustup component add rustfmt-preview ; then
-            ci/all.sh check_fmt || true
-        fi
-      stage: tools
-    - name: "clippy"
-      install: true
-      script: |
-        if rustup component add clippy-preview ; then
-            ci/all.sh clippy
-        fi
+        rustup toolchain install nightly -c rustfmt --allow-downgrade
+        ci/all.sh check_fmt || true
       stage: tools
 
   allow_failures:
@@ -213,14 +194,6 @@ jobs:
     # Is this related to the above? Mysterious test failure
     - name: "aarch64-apple-ios + NEON"
 
-    # FIXME: https://github.com/rust-lang-nursery/packed_simd/issues/182
-    - env: TARGET=arm-unknown-linux-gnueabi RUSTFLAGS="-C target-feature=+v7,+neon"
-    - env: TARGET=arm-unknown-linux-gnueabihf RUSTFLAGS="-C target-feature=+v7,+neon"
-    - env: TARGET=armv7-unknown-linux-gnueabihf RUSTFLAGS="-C target-feature=+neon"
-
-    # FIXME: https://github.com/rust-lang-nursery/packed_simd/issues/183
-    - env: TARGET=wasm32-unknown-unknown
-
 install: travis_retry rustup target add $TARGET
 before_script: cargo generate-lockfile
 script: travis_wait 50 ci/run-docker.sh
diff --git a/third_party/rust/packed_simd/Cargo.toml b/third_party/rust/packed_simd_2/Cargo.toml
similarity index 50%
rename from third_party/rust/packed_simd/Cargo.toml
rename to third_party/rust/packed_simd_2/Cargo.toml
index 1e52297b7ec8..d3d07ef9ae97 100644
--- a/third_party/rust/packed_simd/Cargo.toml
+++ b/third_party/rust/packed_simd_2/Cargo.toml
@@ -1,37 +1,36 @@
 [package]
-name = "packed_simd"
-version = "0.3.4"
-authors = ["Gonzalo Brito Gadeschi <gonzalobg88@gmail.com>"]
+name = "packed_simd_2"
+version = "0.3.8"
 description = "Portable Packed SIMD vectors"
 documentation = "https://docs.rs/crate/packed_simd/"
-homepage = "https://github.com/rust-lang-nursery/packed_simd"
-repository = "https://github.com/rust-lang-nursery/packed_simd"
+homepage = "https://github.com/rust-lang/packed_simd"
+repository = "https://github.com/rust-lang/packed_simd"
 keywords = ["simd", "vector", "portability"]
 categories = ["hardware-support", "concurrency", "no-std", "data-structures"]
-license = "MIT/Apache-2.0"
+license = "MIT OR Apache-2.0"
 build = "build.rs"
 edition = "2018"
 
 [badges]
-appveyor = { repository = "rust-lang-nursery/packed_simd" }
-travis-ci = { repository = "rust-lang-nursery/packed_simd" }
-codecov = { repository = "rust-lang-nursery/packed_simd" }
-is-it-maintained-issue-resolution = { repository = "rust-lang-nursery/packed_simd" }
-is-it-maintained-open-issues = { repository = "rust-lang-nursery/packed_simd" }
+appveyor = { repository = "rust-lang/packed_simd" }
+travis-ci = { repository = "rust-lang/packed_simd" }
+codecov = { repository = "rust-lang/packed_simd" }
+is-it-maintained-issue-resolution = { repository = "rust-lang/packed_simd" }
+is-it-maintained-open-issues = { repository = "rust-lang/packed_simd" }
 maintenance = { status = "experimental" }
 
 [dependencies]
-cfg-if = "0.1.10"
+cfg-if = "1.0.0"
 core_arch = { version = "0.1.5", optional = true }
 
+[build-dependencies]
+rustc_version = "0.4"
+
 [features]
 default = []
 into_bits = []
 libcore_neon = []
 
-[build-dependencies]
-rustc_version = "0.2"
-
 [dev-dependencies]
 paste = "^0.1.3"
 arrayvec = { version = "^0.5", default-features = false }
@@ -41,5 +40,6 @@ version = "0.1.2"
 optional = true
 
 [target.wasm32-unknown-unknown.dev-dependencies]
-wasm-bindgen = "=0.2.52"
-wasm-bindgen-test = "=0.3.2"
+# Keep in sync with the version on Dockerfile.
+wasm-bindgen = "=0.2.73"
+wasm-bindgen-test = "=0.3.23"
diff --git a/third_party/rust/packed_simd/LICENSE-APACHE b/third_party/rust/packed_simd_2/LICENSE-APACHE
similarity index 100%
rename from third_party/rust/packed_simd/LICENSE-APACHE
rename to third_party/rust/packed_simd_2/LICENSE-APACHE
diff --git a/third_party/rust/packed_simd/LICENSE-MIT b/third_party/rust/packed_simd_2/LICENSE-MIT
similarity index 100%
rename from third_party/rust/packed_simd/LICENSE-MIT
rename to third_party/rust/packed_simd_2/LICENSE-MIT
diff --git a/third_party/rust/packed_simd/README.md b/third_party/rust/packed_simd_2/README.md
similarity index 85%
rename from third_party/rust/packed_simd/README.md
rename to third_party/rust/packed_simd_2/README.md
index ad4f3f27093f..eb3101c33d15 100644
--- a/third_party/rust/packed_simd/README.md
+++ b/third_party/rust/packed_simd_2/README.md
@@ -1,11 +1,24 @@
+# The Crates.io Version Can No Longer Be Updated!
+
+The original maintainer is out of contact, and the new maintainers (the Portable SIMD Project Group) do not have the appropriate crates.io permissions to issue updates.
+
+We are aware that the version available on crates.io is currently broken, and will not build.
+
+If you need to continue to use the crate, we have published a "next version" under an alternative name.
+
+Adjust your `[dependencies]` section of `Cargo.toml` to be the following:
+```toml
+packed_simd = { version = "0.3.8", package = "packed_simd_2" }
+```
+
 # `Simd<[T; N]>`
 
 ## Implementation of [Rust RFC #2366: `std::simd`][rfc2366]
 
-[![Travis-CI Status]][travis] [![Appveyor Status]][appveyor] [![Latest Version]][crates.io] [![docs]][master_docs]
+[![Travis-CI Status]][travis] <!-- [![Appveyor Status]][appveyor] --> [![Latest Version]][crates.io] [![docs]][master_docs]
 
 **WARNING**: this crate only supports the most recent nightly Rust toolchain
-and will be superceded by [stdsimd](https://github.com/rust-lang/stdsimd).
+and will be superseded by [stdsimd](https://github.com/rust-lang/stdsimd).
 
 ## Documentation
 
@@ -129,15 +142,15 @@ Unless you explicitly state otherwise, any contribution intentionally submitted
 for inclusion in `packed_simd` by you, as defined in the Apache-2.0 license, shall be
 dual licensed as above, without any additional terms or conditions.
 
-[travis]: https://travis-ci.com/rust-lang-nursery/packed_simd
-[Travis-CI Status]: https://travis-ci.com/rust-lang-nursery/packed_simd.svg?branch=master
+[travis]: https://travis-ci.com/rust-lang/packed_simd
+[Travis-CI Status]: https://travis-ci.com/rust-lang/packed_simd.svg?branch=master
 [appveyor]: https://ci.appveyor.com/project/gnzlbg/packed-simd
 [Appveyor Status]: https://ci.appveyor.com/api/projects/status/hd7v9dvr442hgdix?svg=true
-[Latest Version]: https://img.shields.io/crates/v/packed_simd.svg
-[crates.io]: https://crates.io/crates/packed_simd
-[docs]: https://docs.rs/packed_simd/badge.svg
-[docs.rs]: https://docs.rs/packed_simd/
-[master_docs]: https://rust-lang-nursery.github.io/packed_simd/packed_simd/
+[Latest Version]: https://img.shields.io/crates/v/packed_simd_2.svg
+[crates.io]: https://crates.io/crates/packed_simd_2
+[docs]: https://docs.rs/packed_simd_2/badge.svg
+[docs.rs]: https://docs.rs/packed_simd_2
+[master_docs]: https://rust-lang-nursery.github.io/packed_simd/packed_simd_2/
 [perf_guide]: https://rust-lang-nursery.github.io/packed_simd/perf-guide/
 [rfc2366]: https://github.com/rust-lang/rfcs/pull/2366
 [ISPC]: https://ispc.github.io/
diff --git a/third_party/rust/packed_simd/bors.toml b/third_party/rust/packed_simd_2/bors.toml
similarity index 100%
rename from third_party/rust/packed_simd/bors.toml
rename to third_party/rust/packed_simd_2/bors.toml
diff --git a/third_party/rust/packed_simd_2/build.rs b/third_party/rust/packed_simd_2/build.rs
new file mode 100644
index 000000000000..afdee9f55b62
--- /dev/null
+++ b/third_party/rust/packed_simd_2/build.rs
@@ -0,0 +1,11 @@
+use rustc_version::{version, Version};
+
+fn main() {
+    let target = std::env::var("TARGET").expect("TARGET environment variable not defined");
+    if target.contains("neon") {
+        println!("cargo:rustc-cfg=libcore_neon");
+    }
+    if version().unwrap() < Version::parse("1.61.0-alpha").unwrap() {
+        println!("cargo:rustc-cfg=aarch64_target_feature");
+    }
+}
diff --git a/third_party/rust/packed_simd/ci/all.sh b/third_party/rust/packed_simd_2/ci/all.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/all.sh
rename to third_party/rust/packed_simd_2/ci/all.sh
diff --git a/third_party/rust/packed_simd/ci/android-install-ndk.sh b/third_party/rust/packed_simd_2/ci/android-install-ndk.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/android-install-ndk.sh
rename to third_party/rust/packed_simd_2/ci/android-install-ndk.sh
diff --git a/third_party/rust/packed_simd/ci/android-install-sdk.sh b/third_party/rust/packed_simd_2/ci/android-install-sdk.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/android-install-sdk.sh
rename to third_party/rust/packed_simd_2/ci/android-install-sdk.sh
diff --git a/third_party/rust/packed_simd/ci/android-sysimage.sh b/third_party/rust/packed_simd_2/ci/android-sysimage.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/android-sysimage.sh
rename to third_party/rust/packed_simd_2/ci/android-sysimage.sh
diff --git a/third_party/rust/packed_simd/ci/benchmark.sh b/third_party/rust/packed_simd_2/ci/benchmark.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/benchmark.sh
rename to third_party/rust/packed_simd_2/ci/benchmark.sh
diff --git a/third_party/rust/packed_simd/ci/deploy_and_run_on_ios_simulator.rs b/third_party/rust/packed_simd_2/ci/deploy_and_run_on_ios_simulator.rs
similarity index 100%
rename from third_party/rust/packed_simd/ci/deploy_and_run_on_ios_simulator.rs
rename to third_party/rust/packed_simd_2/ci/deploy_and_run_on_ios_simulator.rs
diff --git a/third_party/rust/packed_simd/ci/docker/aarch64-linux-android/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/aarch64-linux-android/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/aarch64-linux-android/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/aarch64-linux-android/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/aarch64-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/aarch64-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/aarch64-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/aarch64-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/arm-linux-androideabi/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/arm-linux-androideabi/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/arm-linux-androideabi/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/arm-linux-androideabi/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/arm-unknown-linux-gnueabi/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/arm-unknown-linux-gnueabi/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/arm-unknown-linux-gnueabi/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/arm-unknown-linux-gnueabi/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/i586-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/i586-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/i586-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/i586-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/i686-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/i686-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/i686-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/i686-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/mips-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/mips-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/mips-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/mips-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/mipsel-unknown-linux-musl/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/mipsel-unknown-linux-musl/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/mipsel-unknown-linux-musl/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/mipsel-unknown-linux-musl/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/powerpc-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/powerpc-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/powerpc-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/powerpc-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/s390x-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/s390x-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/s390x-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/s390x-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/sparc64-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/sparc64-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/sparc64-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/sparc64-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/thumbv7neon-linux-androideabi/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/thumbv7neon-linux-androideabi/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/thumbv7neon-linux-androideabi/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/thumbv7neon-linux-androideabi/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/wasm32-unknown-unknown/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/wasm32-unknown-unknown/Dockerfile
similarity index 77%
rename from third_party/rust/packed_simd/ci/docker/wasm32-unknown-unknown/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/wasm32-unknown-unknown/Dockerfile
index f905cf1a36eb..bd97170bc7e8 100644
--- a/third_party/rust/packed_simd/ci/docker/wasm32-unknown-unknown/Dockerfile
+++ b/third_party/rust/packed_simd_2/ci/docker/wasm32-unknown-unknown/Dockerfile
@@ -17,14 +17,15 @@ RUN make -C wabt -j$(nproc)
 ENV PATH=$PATH:/wabt/bin
 
 # Install `wasm-bindgen-test-runner`
-RUN curl -L https://github.com/rustwasm/wasm-bindgen/releases/download/0.2.19/wasm-bindgen-0.2.19-x86_64-unknown-linux-musl.tar.gz \
+RUN curl -L https://github.com/rustwasm/wasm-bindgen/releases/download/0.2.73/wasm-bindgen-0.2.73-x86_64-unknown-linux-musl.tar.gz \
   | tar xzf -
-ENV PATH=$PATH:/wasm-bindgen-0.2.19-x86_64-unknown-linux-musl
+# Keep in sync with the version on Cargo.toml.
+ENV PATH=$PATH:/wasm-bindgen-0.2.73-x86_64-unknown-linux-musl
 ENV CARGO_TARGET_WASM32_UNKNOWN_UNKNOWN_RUNNER=wasm-bindgen-test-runner
 
 # Install `node`
-RUN curl https://nodejs.org/dist/v10.8.0/node-v10.8.0-linux-x64.tar.xz | tar xJf -
-ENV PATH=$PATH:/node-v10.8.0-linux-x64/bin
+RUN curl https://nodejs.org/dist/v14.16.0/node-v14.16.0-linux-x64.tar.xz | tar xJf -
+ENV PATH=$PATH:/node-v14.16.0-linux-x64/bin
 
 # We use a shim linker that removes `--strip-debug` when passed to LLD. While
 # this typically results in invalid debug information in release mode it doesn't
diff --git a/third_party/rust/packed_simd/ci/docker/x86_64-linux-android/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/x86_64-linux-android/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/x86_64-linux-android/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/x86_64-linux-android/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/x86_64-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/x86_64-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/x86_64-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/x86_64-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/dox.sh b/third_party/rust/packed_simd_2/ci/dox.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/dox.sh
rename to third_party/rust/packed_simd_2/ci/dox.sh
diff --git a/third_party/rust/packed_simd/ci/linux-s390x.sh b/third_party/rust/packed_simd_2/ci/linux-s390x.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/linux-s390x.sh
rename to third_party/rust/packed_simd_2/ci/linux-s390x.sh
diff --git a/third_party/rust/packed_simd/ci/linux-sparc64.sh b/third_party/rust/packed_simd_2/ci/linux-sparc64.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/linux-sparc64.sh
rename to third_party/rust/packed_simd_2/ci/linux-sparc64.sh
diff --git a/third_party/rust/packed_simd/ci/lld-shim.rs b/third_party/rust/packed_simd_2/ci/lld-shim.rs
similarity index 100%
rename from third_party/rust/packed_simd/ci/lld-shim.rs
rename to third_party/rust/packed_simd_2/ci/lld-shim.rs
diff --git a/third_party/rust/packed_simd/ci/max_line_width.sh b/third_party/rust/packed_simd_2/ci/max_line_width.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/max_line_width.sh
rename to third_party/rust/packed_simd_2/ci/max_line_width.sh
diff --git a/third_party/rust/packed_simd/ci/run-docker.sh b/third_party/rust/packed_simd_2/ci/run-docker.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/run-docker.sh
rename to third_party/rust/packed_simd_2/ci/run-docker.sh
diff --git a/third_party/rust/packed_simd/ci/run.sh b/third_party/rust/packed_simd_2/ci/run.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/run.sh
rename to third_party/rust/packed_simd_2/ci/run.sh
diff --git a/third_party/rust/packed_simd/ci/run_examples.sh b/third_party/rust/packed_simd_2/ci/run_examples.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/run_examples.sh
rename to third_party/rust/packed_simd_2/ci/run_examples.sh
diff --git a/third_party/rust/packed_simd/ci/runtest-android.rs b/third_party/rust/packed_simd_2/ci/runtest-android.rs
similarity index 100%
rename from third_party/rust/packed_simd/ci/runtest-android.rs
rename to third_party/rust/packed_simd_2/ci/runtest-android.rs
diff --git a/third_party/rust/packed_simd/ci/setup_benchmarks.sh b/third_party/rust/packed_simd_2/ci/setup_benchmarks.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/setup_benchmarks.sh
rename to third_party/rust/packed_simd_2/ci/setup_benchmarks.sh
diff --git a/third_party/rust/packed_simd/ci/test-runner-linux b/third_party/rust/packed_simd_2/ci/test-runner-linux
similarity index 100%
rename from third_party/rust/packed_simd/ci/test-runner-linux
rename to third_party/rust/packed_simd_2/ci/test-runner-linux
diff --git a/third_party/rust/packed_simd/contributing.md b/third_party/rust/packed_simd_2/contributing.md
similarity index 99%
rename from third_party/rust/packed_simd/contributing.md
rename to third_party/rust/packed_simd_2/contributing.md
index 93fa92783740..79af8c199e8f 100644
--- a/third_party/rust/packed_simd/contributing.md
+++ b/third_party/rust/packed_simd_2/contributing.md
@@ -35,7 +35,7 @@ If LLVM is indeed the cause, the issue will be reported upstream to the
 ## Submitting Pull Requests
 
 New code is submitted to the crate using GitHub's [pull request] mechanism.
-You should first fork this repository, make your changes (preferrably in a new
+You should first fork this repository, make your changes (preferably in a new
 branch), then use GitHub's web UI to create a new PR.
 
 [pull request]: https://help.github.com/articles/about-pull-requests/
diff --git a/third_party/rust/packed_simd/perf-guide/.gitignore b/third_party/rust/packed_simd_2/perf-guide/.gitignore
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/.gitignore
rename to third_party/rust/packed_simd_2/perf-guide/.gitignore
diff --git a/third_party/rust/packed_simd/perf-guide/book.toml b/third_party/rust/packed_simd_2/perf-guide/book.toml
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/book.toml
rename to third_party/rust/packed_simd_2/perf-guide/book.toml
diff --git a/third_party/rust/packed_simd/perf-guide/src/SUMMARY.md b/third_party/rust/packed_simd_2/perf-guide/src/SUMMARY.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/SUMMARY.md
rename to third_party/rust/packed_simd_2/perf-guide/src/SUMMARY.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/ascii.css b/third_party/rust/packed_simd_2/perf-guide/src/ascii.css
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/ascii.css
rename to third_party/rust/packed_simd_2/perf-guide/src/ascii.css
diff --git a/third_party/rust/packed_simd/perf-guide/src/bound_checks.md b/third_party/rust/packed_simd_2/perf-guide/src/bound_checks.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/bound_checks.md
rename to third_party/rust/packed_simd_2/perf-guide/src/bound_checks.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/float-math/approx.md b/third_party/rust/packed_simd_2/perf-guide/src/float-math/approx.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/float-math/approx.md
rename to third_party/rust/packed_simd_2/perf-guide/src/float-math/approx.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/float-math/fma.md b/third_party/rust/packed_simd_2/perf-guide/src/float-math/fma.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/float-math/fma.md
rename to third_party/rust/packed_simd_2/perf-guide/src/float-math/fma.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/float-math/fp.md b/third_party/rust/packed_simd_2/perf-guide/src/float-math/fp.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/float-math/fp.md
rename to third_party/rust/packed_simd_2/perf-guide/src/float-math/fp.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/float-math/svml.md b/third_party/rust/packed_simd_2/perf-guide/src/float-math/svml.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/float-math/svml.md
rename to third_party/rust/packed_simd_2/perf-guide/src/float-math/svml.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/introduction.md b/third_party/rust/packed_simd_2/perf-guide/src/introduction.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/introduction.md
rename to third_party/rust/packed_simd_2/perf-guide/src/introduction.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/prof/linux.md b/third_party/rust/packed_simd_2/perf-guide/src/prof/linux.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/prof/linux.md
rename to third_party/rust/packed_simd_2/perf-guide/src/prof/linux.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/prof/mca.md b/third_party/rust/packed_simd_2/perf-guide/src/prof/mca.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/prof/mca.md
rename to third_party/rust/packed_simd_2/perf-guide/src/prof/mca.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/prof/profiling.md b/third_party/rust/packed_simd_2/perf-guide/src/prof/profiling.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/prof/profiling.md
rename to third_party/rust/packed_simd_2/perf-guide/src/prof/profiling.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/target-feature/attribute.md b/third_party/rust/packed_simd_2/perf-guide/src/target-feature/attribute.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/target-feature/attribute.md
rename to third_party/rust/packed_simd_2/perf-guide/src/target-feature/attribute.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/target-feature/features.md b/third_party/rust/packed_simd_2/perf-guide/src/target-feature/features.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/target-feature/features.md
rename to third_party/rust/packed_simd_2/perf-guide/src/target-feature/features.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/target-feature/inlining.md b/third_party/rust/packed_simd_2/perf-guide/src/target-feature/inlining.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/target-feature/inlining.md
rename to third_party/rust/packed_simd_2/perf-guide/src/target-feature/inlining.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/target-feature/practice.md b/third_party/rust/packed_simd_2/perf-guide/src/target-feature/practice.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/target-feature/practice.md
rename to third_party/rust/packed_simd_2/perf-guide/src/target-feature/practice.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/target-feature/runtime.md b/third_party/rust/packed_simd_2/perf-guide/src/target-feature/runtime.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/target-feature/runtime.md
rename to third_party/rust/packed_simd_2/perf-guide/src/target-feature/runtime.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/target-feature/rustflags.md b/third_party/rust/packed_simd_2/perf-guide/src/target-feature/rustflags.md
similarity index 92%
rename from third_party/rust/packed_simd/perf-guide/src/target-feature/rustflags.md
rename to third_party/rust/packed_simd_2/perf-guide/src/target-feature/rustflags.md
index e2e806e085b6..f4c1d1304aaa 100644
--- a/third_party/rust/packed_simd/perf-guide/src/target-feature/rustflags.md
+++ b/third_party/rust/packed_simd_2/perf-guide/src/target-feature/rustflags.md
@@ -15,7 +15,7 @@ There are two flags which can be used to enable specific vector extensions:
 - Provides the compiler with a comma-separated set of instruction extensions
   to enable.
 
-  **Example**: Use `-C target-features=+sse3,+avx` to enable generating instructions
+  **Example**: Use `-C target-feature=+sse3,+avx` to enable generating instructions
   for [Streaming SIMD Extensions 3](https://en.wikipedia.org/wiki/SSE3) and
   [Advanced Vector Extensions](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions).
 
@@ -33,9 +33,9 @@ There are two flags which can be used to enable specific vector extensions:
 
 - Note that all CPU features are independent, and will have to be enabled individually.
 
-  **Example**: Setting `-C target-features=+avx2` will _not_ enable `fma`, even though
+  **Example**: Setting `-C target-feature=+avx2` will _not_ enable `fma`, even though
   all CPUs which support AVX2 also support FMA. To enable both, one has to use
-  `-C target-features=+avx2,+fma`
+  `-C target-feature=+avx2,+fma`
 
 - Some features also depend on other features, which need to be enabled for the
   target instructions to be generated.
diff --git a/third_party/rust/packed_simd/perf-guide/src/vert-hor-ops.md b/third_party/rust/packed_simd_2/perf-guide/src/vert-hor-ops.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/vert-hor-ops.md
rename to third_party/rust/packed_simd_2/perf-guide/src/vert-hor-ops.md
diff --git a/third_party/rust/packed_simd_2/rustfmt.toml b/third_party/rust/packed_simd_2/rustfmt.toml
new file mode 100644
index 000000000000..7316518b9980
--- /dev/null
+++ b/third_party/rust/packed_simd_2/rustfmt.toml
@@ -0,0 +1,5 @@
+max_width = 110
+use_small_heuristics = "Max"
+wrap_comments = true
+edition = "2018"
+error_on_line_overflow = true
\ No newline at end of file
diff --git a/third_party/rust/packed_simd/src/api.rs b/third_party/rust/packed_simd_2/src/api.rs
similarity index 99%
rename from third_party/rust/packed_simd/src/api.rs
rename to third_party/rust/packed_simd_2/src/api.rs
index 4e9c4292e06c..aa1403e6e243 100644
--- a/third_party/rust/packed_simd/src/api.rs
+++ b/third_party/rust/packed_simd_2/src/api.rs
@@ -2,7 +2,7 @@
 
 #[macro_use]
 mod bitmask;
-crate mod cast;
+pub(crate) mod cast;
 #[macro_use]
 mod cmp;
 #[macro_use]
@@ -37,7 +37,7 @@ mod swap_bytes;
 mod bit_manip;
 
 #[cfg(feature = "into_bits")]
-crate mod into_bits;
+pub(crate) mod into_bits;
 
 macro_rules! impl_i {
     ([$elem_ty:ident; $elem_n:expr]: $tuple_id:ident, $mask_ty:ident
diff --git a/third_party/rust/packed_simd/src/api/bit_manip.rs b/third_party/rust/packed_simd_2/src/api/bit_manip.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/bit_manip.rs
rename to third_party/rust/packed_simd_2/src/api/bit_manip.rs
diff --git a/third_party/rust/packed_simd/src/api/bitmask.rs b/third_party/rust/packed_simd_2/src/api/bitmask.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/bitmask.rs
rename to third_party/rust/packed_simd_2/src/api/bitmask.rs
diff --git a/third_party/rust/packed_simd/src/api/cast.rs b/third_party/rust/packed_simd_2/src/api/cast.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/cast.rs
rename to third_party/rust/packed_simd_2/src/api/cast.rs
diff --git a/third_party/rust/packed_simd/src/api/cast/macros.rs b/third_party/rust/packed_simd_2/src/api/cast/macros.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/cast/macros.rs
rename to third_party/rust/packed_simd_2/src/api/cast/macros.rs
diff --git a/third_party/rust/packed_simd_2/src/api/cast/v128.rs b/third_party/rust/packed_simd_2/src/api/cast/v128.rs
new file mode 100644
index 000000000000..2e10b97b7737
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/cast/v128.rs
@@ -0,0 +1,302 @@
+//! `FromCast` and `IntoCast` implementations for portable 128-bit wide vectors
+#[rustfmt::skip]
+
+use crate::*;
+
+impl_from_cast!(i8x16[test_v128]: u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16, m32x16);
+impl_from_cast!(u8x16[test_v128]: i8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16, m32x16);
+impl_from_cast_mask!(m8x16[test_v128]: i8x16, u8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16, m32x16);
+
+impl_from_cast!(
+    i16x8[test_v128]: i8x8,
+    u8x8,
+    m8x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast!(
+    u16x8[test_v128]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast_mask!(
+    m16x8[test_v128]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+
+impl_from_cast!(
+    i32x4[test_v128]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast!(
+    u32x4[test_v128]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast!(
+    f32x4[test_v128]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast_mask!(
+    m32x4[test_v128]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+
+impl_from_cast!(
+    i64x2[test_v128]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast!(
+    u64x2[test_v128]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast!(
+    f64x2[test_v128]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast_mask!(
+    m64x2[test_v128]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+
+impl_from_cast!(
+    isizex2[test_v128]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    usizex2,
+    msizex2
+);
+impl_from_cast!(
+    usizex2[test_v128]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    msizex2
+);
+impl_from_cast_mask!(
+    msizex2[test_v128]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2
+);
+
+// FIXME[test_v128]: 64-bit single element vectors into_cast impls
+impl_from_cast!(i128x1[test_v128]: u128x1, m128x1);
+impl_from_cast!(u128x1[test_v128]: i128x1, m128x1);
+impl_from_cast!(m128x1[test_v128]: i128x1, u128x1);
diff --git a/third_party/rust/packed_simd_2/src/api/cast/v16.rs b/third_party/rust/packed_simd_2/src/api/cast/v16.rs
new file mode 100644
index 000000000000..896febacbb42
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/cast/v16.rs
@@ -0,0 +1,68 @@
+//! `FromCast` and `IntoCast` implementations for portable 16-bit wide vectors
+#[rustfmt::skip]
+
+use crate::*;
+
+impl_from_cast!(
+    i8x2[test_v16]: u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast!(
+    u8x2[test_v16]: i8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast_mask!(
+    m8x2[test_v16]: i8x2,
+    u8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
diff --git a/third_party/rust/packed_simd_2/src/api/cast/v256.rs b/third_party/rust/packed_simd_2/src/api/cast/v256.rs
new file mode 100644
index 000000000000..fe0c835e3c90
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/cast/v256.rs
@@ -0,0 +1,298 @@
+//! `FromCast` and `IntoCast` implementations for portable 256-bit wide vectors
+#[rustfmt::skip]
+
+use crate::*;
+
+impl_from_cast!(i8x32[test_v256]: u8x32, m8x32, i16x32, u16x32, m16x32);
+impl_from_cast!(u8x32[test_v256]: i8x32, m8x32, i16x32, u16x32, m16x32);
+impl_from_cast_mask!(m8x32[test_v256]: i8x32, u8x32, i16x32, u16x32, m16x32);
+
+impl_from_cast!(i16x16[test_v256]: i8x16, u8x16, m8x16, u16x16, m16x16, i32x16, u32x16, f32x16, m32x16);
+impl_from_cast!(u16x16[test_v256]: i8x16, u8x16, m8x16, i16x16, m16x16, i32x16, u32x16, f32x16, m32x16);
+impl_from_cast_mask!(m16x16[test_v256]: i8x16, u8x16, m8x16, i16x16, u16x16, i32x16, u32x16, f32x16, m32x16);
+
+impl_from_cast!(
+    i32x8[test_v256]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast!(
+    u32x8[test_v256]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast!(
+    f32x8[test_v256]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast_mask!(
+    m32x8[test_v256]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+
+impl_from_cast!(
+    i64x4[test_v256]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast!(
+    u64x4[test_v256]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast!(
+    f64x4[test_v256]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast_mask!(
+    m64x4[test_v256]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+
+impl_from_cast!(
+    i128x2[test_v256]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast!(
+    u128x2[test_v256]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast_mask!(
+    m128x2[test_v256]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    m64x2,
+    f64x2,
+    i128x2,
+    u128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+
+impl_from_cast!(
+    isizex4[test_v256]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    usizex4,
+    msizex4
+);
+impl_from_cast!(
+    usizex4[test_v256]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    msizex4
+);
+impl_from_cast_mask!(
+    msizex4[test_v256]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4
+);
diff --git a/third_party/rust/packed_simd_2/src/api/cast/v32.rs b/third_party/rust/packed_simd_2/src/api/cast/v32.rs
new file mode 100644
index 000000000000..4ad1cbf74d2e
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/cast/v32.rs
@@ -0,0 +1,132 @@
+//! `FromCast` and `IntoCast` implementations for portable 32-bit wide vectors
+#[rustfmt::skip]
+
+use crate::*;
+
+impl_from_cast!(
+    i8x4[test_v32]: u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast!(
+    u8x4[test_v32]: i8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast_mask!(
+    m8x4[test_v32]: i8x4,
+    u8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+
+impl_from_cast!(
+    i16x2[test_v32]: i8x2,
+    u8x2,
+    m8x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast!(
+    u16x2[test_v32]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast_mask!(
+    m16x2[test_v32]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
diff --git a/third_party/rust/packed_simd_2/src/api/cast/v512.rs b/third_party/rust/packed_simd_2/src/api/cast/v512.rs
new file mode 100644
index 000000000000..b64605045e33
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/cast/v512.rs
@@ -0,0 +1,209 @@
+//! `FromCast` and `IntoCast` implementations for portable 512-bit wide vectors
+#[rustfmt::skip]
+
+use crate::*;
+
+impl_from_cast!(i8x64[test_v512]: u8x64, m8x64);
+impl_from_cast!(u8x64[test_v512]: i8x64, m8x64);
+impl_from_cast_mask!(m8x64[test_v512]: i8x64, u8x64);
+
+impl_from_cast!(i16x32[test_v512]: i8x32, u8x32, m8x32, u16x32, m16x32);
+impl_from_cast!(u16x32[test_v512]: i8x32, u8x32, m8x32, i16x32, m16x32);
+impl_from_cast_mask!(m16x32[test_v512]: i8x32, u8x32, m8x32, i16x32, u16x32);
+
+impl_from_cast!(i32x16[test_v512]: i8x16, u8x16, m8x16, i16x16, u16x16, m16x16, u32x16, f32x16, m32x16);
+impl_from_cast!(u32x16[test_v512]: i8x16, u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, f32x16, m32x16);
+impl_from_cast!(f32x16[test_v512]: i8x16, u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, m32x16);
+impl_from_cast_mask!(m32x16[test_v512]: i8x16, u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16);
+
+impl_from_cast!(
+    i64x8[test_v512]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast!(
+    u64x8[test_v512]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast!(
+    f64x8[test_v512]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast_mask!(
+    m64x8[test_v512]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+
+impl_from_cast!(
+    i128x4[test_v512]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast!(
+    u128x4[test_v512]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast_mask!(
+    m128x4[test_v512]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    m64x4,
+    f64x4,
+    i128x4,
+    u128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+
+impl_from_cast!(
+    isizex8[test_v512]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    usizex8,
+    msizex8
+);
+impl_from_cast!(
+    usizex8[test_v512]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    msizex8
+);
+impl_from_cast_mask!(
+    msizex8[test_v512]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8
+);
diff --git a/third_party/rust/packed_simd_2/src/api/cast/v64.rs b/third_party/rust/packed_simd_2/src/api/cast/v64.rs
new file mode 100644
index 000000000000..b23d1a49171f
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/cast/v64.rs
@@ -0,0 +1,208 @@
+//! `FromCast` and `IntoCast` implementations for portable 64-bit wide vectors
+#[rustfmt::skip]
+
+use crate::*;
+
+impl_from_cast!(
+    i8x8[test_v64]: u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast!(
+    u8x8[test_v64]: i8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast_mask!(
+    m8x8[test_v64]: i8x8,
+    u8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+
+impl_from_cast!(
+    i16x4[test_v64]: i8x4,
+    u8x4,
+    m8x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast!(
+    u16x4[test_v64]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast_mask!(
+    m16x4[test_v64]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+
+impl_from_cast!(
+    i32x2[test_v64]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast!(
+    u32x2[test_v64]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast!(
+    f32x2[test_v64]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast_mask!(
+    m32x2[test_v64]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
diff --git a/third_party/rust/packed_simd/src/api/cmp.rs b/third_party/rust/packed_simd_2/src/api/cmp.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/cmp.rs
rename to third_party/rust/packed_simd_2/src/api/cmp.rs
diff --git a/third_party/rust/packed_simd/src/api/cmp/eq.rs b/third_party/rust/packed_simd_2/src/api/cmp/eq.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/cmp/eq.rs
rename to third_party/rust/packed_simd_2/src/api/cmp/eq.rs
diff --git a/third_party/rust/packed_simd/src/api/cmp/ord.rs b/third_party/rust/packed_simd_2/src/api/cmp/ord.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/cmp/ord.rs
rename to third_party/rust/packed_simd_2/src/api/cmp/ord.rs
diff --git a/third_party/rust/packed_simd/src/api/cmp/partial_eq.rs b/third_party/rust/packed_simd_2/src/api/cmp/partial_eq.rs
similarity index 97%
rename from third_party/rust/packed_simd/src/api/cmp/partial_eq.rs
rename to third_party/rust/packed_simd_2/src/api/cmp/partial_eq.rs
index 1712a0de56cb..d69dd47425f7 100644
--- a/third_party/rust/packed_simd/src/api/cmp/partial_eq.rs
+++ b/third_party/rust/packed_simd_2/src/api/cmp/partial_eq.rs
@@ -21,9 +21,7 @@ macro_rules! impl_cmp_partial_eq {
 
         // FIXME: https://github.com/rust-lang-nursery/rust-clippy/issues/2892
         #[allow(clippy::partialeq_ne_impl)]
-        impl crate::cmp::PartialEq<LexicographicallyOrdered<$id>>
-            for LexicographicallyOrdered<$id>
-        {
+        impl crate::cmp::PartialEq<LexicographicallyOrdered<$id>> for LexicographicallyOrdered<$id> {
             #[inline]
             fn eq(&self, other: &Self) -> bool {
                 self.0 == other.0
diff --git a/third_party/rust/packed_simd/src/api/cmp/partial_ord.rs b/third_party/rust/packed_simd_2/src/api/cmp/partial_ord.rs
similarity index 98%
rename from third_party/rust/packed_simd/src/api/cmp/partial_ord.rs
rename to third_party/rust/packed_simd_2/src/api/cmp/partial_ord.rs
index a2292918bae1..76ed9ebe4e5a 100644
--- a/third_party/rust/packed_simd/src/api/cmp/partial_ord.rs
+++ b/third_party/rust/packed_simd_2/src/api/cmp/partial_ord.rs
@@ -12,13 +12,9 @@ macro_rules! impl_cmp_partial_ord {
             }
         }
 
-        impl crate::cmp::PartialOrd<LexicographicallyOrdered<$id>>
-            for LexicographicallyOrdered<$id>
-        {
+        impl crate::cmp::PartialOrd<LexicographicallyOrdered<$id>> for LexicographicallyOrdered<$id> {
             #[inline]
-            fn partial_cmp(
-                &self, other: &Self,
-            ) -> Option<crate::cmp::Ordering> {
+            fn partial_cmp(&self, other: &Self) -> Option<crate::cmp::Ordering> {
                 if PartialEq::eq(self, other) {
                     Some(crate::cmp::Ordering::Equal)
                 } else if PartialOrd::lt(self, other) {
diff --git a/third_party/rust/packed_simd/src/api/cmp/vertical.rs b/third_party/rust/packed_simd_2/src/api/cmp/vertical.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/cmp/vertical.rs
rename to third_party/rust/packed_simd_2/src/api/cmp/vertical.rs
diff --git a/third_party/rust/packed_simd/src/api/default.rs b/third_party/rust/packed_simd_2/src/api/default.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/default.rs
rename to third_party/rust/packed_simd_2/src/api/default.rs
diff --git a/third_party/rust/packed_simd/src/api/fmt.rs b/third_party/rust/packed_simd_2/src/api/fmt.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/fmt.rs
rename to third_party/rust/packed_simd_2/src/api/fmt.rs
diff --git a/third_party/rust/packed_simd/src/api/fmt/binary.rs b/third_party/rust/packed_simd_2/src/api/fmt/binary.rs
similarity index 94%
rename from third_party/rust/packed_simd/src/api/fmt/binary.rs
rename to third_party/rust/packed_simd_2/src/api/fmt/binary.rs
index b60769082d51..91c082555908 100644
--- a/third_party/rust/packed_simd/src/api/fmt/binary.rs
+++ b/third_party/rust/packed_simd_2/src/api/fmt/binary.rs
@@ -4,9 +4,7 @@ macro_rules! impl_fmt_binary {
     ([$elem_ty:ident; $elem_count:expr]: $id:ident | $test_tt:tt) => {
         impl crate::fmt::Binary for $id {
             #[allow(clippy::missing_inline_in_public_items)]
-            fn fmt(
-                &self, f: &mut crate::fmt::Formatter<'_>,
-            ) -> crate::fmt::Result {
+            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {
                 write!(f, "{}(", stringify!($id))?;
                 for i in 0..$elem_count {
                     if i > 0 {
diff --git a/third_party/rust/packed_simd/src/api/fmt/debug.rs b/third_party/rust/packed_simd_2/src/api/fmt/debug.rs
similarity index 95%
rename from third_party/rust/packed_simd/src/api/fmt/debug.rs
rename to third_party/rust/packed_simd_2/src/api/fmt/debug.rs
index ad0b8a59a1f0..1e209b3bff77 100644
--- a/third_party/rust/packed_simd/src/api/fmt/debug.rs
+++ b/third_party/rust/packed_simd_2/src/api/fmt/debug.rs
@@ -44,9 +44,7 @@ macro_rules! impl_fmt_debug {
     ([$elem_ty:ty; $elem_count:expr]: $id:ident | $test_tt:tt) => {
         impl crate::fmt::Debug for $id {
             #[allow(clippy::missing_inline_in_public_items)]
-            fn fmt(
-                &self, f: &mut crate::fmt::Formatter<'_>,
-            ) -> crate::fmt::Result {
+            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {
                 write!(f, "{}(", stringify!($id))?;
                 for i in 0..$elem_count {
                     if i > 0 {
diff --git a/third_party/rust/packed_simd/src/api/fmt/lower_hex.rs b/third_party/rust/packed_simd_2/src/api/fmt/lower_hex.rs
similarity index 94%
rename from third_party/rust/packed_simd/src/api/fmt/lower_hex.rs
rename to third_party/rust/packed_simd_2/src/api/fmt/lower_hex.rs
index 5a7aa14b5b8a..8f11d3119b70 100644
--- a/third_party/rust/packed_simd/src/api/fmt/lower_hex.rs
+++ b/third_party/rust/packed_simd_2/src/api/fmt/lower_hex.rs
@@ -4,9 +4,7 @@ macro_rules! impl_fmt_lower_hex {
     ([$elem_ty:ident; $elem_count:expr]: $id:ident | $test_tt:tt) => {
         impl crate::fmt::LowerHex for $id {
             #[allow(clippy::missing_inline_in_public_items)]
-            fn fmt(
-                &self, f: &mut crate::fmt::Formatter<'_>,
-            ) -> crate::fmt::Result {
+            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {
                 write!(f, "{}(", stringify!($id))?;
                 for i in 0..$elem_count {
                     if i > 0 {
diff --git a/third_party/rust/packed_simd/src/api/fmt/octal.rs b/third_party/rust/packed_simd_2/src/api/fmt/octal.rs
similarity index 94%
rename from third_party/rust/packed_simd/src/api/fmt/octal.rs
rename to third_party/rust/packed_simd_2/src/api/fmt/octal.rs
index 83ac8abc7dae..e708e094cee0 100644
--- a/third_party/rust/packed_simd/src/api/fmt/octal.rs
+++ b/third_party/rust/packed_simd_2/src/api/fmt/octal.rs
@@ -4,9 +4,7 @@ macro_rules! impl_fmt_octal {
     ([$elem_ty:ident; $elem_count:expr]: $id:ident | $test_tt:tt) => {
         impl crate::fmt::Octal for $id {
             #[allow(clippy::missing_inline_in_public_items)]
-            fn fmt(
-                &self, f: &mut crate::fmt::Formatter<'_>,
-            ) -> crate::fmt::Result {
+            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {
                 write!(f, "{}(", stringify!($id))?;
                 for i in 0..$elem_count {
                     if i > 0 {
diff --git a/third_party/rust/packed_simd/src/api/fmt/upper_hex.rs b/third_party/rust/packed_simd_2/src/api/fmt/upper_hex.rs
similarity index 94%
rename from third_party/rust/packed_simd/src/api/fmt/upper_hex.rs
rename to third_party/rust/packed_simd_2/src/api/fmt/upper_hex.rs
index aa88f673abf0..5ad455706baa 100644
--- a/third_party/rust/packed_simd/src/api/fmt/upper_hex.rs
+++ b/third_party/rust/packed_simd_2/src/api/fmt/upper_hex.rs
@@ -4,9 +4,7 @@ macro_rules! impl_fmt_upper_hex {
     ([$elem_ty:ident; $elem_count:expr]: $id:ident | $test_tt:tt) => {
         impl crate::fmt::UpperHex for $id {
             #[allow(clippy::missing_inline_in_public_items)]
-            fn fmt(
-                &self, f: &mut crate::fmt::Formatter<'_>,
-            ) -> crate::fmt::Result {
+            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {
                 write!(f, "{}(", stringify!($id))?;
                 for i in 0..$elem_count {
                     if i > 0 {
diff --git a/third_party/rust/packed_simd/src/api/from.rs b/third_party/rust/packed_simd_2/src/api/from.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/from.rs
rename to third_party/rust/packed_simd_2/src/api/from.rs
diff --git a/third_party/rust/packed_simd/src/api/from/from_array.rs b/third_party/rust/packed_simd_2/src/api/from/from_array.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/from/from_array.rs
rename to third_party/rust/packed_simd_2/src/api/from/from_array.rs
diff --git a/third_party/rust/packed_simd/src/api/from/from_vector.rs b/third_party/rust/packed_simd_2/src/api/from/from_vector.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/from/from_vector.rs
rename to third_party/rust/packed_simd_2/src/api/from/from_vector.rs
diff --git a/third_party/rust/packed_simd/src/api/hash.rs b/third_party/rust/packed_simd_2/src/api/hash.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/hash.rs
rename to third_party/rust/packed_simd_2/src/api/hash.rs
diff --git a/third_party/rust/packed_simd/src/api/into_bits.rs b/third_party/rust/packed_simd_2/src/api/into_bits.rs
similarity index 90%
rename from third_party/rust/packed_simd/src/api/into_bits.rs
rename to third_party/rust/packed_simd_2/src/api/into_bits.rs
index f2cc1bae5397..32b6d2ddcee4 100644
--- a/third_party/rust/packed_simd/src/api/into_bits.rs
+++ b/third_party/rust/packed_simd_2/src/api/into_bits.rs
@@ -19,9 +19,7 @@ where
 {
     #[inline]
     fn into_bits(self) -> U {
-        debug_assert!(
-            crate::mem::size_of::<Self>() == crate::mem::size_of::<U>()
-        );
+        debug_assert!(crate::mem::size_of::<Self>() == crate::mem::size_of::<U>());
         U::from_bits(self)
     }
 }
diff --git a/third_party/rust/packed_simd/src/api/into_bits/arch_specific.rs b/third_party/rust/packed_simd_2/src/api/into_bits/arch_specific.rs
similarity index 54%
rename from third_party/rust/packed_simd/src/api/into_bits/arch_specific.rs
rename to third_party/rust/packed_simd_2/src/api/into_bits/arch_specific.rs
index fee6140052f9..bfac915576c3 100644
--- a/third_party/rust/packed_simd/src/api/into_bits/arch_specific.rs
+++ b/third_party/rust/packed_simd_2/src/api/into_bits/arch_specific.rs
@@ -84,15 +84,48 @@ macro_rules! impl_arch {
 // FIXME: 64-bit single element types
 // FIXME: arm/aarch float16x4_t missing
 impl_arch!(
-    [arm["arm"]: int8x8_t, uint8x8_t, poly8x8_t, int16x4_t, uint16x4_t,
-     poly16x4_t, int32x2_t, uint32x2_t, float32x2_t, int64x1_t,
-     uint64x1_t],
-    [aarch64["aarch64"]: int8x8_t, uint8x8_t, poly8x8_t, int16x4_t, uint16x4_t,
-     poly16x4_t, int32x2_t, uint32x2_t, float32x2_t, int64x1_t, uint64x1_t,
-     float64x1_t] |
-    from: i8x8, u8x8, m8x8, i16x4, u16x4, m16x4, i32x2, u32x2, f32x2, m32x2 |
-    into: i8x8, u8x8, i16x4, u16x4, i32x2, u32x2, f32x2 |
-    test: test_v64
+    [
+        arm["arm"]: int8x8_t,
+        uint8x8_t,
+        poly8x8_t,
+        int16x4_t,
+        uint16x4_t,
+        poly16x4_t,
+        int32x2_t,
+        uint32x2_t,
+        float32x2_t,
+        int64x1_t,
+        uint64x1_t
+    ],
+    [
+        aarch64["aarch64"]: int8x8_t,
+        uint8x8_t,
+        poly8x8_t,
+        int16x4_t,
+        uint16x4_t,
+        poly16x4_t,
+        int32x2_t,
+        uint32x2_t,
+        float32x2_t,
+        int64x1_t,
+        uint64x1_t,
+        float64x1_t
+    ] | from: i8x8,
+    u8x8,
+    m8x8,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2 | into: i8x8,
+    u8x8,
+    i16x4,
+    u16x4,
+    i32x2,
+    u32x2,
+    f32x2 | test: test_v64
 );
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -108,67 +141,169 @@ impl_arch!(
 // FIXME: ppc64 vector_unsigned___int128 missing
 impl_arch!(
     [x86["x86"]: __m128, __m128i, __m128d],
-    [x86_64["x86_64"]:  __m128, __m128i, __m128d],
-    [arm["arm"]: int8x16_t, uint8x16_t, poly8x16_t, int16x8_t, uint16x8_t,
-     poly16x8_t, int32x4_t, uint32x4_t, float32x4_t, int64x2_t, uint64x2_t],
-    [aarch64["aarch64"]: int8x16_t, uint8x16_t, poly8x16_t, int16x8_t,
-     uint16x8_t, poly16x8_t, int32x4_t, uint32x4_t, float32x4_t, int64x2_t,
-     uint64x2_t, float64x2_t],
-    [powerpc["powerpc"]: vector_signed_char, vector_unsigned_char,
-     vector_signed_short, vector_unsigned_short, vector_signed_int,
-     vector_unsigned_int, vector_float],
-    [powerpc64["powerpc64"]: vector_signed_char, vector_unsigned_char,
-     vector_signed_short, vector_unsigned_short, vector_signed_int,
-     vector_unsigned_int,  vector_float, vector_signed_long,
-     vector_unsigned_long, vector_double] |
-    from: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4,
-    i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1 |
-    into: i8x16, u8x16, i16x8, u16x8, i32x4, u32x4, f32x4, i64x2, u64x2, f64x2,
-    i128x1, u128x1 |
-    test: test_v128
+    [x86_64["x86_64"]: __m128, __m128i, __m128d],
+    [
+        arm["arm"]: int8x16_t,
+        uint8x16_t,
+        poly8x16_t,
+        int16x8_t,
+        uint16x8_t,
+        poly16x8_t,
+        int32x4_t,
+        uint32x4_t,
+        float32x4_t,
+        int64x2_t,
+        uint64x2_t
+    ],
+    [
+        aarch64["aarch64"]: int8x16_t,
+        uint8x16_t,
+        poly8x16_t,
+        int16x8_t,
+        uint16x8_t,
+        poly16x8_t,
+        int32x4_t,
+        uint32x4_t,
+        float32x4_t,
+        int64x2_t,
+        uint64x2_t,
+        float64x2_t
+    ],
+    [
+        powerpc["powerpc"]: vector_signed_char,
+        vector_unsigned_char,
+        vector_signed_short,
+        vector_unsigned_short,
+        vector_signed_int,
+        vector_unsigned_int,
+        vector_float
+    ],
+    [
+        powerpc64["powerpc64"]: vector_signed_char,
+        vector_unsigned_char,
+        vector_signed_short,
+        vector_unsigned_short,
+        vector_signed_int,
+        vector_unsigned_int,
+        vector_float,
+        vector_signed_long,
+        vector_unsigned_long,
+        vector_double
+    ] | from: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1 | into: i8x16,
+    u8x16,
+    i16x8,
+    u16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    i128x1,
+    u128x1 | test: test_v128
 );
 
 impl_arch!(
     [powerpc["powerpc"]: vector_bool_char],
-    [powerpc64["powerpc64"]: vector_bool_char] |
-    from: m8x16, m16x8, m32x4, m64x2, m128x1 |
-    into: i8x16, u8x16, i16x8, u16x8, i32x4, u32x4, f32x4,
-    i64x2, u64x2, f64x2, i128x1, u128x1,
+    [powerpc64["powerpc64"]: vector_bool_char] | from: m8x16,
+    m16x8,
+    m32x4,
+    m64x2,
+    m128x1 | into: i8x16,
+    u8x16,
+    i16x8,
+    u16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    i128x1,
+    u128x1,
     // Masks:
-    m8x16 |
-    test: test_v128
+    m8x16 | test: test_v128
 );
 
 impl_arch!(
     [powerpc["powerpc"]: vector_bool_short],
-    [powerpc64["powerpc64"]: vector_bool_short] |
-    from: m16x8, m32x4, m64x2, m128x1 |
-    into: i8x16, u8x16, i16x8, u16x8, i32x4, u32x4, f32x4,
-    i64x2, u64x2, f64x2, i128x1, u128x1,
+    [powerpc64["powerpc64"]: vector_bool_short] | from: m16x8,
+    m32x4,
+    m64x2,
+    m128x1 | into: i8x16,
+    u8x16,
+    i16x8,
+    u16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    i128x1,
+    u128x1,
     // Masks:
-    m8x16, m16x8 |
-    test: test_v128
+    m8x16,
+    m16x8 | test: test_v128
 );
 
 impl_arch!(
     [powerpc["powerpc"]: vector_bool_int],
-    [powerpc64["powerpc64"]: vector_bool_int] |
-    from: m32x4, m64x2, m128x1 |
-    into: i8x16, u8x16, i16x8, u16x8, i32x4, u32x4, f32x4,
-    i64x2, u64x2, f64x2, i128x1, u128x1,
+    [powerpc64["powerpc64"]: vector_bool_int] | from: m32x4,
+    m64x2,
+    m128x1 | into: i8x16,
+    u8x16,
+    i16x8,
+    u16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    i128x1,
+    u128x1,
     // Masks:
-    m8x16, m16x8, m32x4 |
-    test: test_v128
+    m8x16,
+    m16x8,
+    m32x4 | test: test_v128
 );
 
 impl_arch!(
-    [powerpc64["powerpc64"]: vector_bool_long] |
-    from: m64x2, m128x1 |
-    into: i8x16, u8x16, i16x8, u16x8, i32x4, u32x4, f32x4,
-    i64x2, u64x2, f64x2, i128x1, u128x1,
+    [powerpc64["powerpc64"]: vector_bool_long] | from: m64x2,
+    m128x1 | into: i8x16,
+    u8x16,
+    i16x8,
+    u16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    i128x1,
+    u128x1,
     // Masks:
-    m8x16, m16x8, m32x4, m64x2 |
-    test: test_v128
+    m8x16,
+    m16x8,
+    m32x4,
+    m64x2 | test: test_v128
 );
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -176,13 +311,34 @@ impl_arch!(
 
 impl_arch!(
     [x86["x86"]: __m256, __m256i, __m256d],
-    [x86_64["x86_64"]:  __m256, __m256i, __m256d] |
-    from: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16,
-    i32x8, u32x8, f32x8, m32x8,
-    i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2 |
-    into: i8x32, u8x32, i16x16, u16x16, i32x8, u32x8, f32x8,
-    i64x4, u64x4, f64x4, i128x2, u128x2 |
-    test: test_v256
+    [x86_64["x86_64"]: __m256, __m256i, __m256d] | from: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2 | into: i8x32,
+    u8x32,
+    i16x16,
+    u16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    i128x2,
+    u128x2 | test: test_v256
 );
 
 ////////////////////////////////////////////////////////////////////////////////
diff --git a/third_party/rust/packed_simd/src/api/into_bits/macros.rs b/third_party/rust/packed_simd_2/src/api/into_bits/macros.rs
similarity index 97%
rename from third_party/rust/packed_simd/src/api/into_bits/macros.rs
rename to third_party/rust/packed_simd_2/src/api/into_bits/macros.rs
index 8cec5b00479f..265ab34ae0f3 100644
--- a/third_party/rust/packed_simd/src/api/into_bits/macros.rs
+++ b/third_party/rust/packed_simd_2/src/api/into_bits/macros.rs
@@ -24,7 +24,7 @@ macro_rules! impl_from_bits_ {
                         use crate::IntoBits;
                         assert_eq!(size_of::<$id>(),
                                    size_of::<$from_ty>());
-                        // This is safe becasue we never create a reference to
+                        // This is safe because we never create a reference to
                         // uninitialized memory:
                         let a: $from_ty = unsafe { zeroed() };
 
diff --git a/third_party/rust/packed_simd_2/src/api/into_bits/v128.rs b/third_party/rust/packed_simd_2/src/api/into_bits/v128.rs
new file mode 100644
index 000000000000..639c09c2c4bd
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/into_bits/v128.rs
@@ -0,0 +1,232 @@
+//! `FromBits` and `IntoBits` implementations for portable 128-bit wide vectors
+#[rustfmt::skip]
+
+#[allow(unused)]  // wasm_bindgen_test
+use crate::*;
+
+impl_from_bits!(
+    i8x16[test_v128]: u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(
+    u8x16[test_v128]: i8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(m8x16[test_v128]: m16x8, m32x4, m64x2, m128x1);
+
+impl_from_bits!(
+    i16x8[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(
+    u16x8[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(m16x8[test_v128]: m32x4, m64x2, m128x1);
+
+impl_from_bits!(
+    i32x4[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(
+    u32x4[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(
+    f32x4[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(m32x4[test_v128]: m64x2, m128x1);
+
+impl_from_bits!(
+    i64x2[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(
+    u64x2[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(
+    f64x2[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(m64x2[test_v128]: m128x1);
+
+impl_from_bits!(
+    i128x1[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(
+    u128x1[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    m128x1
+);
+// note: m128x1 cannot be constructed from all the other masks bit patterns in
+// here
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v16.rs b/third_party/rust/packed_simd_2/src/api/into_bits/v16.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/into_bits/v16.rs
rename to third_party/rust/packed_simd_2/src/api/into_bits/v16.rs
diff --git a/third_party/rust/packed_simd_2/src/api/into_bits/v256.rs b/third_party/rust/packed_simd_2/src/api/into_bits/v256.rs
new file mode 100644
index 000000000000..e432bbbc9f05
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/into_bits/v256.rs
@@ -0,0 +1,232 @@
+//! `FromBits` and `IntoBits` implementations for portable 256-bit wide vectors
+#[rustfmt::skip]
+
+#[allow(unused)]  // wasm_bindgen_test
+use crate::*;
+
+impl_from_bits!(
+    i8x32[test_v256]: u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(
+    u8x32[test_v256]: i8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(m8x32[test_v256]: m16x16, m32x8, m64x4, m128x2);
+
+impl_from_bits!(
+    i16x16[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(
+    u16x16[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(m16x16[test_v256]: m32x8, m64x4, m128x2);
+
+impl_from_bits!(
+    i32x8[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(
+    u32x8[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(
+    f32x8[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(m32x8[test_v256]: m64x4, m128x2);
+
+impl_from_bits!(
+    i64x4[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(
+    u64x4[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(
+    f64x4[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(m64x4[test_v256]: m128x2);
+
+impl_from_bits!(
+    i128x2[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(
+    u128x2[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    m128x2
+);
+// note: m128x2 cannot be constructed from all the other masks bit patterns in
+// here
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v32.rs b/third_party/rust/packed_simd_2/src/api/into_bits/v32.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/into_bits/v32.rs
rename to third_party/rust/packed_simd_2/src/api/into_bits/v32.rs
diff --git a/third_party/rust/packed_simd_2/src/api/into_bits/v512.rs b/third_party/rust/packed_simd_2/src/api/into_bits/v512.rs
new file mode 100644
index 000000000000..f6e9bb8bf7a3
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/into_bits/v512.rs
@@ -0,0 +1,232 @@
+//! `FromBits` and `IntoBits` implementations for portable 512-bit wide vectors
+#[rustfmt::skip]
+
+#[allow(unused)]  // wasm_bindgen_test
+use crate::*;
+
+impl_from_bits!(
+    i8x64[test_v512]: u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(
+    u8x64[test_v512]: i8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(m8x64[test_v512]: m16x32, m32x16, m64x8, m128x4);
+
+impl_from_bits!(
+    i16x32[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(
+    u16x32[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(m16x32[test_v512]: m32x16, m64x8, m128x4);
+
+impl_from_bits!(
+    i32x16[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(
+    u32x16[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(
+    f32x16[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(m32x16[test_v512]: m64x8, m128x4);
+
+impl_from_bits!(
+    i64x8[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(
+    u64x8[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(
+    f64x8[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(m64x8[test_v512]: m128x4);
+
+impl_from_bits!(
+    i128x4[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(
+    u128x4[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    m128x4
+);
+// note: m128x4 cannot be constructed from all the other masks bit patterns in
+// here
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v64.rs b/third_party/rust/packed_simd_2/src/api/into_bits/v64.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/into_bits/v64.rs
rename to third_party/rust/packed_simd_2/src/api/into_bits/v64.rs
diff --git a/third_party/rust/packed_simd/src/api/math.rs b/third_party/rust/packed_simd_2/src/api/math.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math.rs
rename to third_party/rust/packed_simd_2/src/api/math.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float.rs b/third_party/rust/packed_simd_2/src/api/math/float.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float.rs
rename to third_party/rust/packed_simd_2/src/api/math/float.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/abs.rs b/third_party/rust/packed_simd_2/src/api/math/float/abs.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/abs.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/abs.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/consts.rs b/third_party/rust/packed_simd_2/src/api/math/float/consts.rs
similarity index 57%
rename from third_party/rust/packed_simd/src/api/math/float/consts.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/consts.rs
index 89f93a6d692b..7f41acbf1b51 100644
--- a/third_party/rust/packed_simd/src/api/math/float/consts.rs
+++ b/third_party/rust/packed_simd_2/src/api/math/float/consts.rs
@@ -8,8 +8,7 @@ macro_rules! impl_float_consts {
             pub const MIN: $id = $id::splat(core::$elem_ty::MIN);
 
             /// Smallest positive normal value.
-            pub const MIN_POSITIVE: $id =
-                $id::splat(core::$elem_ty::MIN_POSITIVE);
+            pub const MIN_POSITIVE: $id = $id::splat(core::$elem_ty::MIN_POSITIVE);
 
             /// Largest finite value.
             pub const MAX: $id = $id::splat(core::$elem_ty::MAX);
@@ -21,50 +20,40 @@ macro_rules! impl_float_consts {
             pub const INFINITY: $id = $id::splat(core::$elem_ty::INFINITY);
 
             /// Negative infinity (-∞).
-            pub const NEG_INFINITY: $id =
-                $id::splat(core::$elem_ty::NEG_INFINITY);
+            pub const NEG_INFINITY: $id = $id::splat(core::$elem_ty::NEG_INFINITY);
 
             /// Archimedes' constant (π)
             pub const PI: $id = $id::splat(core::$elem_ty::consts::PI);
 
             /// π/2
-            pub const FRAC_PI_2: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_PI_2);
+            pub const FRAC_PI_2: $id = $id::splat(core::$elem_ty::consts::FRAC_PI_2);
 
             /// π/3
-            pub const FRAC_PI_3: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_PI_3);
+            pub const FRAC_PI_3: $id = $id::splat(core::$elem_ty::consts::FRAC_PI_3);
 
             /// π/4
-            pub const FRAC_PI_4: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_PI_4);
+            pub const FRAC_PI_4: $id = $id::splat(core::$elem_ty::consts::FRAC_PI_4);
 
             /// π/6
-            pub const FRAC_PI_6: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_PI_6);
+            pub const FRAC_PI_6: $id = $id::splat(core::$elem_ty::consts::FRAC_PI_6);
 
             /// π/8
-            pub const FRAC_PI_8: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_PI_8);
+            pub const FRAC_PI_8: $id = $id::splat(core::$elem_ty::consts::FRAC_PI_8);
 
             /// 1/π
-            pub const FRAC_1_PI: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_1_PI);
+            pub const FRAC_1_PI: $id = $id::splat(core::$elem_ty::consts::FRAC_1_PI);
 
             /// 2/π
-            pub const FRAC_2_PI: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_2_PI);
+            pub const FRAC_2_PI: $id = $id::splat(core::$elem_ty::consts::FRAC_2_PI);
 
             /// 2/sqrt(π)
-            pub const FRAC_2_SQRT_PI: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_2_SQRT_PI);
+            pub const FRAC_2_SQRT_PI: $id = $id::splat(core::$elem_ty::consts::FRAC_2_SQRT_PI);
 
             /// sqrt(2)
             pub const SQRT_2: $id = $id::splat(core::$elem_ty::consts::SQRT_2);
 
             /// 1/sqrt(2)
-            pub const FRAC_1_SQRT_2: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_1_SQRT_2);
+            pub const FRAC_1_SQRT_2: $id = $id::splat(core::$elem_ty::consts::FRAC_1_SQRT_2);
 
             /// Euler's number (e)
             pub const E: $id = $id::splat(core::$elem_ty::consts::E);
@@ -73,8 +62,7 @@ macro_rules! impl_float_consts {
             pub const LOG2_E: $id = $id::splat(core::$elem_ty::consts::LOG2_E);
 
             /// log<sub>10</sub>(e)
-            pub const LOG10_E: $id =
-                $id::splat(core::$elem_ty::consts::LOG10_E);
+            pub const LOG10_E: $id = $id::splat(core::$elem_ty::consts::LOG10_E);
 
             /// ln(2)
             pub const LN_2: $id = $id::splat(core::$elem_ty::consts::LN_2);
diff --git a/third_party/rust/packed_simd/src/api/math/float/cos.rs b/third_party/rust/packed_simd_2/src/api/math/float/cos.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/cos.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/cos.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/exp.rs b/third_party/rust/packed_simd_2/src/api/math/float/exp.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/exp.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/exp.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/ln.rs b/third_party/rust/packed_simd_2/src/api/math/float/ln.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/ln.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/ln.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/mul_add.rs b/third_party/rust/packed_simd_2/src/api/math/float/mul_add.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/mul_add.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/mul_add.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/mul_adde.rs b/third_party/rust/packed_simd_2/src/api/math/float/mul_adde.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/mul_adde.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/mul_adde.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/powf.rs b/third_party/rust/packed_simd_2/src/api/math/float/powf.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/powf.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/powf.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/recpre.rs b/third_party/rust/packed_simd_2/src/api/math/float/recpre.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/recpre.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/recpre.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/rsqrte.rs b/third_party/rust/packed_simd_2/src/api/math/float/rsqrte.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/rsqrte.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/rsqrte.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/sin.rs b/third_party/rust/packed_simd_2/src/api/math/float/sin.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/sin.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/sin.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/sqrt.rs b/third_party/rust/packed_simd_2/src/api/math/float/sqrt.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/sqrt.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/sqrt.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/sqrte.rs b/third_party/rust/packed_simd_2/src/api/math/float/sqrte.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/sqrte.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/sqrte.rs
diff --git a/third_party/rust/packed_simd/src/api/minimal.rs b/third_party/rust/packed_simd_2/src/api/minimal.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/minimal.rs
rename to third_party/rust/packed_simd_2/src/api/minimal.rs
diff --git a/third_party/rust/packed_simd/src/api/minimal/iuf.rs b/third_party/rust/packed_simd_2/src/api/minimal/iuf.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/minimal/iuf.rs
rename to third_party/rust/packed_simd_2/src/api/minimal/iuf.rs
diff --git a/third_party/rust/packed_simd/src/api/minimal/mask.rs b/third_party/rust/packed_simd_2/src/api/minimal/mask.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/minimal/mask.rs
rename to third_party/rust/packed_simd_2/src/api/minimal/mask.rs
diff --git a/third_party/rust/packed_simd/src/api/minimal/ptr.rs b/third_party/rust/packed_simd_2/src/api/minimal/ptr.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/minimal/ptr.rs
rename to third_party/rust/packed_simd_2/src/api/minimal/ptr.rs
diff --git a/third_party/rust/packed_simd/src/api/ops.rs b/third_party/rust/packed_simd_2/src/api/ops.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops.rs
rename to third_party/rust/packed_simd_2/src/api/ops.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/scalar_arithmetic.rs b/third_party/rust/packed_simd_2/src/api/ops/scalar_arithmetic.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/scalar_arithmetic.rs
rename to third_party/rust/packed_simd_2/src/api/ops/scalar_arithmetic.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/scalar_bitwise.rs b/third_party/rust/packed_simd_2/src/api/ops/scalar_bitwise.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/scalar_bitwise.rs
rename to third_party/rust/packed_simd_2/src/api/ops/scalar_bitwise.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/scalar_mask_bitwise.rs b/third_party/rust/packed_simd_2/src/api/ops/scalar_mask_bitwise.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/scalar_mask_bitwise.rs
rename to third_party/rust/packed_simd_2/src/api/ops/scalar_mask_bitwise.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/scalar_shifts.rs b/third_party/rust/packed_simd_2/src/api/ops/scalar_shifts.rs
similarity index 94%
rename from third_party/rust/packed_simd/src/api/ops/scalar_shifts.rs
rename to third_party/rust/packed_simd_2/src/api/ops/scalar_shifts.rs
index 9c164ad56c0b..4a7a096263d0 100644
--- a/third_party/rust/packed_simd/src/api/ops/scalar_shifts.rs
+++ b/third_party/rust/packed_simd_2/src/api/ops/scalar_shifts.rs
@@ -36,11 +36,10 @@ macro_rules! impl_ops_scalar_shifts {
                     use super::*;
                     #[cfg_attr(not(target_arch = "wasm32"), test)] #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
                     #[cfg_attr(any(target_arch = "s390x", target_arch = "sparc64"),
-                               allow(unreachable_code,
-                                     unused_variables,
-                                     unused_mut)
+                               allow(unreachable_code, unused_variables)
                     )]
-                    // ^^^ FIXME: https://github.com/rust-lang/rust/issues/55344
+                    #[cfg(not(target_arch = "aarch64"))]
+                    //~^ FIXME: https://github.com/rust-lang/packed_simd/issues/317
                     fn ops_scalar_shifts() {
                         let z = $id::splat(0 as $elem_ty);
                         let o = $id::splat(1 as $elem_ty);
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_arithmetic.rs b/third_party/rust/packed_simd_2/src/api/ops/vector_arithmetic.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/vector_arithmetic.rs
rename to third_party/rust/packed_simd_2/src/api/ops/vector_arithmetic.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_bitwise.rs b/third_party/rust/packed_simd_2/src/api/ops/vector_bitwise.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/vector_bitwise.rs
rename to third_party/rust/packed_simd_2/src/api/ops/vector_bitwise.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_float_min_max.rs b/third_party/rust/packed_simd_2/src/api/ops/vector_float_min_max.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/vector_float_min_max.rs
rename to third_party/rust/packed_simd_2/src/api/ops/vector_float_min_max.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_int_min_max.rs b/third_party/rust/packed_simd_2/src/api/ops/vector_int_min_max.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/vector_int_min_max.rs
rename to third_party/rust/packed_simd_2/src/api/ops/vector_int_min_max.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_mask_bitwise.rs b/third_party/rust/packed_simd_2/src/api/ops/vector_mask_bitwise.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/vector_mask_bitwise.rs
rename to third_party/rust/packed_simd_2/src/api/ops/vector_mask_bitwise.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_neg.rs b/third_party/rust/packed_simd_2/src/api/ops/vector_neg.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/vector_neg.rs
rename to third_party/rust/packed_simd_2/src/api/ops/vector_neg.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_rotates.rs b/third_party/rust/packed_simd_2/src/api/ops/vector_rotates.rs
similarity index 96%
rename from third_party/rust/packed_simd/src/api/ops/vector_rotates.rs
rename to third_party/rust/packed_simd_2/src/api/ops/vector_rotates.rs
index 6c794ecf4b93..147fc2e37d1f 100644
--- a/third_party/rust/packed_simd/src/api/ops/vector_rotates.rs
+++ b/third_party/rust/packed_simd_2/src/api/ops/vector_rotates.rs
@@ -47,6 +47,8 @@ macro_rules! impl_ops_vector_rotates {
                 pub mod [<$id _ops_vector_rotate>] {
                     use super::*;
                     #[cfg_attr(not(target_arch = "wasm32"), test)] #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
+                    #[cfg(not(target_arch = "aarch64"))]
+                    //~^ FIXME: https://github.com/rust-lang/packed_simd/issues/317
                     fn rotate_ops() {
                         let z = $id::splat(0 as $elem_ty);
                         let o = $id::splat(1 as $elem_ty);
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_shifts.rs b/third_party/rust/packed_simd_2/src/api/ops/vector_shifts.rs
similarity index 94%
rename from third_party/rust/packed_simd/src/api/ops/vector_shifts.rs
rename to third_party/rust/packed_simd_2/src/api/ops/vector_shifts.rs
index 22e1fbc0ec76..8bb5ac2fc03a 100644
--- a/third_party/rust/packed_simd/src/api/ops/vector_shifts.rs
+++ b/third_party/rust/packed_simd_2/src/api/ops/vector_shifts.rs
@@ -37,11 +37,10 @@ macro_rules! impl_ops_vector_shifts {
                     use super::*;
                     #[cfg_attr(not(target_arch = "wasm32"), test)] #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
                     #[cfg_attr(any(target_arch = "s390x", target_arch = "sparc64"),
-                               allow(unreachable_code,
-                                     unused_variables,
-                                     unused_mut)
+                               allow(unreachable_code, unused_variables)
                     )]
-                    // ^^^ FIXME: https://github.com/rust-lang/rust/issues/55344
+                    #[cfg(not(target_arch = "aarch64"))]
+                    //~^ FIXME: https://github.com/rust-lang/packed_simd/issues/317
                     fn ops_vector_shifts() {
                         let z = $id::splat(0 as $elem_ty);
                         let o = $id::splat(1 as $elem_ty);
diff --git a/third_party/rust/packed_simd/src/api/ptr.rs b/third_party/rust/packed_simd_2/src/api/ptr.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ptr.rs
rename to third_party/rust/packed_simd_2/src/api/ptr.rs
diff --git a/third_party/rust/packed_simd/src/api/ptr/gather_scatter.rs b/third_party/rust/packed_simd_2/src/api/ptr/gather_scatter.rs
similarity index 94%
rename from third_party/rust/packed_simd/src/api/ptr/gather_scatter.rs
rename to third_party/rust/packed_simd_2/src/api/ptr/gather_scatter.rs
index 430435620939..374482ac31c6 100644
--- a/third_party/rust/packed_simd/src/api/ptr/gather_scatter.rs
+++ b/third_party/rust/packed_simd_2/src/api/ptr/gather_scatter.rs
@@ -22,7 +22,8 @@ macro_rules! impl_ptr_read {
             /// pointers must be aligned to `mem::align_of::<T>()`.
             #[inline]
             pub unsafe fn read<M>(
-                self, mask: Simd<[M; $elem_count]>,
+                self,
+                mask: Simd<[M; $elem_count]>,
                 value: Simd<[T; $elem_count]>,
             ) -> Simd<[T; $elem_count]>
             where
@@ -128,10 +129,8 @@ macro_rules! impl_ptr_write {
             /// This method is unsafe because it dereferences raw pointers. The
             /// pointers must be aligned to `mem::align_of::<T>()`.
             #[inline]
-            pub unsafe fn write<M>(
-                self, mask: Simd<[M; $elem_count]>,
-                value: Simd<[T; $elem_count]>,
-            ) where
+            pub unsafe fn write<M>(self, mask: Simd<[M; $elem_count]>, value: Simd<[T; $elem_count]>)
+            where
                 M: sealed::Mask,
                 [M; $elem_count]: sealed::SimdArray,
             {
@@ -147,8 +146,8 @@ macro_rules! impl_ptr_write {
                     use super::*;
                     #[test]
                     fn write() {
-                        // fourty_two = [42, 42, 42, ...]
-                        let fourty_two
+                        // forty_two = [42, 42, 42, ...]
+                        let forty_two
                             = Simd::<[i32; $elem_count]>::splat(42_i32);
 
                         // This test will write to this array
@@ -166,11 +165,11 @@ macro_rules! impl_ptr_write {
                         }
                         // ptr = [&arr[0], &arr[1], ...]
 
-                        // write `fourty_two` to all elements of `v`
+                        // write `forty_two` to all elements of `v`
                         {
                             let backup = arr;
                             unsafe {
-                                ptr.write($mask_ty::splat(true), fourty_two)
+                                ptr.write($mask_ty::splat(true), forty_two)
                             };
                             assert_eq!(arr, [42_i32; $elem_count]);
                             arr = backup;  // arr = [0, 1, 2, ...]
@@ -196,7 +195,7 @@ macro_rules! impl_ptr_write {
                             }
 
                             let backup = arr;
-                            unsafe { ptr.write(mask, fourty_two) };
+                            unsafe { ptr.write(mask, forty_two) };
                             assert_eq!(arr, r);
                             arr = backup;  // arr = [0, 1, 2, 3, ...]
                         }
@@ -205,7 +204,7 @@ macro_rules! impl_ptr_write {
                         {
                             let backup = arr;
                             unsafe {
-                                ptr.write($mask_ty::splat(false), fourty_two)
+                                ptr.write($mask_ty::splat(false), forty_two)
                             };
                             assert_eq!(arr, backup);
                         }
diff --git a/third_party/rust/packed_simd/src/api/reductions.rs b/third_party/rust/packed_simd_2/src/api/reductions.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/reductions.rs
rename to third_party/rust/packed_simd_2/src/api/reductions.rs
diff --git a/third_party/rust/packed_simd/src/api/reductions/bitwise.rs b/third_party/rust/packed_simd_2/src/api/reductions/bitwise.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/reductions/bitwise.rs
rename to third_party/rust/packed_simd_2/src/api/reductions/bitwise.rs
diff --git a/third_party/rust/packed_simd/src/api/reductions/float_arithmetic.rs b/third_party/rust/packed_simd_2/src/api/reductions/float_arithmetic.rs
similarity index 97%
rename from third_party/rust/packed_simd/src/api/reductions/float_arithmetic.rs
rename to third_party/rust/packed_simd_2/src/api/reductions/float_arithmetic.rs
index 4a47452e5006..9dc8783dbbf6 100644
--- a/third_party/rust/packed_simd/src/api/reductions/float_arithmetic.rs
+++ b/third_party/rust/packed_simd_2/src/api/reductions/float_arithmetic.rs
@@ -144,8 +144,6 @@ macro_rules! impl_reduction_float_arithmetic {
                     #[cfg_attr(not(target_arch = "wasm32"), test)]
                     #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
                     #[allow(unreachable_code)]
-                    #[allow(unused_mut)]
-                    // ^^^ FIXME: https://github.com/rust-lang/rust/issues/55344
                     fn sum_nan() {
                         // FIXME: https://bugs.llvm.org/show_bug.cgi?id=36732
                         // https://github.com/rust-lang-nursery/packed_simd/issues/6
@@ -175,8 +173,6 @@ macro_rules! impl_reduction_float_arithmetic {
                     #[cfg_attr(not(target_arch = "wasm32"), test)]
                     #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
                     #[allow(unreachable_code)]
-                    #[allow(unused_mut)]
-                    // ^^^ FIXME: https://github.com/rust-lang/rust/issues/55344
                     fn product_nan() {
                         // FIXME: https://bugs.llvm.org/show_bug.cgi?id=36732
                         // https://github.com/rust-lang-nursery/packed_simd/issues/6
@@ -247,7 +243,7 @@ macro_rules! impl_reduction_float_arithmetic {
                                 tree_bits - red_bits
                             } < 2,
                             "vector: {:?} | simd_reduction: {:?} | \
-                             tree_reduction: {} | scalar_reduction: {}",
+tree_reduction: {} | scalar_reduction: {}",
                             v,
                             simd_reduction,
                             tree_reduction,
@@ -303,7 +299,7 @@ macro_rules! impl_reduction_float_arithmetic {
                                 tree_bits - red_bits
                             } < ulp_limit.try_into().unwrap(),
                             "vector: {:?} | simd_reduction: {:?} | \
-                             tree_reduction: {} | scalar_reduction: {}",
+tree_reduction: {} | scalar_reduction: {}",
                             v,
                             simd_reduction,
                             tree_reduction,
diff --git a/third_party/rust/packed_simd/src/api/reductions/integer_arithmetic.rs b/third_party/rust/packed_simd_2/src/api/reductions/integer_arithmetic.rs
similarity index 96%
rename from third_party/rust/packed_simd/src/api/reductions/integer_arithmetic.rs
rename to third_party/rust/packed_simd_2/src/api/reductions/integer_arithmetic.rs
index 91dffad31032..e99e6cb5d796 100644
--- a/third_party/rust/packed_simd/src/api/reductions/integer_arithmetic.rs
+++ b/third_party/rust/packed_simd_2/src/api/reductions/integer_arithmetic.rs
@@ -18,9 +18,7 @@ macro_rules! impl_reduction_integer_arithmetic {
                 #[cfg(not(target_arch = "aarch64"))]
                 {
                     use crate::llvm::simd_reduce_add_ordered;
-                    let v: $ielem_ty = unsafe {
-                        simd_reduce_add_ordered(self.0, 0 as $ielem_ty)
-                    };
+                    let v: $ielem_ty = unsafe { simd_reduce_add_ordered(self.0, 0 as $ielem_ty) };
                     v as $elem_ty
                 }
                 #[cfg(target_arch = "aarch64")]
@@ -49,9 +47,7 @@ macro_rules! impl_reduction_integer_arithmetic {
                 #[cfg(not(target_arch = "aarch64"))]
                 {
                     use crate::llvm::simd_reduce_mul_ordered;
-                    let v: $ielem_ty = unsafe {
-                        simd_reduce_mul_ordered(self.0, 1 as $ielem_ty)
-                    };
+                    let v: $ielem_ty = unsafe { simd_reduce_mul_ordered(self.0, 1 as $ielem_ty) };
                     v as $elem_ty
                 }
                 #[cfg(target_arch = "aarch64")]
diff --git a/third_party/rust/packed_simd/src/api/reductions/mask.rs b/third_party/rust/packed_simd_2/src/api/reductions/mask.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/reductions/mask.rs
rename to third_party/rust/packed_simd_2/src/api/reductions/mask.rs
diff --git a/third_party/rust/packed_simd/src/api/reductions/min_max.rs b/third_party/rust/packed_simd_2/src/api/reductions/min_max.rs
similarity index 86%
rename from third_party/rust/packed_simd/src/api/reductions/min_max.rs
rename to third_party/rust/packed_simd_2/src/api/reductions/min_max.rs
index c4c1400a8fc4..a3ce13a45123 100644
--- a/third_party/rust/packed_simd/src/api/reductions/min_max.rs
+++ b/third_party/rust/packed_simd_2/src/api/reductions/min_max.rs
@@ -123,7 +123,7 @@ macro_rules! impl_reduction_min_max {
 
 macro_rules! test_reduction_float_min_max {
     ([$elem_ty:ident; $elem_count:expr]: $id:ident | $test_tt:tt) => {
-        test_if!{
+        test_if! {
             $test_tt:
             paste::item! {
                 // Comparisons use integer casts within mantissa^1 range.
@@ -160,20 +160,7 @@ macro_rules! test_reduction_float_min_max {
                             // targets:
                             if i == $id::lanes() - 1 &&
                                 target_with_broken_last_lane_nan {
-                                // FIXME:
-                                // https://github.com/rust-lang-nursery/packed_simd/issues/5
-                                //
-                                // If there is a NaN, the result should always
-                                // the smallest element, but currently when the
-                                // last element is NaN the current
-                                // implementation incorrectly returns NaN.
-                                //
-                                // The targets mentioned above use different
-                                // codegen that produces the correct result.
-                                //
-                                // These asserts detect if this behavior changes
-                                    assert!(v.min_element().is_nan(),
-                                            // FIXME: ^^^ should be -3.
+                                    assert_eq!(v.min_element(), -3.,
                                             "[A]: nan at {} => {} | {:?}",
                                             i, v.min_element(), v);
 
@@ -181,14 +168,17 @@ macro_rules! test_reduction_float_min_max {
                                 // up-to the `i-th` lane with `NaN`s, the result
                                 // is still always `-3.` unless all elements of
                                 // the vector are `NaN`s:
-                                //
-                                // This is also broken:
                                 for j in 0..i {
                                     v = v.replace(j, n);
-                                    assert!(v.min_element().is_nan(),
-                                            // FIXME: ^^^ should be -3.
+                                    if j == i-1 {
+                                        assert!(v.min_element().is_nan(),
+                                            "[B]: nan at {} => {} | {:?}",
+                                            i, v.min_element(), v);
+                                    } else {
+                                        assert_eq!(v.min_element(), -3.,
                                             "[B]: nan at {} => {} | {:?}",
                                             i, v.min_element(), v);
+                                    }
                                 }
 
                                 // We are done here, since we were in the last
@@ -203,7 +193,7 @@ macro_rules! test_reduction_float_min_max {
                             if $id::lanes() == 1 {
                                 assert!(v.min_element().is_nan(),
                                         "[C]: all nans | v={:?} | min={} | \
-                                         is_nan: {}",
+is_nan: {}",
                                         v, v.min_element(),
                                         v.min_element().is_nan()
                                 );
@@ -235,7 +225,7 @@ macro_rules! test_reduction_float_min_max {
                                     // "i - 1" does not overflow.
                                     assert!(v.min_element().is_nan(),
                                             "[E]: all nans | v={:?} | min={} | \
-                                             is_nan: {}",
+is_nan: {}",
                                             v, v.min_element(),
                                             v.min_element().is_nan());
                                 } else {
@@ -280,21 +270,7 @@ macro_rules! test_reduction_float_min_max {
                             // targets:
                             if i == $id::lanes() - 1 &&
                               target_with_broken_last_lane_nan {
-                                // FIXME:
-                                // https://github.com/rust-lang-nursery/packed_simd/issues/5
-                                //
-                                // If there is a NaN, the result should
-                                // always the largest element, but currently
-                                // when the last element is NaN the current
-                                // implementation incorrectly returns NaN.
-                                //
-                                // The targets mentioned above use different
-                                // codegen that produces the correct result.
-                                //
-                                // These asserts detect if this behavior
-                                // changes
-                                assert!(v.max_element().is_nan(),
-                                        // FIXME: ^^^ should be -3.
+                                assert_eq!(v.max_element(), -3.,
                                         "[A]: nan at {} => {} | {:?}",
                                         i, v.max_element(), v);
 
@@ -302,14 +278,17 @@ macro_rules! test_reduction_float_min_max {
                                 // up-to the `i-th` lane with `NaN`s, the result
                                 // is still always `-3.` unless all elements of
                                 // the vector are `NaN`s:
-                                //
-                                // This is also broken:
                                 for j in 0..i {
                                     v = v.replace(j, n);
-                                    assert!(v.max_element().is_nan(),
-                                            // FIXME: ^^^ should be -3.
+                                    if j == i-1 {
+                                        assert!(v.min_element().is_nan(),
+                                        "[B]: nan at {} => {} | {:?}",
+                                        i, v.min_element(), v);
+                                    } else {
+                                        assert_eq!(v.max_element(), -3.,
                                             "[B]: nan at {} => {} | {:?}",
                                             i, v.max_element(), v);
+                                    }
                                 }
 
                                 // We are done here, since we were in the last
@@ -324,7 +303,7 @@ macro_rules! test_reduction_float_min_max {
                             if $id::lanes() == 1 {
                                 assert!(v.max_element().is_nan(),
                                         "[C]: all nans | v={:?} | min={} | \
-                                         is_nan: {}",
+is_nan: {}",
                                         v, v.max_element(),
                                         v.max_element().is_nan());
 
@@ -355,7 +334,7 @@ macro_rules! test_reduction_float_min_max {
                                     // "i - 1" does not overflow.
                                     assert!(v.max_element().is_nan(),
                                             "[E]: all nans | v={:?} | max={} | \
-                                             is_nan: {}",
+is_nan: {}",
                                             v, v.max_element(),
                                             v.max_element().is_nan());
                                 } else {
@@ -377,5 +356,5 @@ macro_rules! test_reduction_float_min_max {
                 }
             }
         }
-    }
+    };
 }
diff --git a/third_party/rust/packed_simd/src/api/select.rs b/third_party/rust/packed_simd_2/src/api/select.rs
similarity index 94%
rename from third_party/rust/packed_simd/src/api/select.rs
rename to third_party/rust/packed_simd_2/src/api/select.rs
index 24525df56c73..daf62947219e 100644
--- a/third_party/rust/packed_simd/src/api/select.rs
+++ b/third_party/rust/packed_simd_2/src/api/select.rs
@@ -12,9 +12,7 @@ macro_rules! impl_select {
             #[inline]
             pub fn select<T>(self, a: Simd<T>, b: Simd<T>) -> Simd<T>
             where
-                T: sealed::SimdArray<
-                    NT = <[$elem_ty; $elem_count] as sealed::SimdArray>::NT,
-                >,
+                T: sealed::SimdArray<NT = <[$elem_ty; $elem_count] as sealed::SimdArray>::NT>,
             {
                 use crate::llvm::simd_select;
                 Simd(unsafe { simd_select(self.0, a.0, b.0) })
diff --git a/third_party/rust/packed_simd/src/api/shuffle.rs b/third_party/rust/packed_simd_2/src/api/shuffle.rs
similarity index 97%
rename from third_party/rust/packed_simd/src/api/shuffle.rs
rename to third_party/rust/packed_simd_2/src/api/shuffle.rs
index 3fe1ad5f2701..fda29ccddc18 100644
--- a/third_party/rust/packed_simd/src/api/shuffle.rs
+++ b/third_party/rust/packed_simd_2/src/api/shuffle.rs
@@ -27,9 +27,7 @@
 /// Shuffling elements of two vectors:
 ///
 /// ```
-/// # #[macro_use]
-/// # extern crate packed_simd;
-/// # use packed_simd::*;
+/// # use packed_simd_2::*;
 /// # fn main() {
 /// // Shuffle allows reordering the elements:
 /// let x = i32x4::new(1, 2, 3, 4);
@@ -51,9 +49,7 @@
 /// Shuffling elements of one vector:
 ///
 /// ```
-/// # #[macro_use]
-/// # extern crate packed_simd;
-/// # use packed_simd::*;
+/// # use packed_simd_2::*;
 /// # fn main() {
 /// // Shuffle allows reordering the elements of a vector:
 /// let x = i32x4::new(1, 2, 3, 4);
diff --git a/third_party/rust/packed_simd/src/api/shuffle1_dyn.rs b/third_party/rust/packed_simd_2/src/api/shuffle1_dyn.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/shuffle1_dyn.rs
rename to third_party/rust/packed_simd_2/src/api/shuffle1_dyn.rs
diff --git a/third_party/rust/packed_simd/src/api/slice.rs b/third_party/rust/packed_simd_2/src/api/slice.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/slice.rs
rename to third_party/rust/packed_simd_2/src/api/slice.rs
diff --git a/third_party/rust/packed_simd/src/api/slice/from_slice.rs b/third_party/rust/packed_simd_2/src/api/slice/from_slice.rs
similarity index 90%
rename from third_party/rust/packed_simd/src/api/slice/from_slice.rs
rename to third_party/rust/packed_simd_2/src/api/slice/from_slice.rs
index 25082d1e6800..50f3914f7bbe 100644
--- a/third_party/rust/packed_simd/src/api/slice/from_slice.rs
+++ b/third_party/rust/packed_simd_2/src/api/slice/from_slice.rs
@@ -14,11 +14,7 @@ macro_rules! impl_slice_from_slice {
                 unsafe {
                     assert!(slice.len() >= $elem_count);
                     let target_ptr = slice.get_unchecked(0) as *const $elem_ty;
-                    assert_eq!(
-                        target_ptr
-                            .align_offset(crate::mem::align_of::<Self>()),
-                        0
-                    );
+                    assert_eq!(target_ptr.align_offset(crate::mem::align_of::<Self>()), 0);
                     Self::from_slice_aligned_unchecked(slice)
                 }
             }
@@ -43,15 +39,10 @@ macro_rules! impl_slice_from_slice {
             /// If `slice.len() < Self::lanes()` or `&slice[0]` is not aligned
             /// to an `align_of::<Self>()` boundary, the behavior is undefined.
             #[inline]
-            pub unsafe fn from_slice_aligned_unchecked(
-                slice: &[$elem_ty],
-            ) -> Self {
+            pub unsafe fn from_slice_aligned_unchecked(slice: &[$elem_ty]) -> Self {
                 debug_assert!(slice.len() >= $elem_count);
                 let target_ptr = slice.get_unchecked(0) as *const $elem_ty;
-                debug_assert_eq!(
-                    target_ptr.align_offset(crate::mem::align_of::<Self>()),
-                    0
-                );
+                debug_assert_eq!(target_ptr.align_offset(crate::mem::align_of::<Self>()), 0);
 
                 #[allow(clippy::cast_ptr_alignment)]
                 *(target_ptr as *const Self)
@@ -63,20 +54,13 @@ macro_rules! impl_slice_from_slice {
             ///
             /// If `slice.len() < Self::lanes()` the behavior is undefined.
             #[inline]
-            pub unsafe fn from_slice_unaligned_unchecked(
-                slice: &[$elem_ty],
-            ) -> Self {
+            pub unsafe fn from_slice_unaligned_unchecked(slice: &[$elem_ty]) -> Self {
                 use crate::mem::size_of;
                 debug_assert!(slice.len() >= $elem_count);
-                let target_ptr =
-                    slice.get_unchecked(0) as *const $elem_ty as *const u8;
+                let target_ptr = slice.get_unchecked(0) as *const $elem_ty as *const u8;
                 let mut x = Self::splat(0 as $elem_ty);
                 let self_ptr = &mut x as *mut Self as *mut u8;
-                crate::ptr::copy_nonoverlapping(
-                    target_ptr,
-                    self_ptr,
-                    size_of::<Self>(),
-                );
+                crate::ptr::copy_nonoverlapping(target_ptr, self_ptr, size_of::<Self>());
                 x
             }
         }
diff --git a/third_party/rust/packed_simd/src/api/slice/write_to_slice.rs b/third_party/rust/packed_simd_2/src/api/slice/write_to_slice.rs
similarity index 88%
rename from third_party/rust/packed_simd/src/api/slice/write_to_slice.rs
rename to third_party/rust/packed_simd_2/src/api/slice/write_to_slice.rs
index b634d98b9962..dd04a2634d90 100644
--- a/third_party/rust/packed_simd/src/api/slice/write_to_slice.rs
+++ b/third_party/rust/packed_simd_2/src/api/slice/write_to_slice.rs
@@ -13,13 +13,8 @@ macro_rules! impl_slice_write_to_slice {
             pub fn write_to_slice_aligned(self, slice: &mut [$elem_ty]) {
                 unsafe {
                     assert!(slice.len() >= $elem_count);
-                    let target_ptr =
-                        slice.get_unchecked_mut(0) as *mut $elem_ty;
-                    assert_eq!(
-                        target_ptr
-                            .align_offset(crate::mem::align_of::<Self>()),
-                        0
-                    );
+                    let target_ptr = slice.get_unchecked_mut(0) as *mut $elem_ty;
+                    assert_eq!(target_ptr.align_offset(crate::mem::align_of::<Self>()), 0);
                     self.write_to_slice_aligned_unchecked(slice);
                 }
             }
@@ -45,18 +40,13 @@ macro_rules! impl_slice_write_to_slice {
             /// aligned to an `align_of::<Self>()` boundary, the behavior is
             /// undefined.
             #[inline]
-            pub unsafe fn write_to_slice_aligned_unchecked(
-                self, slice: &mut [$elem_ty],
-            ) {
+            pub unsafe fn write_to_slice_aligned_unchecked(self, slice: &mut [$elem_ty]) {
                 debug_assert!(slice.len() >= $elem_count);
                 let target_ptr = slice.get_unchecked_mut(0) as *mut $elem_ty;
-                debug_assert_eq!(
-                    target_ptr.align_offset(crate::mem::align_of::<Self>()),
-                    0
-                );
+                debug_assert_eq!(target_ptr.align_offset(crate::mem::align_of::<Self>()), 0);
 
-                                #[allow(clippy::cast_ptr_alignment)]
-                        #[allow(clippy::cast_ptr_alignment)]
+                #[allow(clippy::cast_ptr_alignment)]
+                #[allow(clippy::cast_ptr_alignment)]
                 #[allow(clippy::cast_ptr_alignment)]
                 #[allow(clippy::cast_ptr_alignment)]
                 *(target_ptr as *mut Self) = self;
@@ -68,18 +58,11 @@ macro_rules! impl_slice_write_to_slice {
             ///
             /// If `slice.len() < Self::lanes()` the behavior is undefined.
             #[inline]
-            pub unsafe fn write_to_slice_unaligned_unchecked(
-                self, slice: &mut [$elem_ty],
-            ) {
+            pub unsafe fn write_to_slice_unaligned_unchecked(self, slice: &mut [$elem_ty]) {
                 debug_assert!(slice.len() >= $elem_count);
-                let target_ptr =
-                    slice.get_unchecked_mut(0) as *mut $elem_ty as *mut u8;
+                let target_ptr = slice.get_unchecked_mut(0) as *mut $elem_ty as *mut u8;
                 let self_ptr = &self as *const Self as *const u8;
-                crate::ptr::copy_nonoverlapping(
-                    self_ptr,
-                    target_ptr,
-                    crate::mem::size_of::<Self>(),
-                );
+                crate::ptr::copy_nonoverlapping(self_ptr, target_ptr, crate::mem::size_of::<Self>());
             }
         }
 
diff --git a/third_party/rust/packed_simd/src/api/swap_bytes.rs b/third_party/rust/packed_simd_2/src/api/swap_bytes.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/swap_bytes.rs
rename to third_party/rust/packed_simd_2/src/api/swap_bytes.rs
diff --git a/third_party/rust/packed_simd/src/codegen.rs b/third_party/rust/packed_simd_2/src/codegen.rs
similarity index 54%
rename from third_party/rust/packed_simd/src/codegen.rs
rename to third_party/rust/packed_simd_2/src/codegen.rs
index 9d1517e203d1..8a9e971486d7 100644
--- a/third_party/rust/packed_simd/src/codegen.rs
+++ b/third_party/rust/packed_simd_2/src/codegen.rs
@@ -1,19 +1,19 @@
 //! Code-generation utilities
 
-crate mod bit_manip;
-crate mod llvm;
-crate mod math;
-crate mod reductions;
-crate mod shuffle;
-crate mod shuffle1_dyn;
-crate mod swap_bytes;
+pub(crate) mod bit_manip;
+pub(crate) mod llvm;
+pub(crate) mod math;
+pub(crate) mod reductions;
+pub(crate) mod shuffle;
+pub(crate) mod shuffle1_dyn;
+pub(crate) mod swap_bytes;
 
 macro_rules! impl_simd_array {
     ([$elem_ty:ident; $elem_count:expr]:
      $tuple_id:ident | $($elem_tys:ident),*) => {
         #[derive(Copy, Clone)]
         #[repr(simd)]
-        pub struct $tuple_id($(crate $elem_tys),*);
+        pub struct $tuple_id($(pub(crate) $elem_tys),*);
         //^^^^^^^ leaked through SimdArray
 
         impl crate::sealed::Seal for [$elem_ty; $elem_count] {}
@@ -35,28 +35,28 @@ macro_rules! impl_simd_array {
     }
 }
 
-crate mod pointer_sized_int;
+pub(crate) mod pointer_sized_int;
 
-crate mod v16;
-crate use self::v16::*;
+pub(crate) mod v16;
+pub(crate) use self::v16::*;
 
-crate mod v32;
-crate use self::v32::*;
+pub(crate) mod v32;
+pub(crate) use self::v32::*;
 
-crate mod v64;
-crate use self::v64::*;
+pub(crate) mod v64;
+pub(crate) use self::v64::*;
 
-crate mod v128;
-crate use self::v128::*;
+pub(crate) mod v128;
+pub(crate) use self::v128::*;
 
-crate mod v256;
-crate use self::v256::*;
+pub(crate) mod v256;
+pub(crate) use self::v256::*;
 
-crate mod v512;
-crate use self::v512::*;
+pub(crate) mod v512;
+pub(crate) use self::v512::*;
 
-crate mod vSize;
-crate use self::vSize::*;
+pub(crate) mod vSize;
+pub(crate) use self::vSize::*;
 
-crate mod vPtr;
-crate use self::vPtr::*;
+pub(crate) mod vPtr;
+pub(crate) use self::vPtr::*;
diff --git a/third_party/rust/packed_simd/src/codegen/bit_manip.rs b/third_party/rust/packed_simd_2/src/codegen/bit_manip.rs
similarity index 96%
rename from third_party/rust/packed_simd/src/codegen/bit_manip.rs
rename to third_party/rust/packed_simd_2/src/codegen/bit_manip.rs
index 83c7d1987cac..32d8d717a076 100644
--- a/third_party/rust/packed_simd/src/codegen/bit_manip.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/bit_manip.rs
@@ -1,7 +1,7 @@
 //! LLVM bit manipulation intrinsics.
 #[rustfmt::skip]
 
-use crate::*;
+pub(crate) use crate::*;
 
 #[allow(improper_ctypes, dead_code)]
 extern "C" {
@@ -147,7 +147,7 @@ extern "C" {
     fn ctpop_u128x4(x: u128x4) -> u128x4;
 }
 
-crate trait BitManip {
+pub(crate) trait BitManip {
     fn ctpop(self) -> Self;
     fn ctlz(self) -> Self;
     fn cttz(self) -> Self;
@@ -212,8 +212,7 @@ macro_rules! impl_bit_manip {
             fn ctpop(self) -> Self {
                 let mut ones = self;
                 for i in 0..Self::lanes() {
-                    ones = ones
-                        .replace(i, self.extract(i).count_ones() as $scalar);
+                    ones = ones.replace(i, self.extract(i).count_ones() as $scalar);
                 }
                 ones
             }
@@ -222,10 +221,7 @@ macro_rules! impl_bit_manip {
             fn ctlz(self) -> Self {
                 let mut lz = self;
                 for i in 0..Self::lanes() {
-                    lz = lz.replace(
-                        i,
-                        self.extract(i).leading_zeros() as $scalar,
-                    );
+                    lz = lz.replace(i, self.extract(i).leading_zeros() as $scalar);
                 }
                 lz
             }
@@ -234,10 +230,7 @@ macro_rules! impl_bit_manip {
             fn cttz(self) -> Self {
                 let mut tz = self;
                 for i in 0..Self::lanes() {
-                    tz = tz.replace(
-                        i,
-                        self.extract(i).trailing_zeros() as $scalar,
-                    );
+                    tz = tz.replace(i, self.extract(i).trailing_zeros() as $scalar);
                 }
                 tz
             }
diff --git a/third_party/rust/packed_simd_2/src/codegen/llvm.rs b/third_party/rust/packed_simd_2/src/codegen/llvm.rs
new file mode 100644
index 000000000000..b4c09849bc4a
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/codegen/llvm.rs
@@ -0,0 +1,128 @@
+//! LLVM's platform intrinsics
+#![allow(dead_code)]
+
+use crate::sealed::Shuffle;
+#[allow(unused_imports)] // FIXME: spurious warning?
+use crate::sealed::Simd;
+
+// Shuffle intrinsics: expanded in users' crates, therefore public.
+extern "platform-intrinsic" {
+    pub fn simd_shuffle2<T, U>(x: T, y: T, idx: [u32; 2]) -> U;
+    pub fn simd_shuffle4<T, U>(x: T, y: T, idx: [u32; 4]) -> U;
+    pub fn simd_shuffle8<T, U>(x: T, y: T, idx: [u32; 8]) -> U;
+    pub fn simd_shuffle16<T, U>(x: T, y: T, idx: [u32; 16]) -> U;
+    pub fn simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U;
+    pub fn simd_shuffle64<T, U>(x: T, y: T, idx: [u32; 64]) -> U;
+}
+
+#[allow(clippy::missing_safety_doc)]
+#[inline]
+pub unsafe fn __shuffle_vector2<const IDX: [u32; 2], T, U>(x: T, y: T) -> U
+where
+    T: Simd,
+    <T as Simd>::Element: Shuffle<[u32; 2], Output = U>,
+{
+    simd_shuffle2(x, y, IDX)
+}
+
+#[allow(clippy::missing_safety_doc)]
+#[inline]
+pub unsafe fn __shuffle_vector4<const IDX: [u32; 4], T, U>(x: T, y: T) -> U
+where
+    T: Simd,
+    <T as Simd>::Element: Shuffle<[u32; 4], Output = U>,
+{
+    simd_shuffle4(x, y, IDX)
+}
+
+#[allow(clippy::missing_safety_doc)]
+#[inline]
+pub unsafe fn __shuffle_vector8<const IDX: [u32; 8], T, U>(x: T, y: T) -> U
+where
+    T: Simd,
+    <T as Simd>::Element: Shuffle<[u32; 8], Output = U>,
+{
+    simd_shuffle8(x, y, IDX)
+}
+
+#[allow(clippy::missing_safety_doc)]
+#[inline]
+pub unsafe fn __shuffle_vector16<const IDX: [u32; 16], T, U>(x: T, y: T) -> U
+where
+    T: Simd,
+    <T as Simd>::Element: Shuffle<[u32; 16], Output = U>,
+{
+    simd_shuffle16(x, y, IDX)
+}
+
+#[allow(clippy::missing_safety_doc)]
+#[inline]
+pub unsafe fn __shuffle_vector32<const IDX: [u32; 32], T, U>(x: T, y: T) -> U
+where
+    T: Simd,
+    <T as Simd>::Element: Shuffle<[u32; 32], Output = U>,
+{
+    simd_shuffle32(x, y, IDX)
+}
+
+#[allow(clippy::missing_safety_doc)]
+#[inline]
+pub unsafe fn __shuffle_vector64<const IDX: [u32; 64], T, U>(x: T, y: T) -> U
+where
+    T: Simd,
+    <T as Simd>::Element: Shuffle<[u32; 64], Output = U>,
+{
+    simd_shuffle64(x, y, IDX)
+}
+
+extern "platform-intrinsic" {
+    pub(crate) fn simd_eq<T, U>(x: T, y: T) -> U;
+    pub(crate) fn simd_ne<T, U>(x: T, y: T) -> U;
+    pub(crate) fn simd_lt<T, U>(x: T, y: T) -> U;
+    pub(crate) fn simd_le<T, U>(x: T, y: T) -> U;
+    pub(crate) fn simd_gt<T, U>(x: T, y: T) -> U;
+    pub(crate) fn simd_ge<T, U>(x: T, y: T) -> U;
+
+    pub(crate) fn simd_insert<T, U>(x: T, idx: u32, val: U) -> T;
+    pub(crate) fn simd_extract<T, U>(x: T, idx: u32) -> U;
+
+    pub(crate) fn simd_cast<T, U>(x: T) -> U;
+
+    pub(crate) fn simd_add<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_sub<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_mul<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_div<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_rem<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_shl<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_shr<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_and<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_or<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_xor<T>(x: T, y: T) -> T;
+
+    pub(crate) fn simd_reduce_add_unordered<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_mul_unordered<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_add_ordered<T, U>(x: T, acc: U) -> U;
+    pub(crate) fn simd_reduce_mul_ordered<T, U>(x: T, acc: U) -> U;
+    pub(crate) fn simd_reduce_min<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_max<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_min_nanless<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_max_nanless<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_and<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_or<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_xor<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_all<T>(x: T) -> bool;
+    pub(crate) fn simd_reduce_any<T>(x: T) -> bool;
+
+    pub(crate) fn simd_select<M, T>(m: M, a: T, b: T) -> T;
+
+    pub(crate) fn simd_fmin<T>(a: T, b: T) -> T;
+    pub(crate) fn simd_fmax<T>(a: T, b: T) -> T;
+
+    pub(crate) fn simd_fsqrt<T>(a: T) -> T;
+    pub(crate) fn simd_fma<T>(a: T, b: T, c: T) -> T;
+
+    pub(crate) fn simd_gather<T, P, M>(value: T, pointers: P, mask: M) -> T;
+    pub(crate) fn simd_scatter<T, P, M>(value: T, pointers: P, mask: M);
+
+    pub(crate) fn simd_bitmask<T, U>(value: T) -> U;
+}
diff --git a/third_party/rust/packed_simd/src/codegen/math.rs b/third_party/rust/packed_simd_2/src/codegen/math.rs
similarity index 57%
rename from third_party/rust/packed_simd/src/codegen/math.rs
rename to third_party/rust/packed_simd_2/src/codegen/math.rs
index f3997c7f1135..9a0ea7a4e2d2 100644
--- a/third_party/rust/packed_simd/src/codegen/math.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math.rs
@@ -1,3 +1,3 @@
 //! Vertical math operations
 
-crate mod float;
+pub(crate) mod float;
diff --git a/third_party/rust/packed_simd_2/src/codegen/math/float.rs b/third_party/rust/packed_simd_2/src/codegen/math/float.rs
new file mode 100644
index 000000000000..ffbf18bfe989
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float.rs
@@ -0,0 +1,18 @@
+//! Vertical floating-point math operations.
+#![allow(clippy::useless_transmute)]
+
+#[macro_use]
+pub(crate) mod macros;
+pub(crate) mod abs;
+pub(crate) mod cos;
+pub(crate) mod cos_pi;
+pub(crate) mod exp;
+pub(crate) mod ln;
+pub(crate) mod mul_add;
+pub(crate) mod mul_adde;
+pub(crate) mod powf;
+pub(crate) mod sin;
+pub(crate) mod sin_cos_pi;
+pub(crate) mod sin_pi;
+pub(crate) mod sqrt;
+pub(crate) mod sqrte;
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/abs.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/abs.rs
similarity index 99%
rename from third_party/rust/packed_simd/src/codegen/math/float/abs.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/abs.rs
index bc4421f61de2..34aacc25be75 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/abs.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/abs.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait Abs {
+pub(crate) trait Abs {
     fn abs(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/cos.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/cos.rs
similarity index 99%
rename from third_party/rust/packed_simd/src/codegen/math/float/cos.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/cos.rs
index 50f6c16da255..dec390cb74d4 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/cos.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/cos.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait Cos {
+pub(crate) trait Cos {
     fn cos(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/cos_pi.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/cos_pi.rs
similarity index 99%
rename from third_party/rust/packed_simd/src/codegen/math/float/cos_pi.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/cos_pi.rs
index ebff5fd1c751..e283280ee44b 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/cos_pi.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/cos_pi.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait CosPi {
+pub(crate) trait CosPi {
     fn cos_pi(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/exp.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/exp.rs
similarity index 99%
rename from third_party/rust/packed_simd/src/codegen/math/float/exp.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/exp.rs
index 00d10e9fa644..a7b20580e3f1 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/exp.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/exp.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait Exp {
+pub(crate) trait Exp {
     fn exp(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/ln.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/ln.rs
similarity index 99%
rename from third_party/rust/packed_simd/src/codegen/math/float/ln.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/ln.rs
index 88a5a6c6c158..a5e38cb40d1e 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/ln.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/ln.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait Ln {
+pub(crate) trait Ln {
     fn ln(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/macros.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/macros.rs
similarity index 80%
rename from third_party/rust/packed_simd/src/codegen/math/float/macros.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/macros.rs
index 02d0ca3f5c7a..8daee1afe205 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/macros.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/macros.rs
@@ -1,7 +1,6 @@
 //! Utility macros
 #![allow(unused)]
 
-
 macro_rules! impl_unary_ {
     // implementation mapping 1:1
     (vec | $trait_id:ident, $trait_method:ident, $vec_id:ident,
@@ -64,10 +63,8 @@ macro_rules! impl_unary_ {
 
                     let mut halves = U { vec: self }.halves;
 
-                    *halves.get_unchecked_mut(0) =
-                        transmute($fun(transmute(*halves.get_unchecked(0))));
-                    *halves.get_unchecked_mut(1) =
-                        transmute($fun(transmute(*halves.get_unchecked(1))));
+                    *halves.get_unchecked_mut(0) = transmute($fun(transmute(*halves.get_unchecked(0))));
+                    *halves.get_unchecked_mut(1) = transmute($fun(transmute(*halves.get_unchecked(1))));
 
                     U { halves }.vec
                 }
@@ -89,14 +86,10 @@ macro_rules! impl_unary_ {
 
                     let mut quarters = U { vec: self }.quarters;
 
-                    *quarters.get_unchecked_mut(0) =
-                        transmute($fun(transmute(*quarters.get_unchecked(0))));
-                    *quarters.get_unchecked_mut(1) =
-                        transmute($fun(transmute(*quarters.get_unchecked(1))));
-                    *quarters.get_unchecked_mut(2) =
-                        transmute($fun(transmute(*quarters.get_unchecked(2))));
-                    *quarters.get_unchecked_mut(3) =
-                        transmute($fun(transmute(*quarters.get_unchecked(3))));
+                    *quarters.get_unchecked_mut(0) = transmute($fun(transmute(*quarters.get_unchecked(0))));
+                    *quarters.get_unchecked_mut(1) = transmute($fun(transmute(*quarters.get_unchecked(1))));
+                    *quarters.get_unchecked_mut(2) = transmute($fun(transmute(*quarters.get_unchecked(2))));
+                    *quarters.get_unchecked_mut(3) = transmute($fun(transmute(*quarters.get_unchecked(3))));
 
                     U { quarters }.vec
                 }
@@ -137,43 +130,19 @@ macro_rules! gen_unary_impl_table {
                 impl_unary_!(gen | $trait_id, $trait_method, $vid, $fun);
             };
             ($vid:ident[$sid:ident; $sc:expr]: $fun:ident) => {
-                impl_unary_!(
-                    scalar | $trait_id,
-                    $trait_method,
-                    $vid,
-                    [$sid; $sc],
-                    $fun
-                );
+                impl_unary_!(scalar | $trait_id, $trait_method, $vid, [$sid; $sc], $fun);
             };
             ($vid:ident[s]: $fun:ident) => {
                 impl_unary_!(scalar | $trait_id, $trait_method, $vid, $fun);
             };
             ($vid:ident[h => $vid_h:ident]: $fun:ident) => {
-                impl_unary_!(
-                    halves | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_h,
-                    $fun
-                );
+                impl_unary_!(halves | $trait_id, $trait_method, $vid, $vid_h, $fun);
             };
             ($vid:ident[q => $vid_q:ident]: $fun:ident) => {
-                impl_unary_!(
-                    quarter | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_q,
-                    $fun
-                );
+                impl_unary_!(quarter | $trait_id, $trait_method, $vid, $vid_q, $fun);
             };
             ($vid:ident[t => $vid_t:ident]: $fun:ident) => {
-                impl_unary_!(
-                    twice | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_t,
-                    $fun
-                );
+                impl_unary_!(twice | $trait_id, $trait_method, $vid, $vid_t, $fun);
             };
         }
     };
@@ -188,11 +157,7 @@ macro_rules! impl_tertiary_ {
             fn $trait_method(self, y: Self, z: Self) -> Self {
                 unsafe {
                     use crate::mem::transmute;
-                    transmute($fun(
-                        transmute(self),
-                        transmute(y),
-                        transmute(z),
-                    ))
+                    transmute($fun(transmute(self), transmute(y), transmute(z)))
                 }
             }
         }
@@ -314,11 +279,8 @@ macro_rules! impl_tertiary_ {
                     let x_twice = U { vec: [self, uninitialized()] }.twice;
                     let y_twice = U { vec: [y, uninitialized()] }.twice;
                     let z_twice = U { vec: [z, uninitialized()] }.twice;
-                    let twice: $vect_id = transmute($fun(
-                        transmute(x_twice),
-                        transmute(y_twice),
-                        transmute(z_twice),
-                    ));
+                    let twice: $vect_id =
+                        transmute($fun(transmute(x_twice), transmute(y_twice), transmute(z_twice)));
 
                     *(U { twice }.vec.get_unchecked(0))
                 }
@@ -334,43 +296,19 @@ macro_rules! gen_tertiary_impl_table {
                 impl_tertiary_!(vec | $trait_id, $trait_method, $vid, $fun);
             };
             ($vid:ident[$sid:ident; $sc:expr]: $fun:ident) => {
-                impl_tertiary_!(
-                    scalar | $trait_id,
-                    $trait_method,
-                    $vid,
-                    [$sid; $sc],
-                    $fun
-                );
+                impl_tertiary_!(scalar | $trait_id, $trait_method, $vid, [$sid; $sc], $fun);
             };
             ($vid:ident[s]: $fun:ident) => {
                 impl_tertiary_!(scalar | $trait_id, $trait_method, $vid, $fun);
             };
             ($vid:ident[h => $vid_h:ident]: $fun:ident) => {
-                impl_tertiary_!(
-                    halves | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_h,
-                    $fun
-                );
+                impl_tertiary_!(halves | $trait_id, $trait_method, $vid, $vid_h, $fun);
             };
             ($vid:ident[q => $vid_q:ident]: $fun:ident) => {
-                impl_tertiary_!(
-                    quarter | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_q,
-                    $fun
-                );
+                impl_tertiary_!(quarter | $trait_id, $trait_method, $vid, $vid_q, $fun);
             };
             ($vid:ident[t => $vid_t:ident]: $fun:ident) => {
-                impl_tertiary_!(
-                    twice | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_t,
-                    $fun
-                );
+                impl_tertiary_!(twice | $trait_id, $trait_method, $vid, $vid_t, $fun);
             };
         }
     };
@@ -497,10 +435,7 @@ macro_rules! impl_binary_ {
 
                     let x_twice = U { vec: [self, uninitialized()] }.twice;
                     let y_twice = U { vec: [y, uninitialized()] }.twice;
-                    let twice: $vect_id = transmute($fun(
-                        transmute(x_twice),
-                        transmute(y_twice),
-                    ));
+                    let twice: $vect_id = transmute($fun(transmute(x_twice), transmute(y_twice)));
 
                     *(U { twice }.vec.get_unchecked(0))
                 }
@@ -516,43 +451,19 @@ macro_rules! gen_binary_impl_table {
                 impl_binary_!(vec | $trait_id, $trait_method, $vid, $fun);
             };
             ($vid:ident[$sid:ident; $sc:expr]: $fun:ident) => {
-                impl_binary_!(
-                    scalar | $trait_id,
-                    $trait_method,
-                    $vid,
-                    [$sid; $sc],
-                    $fun
-                );
+                impl_binary_!(scalar | $trait_id, $trait_method, $vid, [$sid; $sc], $fun);
             };
             ($vid:ident[s]: $fun:ident) => {
                 impl_binary_!(scalar | $trait_id, $trait_method, $vid, $fun);
             };
             ($vid:ident[h => $vid_h:ident]: $fun:ident) => {
-                impl_binary_!(
-                    halves | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_h,
-                    $fun
-                );
+                impl_binary_!(halves | $trait_id, $trait_method, $vid, $vid_h, $fun);
             };
             ($vid:ident[q => $vid_q:ident]: $fun:ident) => {
-                impl_binary_!(
-                    quarter | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_q,
-                    $fun
-                );
+                impl_binary_!(quarter | $trait_id, $trait_method, $vid, $vid_q, $fun);
             };
             ($vid:ident[t => $vid_t:ident]: $fun:ident) => {
-                impl_binary_!(
-                    twice | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_t,
-                    $fun
-                );
+                impl_binary_!(twice | $trait_id, $trait_method, $vid, $vid_t, $fun);
             };
         }
     };
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/mul_add.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/mul_add.rs
similarity index 99%
rename from third_party/rust/packed_simd/src/codegen/math/float/mul_add.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/mul_add.rs
index f48a57dc46c6..d37f30fa8614 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/mul_add.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/mul_add.rs
@@ -4,7 +4,7 @@ use crate::*;
 
 // FIXME: 64-bit 1 element mul_add
 
-crate trait MulAdd {
+pub(crate) trait MulAdd {
     fn mul_add(self, y: Self, z: Self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/mul_adde.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/mul_adde.rs
similarity index 88%
rename from third_party/rust/packed_simd/src/codegen/math/float/mul_adde.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/mul_adde.rs
index 8c41fb131d94..c0baeacec20b 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/mul_adde.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/mul_adde.rs
@@ -3,7 +3,7 @@ use crate::*;
 
 // FIXME: 64-bit 1 element mul_adde
 
-crate trait MulAddE {
+pub(crate) trait MulAddE {
     fn mul_adde(self, y: Self, z: Self) -> Self;
 }
 
@@ -38,13 +38,7 @@ macro_rules! impl_mul_adde {
                 #[cfg(not(target_arch = "s390x"))]
                 {
                     use crate::mem::transmute;
-                    unsafe {
-                        transmute($fn(
-                            transmute(self),
-                            transmute(y),
-                            transmute(z),
-                        ))
-                    }
+                    unsafe { transmute($fn(transmute(self), transmute(y), transmute(z))) }
                 }
                 #[cfg(target_arch = "s390x")]
                 {
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/powf.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/powf.rs
similarity index 99%
rename from third_party/rust/packed_simd/src/codegen/math/float/powf.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/powf.rs
index bc15067d73a3..89ca52e96d81 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/powf.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/powf.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait Powf {
+pub(crate) trait Powf {
     fn powf(self, x: Self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/sin.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/sin.rs
similarity index 99%
rename from third_party/rust/packed_simd/src/codegen/math/float/sin.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/sin.rs
index 7b014d07da8d..d881415909af 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/sin.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/sin.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait Sin {
+pub(crate) trait Sin {
     fn sin(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/sin_cos_pi.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/sin_cos_pi.rs
similarity index 87%
rename from third_party/rust/packed_simd/src/codegen/math/float/sin_cos_pi.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/sin_cos_pi.rs
index 0f1249ec88f0..b283d11111fd 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/sin_cos_pi.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/sin_cos_pi.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait SinCosPi: Sized {
+pub(crate) trait SinCosPi: Sized {
     type Output;
     fn sin_cos_pi(self) -> Self::Output;
 }
@@ -85,17 +85,14 @@ macro_rules! impl_unary_t {
 
                     let halves = U { vec: self }.halves;
 
-                    let res_0: ($vid_h, $vid_h) =
-                        transmute($fun(transmute(*halves.get_unchecked(0))));
-                    let res_1: ($vid_h, $vid_h) =
-                        transmute($fun(transmute(*halves.get_unchecked(1))));
+                    let res_0: ($vid_h, $vid_h) = transmute($fun(transmute(*halves.get_unchecked(0))));
+                    let res_1: ($vid_h, $vid_h) = transmute($fun(transmute(*halves.get_unchecked(1))));
 
                     union R {
                         result: ($vid, $vid),
                         halves: ([$vid_h; 2], [$vid_h; 2]),
                     }
-                    R { halves: ([res_0.0, res_1.0], [res_0.1, res_1.1]) }
-                        .result
+                    R { halves: ([res_0.0, res_1.0], [res_0.1, res_1.1]) }.result
                 }
             }
         }
@@ -114,14 +111,10 @@ macro_rules! impl_unary_t {
 
                     let quarters = U { vec: self }.quarters;
 
-                    let res_0: ($vid_q, $vid_q) =
-                        transmute($fun(transmute(*quarters.get_unchecked(0))));
-                    let res_1: ($vid_q, $vid_q) =
-                        transmute($fun(transmute(*quarters.get_unchecked(1))));
-                    let res_2: ($vid_q, $vid_q) =
-                        transmute($fun(transmute(*quarters.get_unchecked(2))));
-                    let res_3: ($vid_q, $vid_q) =
-                        transmute($fun(transmute(*quarters.get_unchecked(3))));
+                    let res_0: ($vid_q, $vid_q) = transmute($fun(transmute(*quarters.get_unchecked(0))));
+                    let res_1: ($vid_q, $vid_q) = transmute($fun(transmute(*quarters.get_unchecked(1))));
+                    let res_2: ($vid_q, $vid_q) = transmute($fun(transmute(*quarters.get_unchecked(2))));
+                    let res_3: ($vid_q, $vid_q) = transmute($fun(transmute(*quarters.get_unchecked(3))));
 
                     union R {
                         result: ($vid, $vid),
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/sin_pi.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/sin_pi.rs
similarity index 99%
rename from third_party/rust/packed_simd/src/codegen/math/float/sin_pi.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/sin_pi.rs
index 72df98c93c91..0c8f6bb12050 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/sin_pi.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/sin_pi.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait SinPi {
+pub(crate) trait SinPi {
     fn sin_pi(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/sqrt.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/sqrt.rs
similarity index 99%
rename from third_party/rust/packed_simd/src/codegen/math/float/sqrt.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/sqrt.rs
index 7ce31df62662..67bb0a2a9c59 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/sqrt.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/sqrt.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait Sqrt {
+pub(crate) trait Sqrt {
     fn sqrt(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/sqrte.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/sqrte.rs
similarity index 99%
rename from third_party/rust/packed_simd/src/codegen/math/float/sqrte.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/sqrte.rs
index c1e379c34241..58a1de1f400f 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/sqrte.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/sqrte.rs
@@ -6,7 +6,7 @@
 use crate::llvm::simd_fsqrt;
 use crate::*;
 
-crate trait Sqrte {
+pub(crate) trait Sqrte {
     fn sqrte(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd_2/src/codegen/pointer_sized_int.rs b/third_party/rust/packed_simd_2/src/codegen/pointer_sized_int.rs
new file mode 100644
index 000000000000..55cbc297aaf5
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/codegen/pointer_sized_int.rs
@@ -0,0 +1,28 @@
+//! Provides `isize` and `usize`
+
+use cfg_if::cfg_if;
+
+cfg_if! {
+    if #[cfg(target_pointer_width = "8")] {
+        pub(crate) type isize_ = i8;
+        pub(crate) type usize_ = u8;
+    } else if #[cfg(target_pointer_width = "16")] {
+        pub(crate) type isize_ = i16;
+        pub(crate) type usize_ = u16;
+    } else if #[cfg(target_pointer_width = "32")] {
+        pub(crate) type isize_ = i32;
+        pub(crate) type usize_ = u32;
+
+    } else if #[cfg(target_pointer_width = "64")] {
+        pub(crate) type isize_ = i64;
+        pub(crate) type usize_ = u64;
+    } else if #[cfg(target_pointer_width = "64")] {
+        pub(crate) type isize_ = i64;
+        pub(crate) type usize_ = u64;
+    } else if #[cfg(target_pointer_width = "128")] {
+        pub(crate) type isize_ = i128;
+        pub(crate) type usize_ = u128;
+    } else {
+        compile_error!("unsupported target_pointer_width");
+    }
+}
diff --git a/third_party/rust/packed_simd_2/src/codegen/reductions.rs b/third_party/rust/packed_simd_2/src/codegen/reductions.rs
new file mode 100644
index 000000000000..302ca6d88f33
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions.rs
@@ -0,0 +1 @@
+pub(crate) mod mask;
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask.rs
similarity index 92%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask.rs
index 97260c6d4e03..a78bcc563267 100644
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask.rs
@@ -1,17 +1,17 @@
 //! Code generation workaround for `all()` mask horizontal reduction.
 //!
-//! Works arround [LLVM bug 36702].
+//! Works around [LLVM bug 36702].
 //!
 //! [LLVM bug 36702]: https://bugs.llvm.org/show_bug.cgi?id=36702
 #![allow(unused_macros)]
 
 use crate::*;
 
-crate trait All: crate::marker::Sized {
+pub(crate) trait All: crate::marker::Sized {
     unsafe fn all(self) -> bool;
 }
 
-crate trait Any: crate::marker::Sized {
+pub(crate) trait Any: crate::marker::Sized {
     unsafe fn any(self) -> bool;
 }
 
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/aarch64.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/aarch64.rs
similarity index 72%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/aarch64.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/aarch64.rs
index e9586eace1ff..b2db52c891c1 100644
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask/aarch64.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/aarch64.rs
@@ -19,7 +19,7 @@ macro_rules! aarch64_128_neon_impl {
                 $vmax(crate::mem::transmute(self)) != 0
             }
         }
-    }
+    };
 }
 
 /// 64-bit wide vectors
@@ -35,9 +35,7 @@ macro_rules! aarch64_64_neon_impl {
                     halves: ($id, $id),
                     vec: $vec128,
                 }
-                U {
-                    halves: (self, self),
-                }.vec.all()
+                U { halves: (self, self) }.vec.all()
             }
         }
         impl Any for $id {
@@ -48,9 +46,7 @@ macro_rules! aarch64_64_neon_impl {
                     halves: ($id, $id),
                     vec: $vec128,
                 }
-                U {
-                    halves: (self, self),
-                }.vec.any()
+                U { halves: (self, self) }.vec.any()
             }
         }
     };
@@ -59,13 +55,27 @@ macro_rules! aarch64_64_neon_impl {
 /// Mask reduction implementation for `aarch64` targets
 macro_rules! impl_mask_reductions {
     // 64-bit wide masks
-    (m8x8) => { aarch64_64_neon_impl!(m8x8, m8x16); };
-    (m16x4) => { aarch64_64_neon_impl!(m16x4, m16x8); };
-    (m32x2) => { aarch64_64_neon_impl!(m32x2, m32x4); };
+    (m8x8) => {
+        aarch64_64_neon_impl!(m8x8, m8x16);
+    };
+    (m16x4) => {
+        aarch64_64_neon_impl!(m16x4, m16x8);
+    };
+    (m32x2) => {
+        aarch64_64_neon_impl!(m32x2, m32x4);
+    };
     // 128-bit wide masks
-    (m8x16) => { aarch64_128_neon_impl!(m8x16, vminvq_u8, vmaxvq_u8); };
-    (m16x8) => { aarch64_128_neon_impl!(m16x8, vminvq_u16, vmaxvq_u16); };
-    (m32x4) => { aarch64_128_neon_impl!(m32x4, vminvq_u32, vmaxvq_u32); };
+    (m8x16) => {
+        aarch64_128_neon_impl!(m8x16, vminvq_u8, vmaxvq_u8);
+    };
+    (m16x8) => {
+        aarch64_128_neon_impl!(m16x8, vminvq_u16, vmaxvq_u16);
+    };
+    (m32x4) => {
+        aarch64_128_neon_impl!(m32x4, vminvq_u32, vmaxvq_u32);
+    };
     // Fallback to LLVM's default code-generation:
-    ($id:ident) => { fallback_impl!($id); };
+    ($id:ident) => {
+        fallback_impl!($id);
+    };
 }
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/arm.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/arm.rs
similarity index 69%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/arm.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/arm.rs
index 1987af7a9676..41c3cbc58afa 100644
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask/arm.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/arm.rs
@@ -15,10 +15,7 @@ macro_rules! arm_128_v7_neon_impl {
                     vec: $id,
                 }
                 let halves = U { vec: self }.halves;
-                let h: $half = transmute($vpmin(
-                    transmute(halves.0),
-                    transmute(halves.1),
-                ));
+                let h: $half = transmute($vpmin(transmute(halves.0), transmute(halves.1)));
                 h.all()
             }
         }
@@ -33,10 +30,7 @@ macro_rules! arm_128_v7_neon_impl {
                     vec: $id,
                 }
                 let halves = U { vec: self }.halves;
-                let h: $half = transmute($vpmax(
-                    transmute(halves.0),
-                    transmute(halves.1),
-                ));
+                let h: $half = transmute($vpmax(transmute(halves.0), transmute(halves.1)));
                 h.any()
             }
         }
@@ -46,9 +40,17 @@ macro_rules! arm_128_v7_neon_impl {
 /// Mask reduction implementation for `arm` targets
 macro_rules! impl_mask_reductions {
     // 128-bit wide masks
-    (m8x16) => { arm_128_v7_neon_impl!(m8x16, m8x8, vpmin_u8, vpmax_u8); };
-    (m16x8) => { arm_128_v7_neon_impl!(m16x8, m16x4, vpmin_u16, vpmax_u16); };
-    (m32x4) => { arm_128_v7_neon_impl!(m32x4, m32x2, vpmin_u32, vpmax_u32); };
+    (m8x16) => {
+        arm_128_v7_neon_impl!(m8x16, m8x8, vpmin_u8, vpmax_u8);
+    };
+    (m16x8) => {
+        arm_128_v7_neon_impl!(m16x8, m16x4, vpmin_u16, vpmax_u16);
+    };
+    (m32x4) => {
+        arm_128_v7_neon_impl!(m32x4, m32x2, vpmin_u32, vpmax_u32);
+    };
     // Fallback to LLVM's default code-generation:
-    ($id:ident) => { fallback_impl!($id); };
+    ($id:ident) => {
+        fallback_impl!($id);
+    };
 }
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/fallback.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/fallback.rs
similarity index 68%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/fallback.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/fallback.rs
index 25e5c813abca..4c377a68784e 100644
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask/fallback.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/fallback.rs
@@ -2,5 +2,7 @@
 
 /// Default mask reduction implementation
 macro_rules! impl_mask_reductions {
-    ($id:ident) => { fallback_impl!($id); };
+    ($id:ident) => {
+        fallback_impl!($id);
+    };
 }
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/fallback_impl.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/fallback_impl.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/fallback_impl.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/fallback_impl.rs
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86.rs
similarity index 80%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/x86.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86.rs
index bcfb1a6e1772..4bf509806545 100644
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86.rs
@@ -114,17 +114,17 @@ macro_rules! x86_m64x4_impl {
 /// Fallback implementation.
 macro_rules! x86_intr_impl {
     ($id:ident) => {
-    impl All for $id {
-        #[inline]
-        unsafe fn all(self) -> bool {
-        use crate::llvm::simd_reduce_all;
-            simd_reduce_all(self.0)
+        impl All for $id {
+            #[inline]
+            unsafe fn all(self) -> bool {
+                use crate::llvm::simd_reduce_all;
+                simd_reduce_all(self.0)
+            }
         }
-    }
         impl Any for $id {
             #[inline]
             unsafe fn any(self) -> bool {
-            use crate::llvm::simd_reduce_any;
+                use crate::llvm::simd_reduce_any;
                 simd_reduce_any(self.0)
             }
         }
@@ -134,21 +134,47 @@ macro_rules! x86_intr_impl {
 /// Mask reduction implementation for `x86` and `x86_64` targets
 macro_rules! impl_mask_reductions {
     // 64-bit wide masks
-    (m8x8) => { x86_m8x8_impl!(m8x8); };
-    (m16x4) => { x86_m8x8_impl!(m16x4); };
-    (m32x2) => { x86_m8x8_impl!(m32x2); };
+    (m8x8) => {
+        x86_m8x8_impl!(m8x8);
+    };
+    (m16x4) => {
+        x86_m8x8_impl!(m16x4);
+    };
+    (m32x2) => {
+        x86_m8x8_impl!(m32x2);
+    };
     // 128-bit wide masks
-    (m8x16) => { x86_m8x16_impl!(m8x16); };
-    (m16x8) => { x86_m8x16_impl!(m16x8); };
-    (m32x4) => { x86_m32x4_impl!(m32x4); };
-    (m64x2) => { x86_m64x2_impl!(m64x2); };
-    (m128x1) => { x86_intr_impl!(m128x1); };
+    (m8x16) => {
+        x86_m8x16_impl!(m8x16);
+    };
+    (m16x8) => {
+        x86_m8x16_impl!(m16x8);
+    };
+    (m32x4) => {
+        x86_m32x4_impl!(m32x4);
+    };
+    (m64x2) => {
+        x86_m64x2_impl!(m64x2);
+    };
+    (m128x1) => {
+        x86_intr_impl!(m128x1);
+    };
     // 256-bit wide masks:
-    (m8x32) => { x86_m8x32_impl!(m8x32, m8x16); };
-    (m16x16) => { x86_m8x32_impl!(m16x16, m16x8); };
-    (m32x8) => { x86_m32x8_impl!(m32x8, m32x4); };
-    (m64x4) => { x86_m64x4_impl!(m64x4, m64x2); };
-    (m128x2) => { x86_intr_impl!(m128x2); };
+    (m8x32) => {
+        x86_m8x32_impl!(m8x32, m8x16);
+    };
+    (m16x16) => {
+        x86_m8x32_impl!(m16x16, m16x8);
+    };
+    (m32x8) => {
+        x86_m32x8_impl!(m32x8, m32x4);
+    };
+    (m64x4) => {
+        x86_m64x4_impl!(m64x4, m64x2);
+    };
+    (m128x2) => {
+        x86_intr_impl!(m128x2);
+    };
     (msizex2) => {
         cfg_if! {
             if #[cfg(target_pointer_width = "64")] {
@@ -184,5 +210,7 @@ macro_rules! impl_mask_reductions {
     };
 
     // Fallback to LLVM's default code-generation:
-    ($id:ident) => { fallback_impl!($id); };
+    ($id:ident) => {
+        fallback_impl!($id);
+    };
 }
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/avx.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/avx.rs
similarity index 91%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/x86/avx.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/avx.rs
index d18736fb0399..61f352d22839 100644
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/avx.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/avx.rs
@@ -13,10 +13,7 @@ macro_rules! x86_m8x32_avx_impl {
                 use crate::arch::x86::_mm256_testc_si256;
                 #[cfg(target_arch = "x86_64")]
                 use crate::arch::x86_64::_mm256_testc_si256;
-                _mm256_testc_si256(
-                    crate::mem::transmute(self),
-                    crate::mem::transmute($id::splat(true)),
-                ) != 0
+                _mm256_testc_si256(crate::mem::transmute(self), crate::mem::transmute($id::splat(true))) != 0
             }
         }
         impl Any for $id {
@@ -27,10 +24,7 @@ macro_rules! x86_m8x32_avx_impl {
                 use crate::arch::x86::_mm256_testz_si256;
                 #[cfg(target_arch = "x86_64")]
                 use crate::arch::x86_64::_mm256_testz_si256;
-                _mm256_testz_si256(
-                    crate::mem::transmute(self),
-                    crate::mem::transmute(self),
-                ) == 0
+                _mm256_testz_si256(crate::mem::transmute(self), crate::mem::transmute(self)) == 0
             }
         }
     };
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/avx2.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/avx2.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/x86/avx2.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/avx2.rs
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/sse.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/sse.rs
similarity index 92%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/x86/sse.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/sse.rs
index eb1ef7fac922..e0c9aee92bd9 100644
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/sse.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/sse.rs
@@ -16,8 +16,7 @@ macro_rules! x86_m32x4_sse_impl {
                 // most significant bit of each lane of `a`. If all
                 // bits are set, then all 4 lanes of the mask are
                 // true.
-                _mm_movemask_ps(crate::mem::transmute(self))
-                    == 0b_1111_i32
+                _mm_movemask_ps(crate::mem::transmute(self)) == 0b_1111_i32
             }
         }
         impl Any for $id {
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/sse2.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/sse2.rs
similarity index 92%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/x86/sse2.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/sse2.rs
index a99c606f5268..bbb52fa47e02 100644
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/sse2.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/sse2.rs
@@ -16,8 +16,7 @@ macro_rules! x86_m64x2_sse2_impl {
                 // most significant bit of each lane of `a`. If all
                 // bits are set, then all 2 lanes of the mask are
                 // true.
-                _mm_movemask_pd(crate::mem::transmute(self))
-                    == 0b_11_i32
+                _mm_movemask_pd(crate::mem::transmute(self)) == 0b_11_i32
             }
         }
         impl Any for $id {
@@ -50,8 +49,7 @@ macro_rules! x86_m8x16_sse2_impl {
                 // most significant bit of each byte of `a`. If all
                 // bits are set, then all 16 lanes of the mask are
                 // true.
-                _mm_movemask_epi8(crate::mem::transmute(self))
-                    == i32::from(u16::max_value())
+                _mm_movemask_epi8(crate::mem::transmute(self)) == i32::from(u16::max_value())
             }
         }
         impl Any for $id {
diff --git a/third_party/rust/packed_simd/src/codegen/shuffle.rs b/third_party/rust/packed_simd_2/src/codegen/shuffle.rs
similarity index 99%
rename from third_party/rust/packed_simd/src/codegen/shuffle.rs
rename to third_party/rust/packed_simd_2/src/codegen/shuffle.rs
index d92c9ee22427..d3acd48f5bed 100644
--- a/third_party/rust/packed_simd/src/codegen/shuffle.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/shuffle.rs
@@ -2,7 +2,7 @@
 //! lanes and vector element types.
 
 use crate::masks::*;
-use crate::sealed::{Shuffle, Seal};
+use crate::sealed::{Seal, Shuffle};
 
 macro_rules! impl_shuffle {
     ($array:ty, $base:ty, $out:ty) => {
@@ -10,7 +10,7 @@ macro_rules! impl_shuffle {
         impl Shuffle<$array> for $base {
             type Output = $out;
         }
-    }
+    };
 }
 
 impl_shuffle! { [u32; 2], i8, crate::codegen::i8x2 }
diff --git a/third_party/rust/packed_simd/src/codegen/shuffle1_dyn.rs b/third_party/rust/packed_simd_2/src/codegen/shuffle1_dyn.rs
similarity index 96%
rename from third_party/rust/packed_simd/src/codegen/shuffle1_dyn.rs
rename to third_party/rust/packed_simd_2/src/codegen/shuffle1_dyn.rs
index a5403a06bb6e..19d457a45bfc 100644
--- a/third_party/rust/packed_simd/src/codegen/shuffle1_dyn.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/shuffle1_dyn.rs
@@ -16,8 +16,7 @@ macro_rules! impl_fallback {
             fn shuffle1_dyn(self, indices: Self::Indices) -> Self {
                 let mut result = Self::splat(0);
                 for i in 0..$id::lanes() {
-                    result = result
-                        .replace(i, self.extract(indices.extract(i) as usize));
+                    result = result.replace(i, self.extract(indices.extract(i) as usize));
                 }
                 result
             }
@@ -150,16 +149,12 @@ macro_rules! impl_shuffle1_dyn {
             #[inline]
             fn shuffle1_dyn(self, indices: Self::Indices) -> Self {
                 let indices: u8x8 = (indices * 2).cast();
-                let indices: u8x16 = shuffle!(
-                    indices, [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7]
-                );
-                let v = u8x16::new(
-                    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
-                );
+                let indices: u8x16 = shuffle!(indices, [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7]);
+                let v = u8x16::new(0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1);
                 let indices = indices + v;
                 unsafe {
-                    let s: u8x16 =crate::mem::transmute(self);
-                   crate::mem::transmute(s.shuffle1_dyn(indices))
+                    let s: u8x16 = crate::mem::transmute(self);
+                    crate::mem::transmute(s.shuffle1_dyn(indices))
                 }
             }
         }
@@ -268,7 +263,9 @@ macro_rules! impl_shuffle1_dyn {
             }
         }
     };
-    ($id:ident) => { impl_fallback!($id); }
+    ($id:ident) => {
+        impl_fallback!($id);
+    };
 }
 
 impl_shuffle1_dyn!(u8x2);
diff --git a/third_party/rust/packed_simd/src/codegen/swap_bytes.rs b/third_party/rust/packed_simd_2/src/codegen/swap_bytes.rs
similarity index 88%
rename from third_party/rust/packed_simd/src/codegen/swap_bytes.rs
rename to third_party/rust/packed_simd_2/src/codegen/swap_bytes.rs
index b435fb5da120..9cf34a3e0401 100644
--- a/third_party/rust/packed_simd/src/codegen/swap_bytes.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/swap_bytes.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait SwapBytes {
+pub(crate) trait SwapBytes {
     fn swap_bytes(self) -> Self;
 }
 
@@ -15,7 +15,7 @@ macro_rules! impl_swap_bytes {
             impl SwapBytes for $id {
                 #[inline]
                 fn swap_bytes(self) -> Self {
-                    unsafe { shuffle!(self, [1, 0]) }
+                    shuffle!(self, [1, 0])
                 }
             }
         )+
@@ -119,52 +119,12 @@ macro_rules! impl_swap_bytes {
 impl_swap_bytes!(v16: u8x2, i8x2,);
 impl_swap_bytes!(v32: u8x4, i8x4, u16x2, i16x2,);
 // FIXME: 64-bit single element vector
-impl_swap_bytes!(
-    v64: u8x8,
-    i8x8,
-    u16x4,
-    i16x4,
-    u32x2,
-    i32x2, /* u64x1, i64x1, */
-);
+impl_swap_bytes!(v64: u8x8, i8x8, u16x4, i16x4, u32x2, i32x2 /* u64x1, i64x1, */,);
 
-impl_swap_bytes!(
-    v128: u8x16,
-    i8x16,
-    u16x8,
-    i16x8,
-    u32x4,
-    i32x4,
-    u64x2,
-    i64x2,
-    u128x1,
-    i128x1,
-);
-impl_swap_bytes!(
-    v256: u8x32,
-    i8x32,
-    u16x16,
-    i16x16,
-    u32x8,
-    i32x8,
-    u64x4,
-    i64x4,
-    u128x2,
-    i128x2,
-);
+impl_swap_bytes!(v128: u8x16, i8x16, u16x8, i16x8, u32x4, i32x4, u64x2, i64x2, u128x1, i128x1,);
+impl_swap_bytes!(v256: u8x32, i8x32, u16x16, i16x16, u32x8, i32x8, u64x4, i64x4, u128x2, i128x2,);
 
-impl_swap_bytes!(
-    v512: u8x64,
-    i8x64,
-    u16x32,
-    i16x32,
-    u32x16,
-    i32x16,
-    u64x8,
-    i64x8,
-    u128x4,
-    i128x4,
-);
+impl_swap_bytes!(v512: u8x64, i8x64, u16x32, i16x32, u32x16, i32x16, u64x8, i64x8, u128x4, i128x4,);
 
 cfg_if! {
     if #[cfg(target_pointer_width = "8")] {
diff --git a/third_party/rust/packed_simd/src/codegen/v128.rs b/third_party/rust/packed_simd_2/src/codegen/v128.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/v128.rs
rename to third_party/rust/packed_simd_2/src/codegen/v128.rs
diff --git a/third_party/rust/packed_simd/src/codegen/v16.rs b/third_party/rust/packed_simd_2/src/codegen/v16.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/v16.rs
rename to third_party/rust/packed_simd_2/src/codegen/v16.rs
diff --git a/third_party/rust/packed_simd/src/codegen/v256.rs b/third_party/rust/packed_simd_2/src/codegen/v256.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/v256.rs
rename to third_party/rust/packed_simd_2/src/codegen/v256.rs
diff --git a/third_party/rust/packed_simd/src/codegen/v32.rs b/third_party/rust/packed_simd_2/src/codegen/v32.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/v32.rs
rename to third_party/rust/packed_simd_2/src/codegen/v32.rs
diff --git a/third_party/rust/packed_simd/src/codegen/v512.rs b/third_party/rust/packed_simd_2/src/codegen/v512.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/v512.rs
rename to third_party/rust/packed_simd_2/src/codegen/v512.rs
diff --git a/third_party/rust/packed_simd/src/codegen/v64.rs b/third_party/rust/packed_simd_2/src/codegen/v64.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/v64.rs
rename to third_party/rust/packed_simd_2/src/codegen/v64.rs
diff --git a/third_party/rust/packed_simd/src/codegen/vPtr.rs b/third_party/rust/packed_simd_2/src/codegen/vPtr.rs
similarity index 95%
rename from third_party/rust/packed_simd/src/codegen/vPtr.rs
rename to third_party/rust/packed_simd_2/src/codegen/vPtr.rs
index cf4765538178..abd3aa877920 100644
--- a/third_party/rust/packed_simd/src/codegen/vPtr.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/vPtr.rs
@@ -5,7 +5,7 @@ macro_rules! impl_simd_ptr {
      | $($tys:ty),*) => {
         #[derive(Copy, Clone)]
         #[repr(simd)]
-        pub struct $tuple_id<$ty>($(crate $tys),*);
+        pub struct $tuple_id<$ty>($(pub(crate) $tys),*);
         //^^^^^^^ leaked through SimdArray
 
         impl<$ty> crate::sealed::Seal for [$ptr_ty; $elem_count] {}
diff --git a/third_party/rust/packed_simd/src/codegen/vSize.rs b/third_party/rust/packed_simd_2/src/codegen/vSize.rs
similarity index 55%
rename from third_party/rust/packed_simd/src/codegen/vSize.rs
rename to third_party/rust/packed_simd_2/src/codegen/vSize.rs
index 3911b21340c8..d5db03991d61 100644
--- a/third_party/rust/packed_simd/src/codegen/vSize.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/vSize.rs
@@ -11,33 +11,6 @@ impl_simd_array!([isize; 4]: isizex4 | isize_, isize_, isize_, isize_);
 impl_simd_array!([usize; 4]: usizex4 | usize_, usize_, usize_, usize_);
 impl_simd_array!([msize; 4]: msizex4 | isize_, isize_, isize_, isize_);
 
-impl_simd_array!(
-    [isize; 8]: isizex8 | isize_,
-    isize_,
-    isize_,
-    isize_,
-    isize_,
-    isize_,
-    isize_,
-    isize_
-);
-impl_simd_array!(
-    [usize; 8]: usizex8 | usize_,
-    usize_,
-    usize_,
-    usize_,
-    usize_,
-    usize_,
-    usize_,
-    usize_
-);
-impl_simd_array!(
-    [msize; 8]: msizex8 | isize_,
-    isize_,
-    isize_,
-    isize_,
-    isize_,
-    isize_,
-    isize_,
-    isize_
-);
+impl_simd_array!([isize; 8]: isizex8 | isize_, isize_, isize_, isize_, isize_, isize_, isize_, isize_);
+impl_simd_array!([usize; 8]: usizex8 | usize_, usize_, usize_, usize_, usize_, usize_, usize_, usize_);
+impl_simd_array!([msize; 8]: msizex8 | isize_, isize_, isize_, isize_, isize_, isize_, isize_, isize_);
diff --git a/third_party/rust/packed_simd/src/lib.rs b/third_party/rust/packed_simd_2/src/lib.rs
similarity index 85%
rename from third_party/rust/packed_simd/src/lib.rs
rename to third_party/rust/packed_simd_2/src/lib.rs
index e3a747025f43..cd8a86805dd5 100644
--- a/third_party/rust/packed_simd/src/lib.rs
+++ b/third_party/rust/packed_simd_2/src/lib.rs
@@ -13,8 +13,8 @@
 //! - [Vector types](#vector-types)
 //! - [Conditional operations](#conditional-operations)
 //! - [Conversions](#conversions)
-//! - [Performance
-//!   guide](https://rust-lang-nursery.github.io/packed_simd/perf-guide/)
+//! - [Hardware Features](#hardware-features)
+//! - [Performance guide](https://rust-lang-nursery.github.io/packed_simd/perf-guide/)
 //!
 //! ## Introduction
 //!
@@ -26,7 +26,7 @@
 //! are applied to each vector lane in isolation of the others:
 //!
 //! ```
-//! # use packed_simd::*;
+//! # use packed_simd_2::*;
 //! let a = i32x4::new(1, 2, 3, 4);
 //! let b = i32x4::new(5, 6, 7, 8);
 //! assert_eq!(a + b, i32x4::new(6, 8, 10, 12));
@@ -35,7 +35,7 @@
 //! Many "horizontal" operations are also provided:
 //!
 //! ```
-//! # use packed_simd::*;
+//! # use packed_simd_2::*;
 //! # let a = i32x4::new(1, 2, 3, 4);
 //! assert_eq!(a.wrapping_sum(), 10);
 //! ```
@@ -47,9 +47,9 @@
 //! and performing a single horizontal operation at the end:
 //!
 //! ```
-//! # use packed_simd::*;
+//! # use packed_simd_2::*;
 //! fn reduce(x: &[i32]) -> i32 {
-//!     assert!(x.len() % 4 == 0);
+//!     assert_eq!(x.len() % 4, 0);
 //!     let mut sum = i32x4::splat(0); // [0, 0, 0, 0]
 //!     for i in (0..x.len()).step_by(4) {
 //!         sum += i32x4::from_slice_unaligned(&x[i..]);
@@ -79,7 +79,7 @@
 //! ## Basic operations
 //!
 //! ```
-//! # use packed_simd::*;
+//! # use packed_simd_2::*;
 //! // Sets all elements to `0`:
 //! let a = i32x4::splat(0);
 //!
@@ -107,7 +107,7 @@
 //! to be performed:
 //!
 //! ```
-//! # use packed_simd::*;
+//! # use packed_simd_2::*;
 //! let a = i32x4::new(1, 1, 2, 2);
 //!
 //! // Add `1` to the first two lanes of the vector.
@@ -134,13 +134,13 @@
 //! > of lanes as the mask. The example shows this by using [`m16x4`] instead
 //! > of [`m32x4`]. It is _typically_ more performant to use a mask element
 //! > width equal to the element width of the vectors being operated upon.
-//! > This is, however, not true for 512-bit wide vectors when targetting
+//! > This is, however, not true for 512-bit wide vectors when targeting
 //! > AVX-512, where the most efficient masks use only 1-bit per element.
 //!
 //! All vertical comparison operations returns masks:
 //!
 //! ```
-//! # use packed_simd::*;
+//! # use packed_simd_2::*;
 //! let a = i32x4::new(1, 1, 3, 3);
 //! let b = i32x4::new(2, 2, 0, 0);
 //!
@@ -168,11 +168,11 @@
 //!   u8x8 = m8x8::splat(true).into_bits();` is provided because all `m8x8` bit
 //!   patterns are valid `u8x8` bit patterns. However, the opposite is not
 //! true,   not all `u8x8` bit patterns are valid `m8x8` bit-patterns, so this
-//!   operation cannot be peformed safely using `x.into_bits()`; one needs to
+//!   operation cannot be performed safely using `x.into_bits()`; one needs to
 //!   use `unsafe { crate::mem::transmute(x) }` for that, making sure that the
 //!   value in the `u8x8` is a valid bit-pattern of `m8x8`.
 //!
-//! * **numeric casts** (`as`): are peformed using [`FromCast`]/[`Cast`]
+//! * **numeric casts** (`as`): are performed using [`FromCast`]/[`Cast`]
 //! (`x.cast()`), just like `as`:
 //!
 //!   * casting integer vectors whose lane types have the same size (e.g.
@@ -198,22 +198,32 @@
 //!
 //!   Numeric casts are not very "precise": sometimes lossy, sometimes value
 //!   preserving, etc.
+//!
+//! ## Hardware Features
+//!
+//! This crate can use different hardware features based on your configured
+//! `RUSTFLAGS`. For example, with no configured `RUSTFLAGS`, `u64x8` on
+//! x86_64 will use SSE2 operations like `PCMPEQD`. If you configure
+//! `RUSTFLAGS='-C target-feature=+avx2,+avx'` on supported x86_64 hardware
+//! the same `u64x8` may use wider AVX2 operations like `VPCMPEQQ`. It is
+//! important for performance and for hardware support requirements that
+//! you choose an appropriate set of `target-feature` and `target-cpu`
+//! options during builds. For more information, see the [Performance
+//! guide](https://rust-lang-nursery.github.io/packed_simd/perf-guide/)
 
-#![cfg_attr(const_generics, feature(const_generics))]
-#![cfg_attr(not(const_generics), feature(adt_const_params))]
 #![feature(
+    adt_const_params,
     repr_simd,
     rustc_attrs,
     platform_intrinsics,
     stdsimd,
-    aarch64_target_feature,
     arm_target_feature,
     link_llvm_intrinsics,
     core_intrinsics,
     stmt_expr_attributes,
-    crate_visibility_modifier,
-    custom_inner_attributes
+    custom_inner_attributes,
 )]
+#![cfg_attr(aarch64_target_feature, feature(aarch64_target_feature))]
 #![allow(non_camel_case_types, non_snake_case,
         // FIXME: these types are unsound in C FFI already
         // See https://github.com/rust-lang/rust/issues/53346
@@ -252,9 +262,8 @@ use wasm_bindgen_test::*;
 
 #[allow(unused_imports)]
 use core::{
-    /* arch (handled above), */ cmp, f32, f64, fmt, hash, hint, i128,
-    i16, i32, i64, i8, intrinsics, isize, iter, marker, mem, ops, ptr, slice,
-    u128, u16, u32, u64, u8, usize,
+    /* arch (handled above), */ cmp, f32, f64, fmt, hash, hint, i128, i16, i32, i64, i8, intrinsics,
+    isize, iter, marker, mem, ops, ptr, slice, u128, u16, u32, u64, u8, usize,
 };
 
 #[macro_use]
@@ -264,14 +273,14 @@ mod api;
 mod codegen;
 mod sealed;
 
-pub use crate::sealed::{Simd as SimdVector, Shuffle, SimdArray, Mask};
+pub use crate::sealed::{Mask, Shuffle, Simd as SimdVector, SimdArray};
 
 /// Packed SIMD vector type.
 ///
 /// # Examples
 ///
 /// ```
-/// # use packed_simd::Simd;
+/// # use packed_simd_2::Simd;
 /// let v = Simd::<[i32; 4]>::new(0, 1, 2, 3);
 /// assert_eq!(v.extract(2), 2);
 /// ```
@@ -330,10 +339,10 @@ pub use self::api::into_bits::*;
 // Re-export the shuffle intrinsics required by the `shuffle!` macro.
 #[doc(hidden)]
 pub use self::codegen::llvm::{
-    __shuffle_vector16, __shuffle_vector2, __shuffle_vector32,
-    __shuffle_vector4, __shuffle_vector64, __shuffle_vector8,
+    __shuffle_vector16, __shuffle_vector2, __shuffle_vector32, __shuffle_vector4, __shuffle_vector64,
+    __shuffle_vector8,
 };
 
-crate mod llvm {
-    crate use crate::codegen::llvm::*;
+pub(crate) mod llvm {
+    pub(crate) use crate::codegen::llvm::*;
 }
diff --git a/third_party/rust/packed_simd/src/masks.rs b/third_party/rust/packed_simd_2/src/masks.rs
similarity index 92%
rename from third_party/rust/packed_simd/src/masks.rs
rename to third_party/rust/packed_simd_2/src/masks.rs
index aeb36d232804..04534eab2ba0 100644
--- a/third_party/rust/packed_simd/src/masks.rs
+++ b/third_party/rust/packed_simd_2/src/masks.rs
@@ -54,9 +54,7 @@ macro_rules! impl_mask_ty {
 
         impl PartialOrd<$id> for $id {
             #[inline]
-            fn partial_cmp(
-                &self, other: &Self,
-            ) -> Option<crate::cmp::Ordering> {
+            fn partial_cmp(&self, other: &Self) -> Option<crate::cmp::Ordering> {
                 use crate::cmp::Ordering;
                 if self == other {
                     Some(Ordering::Equal)
@@ -107,9 +105,7 @@ macro_rules! impl_mask_ty {
 
         impl crate::fmt::Debug for $id {
             #[inline]
-            fn fmt(
-                &self, fmtter: &mut crate::fmt::Formatter<'_>,
-            ) -> Result<(), crate::fmt::Error> {
+            fn fmt(&self, fmtter: &mut crate::fmt::Formatter<'_>) -> Result<(), crate::fmt::Error> {
                 write!(fmtter, "{}({})", stringify!($id), self.0 != 0)
             }
         }
diff --git a/third_party/rust/packed_simd/src/sealed.rs b/third_party/rust/packed_simd_2/src/sealed.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/sealed.rs
rename to third_party/rust/packed_simd_2/src/sealed.rs
diff --git a/third_party/rust/packed_simd/src/testing.rs b/third_party/rust/packed_simd_2/src/testing.rs
similarity index 80%
rename from third_party/rust/packed_simd/src/testing.rs
rename to third_party/rust/packed_simd_2/src/testing.rs
index fcbcf9e2ac8e..6320b2805556 100644
--- a/third_party/rust/packed_simd/src/testing.rs
+++ b/third_party/rust/packed_simd_2/src/testing.rs
@@ -5,4 +5,4 @@ mod macros;
 
 #[cfg(test)]
 #[macro_use]
-crate mod utils;
+pub(crate) mod utils;
diff --git a/third_party/rust/packed_simd_2/src/testing/macros.rs b/third_party/rust/packed_simd_2/src/testing/macros.rs
new file mode 100644
index 000000000000..7bc4268b9002
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/testing/macros.rs
@@ -0,0 +1,44 @@
+//! Testing macros
+
+macro_rules! test_if {
+    ($cfg_tt:tt: $it:item) => {
+        #[cfg(any(
+                                                            // Test everything if:
+                                                            //
+                                                            // * tests are enabled,
+                                                            // * no features about exclusively testing
+                                                            //   specific vector classes are enabled
+                                                            all(test, not(any(
+                                                                test_v16,
+                                                                test_v32,
+                                                                test_v64,
+                                                                test_v128,
+                                                                test_v256,
+                                                                test_v512,
+                                                                test_none,  // disables all tests
+                                                            ))),
+                                                            // Test if:
+                                                            //
+                                                            // * tests are enabled
+                                                            // * a particular cfg token tree returns true
+                                                            all(test, $cfg_tt),
+                                                        ))]
+        $it
+    };
+}
+
+#[cfg(test)]
+#[allow(unused)]
+macro_rules! ref_ {
+    ($anything:tt) => {
+        &$anything
+    };
+}
+
+#[cfg(test)]
+#[allow(unused)]
+macro_rules! ref_mut_ {
+    ($anything:tt) => {
+        &mut $anything
+    };
+}
diff --git a/third_party/rust/packed_simd/src/testing/utils.rs b/third_party/rust/packed_simd_2/src/testing/utils.rs
similarity index 83%
rename from third_party/rust/packed_simd/src/testing/utils.rs
rename to third_party/rust/packed_simd_2/src/testing/utils.rs
index 21f27aae5432..7d8f39573964 100644
--- a/third_party/rust/packed_simd/src/testing/utils.rs
+++ b/third_party/rust/packed_simd_2/src/testing/utils.rs
@@ -7,16 +7,15 @@
 use crate::{cmp::PartialOrd, fmt::Debug, LexicographicallyOrdered};
 
 /// Tests PartialOrd for `a` and `b` where `a < b` is true.
-pub fn test_lt<T>(
-    a: LexicographicallyOrdered<T>, b: LexicographicallyOrdered<T>,
-) where
+pub fn test_lt<T>(a: LexicographicallyOrdered<T>, b: LexicographicallyOrdered<T>)
+where
     LexicographicallyOrdered<T>: Debug + PartialOrd,
 {
     assert!(a < b, "{:?}, {:?}", a, b);
     assert!(b > a, "{:?}, {:?}", a, b);
 
     assert!(!(a == b), "{:?}, {:?}", a, b);
-    assert!(a != b, "{:?}, {:?}", a, b);
+    assert_ne!(a, b, "{:?}, {:?}", a, b);
 
     assert!(a <= b, "{:?}, {:?}", a, b);
     assert!(b >= a, "{:?}, {:?}", a, b);
@@ -37,9 +36,8 @@ pub fn test_lt<T>(
 }
 
 /// Tests PartialOrd for `a` and `b` where `a <= b` is true.
-pub fn test_le<T>(
-    a: LexicographicallyOrdered<T>, b: LexicographicallyOrdered<T>,
-) where
+pub fn test_le<T>(a: LexicographicallyOrdered<T>, b: LexicographicallyOrdered<T>)
+where
     LexicographicallyOrdered<T>: Debug + PartialOrd,
 {
     assert!(a <= b, "{:?}, {:?}", a, b);
@@ -54,14 +52,15 @@ pub fn test_le<T>(
 
         assert!(!(a != b), "{:?}, {:?}", a, b);
     } else {
-        assert!(a != b, "{:?}, {:?}", a, b);
+        assert_ne!(a, b, "{:?}, {:?}", a, b);
         test_lt(a, b);
     }
 }
 
 /// Test PartialOrd::partial_cmp for `a` and `b` returning `Ordering`
 pub fn test_cmp<T>(
-    a: LexicographicallyOrdered<T>, b: LexicographicallyOrdered<T>,
+    a: LexicographicallyOrdered<T>,
+    b: LexicographicallyOrdered<T>,
     o: Option<crate::cmp::Ordering>,
 ) where
     LexicographicallyOrdered<T>: PartialOrd + Debug,
@@ -72,18 +71,8 @@ pub fn test_cmp<T>(
     let mut arr_a: [T::Element; 64] = [Default::default(); 64];
     let mut arr_b: [T::Element; 64] = [Default::default(); 64];
 
-    unsafe {
-        crate::ptr::write_unaligned(
-            arr_a.as_mut_ptr() as *mut LexicographicallyOrdered<T>,
-            a,
-        )
-    }
-    unsafe {
-        crate::ptr::write_unaligned(
-            arr_b.as_mut_ptr() as *mut LexicographicallyOrdered<T>,
-            b,
-        )
-    }
+    unsafe { crate::ptr::write_unaligned(arr_a.as_mut_ptr() as *mut LexicographicallyOrdered<T>, a) }
+    unsafe { crate::ptr::write_unaligned(arr_b.as_mut_ptr() as *mut LexicographicallyOrdered<T>, b) }
     let expected = arr_a[0..T::LANES].partial_cmp(&arr_b[0..T::LANES]);
     let result = a.partial_cmp(&b);
     assert_eq!(expected, result, "{:?}, {:?}", a, b);
@@ -134,8 +123,7 @@ macro_rules! ptr_vals {
             // all bits cleared
             let clear: <$id as sealed::Simd>::Element = crate::mem::zeroed();
             // all bits set
-            let set: <$id as sealed::Simd>::Element =
-                crate::mem::transmute(-1_isize);
+            let set: <$id as sealed::Simd>::Element = crate::mem::transmute(-1_isize);
             (clear, set)
         }
     };
diff --git a/third_party/rust/packed_simd/src/v128.rs b/third_party/rust/packed_simd_2/src/v128.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/v128.rs
rename to third_party/rust/packed_simd_2/src/v128.rs
diff --git a/third_party/rust/packed_simd/src/v16.rs b/third_party/rust/packed_simd_2/src/v16.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/v16.rs
rename to third_party/rust/packed_simd_2/src/v16.rs
diff --git a/third_party/rust/packed_simd/src/v256.rs b/third_party/rust/packed_simd_2/src/v256.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/v256.rs
rename to third_party/rust/packed_simd_2/src/v256.rs
diff --git a/third_party/rust/packed_simd/src/v32.rs b/third_party/rust/packed_simd_2/src/v32.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/v32.rs
rename to third_party/rust/packed_simd_2/src/v32.rs
diff --git a/third_party/rust/packed_simd/src/v512.rs b/third_party/rust/packed_simd_2/src/v512.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/v512.rs
rename to third_party/rust/packed_simd_2/src/v512.rs
diff --git a/third_party/rust/packed_simd/src/v64.rs b/third_party/rust/packed_simd_2/src/v64.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/v64.rs
rename to third_party/rust/packed_simd_2/src/v64.rs
diff --git a/third_party/rust/packed_simd/src/vPtr.rs b/third_party/rust/packed_simd_2/src/vPtr.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/vPtr.rs
rename to third_party/rust/packed_simd_2/src/vPtr.rs
diff --git a/third_party/rust/packed_simd/src/vSize.rs b/third_party/rust/packed_simd_2/src/vSize.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/vSize.rs
rename to third_party/rust/packed_simd_2/src/vSize.rs
diff --git a/third_party/rust/packed_simd/tests/endianness.rs b/third_party/rust/packed_simd_2/tests/endianness.rs
similarity index 96%
rename from third_party/rust/packed_simd/tests/endianness.rs
rename to third_party/rust/packed_simd_2/tests/endianness.rs
index 31fb7073afb3..da12c2338b1f 100644
--- a/third_party/rust/packed_simd/tests/endianness.rs
+++ b/third_party/rust/packed_simd_2/tests/endianness.rs
@@ -1,7 +1,7 @@
 #[cfg(target_arch = "wasm32")]
 use wasm_bindgen_test::*;
 
-use packed_simd::*;
+use packed_simd_2::*;
 use std::{mem, slice};
 
 #[cfg_attr(not(target_arch = "wasm32"), test)]
@@ -57,9 +57,7 @@ fn endian_load_and_stores() {
         8, 9, 10, 11, 12, 13, 14, 15,
     );
     let mut y: [i16; 8] = [0; 8];
-    x.write_to_slice_unaligned(unsafe {
-        slice::from_raw_parts_mut(&mut y as *mut _ as *mut i8, 16)
-    });
+    x.write_to_slice_unaligned(unsafe { slice::from_raw_parts_mut(&mut y as *mut _ as *mut i8, 16) });
 
     let e: [i16; 8] = if cfg!(target_endian = "little") {
         [256, 770, 1284, 1798, 2312, 2826, 3340, 3854]
@@ -68,9 +66,7 @@ fn endian_load_and_stores() {
     };
     assert_eq!(y, e);
 
-    let z = i8x16::from_slice_unaligned(unsafe {
-        slice::from_raw_parts(&y as *const _ as *const i8, 16)
-    });
+    let z = i8x16::from_slice_unaligned(unsafe { slice::from_raw_parts(&y as *const _ as *const i8, 16) });
     assert_eq!(z, x);
 }
 
diff --git a/third_party/rust/rustc_version-0.2.3/.cargo-checksum.json b/third_party/rust/rustc_version-0.2.3/.cargo-checksum.json
new file mode 100644
index 000000000000..f86fe1cf8b59
--- /dev/null
+++ b/third_party/rust/rustc_version-0.2.3/.cargo-checksum.json
@@ -0,0 +1 @@
+{"files":{"Cargo.toml":"80b9fb136c8c2945b4875b05b0f5a4b11e4722997e751f17d8d3f241d7c684db","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"c9a75f18b9ab2927829a208fc6aa2cf4e63b8420887ba29cdb265d6619ae82d5","README.md":"58bd14a1dfa1d828e6e99f35c3b7c2149d08e2d990d6ca93f92ab8ffb43275b7","src/errors.rs":"b28c2eeb1278fc3e8d68a64b177034faed67f6762335729d3a6d1e61be8fb034","src/lib.rs":"92a32673f77961724bc52b872781f06d22d166f06838c9582c5adae3c5214f51"},"package":"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a"}
\ No newline at end of file
diff --git a/third_party/rust/rustc_version-0.2.3/Cargo.toml b/third_party/rust/rustc_version-0.2.3/Cargo.toml
new file mode 100644
index 000000000000..3b252b85a26e
--- /dev/null
+++ b/third_party/rust/rustc_version-0.2.3/Cargo.toml
@@ -0,0 +1,26 @@
+# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
+#
+# When uploading crates to the registry Cargo will automatically
+# "normalize" Cargo.toml files for maximal compatibility
+# with all versions of Cargo and also rewrite `path` dependencies
+# to registry (e.g. crates.io) dependencies
+#
+# If you believe there's an error in this file please file an
+# issue against the rust-lang/cargo repository. If you're
+# editing this file be aware that the upstream Cargo.toml
+# will likely look very different (and much more reasonable)
+
+[package]
+name = "rustc_version"
+version = "0.2.3"
+authors = ["Marvin Löbel <loebel.marvin@gmail.com>"]
+description = "A library for querying the version of a installed rustc compiler"
+documentation = "https://docs.rs/rustc_version/"
+readme = "README.md"
+keywords = ["version", "rustc"]
+license = "MIT/Apache-2.0"
+repository = "https://github.com/Kimundi/rustc-version-rs"
+[dependencies.semver]
+version = "0.9"
+[badges.travis-ci]
+repository = "Kimundi/rustc-version-rs"
diff --git a/third_party/rust/rustc_version-0.2.3/LICENSE-APACHE b/third_party/rust/rustc_version-0.2.3/LICENSE-APACHE
new file mode 100644
index 000000000000..16fe87b06e80
--- /dev/null
+++ b/third_party/rust/rustc_version-0.2.3/LICENSE-APACHE
@@ -0,0 +1,201 @@
+                              Apache License
+                        Version 2.0, January 2004
+                     http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+   "License" shall mean the terms and conditions for use, reproduction,
+   and distribution as defined by Sections 1 through 9 of this document.
+
+   "Licensor" shall mean the copyright owner or entity authorized by
+   the copyright owner that is granting the License.
+
+   "Legal Entity" shall mean the union of the acting entity and all
+   other entities that control, are controlled by, or are under common
+   control with that entity. For the purposes of this definition,
+   "control" means (i) the power, direct or indirect, to cause the
+   direction or management of such entity, whether by contract or
+   otherwise, or (ii) ownership of fifty percent (50%) or more of the
+   outstanding shares, or (iii) beneficial ownership of such entity.
+
+   "You" (or "Your") shall mean an individual or Legal Entity
+   exercising permissions granted by this License.
+
+   "Source" form shall mean the preferred form for making modifications,
+   including but not limited to software source code, documentation
+   source, and configuration files.
+
+   "Object" form shall mean any form resulting from mechanical
+   transformation or translation of a Source form, including but
+   not limited to compiled object code, generated documentation,
+   and conversions to other media types.
+
+   "Work" shall mean the work of authorship, whether in Source or
+   Object form, made available under the License, as indicated by a
+   copyright notice that is included in or attached to the work
+   (an example is provided in the Appendix below).
+
+   "Derivative Works" shall mean any work, whether in Source or Object
+   form, that is based on (or derived from) the Work and for which the
+   editorial revisions, annotations, elaborations, or other modifications
+   represent, as a whole, an original work of authorship. For the purposes
+   of this License, Derivative Works shall not include works that remain
+   separable from, or merely link (or bind by name) to the interfaces of,
+   the Work and Derivative Works thereof.
+
+   "Contribution" shall mean any work of authorship, including
+   the original version of the Work and any modifications or additions
+   to that Work or Derivative Works thereof, that is intentionally
+   submitted to Licensor for inclusion in the Work by the copyright owner
+   or by an individual or Legal Entity authorized to submit on behalf of
+   the copyright owner. For the purposes of this definition, "submitted"
+   means any form of electronic, verbal, or written communication sent
+   to the Licensor or its representatives, including but not limited to
+   communication on electronic mailing lists, source code control systems,
+   and issue tracking systems that are managed by, or on behalf of, the
+   Licensor for the purpose of discussing and improving the Work, but
+   excluding communication that is conspicuously marked or otherwise
+   designated in writing by the copyright owner as "Not a Contribution."
+
+   "Contributor" shall mean Licensor and any individual or Legal Entity
+   on behalf of whom a Contribution has been received by Licensor and
+   subsequently incorporated within the Work.
+
+2. Grant of Copyright License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   copyright license to reproduce, prepare Derivative Works of,
+   publicly display, publicly perform, sublicense, and distribute the
+   Work and such Derivative Works in Source or Object form.
+
+3. Grant of Patent License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   (except as stated in this section) patent license to make, have made,
+   use, offer to sell, sell, import, and otherwise transfer the Work,
+   where such license applies only to those patent claims licensable
+   by such Contributor that are necessarily infringed by their
+   Contribution(s) alone or by combination of their Contribution(s)
+   with the Work to which such Contribution(s) was submitted. If You
+   institute patent litigation against any entity (including a
+   cross-claim or counterclaim in a lawsuit) alleging that the Work
+   or a Contribution incorporated within the Work constitutes direct
+   or contributory patent infringement, then any patent licenses
+   granted to You under this License for that Work shall terminate
+   as of the date such litigation is filed.
+
+4. Redistribution. You may reproduce and distribute copies of the
+   Work or Derivative Works thereof in any medium, with or without
+   modifications, and in Source or Object form, provided that You
+   meet the following conditions:
+
+   (a) You must give any other recipients of the Work or
+       Derivative Works a copy of this License; and
+
+   (b) You must cause any modified files to carry prominent notices
+       stating that You changed the files; and
+
+   (c) You must retain, in the Source form of any Derivative Works
+       that You distribute, all copyright, patent, trademark, and
+       attribution notices from the Source form of the Work,
+       excluding those notices that do not pertain to any part of
+       the Derivative Works; and
+
+   (d) If the Work includes a "NOTICE" text file as part of its
+       distribution, then any Derivative Works that You distribute must
+       include a readable copy of the attribution notices contained
+       within such NOTICE file, excluding those notices that do not
+       pertain to any part of the Derivative Works, in at least one
+       of the following places: within a NOTICE text file distributed
+       as part of the Derivative Works; within the Source form or
+       documentation, if provided along with the Derivative Works; or,
+       within a display generated by the Derivative Works, if and
+       wherever such third-party notices normally appear. The contents
+       of the NOTICE file are for informational purposes only and
+       do not modify the License. You may add Your own attribution
+       notices within Derivative Works that You distribute, alongside
+       or as an addendum to the NOTICE text from the Work, provided
+       that such additional attribution notices cannot be construed
+       as modifying the License.
+
+   You may add Your own copyright statement to Your modifications and
+   may provide additional or different license terms and conditions
+   for use, reproduction, or distribution of Your modifications, or
+   for any such Derivative Works as a whole, provided Your use,
+   reproduction, and distribution of the Work otherwise complies with
+   the conditions stated in this License.
+
+5. Submission of Contributions. Unless You explicitly state otherwise,
+   any Contribution intentionally submitted for inclusion in the Work
+   by You to the Licensor shall be under the terms and conditions of
+   this License, without any additional terms or conditions.
+   Notwithstanding the above, nothing herein shall supersede or modify
+   the terms of any separate license agreement you may have executed
+   with Licensor regarding such Contributions.
+
+6. Trademarks. This License does not grant permission to use the trade
+   names, trademarks, service marks, or product names of the Licensor,
+   except as required for reasonable and customary use in describing the
+   origin of the Work and reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty. Unless required by applicable law or
+   agreed to in writing, Licensor provides the Work (and each
+   Contributor provides its Contributions) on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+   implied, including, without limitation, any warranties or conditions
+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+   PARTICULAR PURPOSE. You are solely responsible for determining the
+   appropriateness of using or redistributing the Work and assume any
+   risks associated with Your exercise of permissions under this License.
+
+8. Limitation of Liability. In no event and under no legal theory,
+   whether in tort (including negligence), contract, or otherwise,
+   unless required by applicable law (such as deliberate and grossly
+   negligent acts) or agreed to in writing, shall any Contributor be
+   liable to You for damages, including any direct, indirect, special,
+   incidental, or consequential damages of any character arising as a
+   result of this License or out of the use or inability to use the
+   Work (including but not limited to damages for loss of goodwill,
+   work stoppage, computer failure or malfunction, or any and all
+   other commercial damages or losses), even if such Contributor
+   has been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability. While redistributing
+   the Work or Derivative Works thereof, You may choose to offer,
+   and charge a fee for, acceptance of support, warranty, indemnity,
+   or other liability obligations and/or rights consistent with this
+   License. However, in accepting such obligations, You may act only
+   on Your own behalf and on Your sole responsibility, not on behalf
+   of any other Contributor, and only if You agree to indemnify,
+   defend, and hold each Contributor harmless for any liability
+   incurred by, or claims asserted against, such Contributor by reason
+   of your accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
+
+APPENDIX: How to apply the Apache License to your work.
+
+   To apply the Apache License to your work, attach the following
+   boilerplate notice, with the fields enclosed by brackets "[]"
+   replaced with your own identifying information. (Don't include
+   the brackets!)  The text should be enclosed in the appropriate
+   comment syntax for the file format. We also recommend that a
+   file or class name and description of purpose be included on the
+   same "printed page" as the copyright notice for easier
+   identification within third-party archives.
+
+Copyright [yyyy] [name of copyright owner]
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+	http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/third_party/rust/rustc_version-0.2.3/LICENSE-MIT b/third_party/rust/rustc_version-0.2.3/LICENSE-MIT
new file mode 100644
index 000000000000..40b8817a47be
--- /dev/null
+++ b/third_party/rust/rustc_version-0.2.3/LICENSE-MIT
@@ -0,0 +1,25 @@
+Copyright (c) 2016 The Rust Project Developers
+
+Permission is hereby granted, free of charge, to any
+person obtaining a copy of this software and associated
+documentation files (the "Software"), to deal in the
+Software without restriction, including without
+limitation the rights to use, copy, modify, merge,
+publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software
+is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice
+shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
diff --git a/third_party/rust/rustc_version-0.2.3/README.md b/third_party/rust/rustc_version-0.2.3/README.md
new file mode 100644
index 000000000000..f491ca964d85
--- /dev/null
+++ b/third_party/rust/rustc_version-0.2.3/README.md
@@ -0,0 +1,75 @@
+rustc-version-rs
+==============
+
+A library for querying the version of a `rustc` compiler.
+
+This can be used by build scripts or other tools dealing with Rust sources
+to make decisions based on the version of the compiler.
+
+[![Travis-CI Status](https://travis-ci.org/Kimundi/rustc-version-rs.png?branch=master)](https://travis-ci.org/Kimundi/rustc-version-rs)
+
+# Getting Started
+
+[rustc-version-rs is available on crates.io](https://crates.io/crates/rustc_version).
+It is recommended to look there for the newest released version, as well as links to the newest builds of the docs.
+
+At the point of the last update of this README, the latest published version could be used like this:
+
+Add the following dependency to your Cargo manifest...
+
+```toml
+[build-dependencies]
+rustc_version = "0.2"
+```
+
+...and see the [docs](http://kimundi.github.io/rustc-version-rs/rustc_version/index.html) for how to use it.
+
+# Example
+
+```rust
+// This could be a cargo build script
+
+extern crate rustc_version;
+use rustc_version::{version, version_meta, Channel, Version};
+
+fn main() {
+    // Assert we haven't travelled back in time
+    assert!(version().unwrap().major >= 1);
+
+    // Set cfg flags depending on release channel
+    match version_meta().unwrap().channel {
+        Channel::Stable => {
+            println!("cargo:rustc-cfg=RUSTC_IS_STABLE");
+        }
+        Channel::Beta => {
+            println!("cargo:rustc-cfg=RUSTC_IS_BETA");
+        }
+        Channel::Nightly => {
+            println!("cargo:rustc-cfg=RUSTC_IS_NIGHTLY");
+        }
+        Channel::Dev => {
+            println!("cargo:rustc-cfg=RUSTC_IS_DEV");
+        }
+    }
+
+    // Check for a minimum version
+    if version().unwrap() >= Version::parse("1.4.0").unwrap() {
+        println!("cargo:rustc-cfg=compiler_has_important_bugfix");
+    }
+}
+```
+
+## License
+
+Licensed under either of
+
+ * Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE) or http://www.apache.org/licenses/LICENSE-2.0)
+ * MIT license ([LICENSE-MIT](LICENSE-MIT) or http://opensource.org/licenses/MIT)
+
+at your option.
+
+### Contribution
+
+Unless you explicitly state otherwise, any contribution intentionally submitted
+for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any
+additional terms or conditions.
diff --git a/third_party/rust/rustc_version/src/errors.rs b/third_party/rust/rustc_version-0.2.3/src/errors.rs
similarity index 100%
rename from third_party/rust/rustc_version/src/errors.rs
rename to third_party/rust/rustc_version-0.2.3/src/errors.rs
diff --git a/third_party/rust/rustc_version-0.2.3/src/lib.rs b/third_party/rust/rustc_version-0.2.3/src/lib.rs
new file mode 100644
index 000000000000..c03828898fba
--- /dev/null
+++ b/third_party/rust/rustc_version-0.2.3/src/lib.rs
@@ -0,0 +1,347 @@
+// Copyright 2016 rustc-version-rs developers
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+#![warn(missing_docs)]
+
+//! Simple library for getting the version information of a `rustc`
+//! compiler.
+//!
+//! This can be used by build scripts or other tools dealing with Rust sources
+//! to make decisions based on the version of the compiler.
+//!
+//! It calls `$RUSTC --version -v` and parses the output, falling
+//! back to `rustc` if `$RUSTC` is not set.
+//!
+//! # Example
+//!
+//! ```rust
+//! // This could be a cargo build script
+//!
+//! extern crate rustc_version;
+//! use rustc_version::{version, version_meta, Channel, Version};
+//!
+//! fn main() {
+//!     // Assert we haven't travelled back in time
+//!     assert!(version().unwrap().major >= 1);
+//!
+//!     // Set cfg flags depending on release channel
+//!     match version_meta().unwrap().channel {
+//!         Channel::Stable => {
+//!             println!("cargo:rustc-cfg=RUSTC_IS_STABLE");
+//!         }
+//!         Channel::Beta => {
+//!             println!("cargo:rustc-cfg=RUSTC_IS_BETA");
+//!         }
+//!         Channel::Nightly => {
+//!             println!("cargo:rustc-cfg=RUSTC_IS_NIGHTLY");
+//!         }
+//!         Channel::Dev => {
+//!             println!("cargo:rustc-cfg=RUSTC_IS_DEV");
+//!         }
+//!     }
+//!
+//!     // Check for a minimum version
+//!     if version().unwrap() >= Version::parse("1.4.0").unwrap() {
+//!         println!("cargo:rustc-cfg=compiler_has_important_bugfix");
+//!     }
+//! }
+//! ```
+
+extern crate semver;
+use semver::Identifier;
+use std::process::Command;
+use std::{env, str};
+use std::ffi::OsString;
+
+// Convenience re-export to allow version comparison without needing to add
+// semver crate.
+pub use semver::Version;
+
+mod errors;
+pub use errors::{Error, Result};
+
+/// Release channel of the compiler.
+#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
+pub enum Channel {
+    /// Development release channel
+    Dev,
+    /// Nightly release channel
+    Nightly,
+    /// Beta release channel
+    Beta,
+    /// Stable release channel
+    Stable,
+}
+
+/// Rustc version plus metada like git short hash and build date.
+#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
+pub struct VersionMeta {
+    /// Version of the compiler
+    pub semver: Version,
+
+    /// Git short hash of the build of the compiler
+    pub commit_hash: Option<String>,
+
+    /// Commit date of the compiler
+    pub commit_date: Option<String>,
+
+    /// Build date of the compiler; this was removed between Rust 1.0.0 and 1.1.0.
+    pub build_date: Option<String>,
+
+    /// Release channel of the compiler
+    pub channel: Channel,
+
+    /// Host target triple of the compiler
+    pub host: String,
+
+    /// Short version string of the compiler
+    pub short_version_string: String,
+}
+
+impl VersionMeta {
+    /// Returns the version metadata for `cmd`, which should be a `rustc` command.
+    pub fn for_command(cmd: Command) -> Result<VersionMeta> {
+        let mut cmd = cmd;
+
+        let out = cmd.arg("-vV").output().map_err(Error::CouldNotExecuteCommand)?;
+        let out = str::from_utf8(&out.stdout)?;
+
+        version_meta_for(out)
+    }
+}
+
+/// Returns the `rustc` SemVer version.
+pub fn version() -> Result<Version> {
+    Ok(version_meta()?.semver)
+}
+
+/// Returns the `rustc` SemVer version and additional metadata
+/// like the git short hash and build date.
+pub fn version_meta() -> Result<VersionMeta> {
+    let cmd = env::var_os("RUSTC").unwrap_or_else(|| OsString::from("rustc"));
+
+    VersionMeta::for_command(Command::new(cmd))
+}
+
+/// Parses a "rustc -vV" output string and returns
+/// the SemVer version and additional metadata
+/// like the git short hash and build date.
+pub fn version_meta_for(verbose_version_string: &str) -> Result<VersionMeta> {
+    let out: Vec<_> = verbose_version_string.lines().collect();
+
+    if !(out.len() >= 6 && out.len() <= 8) {
+        return Err(Error::UnexpectedVersionFormat);
+    }
+
+    let short_version_string = out[0];
+
+    fn expect_prefix<'a>(line: &'a str, prefix: &str) -> Result<&'a str> {
+        if line.starts_with(prefix) {
+            Ok(&line[prefix.len()..])
+        } else {
+            Err(Error::UnexpectedVersionFormat)
+        }
+    }
+
+    let commit_hash = match expect_prefix(out[2], "commit-hash: ")? {
+        "unknown" => None,
+        hash => Some(hash.to_owned()),
+    };
+
+    let commit_date = match expect_prefix(out[3], "commit-date: ")? {
+        "unknown" => None,
+        hash => Some(hash.to_owned()),
+    };
+
+    // Handle that the build date may or may not be present.
+    let mut idx = 4;
+    let mut build_date = None;
+    if out[idx].starts_with("build-date") {
+        build_date = match expect_prefix(out[idx], "build-date: ")? {
+            "unknown" => None,
+            s => Some(s.to_owned()),
+        };
+        idx += 1;
+    }
+
+    let host = expect_prefix(out[idx], "host: ")?;
+    idx += 1;
+    let release = expect_prefix(out[idx], "release: ")?;
+
+    let semver: Version = release.parse()?;
+
+    let channel = if semver.pre.is_empty() {
+        Channel::Stable
+    } else {
+        match semver.pre[0] {
+            Identifier::AlphaNumeric(ref s) if s == "dev" => Channel::Dev,
+            Identifier::AlphaNumeric(ref s) if s == "beta" => Channel::Beta,
+            Identifier::AlphaNumeric(ref s) if s == "nightly" => Channel::Nightly,
+            ref x => return Err(Error::UnknownPreReleaseTag(x.clone())),
+        }
+    };
+
+    Ok(VersionMeta {
+        semver: semver,
+        commit_hash: commit_hash,
+        commit_date: commit_date,
+        build_date: build_date,
+        channel: channel,
+        host: host.into(),
+        short_version_string: short_version_string.into(),
+    })
+}
+
+#[test]
+fn smoketest() {
+    let v = version().unwrap();
+    assert!(v.major >= 1);
+
+    let v = version_meta().unwrap();
+    assert!(v.semver.major >= 1);
+
+    assert!(version().unwrap() >= Version::parse("1.0.0").unwrap());
+}
+
+#[test]
+fn parse_unexpected() {
+    let res = version_meta_for(
+"rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)
+binary: rustc
+commit-hash: a59de37e99060162a2674e3ff45409ac73595c0e
+commit-date: 2015-05-13
+rust-birthday: 2015-05-14
+host: x86_64-unknown-linux-gnu
+release: 1.0.0");
+
+    assert!(match res {
+        Err(Error::UnexpectedVersionFormat) => true,
+        _ => false,
+    });
+
+}
+
+#[test]
+fn parse_1_0_0() {
+    let version = version_meta_for(
+"rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)
+binary: rustc
+commit-hash: a59de37e99060162a2674e3ff45409ac73595c0e
+commit-date: 2015-05-13
+build-date: 2015-05-14
+host: x86_64-unknown-linux-gnu
+release: 1.0.0").unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.0.0").unwrap());
+    assert_eq!(version.commit_hash, Some("a59de37e99060162a2674e3ff45409ac73595c0e".into()));
+    assert_eq!(version.commit_date, Some("2015-05-13".into()));
+    assert_eq!(version.build_date, Some("2015-05-14".into()));
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(version.short_version_string, "rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)");
+}
+
+
+#[test]
+fn parse_unknown() {
+    let version = version_meta_for(
+"rustc 1.3.0
+binary: rustc
+commit-hash: unknown
+commit-date: unknown
+host: x86_64-unknown-linux-gnu
+release: 1.3.0").unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.3.0").unwrap());
+    assert_eq!(version.commit_hash, None);
+    assert_eq!(version.commit_date, None);
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(version.short_version_string, "rustc 1.3.0");
+}
+
+#[test]
+fn parse_nightly() {
+    let version = version_meta_for(
+"rustc 1.5.0-nightly (65d5c0833 2015-09-29)
+binary: rustc
+commit-hash: 65d5c083377645a115c4ac23a620d3581b9562b6
+commit-date: 2015-09-29
+host: x86_64-unknown-linux-gnu
+release: 1.5.0-nightly").unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.5.0-nightly").unwrap());
+    assert_eq!(version.commit_hash, Some("65d5c083377645a115c4ac23a620d3581b9562b6".into()));
+    assert_eq!(version.commit_date, Some("2015-09-29".into()));
+    assert_eq!(version.channel, Channel::Nightly);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(version.short_version_string, "rustc 1.5.0-nightly (65d5c0833 2015-09-29)");
+}
+
+#[test]
+fn parse_stable() {
+    let version = version_meta_for(
+"rustc 1.3.0 (9a92aaf19 2015-09-15)
+binary: rustc
+commit-hash: 9a92aaf19a64603b02b4130fe52958cc12488900
+commit-date: 2015-09-15
+host: x86_64-unknown-linux-gnu
+release: 1.3.0").unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.3.0").unwrap());
+    assert_eq!(version.commit_hash, Some("9a92aaf19a64603b02b4130fe52958cc12488900".into()));
+    assert_eq!(version.commit_date, Some("2015-09-15".into()));
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(version.short_version_string, "rustc 1.3.0 (9a92aaf19 2015-09-15)");
+}
+
+#[test]
+fn parse_1_16_0_nightly() {
+    let version = version_meta_for(
+"rustc 1.16.0-nightly (5d994d8b7 2017-01-05)
+binary: rustc
+commit-hash: 5d994d8b7e482e87467d4a521911477bd8284ce3
+commit-date: 2017-01-05
+host: x86_64-unknown-linux-gnu
+release: 1.16.0-nightly
+LLVM version: 3.9").unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.16.0-nightly").unwrap());
+    assert_eq!(version.commit_hash, Some("5d994d8b7e482e87467d4a521911477bd8284ce3".into()));
+    assert_eq!(version.commit_date, Some("2017-01-05".into()));
+    assert_eq!(version.channel, Channel::Nightly);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(version.short_version_string, "rustc 1.16.0-nightly (5d994d8b7 2017-01-05)");
+}
+
+/*
+#[test]
+fn version_matches_replacement() {
+    let f = |s1: &str, s2: &str| {
+        let a = Version::parse(s1).unwrap();
+        let b = Version::parse(s2).unwrap();
+        println!("{} <= {} : {}", s1, s2, a <= b);
+    };
+
+    println!();
+
+    f("1.5.0",         "1.5.0");
+    f("1.5.0-nightly", "1.5.0");
+    f("1.5.0",         "1.5.0-nightly");
+    f("1.5.0-nightly", "1.5.0-nightly");
+
+    f("1.5.0",         "1.6.0");
+    f("1.5.0-nightly", "1.6.0");
+    f("1.5.0",         "1.6.0-nightly");
+    f("1.5.0-nightly", "1.6.0-nightly");
+
+    panic!();
+
+}
+*/
diff --git a/third_party/rust/rustc_version/.cargo-checksum.json b/third_party/rust/rustc_version/.cargo-checksum.json
index f86fe1cf8b59..496c646ce633 100644
--- a/third_party/rust/rustc_version/.cargo-checksum.json
+++ b/third_party/rust/rustc_version/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"Cargo.toml":"80b9fb136c8c2945b4875b05b0f5a4b11e4722997e751f17d8d3f241d7c684db","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"c9a75f18b9ab2927829a208fc6aa2cf4e63b8420887ba29cdb265d6619ae82d5","README.md":"58bd14a1dfa1d828e6e99f35c3b7c2149d08e2d990d6ca93f92ab8ffb43275b7","src/errors.rs":"b28c2eeb1278fc3e8d68a64b177034faed67f6762335729d3a6d1e61be8fb034","src/lib.rs":"92a32673f77961724bc52b872781f06d22d166f06838c9582c5adae3c5214f51"},"package":"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a"}
\ No newline at end of file
+{"files":{"Cargo.toml":"6a2e927f37b4897e75470e62face13eff0fe846c57f8fcfb98bcd5e0fe8ed0a2","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"c9a75f18b9ab2927829a208fc6aa2cf4e63b8420887ba29cdb265d6619ae82d5","README.md":"40f1138d4ddcfcfd0534429cea8dcbdcaf4a175aca1c26662f011f6e83d2fd7a","deny.toml":"22979f2da49546b27a5c892d5216bf74215987810a2d011b58870471883b9437","src/lib.rs":"bc18589948e3c04c3ffb491ffc3d4eccd8037c8e377d0bbae8aca2b21978b1de","tests/all.rs":"7b2969022feab85a948fafd331d9bb30d80357d01afaf7e0f723908e75f39e89"},"package":"bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366"}
\ No newline at end of file
diff --git a/third_party/rust/rustc_version/Cargo.toml b/third_party/rust/rustc_version/Cargo.toml
index 3b252b85a26e..c81ff85ceb7e 100644
--- a/third_party/rust/rustc_version/Cargo.toml
+++ b/third_party/rust/rustc_version/Cargo.toml
@@ -3,7 +3,7 @@
 # When uploading crates to the registry Cargo will automatically
 # "normalize" Cargo.toml files for maximal compatibility
 # with all versions of Cargo and also rewrite `path` dependencies
-# to registry (e.g. crates.io) dependencies
+# to registry (e.g., crates.io) dependencies
 #
 # If you believe there's an error in this file please file an
 # issue against the rust-lang/cargo repository. If you're
@@ -11,9 +11,10 @@
 # will likely look very different (and much more reasonable)
 
 [package]
+edition = "2018"
 name = "rustc_version"
-version = "0.2.3"
-authors = ["Marvin Löbel <loebel.marvin@gmail.com>"]
+version = "0.4.0"
+authors = ["Dirkjan Ochtman <dirkjan@ochtman.nl>", "Marvin Löbel <loebel.marvin@gmail.com>"]
 description = "A library for querying the version of a installed rustc compiler"
 documentation = "https://docs.rs/rustc_version/"
 readme = "README.md"
@@ -21,6 +22,6 @@ keywords = ["version", "rustc"]
 license = "MIT/Apache-2.0"
 repository = "https://github.com/Kimundi/rustc-version-rs"
 [dependencies.semver]
-version = "0.9"
-[badges.travis-ci]
-repository = "Kimundi/rustc-version-rs"
+version = "1.0"
+[dev-dependencies.doc-comment]
+version = "0.3"
diff --git a/third_party/rust/rustc_version/README.md b/third_party/rust/rustc_version/README.md
index f491ca964d85..e76ef950dfd2 100644
--- a/third_party/rust/rustc_version/README.md
+++ b/third_party/rust/rustc_version/README.md
@@ -1,12 +1,19 @@
 rustc-version-rs
-==============
+================
+
+[![Documentation](https://docs.rs/rustc_version/badge.svg)](https://docs.rs/rustc_version/)
+[![Crates.io](https://img.shields.io/crates/v/rustc_version.svg)](https://crates.io/crates/rustc_version)
+[![Build status](https://github.com/Kimundi/rustc-version-rs/workflows/CI/badge.svg)](https://github.com/Kimundi/rustc-version-rs/actions?query=workflow%3ACI)
 
 A library for querying the version of a `rustc` compiler.
 
 This can be used by build scripts or other tools dealing with Rust sources
-to make decisions based on the version of the compiler.
+to make decisions based on the version of the compiler. Current MSRV is 1.32.0.
+
+If this is of interest, also consider looking at these other crates:
 
-[![Travis-CI Status](https://travis-ci.org/Kimundi/rustc-version-rs.png?branch=master)](https://travis-ci.org/Kimundi/rustc-version-rs)
+* [autocfg](https://crates.io/crates/autocfg/), which helps with feature detection instead of depending on compiler versions
+* [rustversion](https://github.com/dtolnay/rustversion) provides a procedural macro with no other dependencies
 
 # Getting Started
 
@@ -22,14 +29,13 @@ Add the following dependency to your Cargo manifest...
 rustc_version = "0.2"
 ```
 
-...and see the [docs](http://kimundi.github.io/rustc-version-rs/rustc_version/index.html) for how to use it.
+... and see the [docs](https://docs.rs/rustc_version) for how to use it.
 
 # Example
 
 ```rust
 // This could be a cargo build script
 
-extern crate rustc_version;
 use rustc_version::{version, version_meta, Channel, Version};
 
 fn main() {
diff --git a/third_party/rust/rustc_version/deny.toml b/third_party/rust/rustc_version/deny.toml
new file mode 100644
index 000000000000..38c47a8dc665
--- /dev/null
+++ b/third_party/rust/rustc_version/deny.toml
@@ -0,0 +1,3 @@
+[licenses]
+allow-osi-fsf-free = "either"
+copyleft = "deny"
diff --git a/third_party/rust/rustc_version/src/lib.rs b/third_party/rust/rustc_version/src/lib.rs
index c03828898fba..cee1ec81431e 100644
--- a/third_party/rust/rustc_version/src/lib.rs
+++ b/third_party/rust/rustc_version/src/lib.rs
@@ -22,48 +22,50 @@
 //! ```rust
 //! // This could be a cargo build script
 //!
-//! extern crate rustc_version;
 //! use rustc_version::{version, version_meta, Channel, Version};
 //!
-//! fn main() {
-//!     // Assert we haven't travelled back in time
-//!     assert!(version().unwrap().major >= 1);
+//! // Assert we haven't travelled back in time
+//! assert!(version().unwrap().major >= 1);
 //!
-//!     // Set cfg flags depending on release channel
-//!     match version_meta().unwrap().channel {
-//!         Channel::Stable => {
-//!             println!("cargo:rustc-cfg=RUSTC_IS_STABLE");
-//!         }
-//!         Channel::Beta => {
-//!             println!("cargo:rustc-cfg=RUSTC_IS_BETA");
-//!         }
-//!         Channel::Nightly => {
-//!             println!("cargo:rustc-cfg=RUSTC_IS_NIGHTLY");
-//!         }
-//!         Channel::Dev => {
-//!             println!("cargo:rustc-cfg=RUSTC_IS_DEV");
-//!         }
+//! // Set cfg flags depending on release channel
+//! match version_meta().unwrap().channel {
+//!     Channel::Stable => {
+//!         println!("cargo:rustc-cfg=RUSTC_IS_STABLE");
 //!     }
-//!
-//!     // Check for a minimum version
-//!     if version().unwrap() >= Version::parse("1.4.0").unwrap() {
-//!         println!("cargo:rustc-cfg=compiler_has_important_bugfix");
+//!     Channel::Beta => {
+//!         println!("cargo:rustc-cfg=RUSTC_IS_BETA");
+//!     }
+//!     Channel::Nightly => {
+//!         println!("cargo:rustc-cfg=RUSTC_IS_NIGHTLY");
 //!     }
+//!     Channel::Dev => {
+//!         println!("cargo:rustc-cfg=RUSTC_IS_DEV");
+//!     }
+//! }
+//!
+//! // Check for a minimum version
+//! if version().unwrap() >= Version::parse("1.4.0").unwrap() {
+//!     println!("cargo:rustc-cfg=compiler_has_important_bugfix");
 //! }
 //! ```
 
-extern crate semver;
-use semver::Identifier;
+#[cfg(test)]
+#[macro_use]
+extern crate doc_comment;
+
+#[cfg(test)]
+doctest!("../README.md");
+
+use std::collections::HashMap;
 use std::process::Command;
-use std::{env, str};
-use std::ffi::OsString;
+use std::{env, error, fmt, io, num, str};
+use std::{ffi::OsString, str::FromStr};
 
 // Convenience re-export to allow version comparison without needing to add
 // semver crate.
 pub use semver::Version;
 
-mod errors;
-pub use errors::{Error, Result};
+use Error::*;
 
 /// Release channel of the compiler.
 #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
@@ -78,7 +80,70 @@ pub enum Channel {
     Stable,
 }
 
-/// Rustc version plus metada like git short hash and build date.
+/// LLVM version
+///
+/// LLVM's version numbering scheme is not semver compatible until version 4.0
+///
+/// rustc [just prints the major and minor versions], so other parts of the version are not included.
+///
+/// [just prints the major and minor versions]: https://github.com/rust-lang/rust/blob/b5c9e2448c9ace53ad5c11585803894651b18b0a/compiler/rustc_codegen_llvm/src/llvm_util.rs#L173-L178
+#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
+pub struct LlvmVersion {
+    // fields must be ordered major, minor for comparison to be correct
+    /// Major version
+    pub major: u64,
+    /// Minor version
+    pub minor: u64,
+    // TODO: expose micro version here
+}
+
+impl fmt::Display for LlvmVersion {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "{}.{}", self.major, self.minor)
+    }
+}
+
+impl FromStr for LlvmVersion {
+    type Err = LlvmVersionParseError;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        let mut parts = s
+            .split('.')
+            .map(|part| -> Result<u64, LlvmVersionParseError> {
+                if part == "0" {
+                    Ok(0)
+                } else if part.starts_with('0') {
+                    Err(LlvmVersionParseError::ComponentMustNotHaveLeadingZeros)
+                } else if part.starts_with('-') || part.starts_with('+') {
+                    Err(LlvmVersionParseError::ComponentMustNotHaveSign)
+                } else {
+                    Ok(part.parse()?)
+                }
+            });
+
+        let major = parts.next().unwrap()?;
+        let mut minor = 0;
+
+        if let Some(part) = parts.next() {
+            minor = part?;
+        } else if major < 4 {
+            // LLVM versions earlier than 4.0 have significant minor versions, so require the minor version in this case.
+            return Err(LlvmVersionParseError::MinorVersionRequiredBefore4);
+        }
+
+        if let Some(Err(e)) = parts.next() {
+            return Err(e);
+        }
+
+        if parts.next().is_some() {
+            return Err(LlvmVersionParseError::TooManyComponents);
+        }
+
+        Ok(Self { major, minor })
+    }
+}
+
+/// Rustc version plus metadata like git short hash and build date.
 #[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
 pub struct VersionMeta {
     /// Version of the compiler
@@ -101,17 +166,27 @@ pub struct VersionMeta {
 
     /// Short version string of the compiler
     pub short_version_string: String,
+
+    /// Version of LLVM used by the compiler
+    pub llvm_version: Option<LlvmVersion>,
 }
 
 impl VersionMeta {
     /// Returns the version metadata for `cmd`, which should be a `rustc` command.
-    pub fn for_command(cmd: Command) -> Result<VersionMeta> {
-        let mut cmd = cmd;
-
-        let out = cmd.arg("-vV").output().map_err(Error::CouldNotExecuteCommand)?;
-        let out = str::from_utf8(&out.stdout)?;
+    pub fn for_command(mut cmd: Command) -> Result<VersionMeta> {
+        let out = cmd
+            .arg("-vV")
+            .output()
+            .map_err(Error::CouldNotExecuteCommand)?;
+
+        if !out.status.success() {
+            return Err(Error::CommandError {
+                stdout: String::from_utf8_lossy(&out.stdout).into(),
+                stderr: String::from_utf8_lossy(&out.stderr).into(),
+            });
+        }
 
-        version_meta_for(out)
+        version_meta_for(str::from_utf8(&out.stdout)?)
     }
 }
 
@@ -132,216 +207,211 @@ pub fn version_meta() -> Result<VersionMeta> {
 /// the SemVer version and additional metadata
 /// like the git short hash and build date.
 pub fn version_meta_for(verbose_version_string: &str) -> Result<VersionMeta> {
-    let out: Vec<_> = verbose_version_string.lines().collect();
-
-    if !(out.len() >= 6 && out.len() <= 8) {
-        return Err(Error::UnexpectedVersionFormat);
-    }
+    let mut map = HashMap::new();
+    for (i, line) in verbose_version_string.lines().enumerate() {
+        if i == 0 {
+            map.insert("short", line);
+            continue;
+        }
 
-    let short_version_string = out[0];
+        let mut parts = line.splitn(2, ": ");
+        let key = match parts.next() {
+            Some(key) => key,
+            None => continue,
+        };
 
-    fn expect_prefix<'a>(line: &'a str, prefix: &str) -> Result<&'a str> {
-        if line.starts_with(prefix) {
-            Ok(&line[prefix.len()..])
-        } else {
-            Err(Error::UnexpectedVersionFormat)
+        if let Some(value) = parts.next() {
+            map.insert(key, value);
         }
     }
 
-    let commit_hash = match expect_prefix(out[2], "commit-hash: ")? {
-        "unknown" => None,
-        hash => Some(hash.to_owned()),
-    };
+    let short_version_string = expect_key("short", &map)?;
+    let host = expect_key("host", &map)?;
+    let release = expect_key("release", &map)?;
+    let semver: Version = release.parse()?;
 
-    let commit_date = match expect_prefix(out[3], "commit-date: ")? {
-        "unknown" => None,
-        hash => Some(hash.to_owned()),
+    let channel = match semver.pre.split('.').next().unwrap() {
+        "" => Channel::Stable,
+        "dev" => Channel::Dev,
+        "beta" => Channel::Beta,
+        "nightly" => Channel::Nightly,
+        x => return Err(Error::UnknownPreReleaseTag(x.to_owned())),
     };
 
-    // Handle that the build date may or may not be present.
-    let mut idx = 4;
-    let mut build_date = None;
-    if out[idx].starts_with("build-date") {
-        build_date = match expect_prefix(out[idx], "build-date: ")? {
-            "unknown" => None,
-            s => Some(s.to_owned()),
-        };
-        idx += 1;
-    }
-
-    let host = expect_prefix(out[idx], "host: ")?;
-    idx += 1;
-    let release = expect_prefix(out[idx], "release: ")?;
-
-    let semver: Version = release.parse()?;
-
-    let channel = if semver.pre.is_empty() {
-        Channel::Stable
-    } else {
-        match semver.pre[0] {
-            Identifier::AlphaNumeric(ref s) if s == "dev" => Channel::Dev,
-            Identifier::AlphaNumeric(ref s) if s == "beta" => Channel::Beta,
-            Identifier::AlphaNumeric(ref s) if s == "nightly" => Channel::Nightly,
-            ref x => return Err(Error::UnknownPreReleaseTag(x.clone())),
-        }
+    let commit_hash = expect_key_or_unknown("commit-hash", &map)?;
+    let commit_date = expect_key_or_unknown("commit-date", &map)?;
+    let build_date = map
+        .get("build-date")
+        .filter(|&v| *v != "unknown")
+        .map(|&v| String::from(v));
+    let llvm_version = match map.get("LLVM version") {
+        Some(&v) => Some(v.parse()?),
+        None => None,
     };
 
     Ok(VersionMeta {
-        semver: semver,
-        commit_hash: commit_hash,
-        commit_date: commit_date,
-        build_date: build_date,
-        channel: channel,
-        host: host.into(),
-        short_version_string: short_version_string.into(),
+        semver,
+        commit_hash,
+        commit_date,
+        build_date,
+        channel,
+        host,
+        short_version_string,
+        llvm_version,
     })
 }
 
-#[test]
-fn smoketest() {
-    let v = version().unwrap();
-    assert!(v.major >= 1);
-
-    let v = version_meta().unwrap();
-    assert!(v.semver.major >= 1);
-
-    assert!(version().unwrap() >= Version::parse("1.0.0").unwrap());
+fn expect_key_or_unknown(key: &str, map: &HashMap<&str, &str>) -> Result<Option<String>, Error> {
+    match map.get(key) {
+        Some(&v) if v == "unknown" => Ok(None),
+        Some(&v) => Ok(Some(String::from(v))),
+        None => Err(Error::UnexpectedVersionFormat),
+    }
 }
 
-#[test]
-fn parse_unexpected() {
-    let res = version_meta_for(
-"rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)
-binary: rustc
-commit-hash: a59de37e99060162a2674e3ff45409ac73595c0e
-commit-date: 2015-05-13
-rust-birthday: 2015-05-14
-host: x86_64-unknown-linux-gnu
-release: 1.0.0");
-
-    assert!(match res {
-        Err(Error::UnexpectedVersionFormat) => true,
-        _ => false,
-    });
-
+fn expect_key(key: &str, map: &HashMap<&str, &str>) -> Result<String, Error> {
+    map.get(key)
+        .map(|&v| String::from(v))
+        .ok_or(Error::UnexpectedVersionFormat)
 }
 
-#[test]
-fn parse_1_0_0() {
-    let version = version_meta_for(
-"rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)
-binary: rustc
-commit-hash: a59de37e99060162a2674e3ff45409ac73595c0e
-commit-date: 2015-05-13
-build-date: 2015-05-14
-host: x86_64-unknown-linux-gnu
-release: 1.0.0").unwrap();
-
-    assert_eq!(version.semver, Version::parse("1.0.0").unwrap());
-    assert_eq!(version.commit_hash, Some("a59de37e99060162a2674e3ff45409ac73595c0e".into()));
-    assert_eq!(version.commit_date, Some("2015-05-13".into()));
-    assert_eq!(version.build_date, Some("2015-05-14".into()));
-    assert_eq!(version.channel, Channel::Stable);
-    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
-    assert_eq!(version.short_version_string, "rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)");
+/// LLVM Version Parse Error
+#[derive(Debug)]
+pub enum LlvmVersionParseError {
+    /// An error occurred in parsing a version component as an integer
+    ParseIntError(num::ParseIntError),
+    /// A version component must not have leading zeros
+    ComponentMustNotHaveLeadingZeros,
+    /// A version component has a sign
+    ComponentMustNotHaveSign,
+    /// Minor version component must be zero on LLVM versions later than 4.0
+    MinorVersionMustBeZeroAfter4,
+    /// Minor version component is required on LLVM versions earlier than 4.0
+    MinorVersionRequiredBefore4,
+    /// Too many components
+    TooManyComponents,
 }
 
-
-#[test]
-fn parse_unknown() {
-    let version = version_meta_for(
-"rustc 1.3.0
-binary: rustc
-commit-hash: unknown
-commit-date: unknown
-host: x86_64-unknown-linux-gnu
-release: 1.3.0").unwrap();
-
-    assert_eq!(version.semver, Version::parse("1.3.0").unwrap());
-    assert_eq!(version.commit_hash, None);
-    assert_eq!(version.commit_date, None);
-    assert_eq!(version.channel, Channel::Stable);
-    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
-    assert_eq!(version.short_version_string, "rustc 1.3.0");
+impl From<num::ParseIntError> for LlvmVersionParseError {
+    fn from(e: num::ParseIntError) -> Self {
+        LlvmVersionParseError::ParseIntError(e)
+    }
 }
 
-#[test]
-fn parse_nightly() {
-    let version = version_meta_for(
-"rustc 1.5.0-nightly (65d5c0833 2015-09-29)
-binary: rustc
-commit-hash: 65d5c083377645a115c4ac23a620d3581b9562b6
-commit-date: 2015-09-29
-host: x86_64-unknown-linux-gnu
-release: 1.5.0-nightly").unwrap();
-
-    assert_eq!(version.semver, Version::parse("1.5.0-nightly").unwrap());
-    assert_eq!(version.commit_hash, Some("65d5c083377645a115c4ac23a620d3581b9562b6".into()));
-    assert_eq!(version.commit_date, Some("2015-09-29".into()));
-    assert_eq!(version.channel, Channel::Nightly);
-    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
-    assert_eq!(version.short_version_string, "rustc 1.5.0-nightly (65d5c0833 2015-09-29)");
+impl fmt::Display for LlvmVersionParseError {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match self {
+            LlvmVersionParseError::ParseIntError(e) => {
+                write!(f, "error parsing LLVM version component: {}", e)
+            }
+            LlvmVersionParseError::ComponentMustNotHaveLeadingZeros => {
+                write!(f, "a version component must not have leading zeros")
+            }
+            LlvmVersionParseError::ComponentMustNotHaveSign => {
+                write!(f, "a version component must not have a sign")
+            }
+            LlvmVersionParseError::MinorVersionMustBeZeroAfter4 => write!(
+                f,
+                "LLVM's minor version component must be 0 for versions greater than 4.0"
+            ),
+            LlvmVersionParseError::MinorVersionRequiredBefore4 => write!(
+                f,
+                "LLVM's minor version component is required for versions less than 4.0"
+            ),
+            LlvmVersionParseError::TooManyComponents => write!(f, "too many version components"),
+        }
+    }
 }
 
-#[test]
-fn parse_stable() {
-    let version = version_meta_for(
-"rustc 1.3.0 (9a92aaf19 2015-09-15)
-binary: rustc
-commit-hash: 9a92aaf19a64603b02b4130fe52958cc12488900
-commit-date: 2015-09-15
-host: x86_64-unknown-linux-gnu
-release: 1.3.0").unwrap();
-
-    assert_eq!(version.semver, Version::parse("1.3.0").unwrap());
-    assert_eq!(version.commit_hash, Some("9a92aaf19a64603b02b4130fe52958cc12488900".into()));
-    assert_eq!(version.commit_date, Some("2015-09-15".into()));
-    assert_eq!(version.channel, Channel::Stable);
-    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
-    assert_eq!(version.short_version_string, "rustc 1.3.0 (9a92aaf19 2015-09-15)");
+impl error::Error for LlvmVersionParseError {
+    fn source(&self) -> Option<&(dyn error::Error + 'static)> {
+        match self {
+            LlvmVersionParseError::ParseIntError(e) => Some(e),
+            LlvmVersionParseError::ComponentMustNotHaveLeadingZeros
+            | LlvmVersionParseError::ComponentMustNotHaveSign
+            | LlvmVersionParseError::MinorVersionMustBeZeroAfter4
+            | LlvmVersionParseError::MinorVersionRequiredBefore4
+            | LlvmVersionParseError::TooManyComponents => None,
+        }
+    }
 }
 
-#[test]
-fn parse_1_16_0_nightly() {
-    let version = version_meta_for(
-"rustc 1.16.0-nightly (5d994d8b7 2017-01-05)
-binary: rustc
-commit-hash: 5d994d8b7e482e87467d4a521911477bd8284ce3
-commit-date: 2017-01-05
-host: x86_64-unknown-linux-gnu
-release: 1.16.0-nightly
-LLVM version: 3.9").unwrap();
-
-    assert_eq!(version.semver, Version::parse("1.16.0-nightly").unwrap());
-    assert_eq!(version.commit_hash, Some("5d994d8b7e482e87467d4a521911477bd8284ce3".into()));
-    assert_eq!(version.commit_date, Some("2017-01-05".into()));
-    assert_eq!(version.channel, Channel::Nightly);
-    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
-    assert_eq!(version.short_version_string, "rustc 1.16.0-nightly (5d994d8b7 2017-01-05)");
+/// The error type for this crate.
+#[derive(Debug)]
+pub enum Error {
+    /// An error occurred while trying to find the `rustc` to run.
+    CouldNotExecuteCommand(io::Error),
+    /// Error output from the command that was run.
+    CommandError {
+        /// stdout output from the command
+        stdout: String,
+        /// stderr output from the command
+        stderr: String,
+    },
+    /// The output of `rustc -vV` was not valid utf-8.
+    Utf8Error(str::Utf8Error),
+    /// The output of `rustc -vV` was not in the expected format.
+    UnexpectedVersionFormat,
+    /// An error occurred in parsing the semver.
+    SemVerError(semver::Error),
+    /// The pre-release tag is unknown.
+    UnknownPreReleaseTag(String),
+    /// An error occurred in parsing a `LlvmVersion`.
+    LlvmVersionError(LlvmVersionParseError),
 }
 
-/*
-#[test]
-fn version_matches_replacement() {
-    let f = |s1: &str, s2: &str| {
-        let a = Version::parse(s1).unwrap();
-        let b = Version::parse(s2).unwrap();
-        println!("{} <= {} : {}", s1, s2, a <= b);
-    };
-
-    println!();
-
-    f("1.5.0",         "1.5.0");
-    f("1.5.0-nightly", "1.5.0");
-    f("1.5.0",         "1.5.0-nightly");
-    f("1.5.0-nightly", "1.5.0-nightly");
+impl fmt::Display for Error {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match *self {
+            CouldNotExecuteCommand(ref e) => write!(f, "could not execute command: {}", e),
+            CommandError {
+                ref stdout,
+                ref stderr,
+            } => write!(
+                f,
+                "error from command -- stderr:\n\n{}\n\nstderr:\n\n{}",
+                stderr, stdout,
+            ),
+            Utf8Error(_) => write!(f, "invalid UTF-8 output from `rustc -vV`"),
+            UnexpectedVersionFormat => write!(f, "unexpected `rustc -vV` format"),
+            SemVerError(ref e) => write!(f, "error parsing version: {}", e),
+            UnknownPreReleaseTag(ref i) => write!(f, "unknown pre-release tag: {}", i),
+            LlvmVersionError(ref e) => write!(f, "error parsing LLVM's version: {}", e),
+        }
+    }
+}
 
-    f("1.5.0",         "1.6.0");
-    f("1.5.0-nightly", "1.6.0");
-    f("1.5.0",         "1.6.0-nightly");
-    f("1.5.0-nightly", "1.6.0-nightly");
+impl error::Error for Error {
+    fn source(&self) -> Option<&(dyn error::Error + 'static)> {
+        match *self {
+            CouldNotExecuteCommand(ref e) => Some(e),
+            CommandError { .. } => None,
+            Utf8Error(ref e) => Some(e),
+            UnexpectedVersionFormat => None,
+            SemVerError(ref e) => Some(e),
+            UnknownPreReleaseTag(_) => None,
+            LlvmVersionError(ref e) => Some(e),
+        }
+    }
+}
 
-    panic!();
+macro_rules! impl_from {
+    ($($err_ty:ty => $variant:ident),* $(,)*) => {
+        $(
+            impl From<$err_ty> for Error {
+                fn from(e: $err_ty) -> Error {
+                    Error::$variant(e)
+                }
+            }
+        )*
+    }
+}
 
+impl_from! {
+    str::Utf8Error => Utf8Error,
+    semver::Error => SemVerError,
+    LlvmVersionParseError => LlvmVersionError,
 }
-*/
+
+/// The result type for this crate.
+pub type Result<T, E = Error> = std::result::Result<T, E>;
diff --git a/third_party/rust/rustc_version/tests/all.rs b/third_party/rust/rustc_version/tests/all.rs
new file mode 100644
index 000000000000..c3cff7048a8d
--- /dev/null
+++ b/third_party/rust/rustc_version/tests/all.rs
@@ -0,0 +1,456 @@
+#![allow(clippy::match_like_matches_macro)]
+
+use std::process::Command;
+
+use rustc_version::{
+    version, version_meta, version_meta_for, Channel, Error, LlvmVersion, LlvmVersionParseError,
+    Version, VersionMeta,
+};
+
+#[test]
+fn rustc_error() {
+    let mut cmd = Command::new("rustc");
+    cmd.arg("--FOO");
+    let stderr = match VersionMeta::for_command(cmd) {
+        Err(Error::CommandError { stdout: _, stderr }) => stderr,
+        _ => panic!("command error expected"),
+    };
+    assert_eq!(stderr, "error: Unrecognized option: \'FOO\'\n\n");
+}
+
+#[test]
+fn smoketest() {
+    let v = version().unwrap();
+    assert!(v.major >= 1);
+
+    let v = version_meta().unwrap();
+    assert!(v.semver.major >= 1);
+
+    assert!(version().unwrap() >= Version::parse("1.0.0").unwrap());
+}
+
+#[test]
+fn parse_1_0_0() {
+    let version = version_meta_for(
+        "rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)
+binary: rustc
+commit-hash: a59de37e99060162a2674e3ff45409ac73595c0e
+commit-date: 2015-05-13
+build-date: 2015-05-14
+host: x86_64-unknown-linux-gnu
+release: 1.0.0",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.0.0").unwrap());
+    assert_eq!(
+        version.commit_hash,
+        Some("a59de37e99060162a2674e3ff45409ac73595c0e".into())
+    );
+    assert_eq!(version.commit_date, Some("2015-05-13".into()));
+    assert_eq!(version.build_date, Some("2015-05-14".into()));
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(
+        version.short_version_string,
+        "rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)"
+    );
+    assert_eq!(version.llvm_version, None);
+}
+
+#[test]
+fn parse_unknown() {
+    let version = version_meta_for(
+        "rustc 1.3.0
+binary: rustc
+commit-hash: unknown
+commit-date: unknown
+host: x86_64-unknown-linux-gnu
+release: 1.3.0",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.3.0").unwrap());
+    assert_eq!(version.commit_hash, None);
+    assert_eq!(version.commit_date, None);
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(version.short_version_string, "rustc 1.3.0");
+    assert_eq!(version.llvm_version, None);
+}
+
+#[test]
+fn parse_nightly() {
+    let version = version_meta_for(
+        "rustc 1.5.0-nightly (65d5c0833 2015-09-29)
+binary: rustc
+commit-hash: 65d5c083377645a115c4ac23a620d3581b9562b6
+commit-date: 2015-09-29
+host: x86_64-unknown-linux-gnu
+release: 1.5.0-nightly",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.5.0-nightly").unwrap());
+    assert_eq!(
+        version.commit_hash,
+        Some("65d5c083377645a115c4ac23a620d3581b9562b6".into())
+    );
+    assert_eq!(version.commit_date, Some("2015-09-29".into()));
+    assert_eq!(version.channel, Channel::Nightly);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(
+        version.short_version_string,
+        "rustc 1.5.0-nightly (65d5c0833 2015-09-29)"
+    );
+    assert_eq!(version.llvm_version, None);
+}
+
+#[test]
+fn parse_stable() {
+    let version = version_meta_for(
+        "rustc 1.3.0 (9a92aaf19 2015-09-15)
+binary: rustc
+commit-hash: 9a92aaf19a64603b02b4130fe52958cc12488900
+commit-date: 2015-09-15
+host: x86_64-unknown-linux-gnu
+release: 1.3.0",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.3.0").unwrap());
+    assert_eq!(
+        version.commit_hash,
+        Some("9a92aaf19a64603b02b4130fe52958cc12488900".into())
+    );
+    assert_eq!(version.commit_date, Some("2015-09-15".into()));
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(
+        version.short_version_string,
+        "rustc 1.3.0 (9a92aaf19 2015-09-15)"
+    );
+    assert_eq!(version.llvm_version, None);
+}
+
+#[test]
+fn parse_1_16_0_nightly() {
+    let version = version_meta_for(
+        "rustc 1.16.0-nightly (5d994d8b7 2017-01-05)
+binary: rustc
+commit-hash: 5d994d8b7e482e87467d4a521911477bd8284ce3
+commit-date: 2017-01-05
+host: x86_64-unknown-linux-gnu
+release: 1.16.0-nightly
+LLVM version: 3.9",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.16.0-nightly").unwrap());
+    assert_eq!(
+        version.commit_hash,
+        Some("5d994d8b7e482e87467d4a521911477bd8284ce3".into())
+    );
+    assert_eq!(version.commit_date, Some("2017-01-05".into()));
+    assert_eq!(version.channel, Channel::Nightly);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(
+        version.short_version_string,
+        "rustc 1.16.0-nightly (5d994d8b7 2017-01-05)"
+    );
+    assert_eq!(
+        version.llvm_version,
+        Some(LlvmVersion { major: 3, minor: 9 })
+    );
+}
+
+#[test]
+fn parse_1_47_0_stable() {
+    let version = version_meta_for(
+        "rustc 1.47.0 (18bf6b4f0 2020-10-07)
+binary: rustc
+commit-hash: 18bf6b4f01a6feaf7259ba7cdae58031af1b7b39
+commit-date: 2020-10-07
+host: powerpc64le-unknown-linux-gnu
+release: 1.47.0
+LLVM version: 11.0",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.47.0").unwrap());
+    assert_eq!(
+        version.commit_hash,
+        Some("18bf6b4f01a6feaf7259ba7cdae58031af1b7b39".into())
+    );
+    assert_eq!(version.commit_date, Some("2020-10-07".into()));
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "powerpc64le-unknown-linux-gnu");
+    assert_eq!(
+        version.short_version_string,
+        "rustc 1.47.0 (18bf6b4f0 2020-10-07)"
+    );
+    assert_eq!(
+        version.llvm_version,
+        Some(LlvmVersion {
+            major: 11,
+            minor: 0,
+        })
+    );
+}
+
+#[test]
+fn parse_llvm_micro() {
+    let version = version_meta_for(
+        "rustc 1.51.0-nightly (4253153db 2021-01-17)
+binary: rustc
+commit-hash: 4253153db205251f72ea4493687a31e04a2a8ca0
+commit-date: 2021-01-17
+host: x86_64-pc-windows-msvc
+release: 1.51.0-nightly
+LLVM version: 11.0.1",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.51.0-nightly").unwrap());
+    assert_eq!(
+        version.commit_hash.unwrap(),
+        "4253153db205251f72ea4493687a31e04a2a8ca0"
+    );
+    assert_eq!(version.commit_date.unwrap(), "2021-01-17");
+    assert_eq!(version.host, "x86_64-pc-windows-msvc");
+    assert_eq!(
+        version.short_version_string,
+        "rustc 1.51.0-nightly (4253153db 2021-01-17)"
+    );
+    assert_eq!(
+        version.llvm_version,
+        Some(LlvmVersion {
+            major: 11,
+            minor: 0
+        })
+    );
+}
+
+#[test]
+fn parse_debian_buster() {
+    let version = version_meta_for(
+        "rustc 1.41.1
+binary: rustc
+commit-hash: unknown
+commit-date: unknown
+host: powerpc64le-unknown-linux-gnu
+release: 1.41.1
+LLVM version: 7.0",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.41.1").unwrap());
+    assert_eq!(version.commit_hash, None);
+    assert_eq!(version.commit_date, None);
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "powerpc64le-unknown-linux-gnu");
+    assert_eq!(version.short_version_string, "rustc 1.41.1");
+    assert_eq!(
+        version.llvm_version,
+        Some(LlvmVersion { major: 7, minor: 0 })
+    );
+}
+
+#[test]
+fn parse_termux() {
+    let version = version_meta_for(
+        "rustc 1.46.0
+binary: rustc
+commit-hash: unknown
+commit-date: unknown
+host: aarch64-linux-android
+release: 1.46.0
+LLVM version: 10.0",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.46.0").unwrap());
+    assert_eq!(version.commit_hash, None);
+    assert_eq!(version.commit_date, None);
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "aarch64-linux-android");
+    assert_eq!(version.short_version_string, "rustc 1.46.0");
+    assert_eq!(
+        version.llvm_version,
+        Some(LlvmVersion {
+            major: 10,
+            minor: 0,
+        })
+    );
+}
+
+#[test]
+fn parse_llvm_version_empty() {
+    let res: Result<LlvmVersion, _> = "".parse();
+    assert!(match res {
+        Err(LlvmVersionParseError::ParseIntError(_)) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_invalid_char() {
+    let res: Result<LlvmVersion, _> = "A".parse();
+    assert!(match res {
+        Err(LlvmVersionParseError::ParseIntError(_)) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_overflow() {
+    let res: Result<LlvmVersion, _> = "9999999999999999999999999999999".parse();
+    assert!(match res {
+        Err(LlvmVersionParseError::ParseIntError(_)) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_leading_zero_on_zero() {
+    let res: Result<LlvmVersion, _> = "00".parse();
+    assert!(match res {
+        Err(LlvmVersionParseError::ComponentMustNotHaveLeadingZeros) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_leading_zero_on_nonzero() {
+    let res: Result<LlvmVersion, _> = "01".parse();
+    assert!(match res {
+        Err(LlvmVersionParseError::ComponentMustNotHaveLeadingZeros) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_4_components() {
+    let res: Result<LlvmVersion, _> = "4.0.0.0".parse();
+
+    assert!(match res {
+        Err(LlvmVersionParseError::TooManyComponents) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_component_sign_plus() {
+    let res: Result<LlvmVersion, _> = "1.+3".parse();
+
+    assert!(match res {
+        Err(LlvmVersionParseError::ComponentMustNotHaveSign) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_component_sign_minus() {
+    let res: Result<LlvmVersion, _> = "1.-3".parse();
+
+    assert!(match res {
+        Err(LlvmVersionParseError::ComponentMustNotHaveSign) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_3() {
+    let res: Result<LlvmVersion, _> = "3".parse();
+
+    assert!(match res {
+        Err(LlvmVersionParseError::MinorVersionRequiredBefore4) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_5() {
+    let v: LlvmVersion = "5".parse().unwrap();
+    assert_eq!(v, LlvmVersion { major: 5, minor: 0 });
+}
+
+#[test]
+fn parse_llvm_version_5_0() {
+    let v: LlvmVersion = "5.0".parse().unwrap();
+    assert_eq!(v, LlvmVersion { major: 5, minor: 0 });
+}
+
+#[test]
+fn parse_llvm_version_4_0() {
+    let v: LlvmVersion = "4.0".parse().unwrap();
+    assert_eq!(v, LlvmVersion { major: 4, minor: 0 });
+}
+
+#[test]
+fn parse_llvm_version_3_0() {
+    let v: LlvmVersion = "3.0".parse().unwrap();
+    assert_eq!(v, LlvmVersion { major: 3, minor: 0 });
+}
+
+#[test]
+fn parse_llvm_version_3_9() {
+    let v: LlvmVersion = "3.9".parse().unwrap();
+    assert_eq!(v, LlvmVersion { major: 3, minor: 9 });
+}
+
+#[test]
+fn parse_llvm_version_11_0() {
+    let v: LlvmVersion = "11.0".parse().unwrap();
+    assert_eq!(
+        v,
+        LlvmVersion {
+            major: 11,
+            minor: 0
+        }
+    );
+}
+
+#[test]
+fn parse_llvm_version_11() {
+    let v: LlvmVersion = "11".parse().unwrap();
+    assert_eq!(
+        v,
+        LlvmVersion {
+            major: 11,
+            minor: 0
+        }
+    );
+}
+
+#[test]
+fn test_llvm_version_comparison() {
+    // check that field order is correct
+    assert!(LlvmVersion { major: 3, minor: 9 } < LlvmVersion { major: 4, minor: 0 });
+}
+
+/*
+#[test]
+fn version_matches_replacement() {
+    let f = |s1: &str, s2: &str| {
+        let a = Version::parse(s1).unwrap();
+        let b = Version::parse(s2).unwrap();
+        println!("{} <= {} : {}", s1, s2, a <= b);
+    };
+
+    println!();
+
+    f("1.5.0",         "1.5.0");
+    f("1.5.0-nightly", "1.5.0");
+    f("1.5.0",         "1.5.0-nightly");
+    f("1.5.0-nightly", "1.5.0-nightly");
+
+    f("1.5.0",         "1.6.0");
+    f("1.5.0-nightly", "1.6.0");
+    f("1.5.0",         "1.6.0-nightly");
+    f("1.5.0-nightly", "1.6.0-nightly");
+
+    panic!();
+
+}
+*/
diff --git a/third_party/rust/semver-0.9.0/.cargo-checksum.json b/third_party/rust/semver-0.9.0/.cargo-checksum.json
new file mode 100644
index 000000000000..2f9af6eca870
--- /dev/null
+++ b/third_party/rust/semver-0.9.0/.cargo-checksum.json
@@ -0,0 +1 @@
+{"files":{"Cargo.toml":"a5b995796b5559de8975a6fee7166c9fda6c21b449ec90bef5f9baaeddd479a5","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"6485b8ed310d3f0340bf1ad1f47645069ce4069dcc6bb46c7d5c6faf41de1fdb","README.md":"c780d8c3c802c5fe2c316127900385010c3e57f71c851eea9e8ed8495e2030dd","src/lib.rs":"cb1725a8bb90c1043f187c6ba504d0a9d07793e2f39f5205f926c58849311770","src/version.rs":"ffdf9c628597b889f149f3b2b1245b97c774eae1ce7030bd19235eabecaaede0","src/version_req.rs":"40d20720f5fdc0b3d9e398e64eb448a65987229bd322cab0fedf0cf1843f3bd8","tests/deprecation.rs":"b5ec79e19d61968d05b96b876c449e54d43cbd1762c6e63c23c3470f9db56292","tests/regression.rs":"180b699ad029b81e6135d42f0a8e6d782177bc29a41132f875ee6f8607a46b56","tests/serde.rs":"cdbbefc576ffcc814c30dad9598ab87a7fd9d14c5f42f1349e1db6afc72f8fed"},"package":"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403"}
\ No newline at end of file
diff --git a/third_party/rust/semver-0.9.0/Cargo.toml b/third_party/rust/semver-0.9.0/Cargo.toml
new file mode 100644
index 000000000000..7749f76c3778
--- /dev/null
+++ b/third_party/rust/semver-0.9.0/Cargo.toml
@@ -0,0 +1,45 @@
+# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
+#
+# When uploading crates to the registry Cargo will automatically
+# "normalize" Cargo.toml files for maximal compatibility
+# with all versions of Cargo and also rewrite `path` dependencies
+# to registry (e.g. crates.io) dependencies
+#
+# If you believe there's an error in this file please file an
+# issue against the rust-lang/cargo repository. If you're
+# editing this file be aware that the upstream Cargo.toml
+# will likely look very different (and much more reasonable)
+
+[package]
+name = "semver"
+version = "0.9.0"
+authors = ["Steve Klabnik <steve@steveklabnik.com>", "The Rust Project Developers"]
+description = "Semantic version parsing and comparison.\n"
+homepage = "https://docs.rs/crate/semver/"
+documentation = "https://docs.rs/crate/semver/"
+readme = "README.md"
+license = "MIT/Apache-2.0"
+repository = "https://github.com/steveklabnik/semver"
+[dependencies.semver-parser]
+version = "0.7.0"
+
+[dependencies.serde]
+version = "1.0"
+optional = true
+[dev-dependencies.crates-index]
+version = "0.5.0"
+
+[dev-dependencies.serde_json]
+version = "1.0"
+
+[dev-dependencies.serde_derive]
+version = "1.0"
+
+[dev-dependencies.tempdir]
+version = "0.3.4"
+
+[features]
+default = []
+ci = ["serde"]
+[badges.travis-ci]
+repository = "steveklabnik/semver"
diff --git a/third_party/rust/semver-0.9.0/LICENSE-APACHE b/third_party/rust/semver-0.9.0/LICENSE-APACHE
new file mode 100644
index 000000000000..16fe87b06e80
--- /dev/null
+++ b/third_party/rust/semver-0.9.0/LICENSE-APACHE
@@ -0,0 +1,201 @@
+                              Apache License
+                        Version 2.0, January 2004
+                     http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+   "License" shall mean the terms and conditions for use, reproduction,
+   and distribution as defined by Sections 1 through 9 of this document.
+
+   "Licensor" shall mean the copyright owner or entity authorized by
+   the copyright owner that is granting the License.
+
+   "Legal Entity" shall mean the union of the acting entity and all
+   other entities that control, are controlled by, or are under common
+   control with that entity. For the purposes of this definition,
+   "control" means (i) the power, direct or indirect, to cause the
+   direction or management of such entity, whether by contract or
+   otherwise, or (ii) ownership of fifty percent (50%) or more of the
+   outstanding shares, or (iii) beneficial ownership of such entity.
+
+   "You" (or "Your") shall mean an individual or Legal Entity
+   exercising permissions granted by this License.
+
+   "Source" form shall mean the preferred form for making modifications,
+   including but not limited to software source code, documentation
+   source, and configuration files.
+
+   "Object" form shall mean any form resulting from mechanical
+   transformation or translation of a Source form, including but
+   not limited to compiled object code, generated documentation,
+   and conversions to other media types.
+
+   "Work" shall mean the work of authorship, whether in Source or
+   Object form, made available under the License, as indicated by a
+   copyright notice that is included in or attached to the work
+   (an example is provided in the Appendix below).
+
+   "Derivative Works" shall mean any work, whether in Source or Object
+   form, that is based on (or derived from) the Work and for which the
+   editorial revisions, annotations, elaborations, or other modifications
+   represent, as a whole, an original work of authorship. For the purposes
+   of this License, Derivative Works shall not include works that remain
+   separable from, or merely link (or bind by name) to the interfaces of,
+   the Work and Derivative Works thereof.
+
+   "Contribution" shall mean any work of authorship, including
+   the original version of the Work and any modifications or additions
+   to that Work or Derivative Works thereof, that is intentionally
+   submitted to Licensor for inclusion in the Work by the copyright owner
+   or by an individual or Legal Entity authorized to submit on behalf of
+   the copyright owner. For the purposes of this definition, "submitted"
+   means any form of electronic, verbal, or written communication sent
+   to the Licensor or its representatives, including but not limited to
+   communication on electronic mailing lists, source code control systems,
+   and issue tracking systems that are managed by, or on behalf of, the
+   Licensor for the purpose of discussing and improving the Work, but
+   excluding communication that is conspicuously marked or otherwise
+   designated in writing by the copyright owner as "Not a Contribution."
+
+   "Contributor" shall mean Licensor and any individual or Legal Entity
+   on behalf of whom a Contribution has been received by Licensor and
+   subsequently incorporated within the Work.
+
+2. Grant of Copyright License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   copyright license to reproduce, prepare Derivative Works of,
+   publicly display, publicly perform, sublicense, and distribute the
+   Work and such Derivative Works in Source or Object form.
+
+3. Grant of Patent License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   (except as stated in this section) patent license to make, have made,
+   use, offer to sell, sell, import, and otherwise transfer the Work,
+   where such license applies only to those patent claims licensable
+   by such Contributor that are necessarily infringed by their
+   Contribution(s) alone or by combination of their Contribution(s)
+   with the Work to which such Contribution(s) was submitted. If You
+   institute patent litigation against any entity (including a
+   cross-claim or counterclaim in a lawsuit) alleging that the Work
+   or a Contribution incorporated within the Work constitutes direct
+   or contributory patent infringement, then any patent licenses
+   granted to You under this License for that Work shall terminate
+   as of the date such litigation is filed.
+
+4. Redistribution. You may reproduce and distribute copies of the
+   Work or Derivative Works thereof in any medium, with or without
+   modifications, and in Source or Object form, provided that You
+   meet the following conditions:
+
+   (a) You must give any other recipients of the Work or
+       Derivative Works a copy of this License; and
+
+   (b) You must cause any modified files to carry prominent notices
+       stating that You changed the files; and
+
+   (c) You must retain, in the Source form of any Derivative Works
+       that You distribute, all copyright, patent, trademark, and
+       attribution notices from the Source form of the Work,
+       excluding those notices that do not pertain to any part of
+       the Derivative Works; and
+
+   (d) If the Work includes a "NOTICE" text file as part of its
+       distribution, then any Derivative Works that You distribute must
+       include a readable copy of the attribution notices contained
+       within such NOTICE file, excluding those notices that do not
+       pertain to any part of the Derivative Works, in at least one
+       of the following places: within a NOTICE text file distributed
+       as part of the Derivative Works; within the Source form or
+       documentation, if provided along with the Derivative Works; or,
+       within a display generated by the Derivative Works, if and
+       wherever such third-party notices normally appear. The contents
+       of the NOTICE file are for informational purposes only and
+       do not modify the License. You may add Your own attribution
+       notices within Derivative Works that You distribute, alongside
+       or as an addendum to the NOTICE text from the Work, provided
+       that such additional attribution notices cannot be construed
+       as modifying the License.
+
+   You may add Your own copyright statement to Your modifications and
+   may provide additional or different license terms and conditions
+   for use, reproduction, or distribution of Your modifications, or
+   for any such Derivative Works as a whole, provided Your use,
+   reproduction, and distribution of the Work otherwise complies with
+   the conditions stated in this License.
+
+5. Submission of Contributions. Unless You explicitly state otherwise,
+   any Contribution intentionally submitted for inclusion in the Work
+   by You to the Licensor shall be under the terms and conditions of
+   this License, without any additional terms or conditions.
+   Notwithstanding the above, nothing herein shall supersede or modify
+   the terms of any separate license agreement you may have executed
+   with Licensor regarding such Contributions.
+
+6. Trademarks. This License does not grant permission to use the trade
+   names, trademarks, service marks, or product names of the Licensor,
+   except as required for reasonable and customary use in describing the
+   origin of the Work and reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty. Unless required by applicable law or
+   agreed to in writing, Licensor provides the Work (and each
+   Contributor provides its Contributions) on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+   implied, including, without limitation, any warranties or conditions
+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+   PARTICULAR PURPOSE. You are solely responsible for determining the
+   appropriateness of using or redistributing the Work and assume any
+   risks associated with Your exercise of permissions under this License.
+
+8. Limitation of Liability. In no event and under no legal theory,
+   whether in tort (including negligence), contract, or otherwise,
+   unless required by applicable law (such as deliberate and grossly
+   negligent acts) or agreed to in writing, shall any Contributor be
+   liable to You for damages, including any direct, indirect, special,
+   incidental, or consequential damages of any character arising as a
+   result of this License or out of the use or inability to use the
+   Work (including but not limited to damages for loss of goodwill,
+   work stoppage, computer failure or malfunction, or any and all
+   other commercial damages or losses), even if such Contributor
+   has been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability. While redistributing
+   the Work or Derivative Works thereof, You may choose to offer,
+   and charge a fee for, acceptance of support, warranty, indemnity,
+   or other liability obligations and/or rights consistent with this
+   License. However, in accepting such obligations, You may act only
+   on Your own behalf and on Your sole responsibility, not on behalf
+   of any other Contributor, and only if You agree to indemnify,
+   defend, and hold each Contributor harmless for any liability
+   incurred by, or claims asserted against, such Contributor by reason
+   of your accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
+
+APPENDIX: How to apply the Apache License to your work.
+
+   To apply the Apache License to your work, attach the following
+   boilerplate notice, with the fields enclosed by brackets "[]"
+   replaced with your own identifying information. (Don't include
+   the brackets!)  The text should be enclosed in the appropriate
+   comment syntax for the file format. We also recommend that a
+   file or class name and description of purpose be included on the
+   same "printed page" as the copyright notice for easier
+   identification within third-party archives.
+
+Copyright [yyyy] [name of copyright owner]
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+	http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/third_party/rust/semver-0.9.0/LICENSE-MIT b/third_party/rust/semver-0.9.0/LICENSE-MIT
new file mode 100644
index 000000000000..39d4bdb5acd3
--- /dev/null
+++ b/third_party/rust/semver-0.9.0/LICENSE-MIT
@@ -0,0 +1,25 @@
+Copyright (c) 2014 The Rust Project Developers
+
+Permission is hereby granted, free of charge, to any
+person obtaining a copy of this software and associated
+documentation files (the "Software"), to deal in the
+Software without restriction, including without
+limitation the rights to use, copy, modify, merge,
+publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software
+is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice
+shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
diff --git a/third_party/rust/semver-0.9.0/README.md b/third_party/rust/semver-0.9.0/README.md
new file mode 100644
index 000000000000..2a5306d4ccd2
--- /dev/null
+++ b/third_party/rust/semver-0.9.0/README.md
@@ -0,0 +1,103 @@
+semver
+======
+
+Semantic version parsing and comparison.
+
+[![Build Status](https://api.travis-ci.org/steveklabnik/semver.svg?branch=master)](https://travis-ci.org/steveklabnik/semver)
+
+[Documentation](https://steveklabnik.github.io/semver)
+
+Semantic versioning (see http://semver.org/) is a set of rules for
+assigning version numbers.
+
+## SemVer and the Rust ecosystem
+
+Rust itself follows the SemVer specification, as does its standard libraries. The two are
+not tied together.
+
+[Cargo](https://crates.io), Rust's package manager, uses SemVer to determine which versions of
+packages you need installed.
+
+## Installation
+
+To use `semver`, add this to your `[dependencies]` section:
+
+```toml
+semver = "0.7.0"
+```
+
+And this to your crate root:
+
+```rust
+extern crate semver;
+```
+
+## Versions
+
+At its simplest, the `semver` crate allows you to construct `Version` objects using the `parse`
+method:
+
+```rust
+use semver::Version;
+
+assert!(Version::parse("1.2.3") == Ok(Version {
+   major: 1,
+   minor: 2,
+   patch: 3,
+   pre: vec!(),
+   build: vec!(),
+}));
+```
+
+If you have multiple `Version`s, you can use the usual comparison operators to compare them:
+
+```rust
+use semver::Version;
+
+assert!(Version::parse("1.2.3-alpha")  != Version::parse("1.2.3-beta"));
+assert!(Version::parse("1.2.3-alpha2") >  Version::parse("1.2.0"));
+```
+
+## Requirements
+
+The `semver` crate also provides the ability to compare requirements, which are more complex
+comparisons.
+
+For example, creating a requirement that only matches versions greater than or
+equal to 1.0.0:
+
+```rust
+use semver::Version;
+use semver::VersionReq;
+
+let r = VersionReq::parse(">= 1.0.0").unwrap();
+let v = Version::parse("1.0.0").unwrap();
+
+assert!(r.to_string() == ">= 1.0.0".to_string());
+assert!(r.matches(&v))
+```
+
+It also allows parsing of `~x.y.z` and `^x.y.z` requirements as defined at
+https://www.npmjs.org/doc/misc/semver.html
+
+**Tilde requirements** specify a minimal version with some updates:
+
+```notrust
+~1.2.3 := >=1.2.3 <1.3.0
+~1.2   := >=1.2.0 <1.3.0
+~1     := >=1.0.0 <2.0.0
+```
+
+**Caret requirements** allow SemVer compatible updates to a specified version,
+`0.x` and `0.x+1` are not considered compatible, but `1.x` and `1.x+1` are.
+
+`0.0.x` is not considered compatible with any other version.
+Missing minor and patch versions are desugared to `0` but allow flexibility for that value.
+
+```notrust
+^1.2.3 := >=1.2.3 <2.0.0
+^0.2.3 := >=0.2.3 <0.3.0
+^0.0.3 := >=0.0.3 <0.0.4
+^0.0   := >=0.0.0 <0.1.0
+^0     := >=0.0.0 <1.0.0
+```
diff --git a/third_party/rust/semver-0.9.0/src/lib.rs b/third_party/rust/semver-0.9.0/src/lib.rs
new file mode 100644
index 000000000000..a38aae0e163d
--- /dev/null
+++ b/third_party/rust/semver-0.9.0/src/lib.rs
@@ -0,0 +1,182 @@
+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT
+// file at the top-level directory of this distribution and at
+// http://rust-lang.org/COPYRIGHT.
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+//! Semantic version parsing and comparison.
+//!
+//! Semantic versioning (see http://semver.org/) is a set of rules for
+//! assigning version numbers.
+//!
+//! ## SemVer overview
+//!
+//! Given a version number MAJOR.MINOR.PATCH, increment the:
+//!
+//! 1. MAJOR version when you make incompatible API changes,
+//! 2. MINOR version when you add functionality in a backwards-compatible
+//!    manner, and
+//! 3. PATCH version when you make backwards-compatible bug fixes.
+//!
+//! Additional labels for pre-release and build metadata are available as
+//! extensions to the MAJOR.MINOR.PATCH format.
+//!
+//! Any references to 'the spec' in this documentation refer to [version 2.0 of
+//! the SemVer spec](http://semver.org/spec/v2.0.0.html).
+//!
+//! ## SemVer and the Rust ecosystem
+//!
+//! Rust itself follows the SemVer specification, as does its standard
+//! libraries. The two are not tied together.
+//!
+//! [Cargo](http://crates.io), Rust's package manager, uses SemVer to determine
+//! which versions of packages you need installed.
+//!
+//! ## Versions
+//!
+//! At its simplest, the `semver` crate allows you to construct `Version`
+//! objects using the `parse` method:
+//!
+//! ```{rust}
+//! use semver::Version;
+//!
+//! assert!(Version::parse("1.2.3") == Ok(Version {
+//!    major: 1,
+//!    minor: 2,
+//!    patch: 3,
+//!    pre: vec!(),
+//!    build: vec!(),
+//! }));
+//! ```
+//!
+//! If you have multiple `Version`s, you can use the usual comparison operators
+//! to compare them:
+//!
+//! ```{rust}
+//! use semver::Version;
+//!
+//! assert!(Version::parse("1.2.3-alpha") != Version::parse("1.2.3-beta"));
+//! assert!(Version::parse("1.2.3-alpha2") >  Version::parse("1.2.0"));
+//! ```
+//!
+//! If you explicitly need to modify a Version, SemVer also allows you to
+//! increment the major, minor, and patch numbers in accordance with the spec.
+//!
+//! Please note that in order to do this, you must use a mutable Version:
+//!
+//! ```{rust}
+//! use semver::Version;
+//!
+//! let mut bugfix_release = Version::parse("1.0.0").unwrap();
+//! bugfix_release.increment_patch();
+//!
+//! assert_eq!(Ok(bugfix_release), Version::parse("1.0.1"));
+//! ```
+//!
+//! When incrementing the minor version number, the patch number resets to zero
+//! (in accordance with section 7 of the spec)
+//!
+//! ```{rust}
+//! use semver::Version;
+//!
+//! let mut feature_release = Version::parse("1.4.6").unwrap();
+//! feature_release.increment_minor();
+//!
+//! assert_eq!(Ok(feature_release), Version::parse("1.5.0"));
+//! ```
+//!
+//! Similarly, when incrementing the major version number, the patch and minor
+//! numbers reset to zero (in accordance with section 8 of the spec)
+//!
+//! ```{rust}
+//! use semver::Version;
+//!
+//! let mut chrome_release = Version::parse("41.5.5377").unwrap();
+//! chrome_release.increment_major();
+//!
+//! assert_eq!(Ok(chrome_release), Version::parse("42.0.0"));
+//! ```
+//!
+//! ## Requirements
+//!
+//! The `semver` crate also provides the ability to compare requirements, which
+//! are more complex comparisons.
+//!
+//! For example, creating a requirement that only matches versions greater than
+//! or equal to 1.0.0:
+//!
+//! ```{rust}
+//! # #![allow(unstable)]
+//! use semver::Version;
+//! use semver::VersionReq;
+//!
+//! let r = VersionReq::parse(">= 1.0.0").unwrap();
+//! let v = Version::parse("1.0.0").unwrap();
+//!
+//! assert!(r.to_string() == ">= 1.0.0".to_string());
+//! assert!(r.matches(&v))
+//! ```
+//!
+//! It also allows parsing of `~x.y.z` and `^x.y.z` requirements as defined at
+//! https://www.npmjs.org/doc/misc/semver.html
+//!
+//! **Tilde requirements** specify a minimal version with some updates:
+//!
+//! ```notrust
+//! ~1.2.3 := >=1.2.3 <1.3.0
+//! ~1.2   := >=1.2.0 <1.3.0
+//! ~1     := >=1.0.0 <2.0.0
+//! ```
+//!
+//! **Caret requirements** allow SemVer compatible updates to a specified
+//! verion, `0.x` and `0.x+1` are not considered compatible, but `1.x` and
+//! `1.x+1` are.
+//!
+//! `0.0.x` is not considered compatible with any other version.
+//! Missing minor and patch versions are desugared to `0` but allow flexibility
+//! for that value.
+//!
+//! ```notrust
+//! ^1.2.3 := >=1.2.3 <2.0.0
+//! ^0.2.3 := >=0.2.3 <0.3.0
+//! ^0.0.3 := >=0.0.3 <0.0.4
+//! ^0.0   := >=0.0.0 <0.1.0
+//! ^0     := >=0.0.0 <1.0.0
+//! ```
+//!
+//! **Wildcard requirements** allows parsing of version requirements of the
+//! formats `*`, `x.*` and `x.y.*`.
+//!
+//! ```notrust
+//! *     := >=0.0.0
+//! 1.*   := >=1.0.0 <2.0.0
+//! 1.2.* := >=1.2.0 <1.3.0
+//! ```
+
+#![doc(html_logo_url = "https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png",
+       html_favicon_url = "https://www.rust-lang.org/favicon.ico")]
+#![deny(missing_docs)]
+#![cfg_attr(test, deny(warnings))]
+
+extern crate semver_parser;
+
+// Serialization and deserialization support for version numbers
+#[cfg(feature = "serde")]
+extern crate serde;
+
+// We take the common approach of keeping our own module system private, and
+// just re-exporting the interface that we want.
+
+pub use version::{Version, Identifier, SemVerError};
+pub use version::Identifier::{Numeric, AlphaNumeric};
+pub use version_req::{VersionReq, ReqParseError};
+
+// SemVer-compliant versions.
+mod version;
+
+// advanced version comparisons
+mod version_req;
diff --git a/third_party/rust/semver/src/version.rs b/third_party/rust/semver-0.9.0/src/version.rs
similarity index 100%
rename from third_party/rust/semver/src/version.rs
rename to third_party/rust/semver-0.9.0/src/version.rs
diff --git a/third_party/rust/semver/src/version_req.rs b/third_party/rust/semver-0.9.0/src/version_req.rs
similarity index 100%
rename from third_party/rust/semver/src/version_req.rs
rename to third_party/rust/semver-0.9.0/src/version_req.rs
diff --git a/third_party/rust/semver/tests/deprecation.rs b/third_party/rust/semver-0.9.0/tests/deprecation.rs
similarity index 100%
rename from third_party/rust/semver/tests/deprecation.rs
rename to third_party/rust/semver-0.9.0/tests/deprecation.rs
diff --git a/third_party/rust/semver/tests/regression.rs b/third_party/rust/semver-0.9.0/tests/regression.rs
similarity index 100%
rename from third_party/rust/semver/tests/regression.rs
rename to third_party/rust/semver-0.9.0/tests/regression.rs
diff --git a/third_party/rust/semver/tests/serde.rs b/third_party/rust/semver-0.9.0/tests/serde.rs
similarity index 100%
rename from third_party/rust/semver/tests/serde.rs
rename to third_party/rust/semver-0.9.0/tests/serde.rs
diff --git a/third_party/rust/semver/.cargo-checksum.json b/third_party/rust/semver/.cargo-checksum.json
index 2f9af6eca870..f9b5c853b449 100644
--- a/third_party/rust/semver/.cargo-checksum.json
+++ b/third_party/rust/semver/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"Cargo.toml":"a5b995796b5559de8975a6fee7166c9fda6c21b449ec90bef5f9baaeddd479a5","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"6485b8ed310d3f0340bf1ad1f47645069ce4069dcc6bb46c7d5c6faf41de1fdb","README.md":"c780d8c3c802c5fe2c316127900385010c3e57f71c851eea9e8ed8495e2030dd","src/lib.rs":"cb1725a8bb90c1043f187c6ba504d0a9d07793e2f39f5205f926c58849311770","src/version.rs":"ffdf9c628597b889f149f3b2b1245b97c774eae1ce7030bd19235eabecaaede0","src/version_req.rs":"40d20720f5fdc0b3d9e398e64eb448a65987229bd322cab0fedf0cf1843f3bd8","tests/deprecation.rs":"b5ec79e19d61968d05b96b876c449e54d43cbd1762c6e63c23c3470f9db56292","tests/regression.rs":"180b699ad029b81e6135d42f0a8e6d782177bc29a41132f875ee6f8607a46b56","tests/serde.rs":"cdbbefc576ffcc814c30dad9598ab87a7fd9d14c5f42f1349e1db6afc72f8fed"},"package":"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403"}
\ No newline at end of file
+{"files":{"Cargo.toml":"2841cf520fc7e71e16036c48021789cdf36182786556b2a97eb8371193e0c69c","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"23f18e03dc49df91622fe2a76176497404e46ced8a715d9d2b67a7446571cca3","README.md":"83e92a83348171f60d768651091803e69e4cb7ea3190cdfc45918d4637f38e1e","benches/parse.rs":"6531f66f80ce2fc83878f9bf84f94c42e96f1e709466f2b88be8d95a3cec1511","build.rs":"eedfc19afa205955347175916974cdad121b55cb940e40c61931e5e7629f0e65","src/backport.rs":"f8866548840434c8974f135528693f25aacc4ad03639c4e3aea3be351e13fdf8","src/display.rs":"9ba42f7a6579aa9c7dd72f2380036f5c9664592f3eacd09ea25cef291a3e64e5","src/error.rs":"3bb489f4a29f38d93370e64ae8d6e4e9b451a055cd7d392b6aeacab7eb3e1953","src/eval.rs":"b7e7ec976051b9f87ddf5cfdbaad64654d98d86ae0763f7d88b14eeaeac6013c","src/identifier.rs":"601231351ac58602b7d193cb0951b5146bd868b62aba938d5cbe52cf2b93414b","src/impls.rs":"79b5a2ac6ca3d4cb46adfb1494756079f53bef780dd81c3a8d3adf86f91395c8","src/lib.rs":"f59b217cd6d3e26389562710c540f0f0e1af7184ac5cbf75b2200f7ed7538f1d","src/parse.rs":"ffbb84081f0f66ec47b752a1e32f1bea5f206ca84f464b99d0497451305a92f8","src/serde.rs":"e2a9b9dc3cd2cccc250eaffad049de418ef791bf8c4a34111a48f068353e0a37","tests/node/mod.rs":"2710d9b8daace2038b66db0f8f4cc522dee938e7cbc42d7739c31995343c32f4","tests/test_autotrait.rs":"070500c32ceee14a8a0110c04a01f98278b24614a0aec8c382dcea3da0343f58","tests/test_identifier.rs":"6c3da46c73df210527b60f1069131b15e2c65eb7b5d11793940d00cf66812f4d","tests/test_version.rs":"09e37c3df162205acf3683d1c760a6001e34e1c709fd4a1a265d82450e340003","tests/test_version_req.rs":"b6eea0258cc3b6d567a9f6c42693a97316345083495236c47e85374fd45f7cf0","tests/util/mod.rs":"db61c2cd86af864d8be4f2a3d5f25c86d7712201cc6ab47b715facf5f7f275b7"},"package":"93f6841e709003d68bb2deee8c343572bf446003ec20a583e76f7b15cebf3711"}
\ No newline at end of file
diff --git a/third_party/rust/semver/Cargo.toml b/third_party/rust/semver/Cargo.toml
index 7749f76c3778..e8ad37c7ad64 100644
--- a/third_party/rust/semver/Cargo.toml
+++ b/third_party/rust/semver/Cargo.toml
@@ -3,43 +3,43 @@
 # When uploading crates to the registry Cargo will automatically
 # "normalize" Cargo.toml files for maximal compatibility
 # with all versions of Cargo and also rewrite `path` dependencies
-# to registry (e.g. crates.io) dependencies
+# to registry (e.g., crates.io) dependencies.
 #
-# If you believe there's an error in this file please file an
-# issue against the rust-lang/cargo repository. If you're
-# editing this file be aware that the upstream Cargo.toml
-# will likely look very different (and much more reasonable)
+# If you are reading this file be aware that the original Cargo.toml
+# will likely look very different (and much more reasonable).
+# See Cargo.toml.orig for the original contents.
 
 [package]
+edition = "2018"
+rust-version = "1.31"
 name = "semver"
-version = "0.9.0"
-authors = ["Steve Klabnik <steve@steveklabnik.com>", "The Rust Project Developers"]
-description = "Semantic version parsing and comparison.\n"
-homepage = "https://docs.rs/crate/semver/"
-documentation = "https://docs.rs/crate/semver/"
+version = "1.0.13"
+authors = ["David Tolnay <dtolnay@gmail.com>"]
+description = "Parser and evaluator for Cargo's flavor of Semantic Versioning"
+documentation = "https://docs.rs/semver"
 readme = "README.md"
-license = "MIT/Apache-2.0"
-repository = "https://github.com/steveklabnik/semver"
-[dependencies.semver-parser]
-version = "0.7.0"
+keywords = ["cargo"]
+categories = [
+    "data-structures",
+    "no-std",
+]
+license = "MIT OR Apache-2.0"
+repository = "https://github.com/dtolnay/semver"
+
+[package.metadata.docs.rs]
+targets = ["x86_64-unknown-linux-gnu"]
+rustdoc-args = [
+    "--cfg",
+    "doc_cfg",
+    "--cfg",
+    "semver_rustdoc_workaround",
+]
 
 [dependencies.serde]
 version = "1.0"
 optional = true
-[dev-dependencies.crates-index]
-version = "0.5.0"
-
-[dev-dependencies.serde_json]
-version = "1.0"
-
-[dev-dependencies.serde_derive]
-version = "1.0"
-
-[dev-dependencies.tempdir]
-version = "0.3.4"
+default-features = false
 
 [features]
-default = []
-ci = ["serde"]
-[badges.travis-ci]
-repository = "steveklabnik/semver"
+default = ["std"]
+std = []
diff --git a/third_party/rust/semver/LICENSE-MIT b/third_party/rust/semver/LICENSE-MIT
index 39d4bdb5acd3..31aa79387f27 100644
--- a/third_party/rust/semver/LICENSE-MIT
+++ b/third_party/rust/semver/LICENSE-MIT
@@ -1,5 +1,3 @@
-Copyright (c) 2014 The Rust Project Developers
-
 Permission is hereby granted, free of charge, to any
 person obtaining a copy of this software and associated
 documentation files (the "Software"), to deal in the
diff --git a/third_party/rust/semver/README.md b/third_party/rust/semver/README.md
index 2a5306d4ccd2..84d227ea8601 100644
--- a/third_party/rust/semver/README.md
+++ b/third_party/rust/semver/README.md
@@ -1,103 +1,84 @@
 semver
 ======
 
-Semantic version parsing and comparison.
+[<img alt="github" src="https://img.shields.io/badge/github-dtolnay/semver-8da0cb?style=for-the-badge&labelColor=555555&logo=github" height="20">](https://github.com/dtolnay/semver)
+[<img alt="crates.io" src="https://img.shields.io/crates/v/semver.svg?style=for-the-badge&color=fc8d62&logo=rust" height="20">](https://crates.io/crates/semver)
+[<img alt="docs.rs" src="https://img.shields.io/badge/docs.rs-semver-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs" height="20">](https://docs.rs/semver)
+[<img alt="build status" src="https://img.shields.io/github/workflow/status/dtolnay/semver/CI/master?style=for-the-badge" height="20">](https://github.com/dtolnay/semver/actions?query=branch%3Amaster)
 
-[![Build Status](https://api.travis-ci.org/steveklabnik/semver.svg?branch=master)](https://travis-ci.org/steveklabnik/semver)
+A parser and evaluator for Cargo's flavor of Semantic Versioning.
 
-[Documentation](https://steveklabnik.github.io/semver)
-
-Semantic versioning (see http://semver.org/) is a set of rules for
-assigning version numbers.
-
-## SemVer and the Rust ecosystem
-
-Rust itself follows the SemVer specification, as does its standard libraries. The two are
-not tied together.
-
-[Cargo](https://crates.io), Rust's package manager, uses SemVer to determine which versions of
-packages you need installed.
-
-## Installation
-
-To use `semver`, add this to your `[dependencies]` section:
+Semantic Versioning (see <https://semver.org>) is a guideline for how version
+numbers are assigned and incremented. It is widely followed within the
+Cargo/crates.io ecosystem for Rust.
 
 ```toml
-semver = "0.7.0"
-```
-
-And this to your crate root:
-
-```rust
-extern crate semver;
+[dependencies]
+semver = "1.0"
 ```
 
-## Versions
+*Compiler support: requires rustc 1.31+*
 
-At its simplest, the `semver` crate allows you to construct `Version` objects using the `parse`
-method:
+<br>
 
-```rust
-use semver::Version;
-
-assert!(Version::parse("1.2.3") == Ok(Version {
-   major: 1,
-   minor: 2,
-   patch: 3,
-   pre: vec!(),
-   build: vec!(),
-}));
-```
-
-If you have multiple `Version`s, you can use the usual comparison operators to compare them:
+## Example
 
 ```rust
-use semver::Version;
-
-assert!(Version::parse("1.2.3-alpha")  != Version::parse("1.2.3-beta"));
-assert!(Version::parse("1.2.3-alpha2") >  Version::parse("1.2.0"));
+use semver::{BuildMetadata, Prerelease, Version, VersionReq};
+
+fn main() {
+    let req = VersionReq::parse(">=1.2.3, <1.8.0").unwrap();
+
+    // Check whether this requirement matches version 1.2.3-alpha.1 (no)
+    let version = Version {
+        major: 1,
+        minor: 2,
+        patch: 3,
+        pre: Prerelease::new("alpha.1").unwrap(),
+        build: BuildMetadata::EMPTY,
+    };
+    assert!(!req.matches(&version));
+
+    // Check whether it matches 1.3.0 (yes it does)
+    let version = Version::parse("1.3.0").unwrap();
+    assert!(req.matches(&version));
+}
 ```
 
-## Requirements
+<br>
 
-The `semver` crate also provides the ability to compare requirements, which are more complex
-comparisons.
+## Scope of this crate
 
-For example, creating a requirement that only matches versions greater than or
-equal to 1.0.0:
+Besides Cargo, several other package ecosystems and package managers for other
+languages also use SemVer:&ensp;RubyGems/Bundler for Ruby, npm for JavaScript,
+Composer for PHP, CocoaPods for Objective-C...
 
-```rust
-use semver::Version;
-use semver::VersionReq;
+The `semver` crate is specifically intended to implement Cargo's interpretation
+of Semantic Versioning.
 
-let r = VersionReq::parse(">= 1.0.0").unwrap();
-let v = Version::parse("1.0.0").unwrap();
+Where the various tools differ in their interpretation or implementation of the
+spec, this crate follows the implementation choices made by Cargo. If you are
+operating on version numbers from some other package ecosystem, you will want to
+use a different semver library which is appropriate to that ecosystem.
 
-assert!(r.to_string() == ">= 1.0.0".to_string());
-assert!(r.matches(&v))
-```
+The extent of Cargo's SemVer support is documented in the *[Specifying
+Dependencies]* chapter of the Cargo reference.
 
-It also allows parsing of `~x.y.z` and `^x.y.z` requirements as defined at
-https://www.npmjs.org/doc/misc/semver.html
+[Specifying Dependencies]: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html
 
-**Tilde requirements** specify a minimal version with some updates:
+<br>
 
-```notrust
-~1.2.3 := >=1.2.3 <1.3.0
-~1.2   := >=1.2.0 <1.3.0
-~1     := >=1.0.0 <2.0.0
-```
+#### License
 
-**Caret requirements** allow SemVer compatible updates to a specified version,
-`0.x` and `0.x+1` are not considered compatible, but `1.x` and `1.x+1` are.
+<sup>
+Licensed under either of <a href="LICENSE-APACHE">Apache License, Version
+2.0</a> or <a href="LICENSE-MIT">MIT license</a> at your option.
+</sup>
 
-`0.0.x` is not considered compatible with any other version.
-Missing minor and patch versions are desugared to `0` but allow flexibility for that value.
+<br>
 
-```notrust
-^1.2.3 := >=1.2.3 <2.0.0
-^0.2.3 := >=0.2.3 <0.3.0
-^0.0.3 := >=0.0.3 <0.0.4
-^0.0   := >=0.0.0 <0.1.0
-^0     := >=0.0.0 <1.0.0
-```
+<sub>
+Unless you explicitly state otherwise, any contribution intentionally submitted
+for inclusion in this crate by you, as defined in the Apache-2.0 license, shall
+be dual licensed as above, without any additional terms or conditions.
+</sub>
diff --git a/third_party/rust/semver/benches/parse.rs b/third_party/rust/semver/benches/parse.rs
new file mode 100644
index 000000000000..d6aded7802f0
--- /dev/null
+++ b/third_party/rust/semver/benches/parse.rs
@@ -0,0 +1,24 @@
+#![feature(test)]
+
+extern crate test;
+
+use semver::{Prerelease, Version, VersionReq};
+use test::{black_box, Bencher};
+
+#[bench]
+fn parse_prerelease(b: &mut Bencher) {
+    let text = "x.7.z.92";
+    b.iter(|| black_box(text).parse::<Prerelease>().unwrap());
+}
+
+#[bench]
+fn parse_version(b: &mut Bencher) {
+    let text = "1.0.2021-beta+exp.sha.5114f85";
+    b.iter(|| black_box(text).parse::<Version>().unwrap());
+}
+
+#[bench]
+fn parse_version_req(b: &mut Bencher) {
+    let text = ">=1.2.3, <2.0.0";
+    b.iter(|| black_box(text).parse::<VersionReq>().unwrap());
+}
diff --git a/third_party/rust/semver/build.rs b/third_party/rust/semver/build.rs
new file mode 100644
index 000000000000..2bf4418c1220
--- /dev/null
+++ b/third_party/rust/semver/build.rs
@@ -0,0 +1,73 @@
+use std::env;
+use std::process::Command;
+use std::str;
+
+fn main() {
+    let compiler = match rustc_minor_version() {
+        Some(compiler) => compiler,
+        None => return,
+    };
+
+    if compiler < 33 {
+        // Exhaustive integer patterns. On older compilers, a final `_` arm is
+        // required even if every possible integer value is otherwise covered.
+        // https://github.com/rust-lang/rust/issues/50907
+        println!("cargo:rustc-cfg=no_exhaustive_int_match");
+    }
+
+    if compiler < 36 {
+        // extern crate alloc.
+        // https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html#the-alloc-crate-is-stable
+        println!("cargo:rustc-cfg=no_alloc_crate");
+    }
+
+    if compiler < 39 {
+        // const Vec::new.
+        // https://doc.rust-lang.org/std/vec/struct.Vec.html#method.new
+        println!("cargo:rustc-cfg=no_const_vec_new");
+    }
+
+    if compiler < 40 {
+        // #[non_exhaustive].
+        // https://blog.rust-lang.org/2019/12/19/Rust-1.40.0.html#non_exhaustive-structs-enums-and-variants
+        println!("cargo:rustc-cfg=no_non_exhaustive");
+    }
+
+    if compiler < 45 {
+        // String::strip_prefix.
+        // https://doc.rust-lang.org/std/primitive.str.html#method.strip_prefix
+        println!("cargo:rustc-cfg=no_str_strip_prefix");
+    }
+
+    if compiler < 46 {
+        // #[track_caller].
+        // https://blog.rust-lang.org/2020/08/27/Rust-1.46.0.html#track_caller
+        println!("cargo:rustc-cfg=no_track_caller");
+    }
+
+    if compiler < 52 {
+        // #![deny(unsafe_op_in_unsafe_fn)].
+        // https://github.com/rust-lang/rust/issues/71668
+        println!("cargo:rustc-cfg=no_unsafe_op_in_unsafe_fn_lint");
+    }
+
+    if compiler < 53 {
+        // Efficient intrinsics for count-leading-zeros and count-trailing-zeros
+        // on NonZero integers stabilized in 1.53.0. On many architectures these
+        // are more efficient than counting zeros on ordinary zeroable integers.
+        // https://doc.rust-lang.org/std/num/struct.NonZeroU64.html#method.leading_zeros
+        // https://doc.rust-lang.org/std/num/struct.NonZeroU64.html#method.trailing_zeros
+        println!("cargo:rustc-cfg=no_nonzero_bitscan");
+    }
+}
+
+fn rustc_minor_version() -> Option<u32> {
+    let rustc = env::var_os("RUSTC")?;
+    let output = Command::new(rustc).arg("--version").output().ok()?;
+    let version = str::from_utf8(&output.stdout).ok()?;
+    let mut pieces = version.split('.');
+    if pieces.next() != Some("rustc 1") {
+        return None;
+    }
+    pieces.next()?.parse().ok()
+}
diff --git a/third_party/rust/semver/src/backport.rs b/third_party/rust/semver/src/backport.rs
new file mode 100644
index 000000000000..c7751b29f3b4
--- /dev/null
+++ b/third_party/rust/semver/src/backport.rs
@@ -0,0 +1,51 @@
+#[cfg(no_str_strip_prefix)] // rustc <1.45
+pub(crate) trait StripPrefixExt {
+    fn strip_prefix(&self, ch: char) -> Option<&str>;
+}
+
+#[cfg(no_str_strip_prefix)]
+impl StripPrefixExt for str {
+    fn strip_prefix(&self, ch: char) -> Option<&str> {
+        if self.starts_with(ch) {
+            Some(&self[ch.len_utf8()..])
+        } else {
+            None
+        }
+    }
+}
+
+pub(crate) use crate::alloc::vec::Vec;
+
+#[cfg(no_alloc_crate)] // rustc <1.36
+pub(crate) mod alloc {
+    pub use std::vec;
+
+    pub mod alloc {
+        use std::mem;
+
+        pub struct Layout {
+            size: usize,
+        }
+
+        impl Layout {
+            pub unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {
+                assert_eq!(align, 2);
+                Layout { size }
+            }
+        }
+
+        pub unsafe fn alloc(layout: Layout) -> *mut u8 {
+            let len_u16 = (layout.size + 1) / 2;
+            let mut vec = Vec::new();
+            vec.reserve_exact(len_u16);
+            let ptr: *mut u16 = vec.as_mut_ptr();
+            mem::forget(vec);
+            ptr as *mut u8
+        }
+
+        pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {
+            let len_u16 = (layout.size + 1) / 2;
+            unsafe { Vec::from_raw_parts(ptr as *mut u16, 0, len_u16) };
+        }
+    }
+}
diff --git a/third_party/rust/semver/src/display.rs b/third_party/rust/semver/src/display.rs
new file mode 100644
index 000000000000..3c2871bb9783
--- /dev/null
+++ b/third_party/rust/semver/src/display.rs
@@ -0,0 +1,165 @@
+use crate::{BuildMetadata, Comparator, Op, Prerelease, Version, VersionReq};
+use core::fmt::{self, Alignment, Debug, Display, Write};
+
+impl Display for Version {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        let do_display = |formatter: &mut fmt::Formatter| -> fmt::Result {
+            write!(formatter, "{}.{}.{}", self.major, self.minor, self.patch)?;
+            if !self.pre.is_empty() {
+                write!(formatter, "-{}", self.pre)?;
+            }
+            if !self.build.is_empty() {
+                write!(formatter, "+{}", self.build)?;
+            }
+            Ok(())
+        };
+
+        let do_len = || -> usize {
+            digits(self.major)
+                + 1
+                + digits(self.minor)
+                + 1
+                + digits(self.patch)
+                + !self.pre.is_empty() as usize
+                + self.pre.len()
+                + !self.build.is_empty() as usize
+                + self.build.len()
+        };
+
+        pad(formatter, do_display, do_len)
+    }
+}
+
+impl Display for VersionReq {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        if self.comparators.is_empty() {
+            return formatter.write_str("*");
+        }
+        for (i, comparator) in self.comparators.iter().enumerate() {
+            if i > 0 {
+                formatter.write_str(", ")?;
+            }
+            write!(formatter, "{}", comparator)?;
+        }
+        Ok(())
+    }
+}
+
+impl Display for Comparator {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        let op = match self.op {
+            Op::Exact => "=",
+            Op::Greater => ">",
+            Op::GreaterEq => ">=",
+            Op::Less => "<",
+            Op::LessEq => "<=",
+            Op::Tilde => "~",
+            Op::Caret => "^",
+            Op::Wildcard => "",
+            #[cfg(no_non_exhaustive)]
+            Op::__NonExhaustive => unreachable!(),
+        };
+        formatter.write_str(op)?;
+        write!(formatter, "{}", self.major)?;
+        if let Some(minor) = &self.minor {
+            write!(formatter, ".{}", minor)?;
+            if let Some(patch) = &self.patch {
+                write!(formatter, ".{}", patch)?;
+                if !self.pre.is_empty() {
+                    write!(formatter, "-{}", self.pre)?;
+                }
+            } else if self.op == Op::Wildcard {
+                formatter.write_str(".*")?;
+            }
+        } else if self.op == Op::Wildcard {
+            formatter.write_str(".*")?;
+        }
+        Ok(())
+    }
+}
+
+impl Display for Prerelease {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        formatter.write_str(self.as_str())
+    }
+}
+
+impl Display for BuildMetadata {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        formatter.write_str(self.as_str())
+    }
+}
+
+impl Debug for Version {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        let mut debug = formatter.debug_struct("Version");
+        debug
+            .field("major", &self.major)
+            .field("minor", &self.minor)
+            .field("patch", &self.patch);
+        if !self.pre.is_empty() {
+            debug.field("pre", &self.pre);
+        }
+        if !self.build.is_empty() {
+            debug.field("build", &self.build);
+        }
+        debug.finish()
+    }
+}
+
+impl Debug for Prerelease {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        write!(formatter, "Prerelease(\"{}\")", self)
+    }
+}
+
+impl Debug for BuildMetadata {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        write!(formatter, "BuildMetadata(\"{}\")", self)
+    }
+}
+
+fn pad(
+    formatter: &mut fmt::Formatter,
+    do_display: impl FnOnce(&mut fmt::Formatter) -> fmt::Result,
+    do_len: impl FnOnce() -> usize,
+) -> fmt::Result {
+    let min_width = match formatter.width() {
+        Some(min_width) => min_width,
+        None => return do_display(formatter),
+    };
+
+    let len = do_len();
+    if len >= min_width {
+        return do_display(formatter);
+    }
+
+    let default_align = Alignment::Left;
+    let align = formatter.align().unwrap_or(default_align);
+    let padding = min_width - len;
+    let (pre_pad, post_pad) = match align {
+        Alignment::Left => (0, padding),
+        Alignment::Right => (padding, 0),
+        Alignment::Center => (padding / 2, (padding + 1) / 2),
+    };
+
+    let fill = formatter.fill();
+    for _ in 0..pre_pad {
+        formatter.write_char(fill)?;
+    }
+
+    do_display(formatter)?;
+
+    for _ in 0..post_pad {
+        formatter.write_char(fill)?;
+    }
+    Ok(())
+}
+
+fn digits(val: u64) -> usize {
+    if val < 10 {
+        1
+    } else {
+        1 + digits(val / 10)
+    }
+}
diff --git a/third_party/rust/semver/src/error.rs b/third_party/rust/semver/src/error.rs
new file mode 100644
index 000000000000..a514e3f11e8f
--- /dev/null
+++ b/third_party/rust/semver/src/error.rs
@@ -0,0 +1,124 @@
+use crate::parse::Error;
+use core::fmt::{self, Debug, Display};
+
+pub(crate) enum ErrorKind {
+    UnexpectedEnd(Position),
+    UnexpectedChar(Position, char),
+    UnexpectedCharAfter(Position, char),
+    ExpectedCommaFound(Position, char),
+    LeadingZero(Position),
+    Overflow(Position),
+    EmptySegment(Position),
+    IllegalCharacter(Position),
+    WildcardNotTheOnlyComparator(char),
+    UnexpectedAfterWildcard,
+    ExcessiveComparators,
+}
+
+#[derive(Copy, Clone, Eq, PartialEq)]
+pub(crate) enum Position {
+    Major,
+    Minor,
+    Patch,
+    Pre,
+    Build,
+}
+
+#[cfg(feature = "std")]
+#[cfg_attr(doc_cfg, doc(cfg(feature = "std")))]
+impl std::error::Error for Error {}
+
+impl Display for Error {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        match &self.kind {
+            ErrorKind::UnexpectedEnd(pos) => {
+                write!(formatter, "unexpected end of input while parsing {}", pos)
+            }
+            ErrorKind::UnexpectedChar(pos, ch) => {
+                write!(
+                    formatter,
+                    "unexpected character {} while parsing {}",
+                    QuotedChar(*ch),
+                    pos,
+                )
+            }
+            ErrorKind::UnexpectedCharAfter(pos, ch) => {
+                write!(
+                    formatter,
+                    "unexpected character {} after {}",
+                    QuotedChar(*ch),
+                    pos,
+                )
+            }
+            ErrorKind::ExpectedCommaFound(pos, ch) => {
+                write!(
+                    formatter,
+                    "expected comma after {}, found {}",
+                    pos,
+                    QuotedChar(*ch),
+                )
+            }
+            ErrorKind::LeadingZero(pos) => {
+                write!(formatter, "invalid leading zero in {}", pos)
+            }
+            ErrorKind::Overflow(pos) => {
+                write!(formatter, "value of {} exceeds u64::MAX", pos)
+            }
+            ErrorKind::EmptySegment(pos) => {
+                write!(formatter, "empty identifier segment in {}", pos)
+            }
+            ErrorKind::IllegalCharacter(pos) => {
+                write!(formatter, "unexpected character in {}", pos)
+            }
+            ErrorKind::WildcardNotTheOnlyComparator(ch) => {
+                write!(
+                    formatter,
+                    "wildcard req ({}) must be the only comparator in the version req",
+                    ch,
+                )
+            }
+            ErrorKind::UnexpectedAfterWildcard => {
+                formatter.write_str("unexpected character after wildcard in version req")
+            }
+            ErrorKind::ExcessiveComparators => {
+                formatter.write_str("excessive number of version comparators")
+            }
+        }
+    }
+}
+
+impl Display for Position {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        formatter.write_str(match self {
+            Position::Major => "major version number",
+            Position::Minor => "minor version number",
+            Position::Patch => "patch version number",
+            Position::Pre => "pre-release identifier",
+            Position::Build => "build metadata",
+        })
+    }
+}
+
+impl Debug for Error {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        formatter.write_str("Error(\"")?;
+        Display::fmt(self, formatter)?;
+        formatter.write_str("\")")?;
+        Ok(())
+    }
+}
+
+struct QuotedChar(char);
+
+impl Display for QuotedChar {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        // Standard library versions prior to https://github.com/rust-lang/rust/pull/95345
+        // print character 0 as '\u{0}'. We prefer '\0' to keep error messages
+        // the same across all supported Rust versions.
+        if self.0 == '\0' {
+            formatter.write_str("'\\0'")
+        } else {
+            write!(formatter, "{:?}", self.0)
+        }
+    }
+}
diff --git a/third_party/rust/semver/src/eval.rs b/third_party/rust/semver/src/eval.rs
new file mode 100644
index 000000000000..e6e38949a93f
--- /dev/null
+++ b/third_party/rust/semver/src/eval.rs
@@ -0,0 +1,181 @@
+use crate::{Comparator, Op, Version, VersionReq};
+
+pub(crate) fn matches_req(req: &VersionReq, ver: &Version) -> bool {
+    for cmp in &req.comparators {
+        if !matches_impl(cmp, ver) {
+            return false;
+        }
+    }
+
+    if ver.pre.is_empty() {
+        return true;
+    }
+
+    // If a version has a prerelease tag (for example, 1.2.3-alpha.3) then it
+    // will only be allowed to satisfy req if at least one comparator with the
+    // same major.minor.patch also has a prerelease tag.
+    for cmp in &req.comparators {
+        if pre_is_compatible(cmp, ver) {
+            return true;
+        }
+    }
+
+    false
+}
+
+pub(crate) fn matches_comparator(cmp: &Comparator, ver: &Version) -> bool {
+    matches_impl(cmp, ver) && (ver.pre.is_empty() || pre_is_compatible(cmp, ver))
+}
+
+fn matches_impl(cmp: &Comparator, ver: &Version) -> bool {
+    match cmp.op {
+        Op::Exact | Op::Wildcard => matches_exact(cmp, ver),
+        Op::Greater => matches_greater(cmp, ver),
+        Op::GreaterEq => matches_exact(cmp, ver) || matches_greater(cmp, ver),
+        Op::Less => matches_less(cmp, ver),
+        Op::LessEq => matches_exact(cmp, ver) || matches_less(cmp, ver),
+        Op::Tilde => matches_tilde(cmp, ver),
+        Op::Caret => matches_caret(cmp, ver),
+        #[cfg(no_non_exhaustive)]
+        Op::__NonExhaustive => unreachable!(),
+    }
+}
+
+fn matches_exact(cmp: &Comparator, ver: &Version) -> bool {
+    if ver.major != cmp.major {
+        return false;
+    }
+
+    if let Some(minor) = cmp.minor {
+        if ver.minor != minor {
+            return false;
+        }
+    }
+
+    if let Some(patch) = cmp.patch {
+        if ver.patch != patch {
+            return false;
+        }
+    }
+
+    ver.pre == cmp.pre
+}
+
+fn matches_greater(cmp: &Comparator, ver: &Version) -> bool {
+    if ver.major != cmp.major {
+        return ver.major > cmp.major;
+    }
+
+    match cmp.minor {
+        None => return false,
+        Some(minor) => {
+            if ver.minor != minor {
+                return ver.minor > minor;
+            }
+        }
+    }
+
+    match cmp.patch {
+        None => return false,
+        Some(patch) => {
+            if ver.patch != patch {
+                return ver.patch > patch;
+            }
+        }
+    }
+
+    ver.pre > cmp.pre
+}
+
+fn matches_less(cmp: &Comparator, ver: &Version) -> bool {
+    if ver.major != cmp.major {
+        return ver.major < cmp.major;
+    }
+
+    match cmp.minor {
+        None => return false,
+        Some(minor) => {
+            if ver.minor != minor {
+                return ver.minor < minor;
+            }
+        }
+    }
+
+    match cmp.patch {
+        None => return false,
+        Some(patch) => {
+            if ver.patch != patch {
+                return ver.patch < patch;
+            }
+        }
+    }
+
+    ver.pre < cmp.pre
+}
+
+fn matches_tilde(cmp: &Comparator, ver: &Version) -> bool {
+    if ver.major != cmp.major {
+        return false;
+    }
+
+    if let Some(minor) = cmp.minor {
+        if ver.minor != minor {
+            return false;
+        }
+    }
+
+    if let Some(patch) = cmp.patch {
+        if ver.patch != patch {
+            return ver.patch > patch;
+        }
+    }
+
+    ver.pre >= cmp.pre
+}
+
+fn matches_caret(cmp: &Comparator, ver: &Version) -> bool {
+    if ver.major != cmp.major {
+        return false;
+    }
+
+    let minor = match cmp.minor {
+        None => return true,
+        Some(minor) => minor,
+    };
+
+    let patch = match cmp.patch {
+        None => {
+            if cmp.major > 0 {
+                return ver.minor >= minor;
+            } else {
+                return ver.minor == minor;
+            }
+        }
+        Some(patch) => patch,
+    };
+
+    if cmp.major > 0 {
+        if ver.minor != minor {
+            return ver.minor > minor;
+        } else if ver.patch != patch {
+            return ver.patch > patch;
+        }
+    } else if minor > 0 {
+        if ver.minor != minor {
+            return false;
+        } else if ver.patch != patch {
+            return ver.patch > patch;
+        }
+    } else if ver.minor != minor || ver.patch != patch {
+        return false;
+    }
+
+    ver.pre >= cmp.pre
+}
+
+fn pre_is_compatible(cmp: &Comparator, ver: &Version) -> bool {
+    cmp.major == ver.major
+        && cmp.minor == Some(ver.minor)
+        && cmp.patch == Some(ver.patch)
+        && !cmp.pre.is_empty()
+}
diff --git a/third_party/rust/semver/src/identifier.rs b/third_party/rust/semver/src/identifier.rs
new file mode 100644
index 000000000000..170a4e05e118
--- /dev/null
+++ b/third_party/rust/semver/src/identifier.rs
@@ -0,0 +1,400 @@
+// This module implements Identifier, a short-optimized string allowed to
+// contain only the ASCII characters hyphen, dot, 0-9, A-Z, a-z.
+//
+// As of mid-2021, the distribution of pre-release lengths on crates.io is:
+//
+//     length  count         length  count         length  count
+//        0  355929            11      81            24       2
+//        1     208            12      48            25       6
+//        2     236            13      55            26      10
+//        3    1909            14      25            27       4
+//        4    1284            15      15            28       1
+//        5    1742            16      35            30       1
+//        6    3440            17       9            31       5
+//        7    5624            18       6            32       1
+//        8    1321            19      12            36       2
+//        9     179            20       2            37     379
+//       10      65            23      11
+//
+// and the distribution of build metadata lengths is:
+//
+//     length  count         length  count         length  count
+//        0  364445             8    7725            18       1
+//        1      72             9      16            19       1
+//        2       7            10      85            20       1
+//        3      28            11      17            22       4
+//        4       9            12      10            26       1
+//        5      68            13       9            27       1
+//        6      73            14      10            40       5
+//        7      53            15       6
+//
+// Therefore it really behooves us to be able to use the entire 8 bytes of a
+// pointer for inline storage. For both pre-release and build metadata there are
+// vastly more strings with length exactly 8 bytes than the sum over all lengths
+// longer than 8 bytes.
+//
+// To differentiate the inline representation from the heap allocated long
+// representation, we'll allocate heap pointers with 2-byte alignment so that
+// they are guaranteed to have an unset least significant bit. Then in the repr
+// we store for pointers, we rotate a 1 into the most significant bit of the
+// most significant byte, which is never set for an ASCII byte.
+//
+// Inline repr:
+//
+//     0xxxxxxx 0xxxxxxx 0xxxxxxx 0xxxxxxx 0xxxxxxx 0xxxxxxx 0xxxxxxx 0xxxxxxx
+//
+// Heap allocated repr:
+//
+//     1ppppppp pppppppp pppppppp pppppppp pppppppp pppppppp pppppppp pppppppp 0
+//     ^ most significant bit   least significant bit of orig ptr, rotated out ^
+//
+// Since the most significant bit doubles as a sign bit for the similarly sized
+// signed integer type, the CPU has an efficient instruction for inspecting it,
+// meaning we can differentiate between an inline repr and a heap allocated repr
+// in one instruction. Effectively an inline repr always looks like a positive
+// i64 while a heap allocated repr always looks like a negative i64.
+//
+// For the inline repr, we store \0 padding on the end of the stored characters,
+// and thus the string length is readily determined efficiently by a cttz (count
+// trailing zeros) or bsf (bit scan forward) instruction.
+//
+// For the heap allocated repr, the length is encoded as a base-128 varint at
+// the head of the allocation.
+//
+// Empty strings are stored as an all-1 bit pattern, corresponding to -1i64.
+// Consequently the all-0 bit pattern is never a legal representation in any
+// repr, leaving it available as a niche for downstream code. For example this
+// allows size_of::<Version>() == size_of::<Option<Version>>().
+
+use crate::alloc::alloc::{alloc, dealloc, Layout};
+use core::mem;
+use core::num::{NonZeroU64, NonZeroUsize};
+use core::ptr::{self, NonNull};
+use core::slice;
+use core::str;
+
+const PTR_BYTES: usize = mem::size_of::<NonNull<u8>>();
+
+// If pointers are already 8 bytes or bigger, then 0. If pointers are smaller
+// than 8 bytes, then Identifier will contain a byte array to raise its size up
+// to 8 bytes total.
+const TAIL_BYTES: usize = 8 * (PTR_BYTES < 8) as usize - PTR_BYTES * (PTR_BYTES < 8) as usize;
+
+#[repr(C, align(8))]
+pub(crate) struct Identifier {
+    head: NonNull<u8>,
+    tail: [u8; TAIL_BYTES],
+}
+
+impl Identifier {
+    pub(crate) const fn empty() -> Self {
+        // This is a separate constant because unsafe function calls are not
+        // allowed in a const fn body, only in a const, until later rustc than
+        // what we support.
+        const HEAD: NonNull<u8> = unsafe { NonNull::new_unchecked(!0 as *mut u8) };
+
+        // `mov rax, -1`
+        Identifier {
+            head: HEAD,
+            tail: [!0; TAIL_BYTES],
+        }
+    }
+
+    // SAFETY: string must be ASCII and not contain \0 bytes.
+    pub(crate) unsafe fn new_unchecked(string: &str) -> Self {
+        let len = string.len();
+        match len as u64 {
+            0 => Self::empty(),
+            1..=8 => {
+                let mut bytes = [0u8; mem::size_of::<Identifier>()];
+                // SAFETY: string is big enough to read len bytes, bytes is big
+                // enough to write len bytes, and they do not overlap.
+                unsafe { ptr::copy_nonoverlapping(string.as_ptr(), bytes.as_mut_ptr(), len) };
+                // SAFETY: the head field is nonzero because the input string
+                // was at least 1 byte of ASCII and did not contain \0.
+                unsafe { mem::transmute::<[u8; mem::size_of::<Identifier>()], Identifier>(bytes) }
+            }
+            9..=0xff_ffff_ffff_ffff => {
+                // SAFETY: len is in a range that does not contain 0.
+                let size = bytes_for_varint(unsafe { NonZeroUsize::new_unchecked(len) }) + len;
+                let align = 2;
+                // SAFETY: align is not zero, align is a power of two, and
+                // rounding size up to align does not overflow usize::MAX.
+                let layout = unsafe { Layout::from_size_align_unchecked(size, align) };
+                // SAFETY: layout's size is nonzero.
+                let ptr = unsafe { alloc(layout) };
+                let mut write = ptr;
+                let mut varint_remaining = len;
+                while varint_remaining > 0 {
+                    // SAFETY: size is bytes_for_varint(len) bytes + len bytes.
+                    // This is writing the first bytes_for_varint(len) bytes.
+                    unsafe { ptr::write(write, varint_remaining as u8 | 0x80) };
+                    varint_remaining >>= 7;
+                    // SAFETY: still in bounds of the same allocation.
+                    write = unsafe { write.add(1) };
+                }
+                // SAFETY: size is bytes_for_varint(len) bytes + len bytes. This
+                // is writing to the last len bytes.
+                unsafe { ptr::copy_nonoverlapping(string.as_ptr(), write, len) };
+                Identifier {
+                    head: ptr_to_repr(ptr),
+                    tail: [0; TAIL_BYTES],
+                }
+            }
+            0x100_0000_0000_0000..=0xffff_ffff_ffff_ffff => {
+                unreachable!("please refrain from storing >64 petabytes of text in semver version");
+            }
+            #[cfg(no_exhaustive_int_match)] // rustc <1.33
+            _ => unreachable!(),
+        }
+    }
+
+    pub(crate) fn is_empty(&self) -> bool {
+        // `cmp rdi, -1` -- basically: `repr as i64 == -1`
+        let empty = Self::empty();
+        let is_empty = self.head == empty.head && self.tail == empty.tail;
+        // The empty representation does nothing on Drop. We can't let this one
+        // drop normally because `impl Drop for Identifier` calls is_empty; that
+        // would be an infinite recursion.
+        mem::forget(empty);
+        is_empty
+    }
+
+    fn is_inline(&self) -> bool {
+        // `test rdi, rdi` -- basically: `repr as i64 >= 0`
+        self.head.as_ptr() as usize >> (PTR_BYTES * 8 - 1) == 0
+    }
+
+    fn is_empty_or_inline(&self) -> bool {
+        // `cmp rdi, -2` -- basically: `repr as i64 > -2`
+        self.is_empty() || self.is_inline()
+    }
+
+    pub(crate) fn as_str(&self) -> &str {
+        if self.is_empty() {
+            ""
+        } else if self.is_inline() {
+            // SAFETY: repr is in the inline representation.
+            unsafe { inline_as_str(self) }
+        } else {
+            // SAFETY: repr is in the heap allocated representation.
+            unsafe { ptr_as_str(&self.head) }
+        }
+    }
+}
+
+impl Clone for Identifier {
+    fn clone(&self) -> Self {
+        if self.is_empty_or_inline() {
+            Identifier {
+                head: self.head,
+                tail: self.tail,
+            }
+        } else {
+            let ptr = repr_to_ptr(self.head);
+            // SAFETY: ptr is one of our own heap allocations.
+            let len = unsafe { decode_len(ptr) };
+            let size = bytes_for_varint(len) + len.get();
+            let align = 2;
+            // SAFETY: align is not zero, align is a power of two, and rounding
+            // size up to align does not overflow usize::MAX. This is just
+            // duplicating a previous allocation where all of these guarantees
+            // were already made.
+            let layout = unsafe { Layout::from_size_align_unchecked(size, align) };
+            // SAFETY: layout's size is nonzero.
+            let clone = unsafe { alloc(layout) };
+            // SAFETY: new allocation cannot overlap the previous one (this was
+            // not a realloc). The argument ptrs are readable/writeable
+            // respectively for size bytes.
+            unsafe { ptr::copy_nonoverlapping(ptr, clone, size) }
+            Identifier {
+                head: ptr_to_repr(clone),
+                tail: [0; TAIL_BYTES],
+            }
+        }
+    }
+}
+
+impl Drop for Identifier {
+    fn drop(&mut self) {
+        if self.is_empty_or_inline() {
+            return;
+        }
+        let ptr = repr_to_ptr_mut(self.head);
+        // SAFETY: ptr is one of our own heap allocations.
+        let len = unsafe { decode_len(ptr) };
+        let size = bytes_for_varint(len) + len.get();
+        let align = 2;
+        // SAFETY: align is not zero, align is a power of two, and rounding
+        // size up to align does not overflow usize::MAX. These guarantees were
+        // made when originally allocating this memory.
+        let layout = unsafe { Layout::from_size_align_unchecked(size, align) };
+        // SAFETY: ptr was previously allocated by the same allocator with the
+        // same layout.
+        unsafe { dealloc(ptr, layout) }
+    }
+}
+
+impl PartialEq for Identifier {
+    fn eq(&self, rhs: &Self) -> bool {
+        if self.is_empty_or_inline() {
+            // Fast path (most common)
+            self.head == rhs.head && self.tail == rhs.tail
+        } else if rhs.is_empty_or_inline() {
+            false
+        } else {
+            // SAFETY: both reprs are in the heap allocated representation.
+            unsafe { ptr_as_str(&self.head) == ptr_as_str(&rhs.head) }
+        }
+    }
+}
+
+unsafe impl Send for Identifier {}
+unsafe impl Sync for Identifier {}
+
+// We use heap pointers that are 2-byte aligned, meaning they have an
+// insignificant 0 in the least significant bit. We take advantage of that
+// unneeded bit to rotate a 1 into the most significant bit to make the repr
+// distinguishable from ASCII bytes.
+fn ptr_to_repr(original: *mut u8) -> NonNull<u8> {
+    // `mov eax, 1`
+    // `shld rax, rdi, 63`
+    let modified = (original as usize | 1).rotate_right(1);
+
+    // `original + (modified - original)`, but being mindful of provenance.
+    let diff = modified.wrapping_sub(original as usize);
+    let modified = original.wrapping_add(diff);
+
+    // SAFETY: the most significant bit of repr is known to be set, so the value
+    // is not zero.
+    unsafe { NonNull::new_unchecked(modified) }
+}
+
+// Shift out the 1 previously placed into the most significant bit of the least
+// significant byte. Shift in a low 0 bit to reconstruct the original 2-byte
+// aligned pointer.
+fn repr_to_ptr(modified: NonNull<u8>) -> *const u8 {
+    // `lea rax, [rdi + rdi]`
+    let modified = modified.as_ptr();
+    let original = (modified as usize) << 1;
+
+    // `modified + (original - modified)`, but being mindful of provenance.
+    let diff = original.wrapping_sub(modified as usize);
+    modified.wrapping_add(diff)
+}
+
+fn repr_to_ptr_mut(repr: NonNull<u8>) -> *mut u8 {
+    repr_to_ptr(repr) as *mut u8
+}
+
+// Compute the length of the inline string, assuming the argument is in short
+// string representation. Short strings are stored as 1 to 8 nonzero ASCII
+// bytes, followed by \0 padding for the remaining bytes.
+//
+// SAFETY: the identifier must indeed be in the inline representation.
+unsafe fn inline_len(repr: &Identifier) -> NonZeroUsize {
+    // SAFETY: Identifier's layout is align(8) and at least size 8. We're doing
+    // an aligned read of the first 8 bytes from it. The bytes are not all zero
+    // because inline strings are at least 1 byte long and cannot contain \0.
+    let repr = unsafe { ptr::read(repr as *const Identifier as *const NonZeroU64) };
+
+    // Rustc >=1.53 has intrinsics for counting zeros on a non-zeroable integer.
+    // On many architectures these are more efficient than counting on ordinary
+    // zeroable integers (bsf vs cttz). On rustc <1.53 without those intrinsics,
+    // we count zeros in the u64 rather than the NonZeroU64.
+    #[cfg(no_nonzero_bitscan)]
+    let repr = repr.get();
+
+    #[cfg(target_endian = "little")]
+    let zero_bits_on_string_end = repr.leading_zeros();
+    #[cfg(target_endian = "big")]
+    let zero_bits_on_string_end = repr.trailing_zeros();
+
+    let nonzero_bytes = 8 - zero_bits_on_string_end as usize / 8;
+
+    // SAFETY: repr is nonzero, so it has at most 63 zero bits on either end,
+    // thus at least one nonzero byte.
+    unsafe { NonZeroUsize::new_unchecked(nonzero_bytes) }
+}
+
+// SAFETY: repr must be in the inline representation, i.e. at least 1 and at
+// most 8 nonzero ASCII bytes padded on the end with \0 bytes.
+unsafe fn inline_as_str(repr: &Identifier) -> &str {
+    let ptr = repr as *const Identifier as *const u8;
+    let len = unsafe { inline_len(repr) }.get();
+    // SAFETY: we are viewing the nonzero ASCII prefix of the inline repr's
+    // contents as a slice of bytes. Input/output lifetimes are correctly
+    // associated.
+    let slice = unsafe { slice::from_raw_parts(ptr, len) };
+    // SAFETY: the string contents are known to be only ASCII bytes, which are
+    // always valid UTF-8.
+    unsafe { str::from_utf8_unchecked(slice) }
+}
+
+// Decode varint. Varints consist of between one and eight base-128 digits, each
+// of which is stored in a byte with most significant bit set. Adjacent to the
+// varint in memory there is guaranteed to be at least 9 ASCII bytes, each of
+// which has an unset most significant bit.
+//
+// SAFETY: ptr must be one of our own heap allocations, with the varint header
+// already written.
+unsafe fn decode_len(ptr: *const u8) -> NonZeroUsize {
+    // SAFETY: There is at least one byte of varint followed by at least 9 bytes
+    // of string content, which is at least 10 bytes total for the allocation,
+    // so reading the first two is no problem.
+    let [first, second] = unsafe { ptr::read(ptr as *const [u8; 2]) };
+    if second < 0x80 {
+        // SAFETY: the length of this heap allocated string has been encoded as
+        // one base-128 digit, so the length is at least 9 and at most 127. It
+        // cannot be zero.
+        unsafe { NonZeroUsize::new_unchecked((first & 0x7f) as usize) }
+    } else {
+        return unsafe { decode_len_cold(ptr) };
+
+        // Identifiers 128 bytes or longer. This is not exercised by any crate
+        // version currently published to crates.io.
+        #[cold]
+        #[inline(never)]
+        unsafe fn decode_len_cold(mut ptr: *const u8) -> NonZeroUsize {
+            let mut len = 0;
+            let mut shift = 0;
+            loop {
+                // SAFETY: varint continues while there are bytes having the
+                // most significant bit set, i.e. until we start hitting the
+                // ASCII string content with msb unset.
+                let byte = unsafe { *ptr };
+                if byte < 0x80 {
+                    // SAFETY: the string length is known to be 128 bytes or
+                    // longer.
+                    return unsafe { NonZeroUsize::new_unchecked(len) };
+                }
+                // SAFETY: still in bounds of the same allocation.
+                ptr = unsafe { ptr.add(1) };
+                len += ((byte & 0x7f) as usize) << shift;
+                shift += 7;
+            }
+        }
+    }
+}
+
+// SAFETY: repr must be in the heap allocated representation, with varint header
+// and string contents already written.
+unsafe fn ptr_as_str(repr: &NonNull<u8>) -> &str {
+    let ptr = repr_to_ptr(*repr);
+    let len = unsafe { decode_len(ptr) };
+    let header = bytes_for_varint(len);
+    let slice = unsafe { slice::from_raw_parts(ptr.add(header), len.get()) };
+    // SAFETY: all identifier contents are ASCII bytes, which are always valid
+    // UTF-8.
+    unsafe { str::from_utf8_unchecked(slice) }
+}
+
+// Number of base-128 digits required for the varint representation of a length.
+fn bytes_for_varint(len: NonZeroUsize) -> usize {
+    #[cfg(no_nonzero_bitscan)] // rustc <1.53
+    let len = len.get();
+
+    let usize_bits = mem::size_of::<usize>() * 8;
+    let len_bits = usize_bits - len.leading_zeros() as usize;
+    (len_bits + 6) / 7
+}
diff --git a/third_party/rust/semver/src/impls.rs b/third_party/rust/semver/src/impls.rs
new file mode 100644
index 000000000000..c3b6c6013377
--- /dev/null
+++ b/third_party/rust/semver/src/impls.rs
@@ -0,0 +1,156 @@
+use crate::backport::*;
+use crate::identifier::Identifier;
+use crate::{BuildMetadata, Comparator, Prerelease, VersionReq};
+use core::cmp::Ordering;
+use core::hash::{Hash, Hasher};
+use core::iter::FromIterator;
+use core::ops::Deref;
+
+impl Default for Identifier {
+    fn default() -> Self {
+        Identifier::empty()
+    }
+}
+
+impl Eq for Identifier {}
+
+impl Hash for Identifier {
+    fn hash<H: Hasher>(&self, hasher: &mut H) {
+        self.as_str().hash(hasher);
+    }
+}
+
+impl Deref for Prerelease {
+    type Target = str;
+
+    fn deref(&self) -> &Self::Target {
+        self.identifier.as_str()
+    }
+}
+
+impl Deref for BuildMetadata {
+    type Target = str;
+
+    fn deref(&self) -> &Self::Target {
+        self.identifier.as_str()
+    }
+}
+
+impl PartialOrd for Prerelease {
+    fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {
+        Some(Ord::cmp(self, rhs))
+    }
+}
+
+impl PartialOrd for BuildMetadata {
+    fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {
+        Some(Ord::cmp(self, rhs))
+    }
+}
+
+impl Ord for Prerelease {
+    fn cmp(&self, rhs: &Self) -> Ordering {
+        match self.is_empty() {
+            true if rhs.is_empty() => return Ordering::Equal,
+            // A real release compares greater than prerelease.
+            true => return Ordering::Greater,
+            // Prerelease compares less than the real release.
+            false if rhs.is_empty() => return Ordering::Less,
+            false => {}
+        }
+
+        let lhs = self.as_str().split('.');
+        let mut rhs = rhs.as_str().split('.');
+
+        for lhs in lhs {
+            let rhs = match rhs.next() {
+                // Spec: "A larger set of pre-release fields has a higher
+                // precedence than a smaller set, if all of the preceding
+                // identifiers are equal."
+                None => return Ordering::Greater,
+                Some(rhs) => rhs,
+            };
+
+            let string_cmp = || Ord::cmp(lhs, rhs);
+            let is_ascii_digit = |b: u8| b.is_ascii_digit();
+            let ordering = match (
+                lhs.bytes().all(is_ascii_digit),
+                rhs.bytes().all(is_ascii_digit),
+            ) {
+                // Respect numeric ordering, for example 99 < 100. Spec says:
+                // "Identifiers consisting of only digits are compared
+                // numerically."
+                (true, true) => Ord::cmp(&lhs.len(), &rhs.len()).then_with(string_cmp),
+                // Spec: "Numeric identifiers always have lower precedence than
+                // non-numeric identifiers."
+                (true, false) => return Ordering::Less,
+                (false, true) => return Ordering::Greater,
+                // Spec: "Identifiers with letters or hyphens are compared
+                // lexically in ASCII sort order."
+                (false, false) => string_cmp(),
+            };
+
+            if ordering != Ordering::Equal {
+                return ordering;
+            }
+        }
+
+        if rhs.next().is_none() {
+            Ordering::Equal
+        } else {
+            Ordering::Less
+        }
+    }
+}
+
+impl Ord for BuildMetadata {
+    fn cmp(&self, rhs: &Self) -> Ordering {
+        let lhs = self.as_str().split('.');
+        let mut rhs = rhs.as_str().split('.');
+
+        for lhs in lhs {
+            let rhs = match rhs.next() {
+                None => return Ordering::Greater,
+                Some(rhs) => rhs,
+            };
+
+            let is_ascii_digit = |b: u8| b.is_ascii_digit();
+            let ordering = match (
+                lhs.bytes().all(is_ascii_digit),
+                rhs.bytes().all(is_ascii_digit),
+            ) {
+                (true, true) => {
+                    // 0 < 00 < 1 < 01 < 001 < 2 < 02 < 002 < 10
+                    let lhval = lhs.trim_start_matches('0');
+                    let rhval = rhs.trim_start_matches('0');
+                    Ord::cmp(&lhval.len(), &rhval.len())
+                        .then_with(|| Ord::cmp(lhval, rhval))
+                        .then_with(|| Ord::cmp(&lhs.len(), &rhs.len()))
+                }
+                (true, false) => return Ordering::Less,
+                (false, true) => return Ordering::Greater,
+                (false, false) => Ord::cmp(lhs, rhs),
+            };
+
+            if ordering != Ordering::Equal {
+                return ordering;
+            }
+        }
+
+        if rhs.next().is_none() {
+            Ordering::Equal
+        } else {
+            Ordering::Less
+        }
+    }
+}
+
+impl FromIterator<Comparator> for VersionReq {
+    fn from_iter<I>(iter: I) -> Self
+    where
+        I: IntoIterator<Item = Comparator>,
+    {
+        let comparators = Vec::from_iter(iter);
+        VersionReq { comparators }
+    }
+}
diff --git a/third_party/rust/semver/src/lib.rs b/third_party/rust/semver/src/lib.rs
index a38aae0e163d..b3c3ea2867e3 100644
--- a/third_party/rust/semver/src/lib.rs
+++ b/third_party/rust/semver/src/lib.rs
@@ -1,182 +1,543 @@
-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT
-// file at the top-level directory of this distribution and at
-// http://rust-lang.org/COPYRIGHT.
-//
-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
-// option. This file may not be copied, modified, or distributed
-// except according to those terms.
-
-//! Semantic version parsing and comparison.
-//!
-//! Semantic versioning (see http://semver.org/) is a set of rules for
-//! assigning version numbers.
-//!
-//! ## SemVer overview
-//!
-//! Given a version number MAJOR.MINOR.PATCH, increment the:
-//!
-//! 1. MAJOR version when you make incompatible API changes,
-//! 2. MINOR version when you add functionality in a backwards-compatible
-//!    manner, and
-//! 3. PATCH version when you make backwards-compatible bug fixes.
-//!
-//! Additional labels for pre-release and build metadata are available as
-//! extensions to the MAJOR.MINOR.PATCH format.
-//!
-//! Any references to 'the spec' in this documentation refer to [version 2.0 of
-//! the SemVer spec](http://semver.org/spec/v2.0.0.html).
-//!
-//! ## SemVer and the Rust ecosystem
+//! [![github]](https://github.com/dtolnay/semver)&ensp;[![crates-io]](https://crates.io/crates/semver)&ensp;[![docs-rs]](https://docs.rs/semver)
 //!
-//! Rust itself follows the SemVer specification, as does its standard
-//! libraries. The two are not tied together.
+//! [github]: https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github
+//! [crates-io]: https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust
+//! [docs-rs]: https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs
 //!
-//! [Cargo](http://crates.io), Rust's package manager, uses SemVer to determine
-//! which versions of packages you need installed.
+//! <br>
 //!
-//! ## Versions
+//! A parser and evaluator for Cargo's flavor of Semantic Versioning.
 //!
-//! At its simplest, the `semver` crate allows you to construct `Version`
-//! objects using the `parse` method:
+//! Semantic Versioning (see <https://semver.org>) is a guideline for how
+//! version numbers are assigned and incremented. It is widely followed within
+//! the Cargo/crates.io ecosystem for Rust.
 //!
-//! ```{rust}
-//! use semver::Version;
+//! <br>
 //!
-//! assert!(Version::parse("1.2.3") == Ok(Version {
-//!    major: 1,
-//!    minor: 2,
-//!    patch: 3,
-//!    pre: vec!(),
-//!    build: vec!(),
-//! }));
-//! ```
-//!
-//! If you have multiple `Version`s, you can use the usual comparison operators
-//! to compare them:
+//! # Example
 //!
-//! ```{rust}
-//! use semver::Version;
-//!
-//! assert!(Version::parse("1.2.3-alpha") != Version::parse("1.2.3-beta"));
-//! assert!(Version::parse("1.2.3-alpha2") >  Version::parse("1.2.0"));
 //! ```
-//!
-//! If you explicitly need to modify a Version, SemVer also allows you to
-//! increment the major, minor, and patch numbers in accordance with the spec.
-//!
-//! Please note that in order to do this, you must use a mutable Version:
-//!
-//! ```{rust}
-//! use semver::Version;
-//!
-//! let mut bugfix_release = Version::parse("1.0.0").unwrap();
-//! bugfix_release.increment_patch();
-//!
-//! assert_eq!(Ok(bugfix_release), Version::parse("1.0.1"));
-//! ```
-//!
-//! When incrementing the minor version number, the patch number resets to zero
-//! (in accordance with section 7 of the spec)
-//!
-//! ```{rust}
-//! use semver::Version;
-//!
-//! let mut feature_release = Version::parse("1.4.6").unwrap();
-//! feature_release.increment_minor();
-//!
-//! assert_eq!(Ok(feature_release), Version::parse("1.5.0"));
-//! ```
-//!
-//! Similarly, when incrementing the major version number, the patch and minor
-//! numbers reset to zero (in accordance with section 8 of the spec)
-//!
-//! ```{rust}
-//! use semver::Version;
-//!
-//! let mut chrome_release = Version::parse("41.5.5377").unwrap();
-//! chrome_release.increment_major();
-//!
-//! assert_eq!(Ok(chrome_release), Version::parse("42.0.0"));
-//! ```
-//!
-//! ## Requirements
-//!
-//! The `semver` crate also provides the ability to compare requirements, which
-//! are more complex comparisons.
-//!
-//! For example, creating a requirement that only matches versions greater than
-//! or equal to 1.0.0:
-//!
-//! ```{rust}
-//! # #![allow(unstable)]
-//! use semver::Version;
-//! use semver::VersionReq;
-//!
-//! let r = VersionReq::parse(">= 1.0.0").unwrap();
-//! let v = Version::parse("1.0.0").unwrap();
-//!
-//! assert!(r.to_string() == ">= 1.0.0".to_string());
-//! assert!(r.matches(&v))
+//! use semver::{BuildMetadata, Prerelease, Version, VersionReq};
+//!
+//! fn main() {
+//!     let req = VersionReq::parse(">=1.2.3, <1.8.0").unwrap();
+//!
+//!     // Check whether this requirement matches version 1.2.3-alpha.1 (no)
+//!     let version = Version {
+//!         major: 1,
+//!         minor: 2,
+//!         patch: 3,
+//!         pre: Prerelease::new("alpha.1").unwrap(),
+//!         build: BuildMetadata::EMPTY,
+//!     };
+//!     assert!(!req.matches(&version));
+//!
+//!     // Check whether it matches 1.3.0 (yes it does)
+//!     let version = Version::parse("1.3.0").unwrap();
+//!     assert!(req.matches(&version));
+//! }
 //! ```
 //!
-//! It also allows parsing of `~x.y.z` and `^x.y.z` requirements as defined at
-//! https://www.npmjs.org/doc/misc/semver.html
+//! <br><br>
 //!
-//! **Tilde requirements** specify a minimal version with some updates:
-//!
-//! ```notrust
-//! ~1.2.3 := >=1.2.3 <1.3.0
-//! ~1.2   := >=1.2.0 <1.3.0
-//! ~1     := >=1.0.0 <2.0.0
-//! ```
+//! # Scope of this crate
 //!
-//! **Caret requirements** allow SemVer compatible updates to a specified
-//! verion, `0.x` and `0.x+1` are not considered compatible, but `1.x` and
-//! `1.x+1` are.
+//! Besides Cargo, several other package ecosystems and package managers for
+//! other languages also use SemVer:&ensp;RubyGems/Bundler for Ruby, npm for
+//! JavaScript, Composer for PHP, CocoaPods for Objective-C...
 //!
-//! `0.0.x` is not considered compatible with any other version.
-//! Missing minor and patch versions are desugared to `0` but allow flexibility
-//! for that value.
+//! The `semver` crate is specifically intended to implement Cargo's
+//! interpretation of Semantic Versioning.
 //!
-//! ```notrust
-//! ^1.2.3 := >=1.2.3 <2.0.0
-//! ^0.2.3 := >=0.2.3 <0.3.0
-//! ^0.0.3 := >=0.0.3 <0.0.4
-//! ^0.0   := >=0.0.0 <0.1.0
-//! ^0     := >=0.0.0 <1.0.0
-//! ```
+//! Where the various tools differ in their interpretation or implementation of
+//! the spec, this crate follows the implementation choices made by Cargo. If
+//! you are operating on version numbers from some other package ecosystem, you
+//! will want to use a different semver library which is appropriate to that
+//! ecosystem.
 //!
-//! **Wildcard requirements** allows parsing of version requirements of the
-//! formats `*`, `x.*` and `x.y.*`.
+//! The extent of Cargo's SemVer support is documented in the *[Specifying
+//! Dependencies]* chapter of the Cargo reference.
 //!
-//! ```notrust
-//! *     := >=0.0.0
-//! 1.*   := >=1.0.0 <2.0.0
-//! 1.2.* := >=1.2.0 <1.3.0
-//! ```
+//! [Specifying Dependencies]: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html
 
-#![doc(html_logo_url = "https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png",
-       html_favicon_url = "https://www.rust-lang.org/favicon.ico")]
-#![deny(missing_docs)]
-#![cfg_attr(test, deny(warnings))]
+#![doc(html_root_url = "https://docs.rs/semver/1.0.13")]
+#![cfg_attr(doc_cfg, feature(doc_cfg))]
+#![cfg_attr(all(not(feature = "std"), not(no_alloc_crate)), no_std)]
+#![cfg_attr(not(no_unsafe_op_in_unsafe_fn_lint), deny(unsafe_op_in_unsafe_fn))]
+#![cfg_attr(no_unsafe_op_in_unsafe_fn_lint, allow(unused_unsafe))]
+#![cfg_attr(no_str_strip_prefix, allow(unstable_name_collisions))]
+#![allow(
+    clippy::cast_lossless,
+    clippy::cast_possible_truncation,
+    clippy::doc_markdown,
+    clippy::items_after_statements,
+    clippy::manual_map,
+    clippy::match_bool,
+    clippy::missing_errors_doc,
+    clippy::must_use_candidate,
+    clippy::needless_doctest_main,
+    clippy::option_if_let_else,
+    clippy::ptr_as_ptr,
+    clippy::redundant_else,
+    clippy::semicolon_if_nothing_returned, // https://github.com/rust-lang/rust-clippy/issues/7324
+    clippy::similar_names,
+    clippy::unnested_or_patterns,
+    clippy::unseparated_literal_suffix,
+    clippy::wildcard_imports
+)]
 
-extern crate semver_parser;
+#[cfg(not(no_alloc_crate))]
+extern crate alloc;
+
+mod backport;
+mod display;
+mod error;
+mod eval;
+mod identifier;
+mod impls;
+mod parse;
 
-// Serialization and deserialization support for version numbers
 #[cfg(feature = "serde")]
-extern crate serde;
+mod serde;
+
+use crate::alloc::vec::Vec;
+use crate::identifier::Identifier;
+use core::str::FromStr;
+
+#[allow(unused_imports)]
+use crate::backport::*;
+
+pub use crate::parse::Error;
+
+/// **SemVer version** as defined by <https://semver.org>.
+///
+/// # Syntax
+///
+/// - The major, minor, and patch numbers may be any integer 0 through u64::MAX.
+///   When representing a SemVer version as a string, each number is written as
+///   a base 10 integer. For example, `1.0.119`.
+///
+/// - Leading zeros are forbidden in those positions. For example `1.01.00` is
+///   invalid as a SemVer version.
+///
+/// - The pre-release identifier, if present, must conform to the syntax
+///   documented for [`Prerelease`].
+///
+/// - The build metadata, if present, must conform to the syntax documented for
+///   [`BuildMetadata`].
+///
+/// - Whitespace is not allowed anywhere in the version.
+///
+/// # Total ordering
+///
+/// Given any two SemVer versions, one is less than, greater than, or equal to
+/// the other. Versions may be compared against one another using Rust's usual
+/// comparison operators.
+///
+/// - The major, minor, and patch number are compared numerically from left to
+/// right, lexicographically ordered as a 3-tuple of integers. So for example
+/// version `1.5.0` is less than version `1.19.0`, despite the fact that
+/// "1.19.0" &lt; "1.5.0" as ASCIIbetically compared strings and 1.19 &lt; 1.5
+/// as real numbers.
+///
+/// - When major, minor, and patch are equal, a pre-release version is
+///   considered less than the ordinary release:&ensp;version `1.0.0-alpha.1` is
+///   less than version `1.0.0`.
+///
+/// - Two pre-releases of the same major, minor, patch are compared by
+///   lexicographic ordering of dot-separated components of the pre-release
+///   string.
+///
+///   - Identifiers consisting of only digits are compared
+///     numerically:&ensp;`1.0.0-pre.8` is less than `1.0.0-pre.12`.
+///
+///   - Identifiers that contain a letter or hyphen are compared in ASCII sort
+///     order:&ensp;`1.0.0-pre12` is less than `1.0.0-pre8`.
+///
+///   - Any numeric identifier is always less than any non-numeric
+///     identifier:&ensp;`1.0.0-pre.1` is less than `1.0.0-pre.x`.
+///
+/// Example:&ensp;`1.0.0-alpha`&ensp;&lt;&ensp;`1.0.0-alpha.1`&ensp;&lt;&ensp;`1.0.0-alpha.beta`&ensp;&lt;&ensp;`1.0.0-beta`&ensp;&lt;&ensp;`1.0.0-beta.2`&ensp;&lt;&ensp;`1.0.0-beta.11`&ensp;&lt;&ensp;`1.0.0-rc.1`&ensp;&lt;&ensp;`1.0.0`
+#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
+pub struct Version {
+    pub major: u64,
+    pub minor: u64,
+    pub patch: u64,
+    pub pre: Prerelease,
+    pub build: BuildMetadata,
+}
+
+/// **SemVer version requirement** describing the intersection of some version
+/// comparators, such as `>=1.2.3, <1.8`.
+///
+/// # Syntax
+///
+/// - Either `*` (meaning "any"), or one or more comma-separated comparators.
+///
+/// - A [`Comparator`] is an operator ([`Op`]) and a partial version, separated
+///   by optional whitespace. For example `>=1.0.0` or `>=1.0`.
+///
+/// - Build metadata is syntactically permitted on the partial versions, but is
+///   completely ignored, as it's never relevant to whether any comparator
+///   matches a particular version.
+///
+/// - Whitespace is permitted around commas and around operators. Whitespace is
+///   not permitted within a partial version, i.e. anywhere between the major
+///   version number and its minor, patch, pre-release, or build metadata.
+#[derive(Clone, Eq, PartialEq, Hash, Debug)]
+#[cfg_attr(no_const_vec_new, derive(Default))]
+pub struct VersionReq {
+    pub comparators: Vec<Comparator>,
+}
+
+/// A pair of comparison operator and partial version, such as `>=1.2`. Forms
+/// one piece of a VersionReq.
+#[derive(Clone, Eq, PartialEq, Hash, Debug)]
+pub struct Comparator {
+    pub op: Op,
+    pub major: u64,
+    pub minor: Option<u64>,
+    /// Patch is only allowed if minor is Some.
+    pub patch: Option<u64>,
+    /// Non-empty pre-release is only allowed if patch is Some.
+    pub pre: Prerelease,
+}
+
+/// SemVer comparison operator: `=`, `>`, `>=`, `<`, `<=`, `~`, `^`, `*`.
+///
+/// # Op::Exact
+/// - &ensp;**`=I.J.K`**&emsp;&mdash;&emsp;exactly the version I.J.K
+/// - &ensp;**`=I.J`**&emsp;&mdash;&emsp;equivalent to `>=I.J.0, <I.(J+1).0`
+/// - &ensp;**`=I`**&emsp;&mdash;&emsp;equivalent to `>=I.0.0, <(I+1).0.0`
+///
+/// # Op::Greater
+/// - &ensp;**`>I.J.K`**
+/// - &ensp;**`>I.J`**&emsp;&mdash;&emsp;equivalent to `>=I.(J+1).0`
+/// - &ensp;**`>I`**&emsp;&mdash;&emsp;equivalent to `>=(I+1).0.0`
+///
+/// # Op::GreaterEq
+/// - &ensp;**`>=I.J.K`**
+/// - &ensp;**`>=I.J`**&emsp;&mdash;&emsp;equivalent to `>=I.J.0`
+/// - &ensp;**`>=I`**&emsp;&mdash;&emsp;equivalent to `>=I.0.0`
+///
+/// # Op::Less
+/// - &ensp;**`<I.J.K`**
+/// - &ensp;**`<I.J`**&emsp;&mdash;&emsp;equivalent to `<I.J.0`
+/// - &ensp;**`<I`**&emsp;&mdash;&emsp;equivalent to `<I.0.0`
+///
+/// # Op::LessEq
+/// - &ensp;**`<=I.J.K`**
+/// - &ensp;**`<=I.J`**&emsp;&mdash;&emsp;equivalent to `<I.(J+1).0`
+/// - &ensp;**`<=I`**&emsp;&mdash;&emsp;equivalent to `<(I+1).0.0`
+///
+/// # Op::Tilde&emsp;("patch" updates)
+/// *Tilde requirements allow the **patch** part of the semver version (the third number) to increase.*
+/// - &ensp;**`~I.J.K`**&emsp;&mdash;&emsp;equivalent to `>=I.J.K, <I.(J+1).0`
+/// - &ensp;**`~I.J`**&emsp;&mdash;&emsp;equivalent to `=I.J`
+/// - &ensp;**`~I`**&emsp;&mdash;&emsp;equivalent to `=I`
+///
+/// # Op::Caret&emsp;("compatible" updates)
+/// *Caret requirements allow parts that are **right of the first nonzero** part of the semver version to increase.*
+/// - &ensp;**`^I.J.K`**&ensp;(for I\>0)&emsp;&mdash;&emsp;equivalent to `>=I.J.K, <(I+1).0.0`
+/// - &ensp;**`^0.J.K`**&ensp;(for J\>0)&emsp;&mdash;&emsp;equivalent to `>=0.J.K, <0.(J+1).0`
+/// - &ensp;**`^0.0.K`**&emsp;&mdash;&emsp;equivalent to `=0.0.K`
+/// - &ensp;**`^I.J`**&ensp;(for I\>0 or J\>0)&emsp;&mdash;&emsp;equivalent to `^I.J.0`
+/// - &ensp;**`^0.0`**&emsp;&mdash;&emsp;equivalent to `=0.0`
+/// - &ensp;**`^I`**&emsp;&mdash;&emsp;equivalent to `=I`
+///
+/// # Op::Wildcard
+/// - &ensp;**`I.J.*`**&emsp;&mdash;&emsp;equivalent to `=I.J`
+/// - &ensp;**`I.*`**&ensp;or&ensp;**`I.*.*`**&emsp;&mdash;&emsp;equivalent to `=I`
+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
+#[cfg_attr(not(no_non_exhaustive), non_exhaustive)]
+pub enum Op {
+    Exact,
+    Greater,
+    GreaterEq,
+    Less,
+    LessEq,
+    Tilde,
+    Caret,
+    Wildcard,
+
+    #[cfg(no_non_exhaustive)] // rustc <1.40
+    #[doc(hidden)]
+    __NonExhaustive,
+}
+
+/// Optional pre-release identifier on a version string. This comes after `-` in
+/// a SemVer version, like `1.0.0-alpha.1`
+///
+/// # Examples
+///
+/// Some real world pre-release idioms drawn from crates.io:
+///
+/// - **[mio]** <code>0.7.0-<b>alpha.1</b></code> &mdash; the most common style
+///   for numbering pre-releases.
+///
+/// - **[pest]** <code>1.0.0-<b>beta.8</b></code>,&ensp;<code>1.0.0-<b>rc.0</b></code>
+///   &mdash; this crate makes a distinction between betas and release
+///   candidates.
+///
+/// - **[sassers]** <code>0.11.0-<b>shitshow</b></code> &mdash; ???.
+///
+/// - **[atomic-utils]** <code>0.0.0-<b>reserved</b></code> &mdash; a squatted
+///   crate name.
+///
+/// [mio]: https://crates.io/crates/mio
+/// [pest]: https://crates.io/crates/pest
+/// [atomic-utils]: https://crates.io/crates/atomic-utils
+/// [sassers]: https://crates.io/crates/sassers
+///
+/// *Tip:* Be aware that if you are planning to number your own pre-releases,
+/// you should prefer to separate the numeric part from any non-numeric
+/// identifiers by using a dot in between. That is, prefer pre-releases
+/// `alpha.1`, `alpha.2`, etc rather than `alpha1`, `alpha2` etc. The SemVer
+/// spec's rule for pre-release precedence has special treatment of numeric
+/// components in the pre-release string, but only if there are no non-digit
+/// characters in the same dot-separated component. So you'd have `alpha.2` &lt;
+/// `alpha.11` as intended, but `alpha11` &lt; `alpha2`.
+///
+/// # Syntax
+///
+/// Pre-release strings are a series of dot separated identifiers immediately
+/// following the patch version. Identifiers must comprise only ASCII
+/// alphanumerics and hyphens: `0-9`, `A-Z`, `a-z`, `-`. Identifiers must not be
+/// empty. Numeric identifiers must not include leading zeros.
+///
+/// # Total ordering
+///
+/// Pre-releases have a total order defined by the SemVer spec. It uses
+/// lexicographic ordering of dot-separated components. Identifiers consisting
+/// of only digits are compared numerically. Otherwise, identifiers are compared
+/// in ASCII sort order. Any numeric identifier is always less than any
+/// non-numeric identifier.
+///
+/// Example:&ensp;`alpha`&ensp;&lt;&ensp;`alpha.85`&ensp;&lt;&ensp;`alpha.90`&ensp;&lt;&ensp;`alpha.200`&ensp;&lt;&ensp;`alpha.0a`&ensp;&lt;&ensp;`alpha.1a0`&ensp;&lt;&ensp;`alpha.a`&ensp;&lt;&ensp;`beta`
+#[derive(Default, Clone, Eq, PartialEq, Hash)]
+pub struct Prerelease {
+    identifier: Identifier,
+}
+
+/// Optional build metadata identifier. This comes after `+` in a SemVer
+/// version, as in `0.8.1+zstd.1.5.0`.
+///
+/// # Examples
+///
+/// Some real world build metadata idioms drawn from crates.io:
+///
+/// - **[libgit2-sys]** <code>0.12.20+<b>1.1.0</b></code> &mdash; for this
+///   crate, the build metadata indicates the version of the C libgit2 library
+///   that the Rust crate is built against.
+///
+/// - **[mashup]** <code>0.1.13+<b>deprecated</b></code> &mdash; just the word
+///   "deprecated" for a crate that has been superseded by another. Eventually
+///   people will take notice of this in Cargo's build output where it lists the
+///   crates being compiled.
+///
+/// - **[google-bigquery2]** <code>2.0.4+<b>20210327</b></code> &mdash; this
+///   library is automatically generated from an official API schema, and the
+///   build metadata indicates the date on which that schema was last captured.
+///
+/// - **[fbthrift-git]** <code>0.0.6+<b>c7fcc0e</b></code> &mdash; this crate is
+///   published from snapshots of a big company monorepo. In monorepo
+///   development, there is no concept of versions, and all downstream code is
+///   just updated atomically in the same commit that breaking changes to a
+///   library are landed. Therefore for crates.io purposes, every published
+///   version must be assumed to be incompatible with the previous. The build
+///   metadata provides the source control hash of the snapshotted code.
+///
+/// [libgit2-sys]: https://crates.io/crates/libgit2-sys
+/// [mashup]: https://crates.io/crates/mashup
+/// [google-bigquery2]: https://crates.io/crates/google-bigquery2
+/// [fbthrift-git]: https://crates.io/crates/fbthrift-git
+///
+/// # Syntax
+///
+/// Build metadata is a series of dot separated identifiers immediately
+/// following the patch or pre-release version. Identifiers must comprise only
+/// ASCII alphanumerics and hyphens: `0-9`, `A-Z`, `a-z`, `-`. Identifiers must
+/// not be empty. Leading zeros *are* allowed, unlike any other place in the
+/// SemVer grammar.
+///
+/// # Total ordering
+///
+/// Build metadata is ignored in evaluating `VersionReq`; it plays no role in
+/// whether a `Version` matches any one of the comparison operators.
+///
+/// However for comparing build metadatas among one another, they do have a
+/// total order which is determined by lexicographic ordering of dot-separated
+/// components. Identifiers consisting of only digits are compared numerically.
+/// Otherwise, identifiers are compared in ASCII sort order. Any numeric
+/// identifier is always less than any non-numeric identifier.
+///
+/// Example:&ensp;`demo`&ensp;&lt;&ensp;`demo.85`&ensp;&lt;&ensp;`demo.90`&ensp;&lt;&ensp;`demo.090`&ensp;&lt;&ensp;`demo.200`&ensp;&lt;&ensp;`demo.1a0`&ensp;&lt;&ensp;`demo.a`&ensp;&lt;&ensp;`memo`
+#[derive(Default, Clone, Eq, PartialEq, Hash)]
+pub struct BuildMetadata {
+    identifier: Identifier,
+}
+
+impl Version {
+    /// Create `Version` with an empty pre-release and build metadata.
+    ///
+    /// Equivalent to:
+    ///
+    /// ```
+    /// # use semver::{BuildMetadata, Prerelease, Version};
+    /// #
+    /// # const fn new(major: u64, minor: u64, patch: u64) -> Version {
+    /// Version {
+    ///     major,
+    ///     minor,
+    ///     patch,
+    ///     pre: Prerelease::EMPTY,
+    ///     build: BuildMetadata::EMPTY,
+    /// }
+    /// # }
+    /// ```
+    pub const fn new(major: u64, minor: u64, patch: u64) -> Self {
+        Version {
+            major,
+            minor,
+            patch,
+            pre: Prerelease::EMPTY,
+            build: BuildMetadata::EMPTY,
+        }
+    }
+
+    /// Create `Version` by parsing from string representation.
+    ///
+    /// # Errors
+    ///
+    /// Possible reasons for the parse to fail include:
+    ///
+    /// - `1.0` &mdash; too few numeric components. A SemVer version must have
+    ///   exactly three. If you are looking at something that has fewer than
+    ///   three numbers in it, it's possible it is a `VersionReq` instead (with
+    ///   an implicit default `^` comparison operator).
+    ///
+    /// - `1.0.01` &mdash; a numeric component has a leading zero.
+    ///
+    /// - `1.0.unknown` &mdash; unexpected character in one of the components.
+    ///
+    /// - `1.0.0-` or `1.0.0+` &mdash; the pre-release or build metadata are
+    ///   indicated present but empty.
+    ///
+    /// - `1.0.0-alpha_123` &mdash; pre-release or build metadata have something
+    ///   outside the allowed characters, which are `0-9`, `A-Z`, `a-z`, `-`,
+    ///   and `.` (dot).
+    ///
+    /// - `23456789999999999999.0.0` &mdash; overflow of a u64.
+    pub fn parse(text: &str) -> Result<Self, Error> {
+        Version::from_str(text)
+    }
+}
+
+impl VersionReq {
+    /// A `VersionReq` with no constraint on the version numbers it matches.
+    /// Equivalent to `VersionReq::parse("*").unwrap()`.
+    ///
+    /// In terms of comparators this is equivalent to `>=0.0.0`.
+    ///
+    /// Counterintuitively a `*` VersionReq does not match every possible
+    /// version number. In particular, in order for *any* `VersionReq` to match
+    /// a pre-release version, the `VersionReq` must contain at least one
+    /// `Comparator` that has an explicit major, minor, and patch version
+    /// identical to the pre-release being matched, and that has a nonempty
+    /// pre-release component. Since `*` is not written with an explicit major,
+    /// minor, and patch version, and does not contain a nonempty pre-release
+    /// component, it does not match any pre-release versions.
+    #[cfg(not(no_const_vec_new))] // rustc <1.39
+    pub const STAR: Self = VersionReq {
+        comparators: Vec::new(),
+    };
+
+    /// Create `VersionReq` by parsing from string representation.
+    ///
+    /// # Errors
+    ///
+    /// Possible reasons for the parse to fail include:
+    ///
+    /// - `>a.b` &mdash; unexpected characters in the partial version.
+    ///
+    /// - `@1.0.0` &mdash; unrecognized comparison operator.
+    ///
+    /// - `^1.0.0, ` &mdash; unexpected end of input.
+    ///
+    /// - `>=1.0 <2.0` &mdash; missing comma between comparators.
+    ///
+    /// - `*.*` &mdash; unsupported wildcard syntax.
+    pub fn parse(text: &str) -> Result<Self, Error> {
+        VersionReq::from_str(text)
+    }
+
+    /// Evaluate whether the given `Version` satisfies the version requirement
+    /// described by `self`.
+    pub fn matches(&self, version: &Version) -> bool {
+        eval::matches_req(self, version)
+    }
+}
+
+/// The default VersionReq is the same as [`VersionReq::STAR`].
+#[cfg(not(no_const_vec_new))]
+impl Default for VersionReq {
+    fn default() -> Self {
+        VersionReq::STAR
+    }
+}
+
+impl Comparator {
+    pub fn parse(text: &str) -> Result<Self, Error> {
+        Comparator::from_str(text)
+    }
+
+    pub fn matches(&self, version: &Version) -> bool {
+        eval::matches_comparator(self, version)
+    }
+}
+
+impl Prerelease {
+    // Work around https://github.com/rust-lang/rust/issues/97933
+    #[cfg(all(doc, semver_rustdoc_workaround))]
+    pub const EMPTY: Self = "";
+
+    #[cfg(not(all(doc, semver_rustdoc_workaround)))]
+    pub const EMPTY: Self = Prerelease {
+        identifier: Identifier::empty(),
+    };
+
+    pub fn new(text: &str) -> Result<Self, Error> {
+        Prerelease::from_str(text)
+    }
+
+    pub fn as_str(&self) -> &str {
+        self.identifier.as_str()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.identifier.is_empty()
+    }
+}
+
+impl BuildMetadata {
+    // Work around https://github.com/rust-lang/rust/issues/97933
+    #[cfg(all(doc, semver_rustdoc_workaround))]
+    pub const EMPTY: Self = "";
 
-// We take the common approach of keeping our own module system private, and
-// just re-exporting the interface that we want.
+    #[cfg(not(all(doc, semver_rustdoc_workaround)))]
+    pub const EMPTY: Self = BuildMetadata {
+        identifier: Identifier::empty(),
+    };
 
-pub use version::{Version, Identifier, SemVerError};
-pub use version::Identifier::{Numeric, AlphaNumeric};
-pub use version_req::{VersionReq, ReqParseError};
+    pub fn new(text: &str) -> Result<Self, Error> {
+        BuildMetadata::from_str(text)
+    }
 
-// SemVer-compliant versions.
-mod version;
+    pub fn as_str(&self) -> &str {
+        self.identifier.as_str()
+    }
 
-// advanced version comparisons
-mod version_req;
+    pub fn is_empty(&self) -> bool {
+        self.identifier.is_empty()
+    }
+}
diff --git a/third_party/rust/semver/src/parse.rs b/third_party/rust/semver/src/parse.rs
new file mode 100644
index 000000000000..6a8f6ffba4fd
--- /dev/null
+++ b/third_party/rust/semver/src/parse.rs
@@ -0,0 +1,405 @@
+use crate::backport::*;
+use crate::error::{ErrorKind, Position};
+use crate::identifier::Identifier;
+use crate::{BuildMetadata, Comparator, Op, Prerelease, Version, VersionReq};
+use core::str::FromStr;
+
+/// Error parsing a SemVer version or version requirement.
+///
+/// # Example
+///
+/// ```
+/// use semver::Version;
+///
+/// fn main() {
+///     let err = Version::parse("1.q.r").unwrap_err();
+///
+///     // "unexpected character 'q' while parsing minor version number"
+///     eprintln!("{}", err);
+/// }
+/// ```
+pub struct Error {
+    pub(crate) kind: ErrorKind,
+}
+
+impl FromStr for Version {
+    type Err = Error;
+
+    fn from_str(text: &str) -> Result<Self, Self::Err> {
+        let mut pos = Position::Major;
+        let (major, text) = numeric_identifier(text, pos)?;
+        let text = dot(text, pos)?;
+
+        pos = Position::Minor;
+        let (minor, text) = numeric_identifier(text, pos)?;
+        let text = dot(text, pos)?;
+
+        pos = Position::Patch;
+        let (patch, text) = numeric_identifier(text, pos)?;
+
+        if text.is_empty() {
+            return Ok(Version::new(major, minor, patch));
+        }
+
+        let (pre, text) = if let Some(text) = text.strip_prefix('-') {
+            pos = Position::Pre;
+            let (pre, text) = prerelease_identifier(text)?;
+            if pre.is_empty() {
+                return Err(Error::new(ErrorKind::EmptySegment(pos)));
+            }
+            (pre, text)
+        } else {
+            (Prerelease::EMPTY, text)
+        };
+
+        let (build, text) = if let Some(text) = text.strip_prefix('+') {
+            pos = Position::Build;
+            let (build, text) = build_identifier(text)?;
+            if build.is_empty() {
+                return Err(Error::new(ErrorKind::EmptySegment(pos)));
+            }
+            (build, text)
+        } else {
+            (BuildMetadata::EMPTY, text)
+        };
+
+        if let Some(unexpected) = text.chars().next() {
+            return Err(Error::new(ErrorKind::UnexpectedCharAfter(pos, unexpected)));
+        }
+
+        Ok(Version {
+            major,
+            minor,
+            patch,
+            pre,
+            build,
+        })
+    }
+}
+
+impl FromStr for VersionReq {
+    type Err = Error;
+
+    fn from_str(text: &str) -> Result<Self, Self::Err> {
+        let text = text.trim_start_matches(' ');
+        if let Some((ch, text)) = wildcard(text) {
+            let rest = text.trim_start_matches(' ');
+            if rest.is_empty() {
+                #[cfg(not(no_const_vec_new))]
+                return Ok(VersionReq::STAR);
+                #[cfg(no_const_vec_new)] // rustc <1.39
+                return Ok(VersionReq {
+                    comparators: Vec::new(),
+                });
+            } else if rest.starts_with(',') {
+                return Err(Error::new(ErrorKind::WildcardNotTheOnlyComparator(ch)));
+            } else {
+                return Err(Error::new(ErrorKind::UnexpectedAfterWildcard));
+            }
+        }
+
+        let depth = 0;
+        let mut comparators = Vec::new();
+        let len = version_req(text, &mut comparators, depth)?;
+        unsafe { comparators.set_len(len) }
+        Ok(VersionReq { comparators })
+    }
+}
+
+impl FromStr for Comparator {
+    type Err = Error;
+
+    fn from_str(text: &str) -> Result<Self, Self::Err> {
+        let text = text.trim_start_matches(' ');
+        let (comparator, pos, rest) = comparator(text)?;
+        if !rest.is_empty() {
+            let unexpected = rest.chars().next().unwrap();
+            return Err(Error::new(ErrorKind::UnexpectedCharAfter(pos, unexpected)));
+        }
+        Ok(comparator)
+    }
+}
+
+impl FromStr for Prerelease {
+    type Err = Error;
+
+    fn from_str(text: &str) -> Result<Self, Self::Err> {
+        let (pre, rest) = prerelease_identifier(text)?;
+        if !rest.is_empty() {
+            return Err(Error::new(ErrorKind::IllegalCharacter(Position::Pre)));
+        }
+        Ok(pre)
+    }
+}
+
+impl FromStr for BuildMetadata {
+    type Err = Error;
+
+    fn from_str(text: &str) -> Result<Self, Self::Err> {
+        let (build, rest) = build_identifier(text)?;
+        if !rest.is_empty() {
+            return Err(Error::new(ErrorKind::IllegalCharacter(Position::Build)));
+        }
+        Ok(build)
+    }
+}
+
+impl Error {
+    fn new(kind: ErrorKind) -> Self {
+        Error { kind }
+    }
+}
+
+impl Op {
+    const DEFAULT: Self = Op::Caret;
+}
+
+fn numeric_identifier(input: &str, pos: Position) -> Result<(u64, &str), Error> {
+    let mut len = 0;
+    let mut value = 0u64;
+
+    while let Some(&digit) = input.as_bytes().get(len) {
+        if digit < b'0' || digit > b'9' {
+            break;
+        }
+        if value == 0 && len > 0 {
+            return Err(Error::new(ErrorKind::LeadingZero(pos)));
+        }
+        match value
+            .checked_mul(10)
+            .and_then(|value| value.checked_add((digit - b'0') as u64))
+        {
+            Some(sum) => value = sum,
+            None => return Err(Error::new(ErrorKind::Overflow(pos))),
+        }
+        len += 1;
+    }
+
+    if len > 0 {
+        Ok((value, &input[len..]))
+    } else if let Some(unexpected) = input[len..].chars().next() {
+        Err(Error::new(ErrorKind::UnexpectedChar(pos, unexpected)))
+    } else {
+        Err(Error::new(ErrorKind::UnexpectedEnd(pos)))
+    }
+}
+
+fn wildcard(input: &str) -> Option<(char, &str)> {
+    if let Some(rest) = input.strip_prefix('*') {
+        Some(('*', rest))
+    } else if let Some(rest) = input.strip_prefix('x') {
+        Some(('x', rest))
+    } else if let Some(rest) = input.strip_prefix('X') {
+        Some(('X', rest))
+    } else {
+        None
+    }
+}
+
+fn dot(input: &str, pos: Position) -> Result<&str, Error> {
+    if let Some(rest) = input.strip_prefix('.') {
+        Ok(rest)
+    } else if let Some(unexpected) = input.chars().next() {
+        Err(Error::new(ErrorKind::UnexpectedCharAfter(pos, unexpected)))
+    } else {
+        Err(Error::new(ErrorKind::UnexpectedEnd(pos)))
+    }
+}
+
+fn prerelease_identifier(input: &str) -> Result<(Prerelease, &str), Error> {
+    let (string, rest) = identifier(input, Position::Pre)?;
+    let identifier = unsafe { Identifier::new_unchecked(string) };
+    Ok((Prerelease { identifier }, rest))
+}
+
+fn build_identifier(input: &str) -> Result<(BuildMetadata, &str), Error> {
+    let (string, rest) = identifier(input, Position::Build)?;
+    let identifier = unsafe { Identifier::new_unchecked(string) };
+    Ok((BuildMetadata { identifier }, rest))
+}
+
+fn identifier(input: &str, pos: Position) -> Result<(&str, &str), Error> {
+    let mut accumulated_len = 0;
+    let mut segment_len = 0;
+    let mut segment_has_nondigit = false;
+
+    loop {
+        match input.as_bytes().get(accumulated_len + segment_len) {
+            Some(b'A'..=b'Z') | Some(b'a'..=b'z') | Some(b'-') => {
+                segment_len += 1;
+                segment_has_nondigit = true;
+            }
+            Some(b'0'..=b'9') => {
+                segment_len += 1;
+            }
+            boundary => {
+                if segment_len == 0 {
+                    if accumulated_len == 0 && boundary != Some(&b'.') {
+                        return Ok(("", input));
+                    } else {
+                        return Err(Error::new(ErrorKind::EmptySegment(pos)));
+                    }
+                }
+                if pos == Position::Pre
+                    && segment_len > 1
+                    && !segment_has_nondigit
+                    && input[accumulated_len..].starts_with('0')
+                {
+                    return Err(Error::new(ErrorKind::LeadingZero(pos)));
+                }
+                accumulated_len += segment_len;
+                if boundary == Some(&b'.') {
+                    accumulated_len += 1;
+                    segment_len = 0;
+                    segment_has_nondigit = false;
+                } else {
+                    return Ok(input.split_at(accumulated_len));
+                }
+            }
+        }
+    }
+}
+
+fn op(input: &str) -> (Op, &str) {
+    let bytes = input.as_bytes();
+    if bytes.first() == Some(&b'=') {
+        (Op::Exact, &input[1..])
+    } else if bytes.first() == Some(&b'>') {
+        if bytes.get(1) == Some(&b'=') {
+            (Op::GreaterEq, &input[2..])
+        } else {
+            (Op::Greater, &input[1..])
+        }
+    } else if bytes.first() == Some(&b'<') {
+        if bytes.get(1) == Some(&b'=') {
+            (Op::LessEq, &input[2..])
+        } else {
+            (Op::Less, &input[1..])
+        }
+    } else if bytes.first() == Some(&b'~') {
+        (Op::Tilde, &input[1..])
+    } else if bytes.first() == Some(&b'^') {
+        (Op::Caret, &input[1..])
+    } else {
+        (Op::DEFAULT, input)
+    }
+}
+
+fn comparator(input: &str) -> Result<(Comparator, Position, &str), Error> {
+    let (mut op, text) = op(input);
+    let default_op = input.len() == text.len();
+    let text = text.trim_start_matches(' ');
+
+    let mut pos = Position::Major;
+    let (major, text) = numeric_identifier(text, pos)?;
+    let mut has_wildcard = false;
+
+    let (minor, text) = if let Some(text) = text.strip_prefix('.') {
+        pos = Position::Minor;
+        if let Some((_, text)) = wildcard(text) {
+            has_wildcard = true;
+            if default_op {
+                op = Op::Wildcard;
+            }
+            (None, text)
+        } else {
+            let (minor, text) = numeric_identifier(text, pos)?;
+            (Some(minor), text)
+        }
+    } else {
+        (None, text)
+    };
+
+    let (patch, text) = if let Some(text) = text.strip_prefix('.') {
+        pos = Position::Patch;
+        if let Some((_, text)) = wildcard(text) {
+            if default_op {
+                op = Op::Wildcard;
+            }
+            (None, text)
+        } else if has_wildcard {
+            return Err(Error::new(ErrorKind::UnexpectedAfterWildcard));
+        } else {
+            let (patch, text) = numeric_identifier(text, pos)?;
+            (Some(patch), text)
+        }
+    } else {
+        (None, text)
+    };
+
+    let (pre, text) = if patch.is_some() && text.starts_with('-') {
+        pos = Position::Pre;
+        let text = &text[1..];
+        let (pre, text) = prerelease_identifier(text)?;
+        if pre.is_empty() {
+            return Err(Error::new(ErrorKind::EmptySegment(pos)));
+        }
+        (pre, text)
+    } else {
+        (Prerelease::EMPTY, text)
+    };
+
+    let text = if patch.is_some() && text.starts_with('+') {
+        pos = Position::Build;
+        let text = &text[1..];
+        let (build, text) = build_identifier(text)?;
+        if build.is_empty() {
+            return Err(Error::new(ErrorKind::EmptySegment(pos)));
+        }
+        text
+    } else {
+        text
+    };
+
+    let text = text.trim_start_matches(' ');
+
+    let comparator = Comparator {
+        op,
+        major,
+        minor,
+        patch,
+        pre,
+    };
+
+    Ok((comparator, pos, text))
+}
+
+fn version_req(input: &str, out: &mut Vec<Comparator>, depth: usize) -> Result<usize, Error> {
+    let (comparator, pos, text) = match comparator(input) {
+        Ok(success) => success,
+        Err(mut error) => {
+            if let Some((ch, mut rest)) = wildcard(input) {
+                rest = rest.trim_start_matches(' ');
+                if rest.is_empty() || rest.starts_with(',') {
+                    error.kind = ErrorKind::WildcardNotTheOnlyComparator(ch);
+                }
+            }
+            return Err(error);
+        }
+    };
+
+    if text.is_empty() {
+        out.reserve_exact(depth + 1);
+        unsafe { out.as_mut_ptr().add(depth).write(comparator) }
+        return Ok(depth + 1);
+    }
+
+    let text = if let Some(text) = text.strip_prefix(',') {
+        text.trim_start_matches(' ')
+    } else {
+        let unexpected = text.chars().next().unwrap();
+        return Err(Error::new(ErrorKind::ExpectedCommaFound(pos, unexpected)));
+    };
+
+    const MAX_COMPARATORS: usize = 32;
+    if depth + 1 == MAX_COMPARATORS {
+        return Err(Error::new(ErrorKind::ExcessiveComparators));
+    }
+
+    // Recurse to collect parsed Comparator objects on the stack. We perform a
+    // single allocation to allocate exactly the right sized Vec only once the
+    // total number of comparators is known.
+    let len = version_req(text, out, depth + 1)?;
+    unsafe { out.as_mut_ptr().add(depth).write(comparator) }
+    Ok(len)
+}
diff --git a/third_party/rust/semver/src/serde.rs b/third_party/rust/semver/src/serde.rs
new file mode 100644
index 000000000000..1fcc7d87f624
--- /dev/null
+++ b/third_party/rust/semver/src/serde.rs
@@ -0,0 +1,109 @@
+use crate::{Comparator, Version, VersionReq};
+use core::fmt;
+use serde::de::{Deserialize, Deserializer, Error, Visitor};
+use serde::ser::{Serialize, Serializer};
+
+impl Serialize for Version {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        serializer.collect_str(self)
+    }
+}
+
+impl Serialize for VersionReq {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        serializer.collect_str(self)
+    }
+}
+
+impl Serialize for Comparator {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        serializer.collect_str(self)
+    }
+}
+
+impl<'de> Deserialize<'de> for Version {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        struct VersionVisitor;
+
+        impl<'de> Visitor<'de> for VersionVisitor {
+            type Value = Version;
+
+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+                formatter.write_str("semver version")
+            }
+
+            fn visit_str<E>(self, string: &str) -> Result<Self::Value, E>
+            where
+                E: Error,
+            {
+                string.parse().map_err(Error::custom)
+            }
+        }
+
+        deserializer.deserialize_str(VersionVisitor)
+    }
+}
+
+impl<'de> Deserialize<'de> for VersionReq {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        struct VersionReqVisitor;
+
+        impl<'de> Visitor<'de> for VersionReqVisitor {
+            type Value = VersionReq;
+
+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+                formatter.write_str("semver version")
+            }
+
+            fn visit_str<E>(self, string: &str) -> Result<Self::Value, E>
+            where
+                E: Error,
+            {
+                string.parse().map_err(Error::custom)
+            }
+        }
+
+        deserializer.deserialize_str(VersionReqVisitor)
+    }
+}
+
+impl<'de> Deserialize<'de> for Comparator {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        struct ComparatorVisitor;
+
+        impl<'de> Visitor<'de> for ComparatorVisitor {
+            type Value = Comparator;
+
+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+                formatter.write_str("semver comparator")
+            }
+
+            fn visit_str<E>(self, string: &str) -> Result<Self::Value, E>
+            where
+                E: Error,
+            {
+                string.parse().map_err(Error::custom)
+            }
+        }
+
+        deserializer.deserialize_str(ComparatorVisitor)
+    }
+}
diff --git a/third_party/rust/semver/tests/node/mod.rs b/third_party/rust/semver/tests/node/mod.rs
new file mode 100644
index 000000000000..eb50673d5ff1
--- /dev/null
+++ b/third_party/rust/semver/tests/node/mod.rs
@@ -0,0 +1,43 @@
+#![cfg(test_node_semver)]
+
+use semver::Version;
+use std::fmt::{self, Display};
+use std::process::Command;
+
+#[derive(Default, Eq, PartialEq, Hash, Debug)]
+pub(super) struct VersionReq(semver::VersionReq);
+
+impl VersionReq {
+    pub(super) const STAR: Self = VersionReq(semver::VersionReq::STAR);
+
+    pub(super) fn matches(&self, version: &Version) -> bool {
+        let out = Command::new("node")
+            .arg("-e")
+            .arg(format!(
+                "console.log(require('semver').satisfies('{}', '{}'))",
+                version,
+                self.to_string().replace(',', ""),
+            ))
+            .output()
+            .unwrap();
+        if out.stdout == b"true\n" {
+            true
+        } else if out.stdout == b"false\n" {
+            false
+        } else {
+            let s = String::from_utf8_lossy(&out.stdout) + String::from_utf8_lossy(&out.stderr);
+            panic!("unexpected output: {}", s);
+        }
+    }
+}
+
+impl Display for VersionReq {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        Display::fmt(&self.0, formatter)
+    }
+}
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+pub(super) fn req(text: &str) -> VersionReq {
+    VersionReq(crate::util::req(text))
+}
diff --git a/third_party/rust/semver/tests/test_autotrait.rs b/third_party/rust/semver/tests/test_autotrait.rs
new file mode 100644
index 000000000000..af8534bd73ce
--- /dev/null
+++ b/third_party/rust/semver/tests/test_autotrait.rs
@@ -0,0 +1,12 @@
+fn assert_send_sync<T: Send + Sync>() {}
+
+#[test]
+fn test() {
+    assert_send_sync::<semver::BuildMetadata>();
+    assert_send_sync::<semver::Comparator>();
+    assert_send_sync::<semver::Error>();
+    assert_send_sync::<semver::Prerelease>();
+    assert_send_sync::<semver::Version>();
+    assert_send_sync::<semver::VersionReq>();
+    assert_send_sync::<semver::Op>();
+}
diff --git a/third_party/rust/semver/tests/test_identifier.rs b/third_party/rust/semver/tests/test_identifier.rs
new file mode 100644
index 000000000000..dc888c9c1019
--- /dev/null
+++ b/third_party/rust/semver/tests/test_identifier.rs
@@ -0,0 +1,45 @@
+#![allow(
+    clippy::eq_op,
+    clippy::needless_pass_by_value,
+    clippy::toplevel_ref_arg,
+    clippy::wildcard_imports
+)]
+
+mod util;
+
+use crate::util::*;
+use semver::Prerelease;
+
+#[test]
+fn test_new() {
+    fn test(identifier: Prerelease, expected: &str) {
+        assert_eq!(identifier.is_empty(), expected.is_empty());
+        assert_eq!(identifier.len(), expected.len());
+        assert_eq!(identifier.as_str(), expected);
+        assert_eq!(identifier, identifier);
+        assert_eq!(identifier, identifier.clone());
+    }
+
+    let ref mut string = String::new();
+    let limit = if cfg!(miri) { 40 } else { 280 }; // miri is slow
+    for _ in 0..limit {
+        test(prerelease(string), string);
+        string.push('1');
+    }
+
+    if !cfg!(miri) {
+        let ref string = string.repeat(20000);
+        test(prerelease(string), string);
+    }
+}
+
+#[test]
+fn test_eq() {
+    assert_eq!(prerelease("-"), prerelease("-"));
+    assert_ne!(prerelease("a"), prerelease("aa"));
+    assert_ne!(prerelease("aa"), prerelease("a"));
+    assert_ne!(prerelease("aaaaaaaaa"), prerelease("a"));
+    assert_ne!(prerelease("a"), prerelease("aaaaaaaaa"));
+    assert_ne!(prerelease("aaaaaaaaa"), prerelease("bbbbbbbbb"));
+    assert_ne!(build_metadata("1"), build_metadata("001"));
+}
diff --git a/third_party/rust/semver/tests/test_version.rs b/third_party/rust/semver/tests/test_version.rs
new file mode 100644
index 000000000000..93a528c1933f
--- /dev/null
+++ b/third_party/rust/semver/tests/test_version.rs
@@ -0,0 +1,241 @@
+#![allow(
+    clippy::nonminimal_bool,
+    clippy::too_many_lines,
+    clippy::wildcard_imports
+)]
+
+mod util;
+
+use crate::util::*;
+use semver::{BuildMetadata, Prerelease, Version};
+
+#[test]
+fn test_parse() {
+    let err = version_err("");
+    assert_to_string(
+        err,
+        "unexpected end of input while parsing major version number",
+    );
+
+    let err = version_err("  ");
+    assert_to_string(
+        err,
+        "unexpected character ' ' while parsing major version number",
+    );
+
+    let err = version_err("1");
+    assert_to_string(
+        err,
+        "unexpected end of input while parsing major version number",
+    );
+
+    let err = version_err("1.2");
+    assert_to_string(
+        err,
+        "unexpected end of input while parsing minor version number",
+    );
+
+    let err = version_err("1.2.3-");
+    assert_to_string(err, "empty identifier segment in pre-release identifier");
+
+    let err = version_err("a.b.c");
+    assert_to_string(
+        err,
+        "unexpected character 'a' while parsing major version number",
+    );
+
+    let err = version_err("1.2.3 abc");
+    assert_to_string(err, "unexpected character ' ' after patch version number");
+
+    let err = version_err("1.2.3-01");
+    assert_to_string(err, "invalid leading zero in pre-release identifier");
+
+    let parsed = version("1.2.3");
+    let expected = Version::new(1, 2, 3);
+    assert_eq!(parsed, expected);
+    let expected = Version {
+        major: 1,
+        minor: 2,
+        patch: 3,
+        pre: Prerelease::EMPTY,
+        build: BuildMetadata::EMPTY,
+    };
+    assert_eq!(parsed, expected);
+
+    let parsed = version("1.2.3-alpha1");
+    let expected = Version {
+        major: 1,
+        minor: 2,
+        patch: 3,
+        pre: prerelease("alpha1"),
+        build: BuildMetadata::EMPTY,
+    };
+    assert_eq!(parsed, expected);
+
+    let parsed = version("1.2.3+build5");
+    let expected = Version {
+        major: 1,
+        minor: 2,
+        patch: 3,
+        pre: Prerelease::EMPTY,
+        build: build_metadata("build5"),
+    };
+    assert_eq!(parsed, expected);
+
+    let parsed = version("1.2.3+5build");
+    let expected = Version {
+        major: 1,
+        minor: 2,
+        patch: 3,
+        pre: Prerelease::EMPTY,
+        build: build_metadata("5build"),
+    };
+    assert_eq!(parsed, expected);
+
+    let parsed = version("1.2.3-alpha1+build5");
+    let expected = Version {
+        major: 1,
+        minor: 2,
+        patch: 3,
+        pre: prerelease("alpha1"),
+        build: build_metadata("build5"),
+    };
+    assert_eq!(parsed, expected);
+
+    let parsed = version("1.2.3-1.alpha1.9+build5.7.3aedf");
+    let expected = Version {
+        major: 1,
+        minor: 2,
+        patch: 3,
+        pre: prerelease("1.alpha1.9"),
+        build: build_metadata("build5.7.3aedf"),
+    };
+    assert_eq!(parsed, expected);
+
+    let parsed = version("1.2.3-0a.alpha1.9+05build.7.3aedf");
+    let expected = Version {
+        major: 1,
+        minor: 2,
+        patch: 3,
+        pre: prerelease("0a.alpha1.9"),
+        build: build_metadata("05build.7.3aedf"),
+    };
+    assert_eq!(parsed, expected);
+
+    let parsed = version("0.4.0-beta.1+0851523");
+    let expected = Version {
+        major: 0,
+        minor: 4,
+        patch: 0,
+        pre: prerelease("beta.1"),
+        build: build_metadata("0851523"),
+    };
+    assert_eq!(parsed, expected);
+
+    // for https://nodejs.org/dist/index.json, where some older npm versions are "1.1.0-beta-10"
+    let parsed = version("1.1.0-beta-10");
+    let expected = Version {
+        major: 1,
+        minor: 1,
+        patch: 0,
+        pre: prerelease("beta-10"),
+        build: BuildMetadata::EMPTY,
+    };
+    assert_eq!(parsed, expected);
+}
+
+#[test]
+fn test_eq() {
+    assert_eq!(version("1.2.3"), version("1.2.3"));
+    assert_eq!(version("1.2.3-alpha1"), version("1.2.3-alpha1"));
+    assert_eq!(version("1.2.3+build.42"), version("1.2.3+build.42"));
+    assert_eq!(version("1.2.3-alpha1+42"), version("1.2.3-alpha1+42"));
+}
+
+#[test]
+fn test_ne() {
+    assert_ne!(version("0.0.0"), version("0.0.1"));
+    assert_ne!(version("0.0.0"), version("0.1.0"));
+    assert_ne!(version("0.0.0"), version("1.0.0"));
+    assert_ne!(version("1.2.3-alpha"), version("1.2.3-beta"));
+    assert_ne!(version("1.2.3+23"), version("1.2.3+42"));
+}
+
+#[test]
+fn test_display() {
+    assert_to_string(version("1.2.3"), "1.2.3");
+    assert_to_string(version("1.2.3-alpha1"), "1.2.3-alpha1");
+    assert_to_string(version("1.2.3+build.42"), "1.2.3+build.42");
+    assert_to_string(version("1.2.3-alpha1+42"), "1.2.3-alpha1+42");
+}
+
+#[test]
+fn test_lt() {
+    assert!(version("0.0.0") < version("1.2.3-alpha2"));
+    assert!(version("1.0.0") < version("1.2.3-alpha2"));
+    assert!(version("1.2.0") < version("1.2.3-alpha2"));
+    assert!(version("1.2.3-alpha1") < version("1.2.3"));
+    assert!(version("1.2.3-alpha1") < version("1.2.3-alpha2"));
+    assert!(!(version("1.2.3-alpha2") < version("1.2.3-alpha2")));
+    assert!(version("1.2.3+23") < version("1.2.3+42"));
+}
+
+#[test]
+fn test_le() {
+    assert!(version("0.0.0") <= version("1.2.3-alpha2"));
+    assert!(version("1.0.0") <= version("1.2.3-alpha2"));
+    assert!(version("1.2.0") <= version("1.2.3-alpha2"));
+    assert!(version("1.2.3-alpha1") <= version("1.2.3-alpha2"));
+    assert!(version("1.2.3-alpha2") <= version("1.2.3-alpha2"));
+    assert!(version("1.2.3+23") <= version("1.2.3+42"));
+}
+
+#[test]
+fn test_gt() {
+    assert!(version("1.2.3-alpha2") > version("0.0.0"));
+    assert!(version("1.2.3-alpha2") > version("1.0.0"));
+    assert!(version("1.2.3-alpha2") > version("1.2.0"));
+    assert!(version("1.2.3-alpha2") > version("1.2.3-alpha1"));
+    assert!(version("1.2.3") > version("1.2.3-alpha2"));
+    assert!(!(version("1.2.3-alpha2") > version("1.2.3-alpha2")));
+    assert!(!(version("1.2.3+23") > version("1.2.3+42")));
+}
+
+#[test]
+fn test_ge() {
+    assert!(version("1.2.3-alpha2") >= version("0.0.0"));
+    assert!(version("1.2.3-alpha2") >= version("1.0.0"));
+    assert!(version("1.2.3-alpha2") >= version("1.2.0"));
+    assert!(version("1.2.3-alpha2") >= version("1.2.3-alpha1"));
+    assert!(version("1.2.3-alpha2") >= version("1.2.3-alpha2"));
+    assert!(!(version("1.2.3+23") >= version("1.2.3+42")));
+}
+
+#[test]
+fn test_spec_order() {
+    let vs = [
+        "1.0.0-alpha",
+        "1.0.0-alpha.1",
+        "1.0.0-alpha.beta",
+        "1.0.0-beta",
+        "1.0.0-beta.2",
+        "1.0.0-beta.11",
+        "1.0.0-rc.1",
+        "1.0.0",
+    ];
+    let mut i = 1;
+    while i < vs.len() {
+        let a = version(vs[i - 1]);
+        let b = version(vs[i]);
+        assert!(a < b, "nope {:?} < {:?}", a, b);
+        i += 1;
+    }
+}
+
+#[test]
+fn test_align() {
+    let version = version("1.2.3-rc1");
+    assert_eq!("1.2.3-rc1           ", format!("{:20}", version));
+    assert_eq!("*****1.2.3-rc1******", format!("{:*^20}", version));
+    assert_eq!("           1.2.3-rc1", format!("{:>20}", version));
+}
diff --git a/third_party/rust/semver/tests/test_version_req.rs b/third_party/rust/semver/tests/test_version_req.rs
new file mode 100644
index 000000000000..98a03ac896ea
--- /dev/null
+++ b/third_party/rust/semver/tests/test_version_req.rs
@@ -0,0 +1,443 @@
+#![allow(
+    clippy::missing_panics_doc,
+    clippy::shadow_unrelated,
+    clippy::toplevel_ref_arg,
+    clippy::wildcard_imports
+)]
+
+mod node;
+mod util;
+
+use crate::util::*;
+use std::collections::hash_map::DefaultHasher;
+use std::hash::{Hash, Hasher};
+
+#[cfg(test_node_semver)]
+use node::{req, VersionReq};
+#[cfg(not(test_node_semver))]
+use semver::VersionReq;
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+fn assert_match_all(req: &VersionReq, versions: &[&str]) {
+    for string in versions {
+        let parsed = version(string);
+        assert!(req.matches(&parsed), "did not match {}", string);
+    }
+}
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+fn assert_match_none(req: &VersionReq, versions: &[&str]) {
+    for string in versions {
+        let parsed = version(string);
+        assert!(!req.matches(&parsed), "matched {}", string);
+    }
+}
+
+#[test]
+fn test_basic() {
+    let ref r = req("1.0.0");
+    assert_to_string(r, "^1.0.0");
+    assert_match_all(r, &["1.0.0", "1.1.0", "1.0.1"]);
+    assert_match_none(r, &["0.9.9", "0.10.0", "0.1.0", "1.0.0-pre", "1.0.1-pre"]);
+}
+
+#[test]
+#[cfg(not(no_const_vec_new))]
+fn test_default() {
+    let ref r = VersionReq::default();
+    assert_eq!(r, &VersionReq::STAR);
+}
+
+#[test]
+fn test_exact() {
+    let ref r = req("=1.0.0");
+    assert_to_string(r, "=1.0.0");
+    assert_match_all(r, &["1.0.0"]);
+    assert_match_none(r, &["1.0.1", "0.9.9", "0.10.0", "0.1.0", "1.0.0-pre"]);
+
+    let ref r = req("=0.9.0");
+    assert_to_string(r, "=0.9.0");
+    assert_match_all(r, &["0.9.0"]);
+    assert_match_none(r, &["0.9.1", "1.9.0", "0.0.9", "0.9.0-pre"]);
+
+    let ref r = req("=0.0.2");
+    assert_to_string(r, "=0.0.2");
+    assert_match_all(r, &["0.0.2"]);
+    assert_match_none(r, &["0.0.1", "0.0.3", "0.0.2-pre"]);
+
+    let ref r = req("=0.1.0-beta2.a");
+    assert_to_string(r, "=0.1.0-beta2.a");
+    assert_match_all(r, &["0.1.0-beta2.a"]);
+    assert_match_none(r, &["0.9.1", "0.1.0", "0.1.1-beta2.a", "0.1.0-beta2"]);
+
+    let ref r = req("=0.1.0+meta");
+    assert_to_string(r, "=0.1.0");
+    assert_match_all(r, &["0.1.0", "0.1.0+meta", "0.1.0+any"]);
+}
+
+#[test]
+pub fn test_greater_than() {
+    let ref r = req(">= 1.0.0");
+    assert_to_string(r, ">=1.0.0");
+    assert_match_all(r, &["1.0.0", "2.0.0"]);
+    assert_match_none(r, &["0.1.0", "0.0.1", "1.0.0-pre", "2.0.0-pre"]);
+
+    let ref r = req(">= 2.1.0-alpha2");
+    assert_to_string(r, ">=2.1.0-alpha2");
+    assert_match_all(r, &["2.1.0-alpha2", "2.1.0-alpha3", "2.1.0", "3.0.0"]);
+    assert_match_none(
+        r,
+        &["2.0.0", "2.1.0-alpha1", "2.0.0-alpha2", "3.0.0-alpha2"],
+    );
+}
+
+#[test]
+pub fn test_less_than() {
+    let ref r = req("< 1.0.0");
+    assert_to_string(r, "<1.0.0");
+    assert_match_all(r, &["0.1.0", "0.0.1"]);
+    assert_match_none(r, &["1.0.0", "1.0.0-beta", "1.0.1", "0.9.9-alpha"]);
+
+    let ref r = req("<= 2.1.0-alpha2");
+    assert_match_all(r, &["2.1.0-alpha2", "2.1.0-alpha1", "2.0.0", "1.0.0"]);
+    assert_match_none(
+        r,
+        &["2.1.0", "2.2.0-alpha1", "2.0.0-alpha2", "1.0.0-alpha2"],
+    );
+
+    let ref r = req(">1.0.0-alpha, <1.0.0");
+    assert_match_all(r, &["1.0.0-beta"]);
+
+    let ref r = req(">1.0.0-alpha, <1.0");
+    assert_match_none(r, &["1.0.0-beta"]);
+
+    let ref r = req(">1.0.0-alpha, <1");
+    assert_match_none(r, &["1.0.0-beta"]);
+}
+
+#[test]
+pub fn test_multiple() {
+    let ref r = req("> 0.0.9, <= 2.5.3");
+    assert_to_string(r, ">0.0.9, <=2.5.3");
+    assert_match_all(r, &["0.0.10", "1.0.0", "2.5.3"]);
+    assert_match_none(r, &["0.0.8", "2.5.4"]);
+
+    let ref r = req("0.3.0, 0.4.0");
+    assert_to_string(r, "^0.3.0, ^0.4.0");
+    assert_match_none(r, &["0.0.8", "0.3.0", "0.4.0"]);
+
+    let ref r = req("<= 0.2.0, >= 0.5.0");
+    assert_to_string(r, "<=0.2.0, >=0.5.0");
+    assert_match_none(r, &["0.0.8", "0.3.0", "0.5.1"]);
+
+    let ref r = req("0.1.0, 0.1.4, 0.1.6");
+    assert_to_string(r, "^0.1.0, ^0.1.4, ^0.1.6");
+    assert_match_all(r, &["0.1.6", "0.1.9"]);
+    assert_match_none(r, &["0.1.0", "0.1.4", "0.2.0"]);
+
+    let err = req_err("> 0.1.0,");
+    assert_to_string(
+        err,
+        "unexpected end of input while parsing major version number",
+    );
+
+    let err = req_err("> 0.3.0, ,");
+    assert_to_string(
+        err,
+        "unexpected character ',' while parsing major version number",
+    );
+
+    let ref r = req(">=0.5.1-alpha3, <0.6");
+    assert_to_string(r, ">=0.5.1-alpha3, <0.6");
+    assert_match_all(
+        r,
+        &[
+            "0.5.1-alpha3",
+            "0.5.1-alpha4",
+            "0.5.1-beta",
+            "0.5.1",
+            "0.5.5",
+        ],
+    );
+    assert_match_none(
+        r,
+        &["0.5.1-alpha1", "0.5.2-alpha3", "0.5.5-pre", "0.5.0-pre"],
+    );
+    assert_match_none(r, &["0.6.0", "0.6.0-pre"]);
+
+    // https://github.com/steveklabnik/semver/issues/56
+    let err = req_err("1.2.3 - 2.3.4");
+    assert_to_string(err, "expected comma after patch version number, found '-'");
+}
+
+#[test]
+pub fn test_whitespace_delimited_comparator_sets() {
+    // https://github.com/steveklabnik/semver/issues/55
+    let err = req_err("> 0.0.9 <= 2.5.3");
+    assert_to_string(err, "expected comma after patch version number, found '<'");
+}
+
+#[test]
+pub fn test_tilde() {
+    let ref r = req("~1");
+    assert_match_all(r, &["1.0.0", "1.0.1", "1.1.1"]);
+    assert_match_none(r, &["0.9.1", "2.9.0", "0.0.9"]);
+
+    let ref r = req("~1.2");
+    assert_match_all(r, &["1.2.0", "1.2.1"]);
+    assert_match_none(r, &["1.1.1", "1.3.0", "0.0.9"]);
+
+    let ref r = req("~1.2.2");
+    assert_match_all(r, &["1.2.2", "1.2.4"]);
+    assert_match_none(r, &["1.2.1", "1.9.0", "1.0.9", "2.0.1", "0.1.3"]);
+
+    let ref r = req("~1.2.3-beta.2");
+    assert_match_all(r, &["1.2.3", "1.2.4", "1.2.3-beta.2", "1.2.3-beta.4"]);
+    assert_match_none(r, &["1.3.3", "1.1.4", "1.2.3-beta.1", "1.2.4-beta.2"]);
+}
+
+#[test]
+pub fn test_caret() {
+    let ref r = req("^1");
+    assert_match_all(r, &["1.1.2", "1.1.0", "1.2.1", "1.0.1"]);
+    assert_match_none(r, &["0.9.1", "2.9.0", "0.1.4"]);
+    assert_match_none(r, &["1.0.0-beta1", "0.1.0-alpha", "1.0.1-pre"]);
+
+    let ref r = req("^1.1");
+    assert_match_all(r, &["1.1.2", "1.1.0", "1.2.1"]);
+    assert_match_none(r, &["0.9.1", "2.9.0", "1.0.1", "0.1.4"]);
+
+    let ref r = req("^1.1.2");
+    assert_match_all(r, &["1.1.2", "1.1.4", "1.2.1"]);
+    assert_match_none(r, &["0.9.1", "2.9.0", "1.1.1", "0.0.1"]);
+    assert_match_none(r, &["1.1.2-alpha1", "1.1.3-alpha1", "2.9.0-alpha1"]);
+
+    let ref r = req("^0.1.2");
+    assert_match_all(r, &["0.1.2", "0.1.4"]);
+    assert_match_none(r, &["0.9.1", "2.9.0", "1.1.1", "0.0.1"]);
+    assert_match_none(r, &["0.1.2-beta", "0.1.3-alpha", "0.2.0-pre"]);
+
+    let ref r = req("^0.5.1-alpha3");
+    assert_match_all(
+        r,
+        &[
+            "0.5.1-alpha3",
+            "0.5.1-alpha4",
+            "0.5.1-beta",
+            "0.5.1",
+            "0.5.5",
+        ],
+    );
+    assert_match_none(
+        r,
+        &[
+            "0.5.1-alpha1",
+            "0.5.2-alpha3",
+            "0.5.5-pre",
+            "0.5.0-pre",
+            "0.6.0",
+        ],
+    );
+
+    let ref r = req("^0.0.2");
+    assert_match_all(r, &["0.0.2"]);
+    assert_match_none(r, &["0.9.1", "2.9.0", "1.1.1", "0.0.1", "0.1.4"]);
+
+    let ref r = req("^0.0");
+    assert_match_all(r, &["0.0.2", "0.0.0"]);
+    assert_match_none(r, &["0.9.1", "2.9.0", "1.1.1", "0.1.4"]);
+
+    let ref r = req("^0");
+    assert_match_all(r, &["0.9.1", "0.0.2", "0.0.0"]);
+    assert_match_none(r, &["2.9.0", "1.1.1"]);
+
+    let ref r = req("^1.4.2-beta.5");
+    assert_match_all(
+        r,
+        &["1.4.2", "1.4.3", "1.4.2-beta.5", "1.4.2-beta.6", "1.4.2-c"],
+    );
+    assert_match_none(
+        r,
+        &[
+            "0.9.9",
+            "2.0.0",
+            "1.4.2-alpha",
+            "1.4.2-beta.4",
+            "1.4.3-beta.5",
+        ],
+    );
+}
+
+#[test]
+pub fn test_wildcard() {
+    let err = req_err("");
+    assert_to_string(
+        err,
+        "unexpected end of input while parsing major version number",
+    );
+
+    let ref r = req("*");
+    assert_match_all(r, &["0.9.1", "2.9.0", "0.0.9", "1.0.1", "1.1.1"]);
+    assert_match_none(r, &["1.0.0-pre"]);
+
+    for s in &["x", "X"] {
+        assert_eq!(*r, req(s));
+    }
+
+    let ref r = req("1.*");
+    assert_match_all(r, &["1.2.0", "1.2.1", "1.1.1", "1.3.0"]);
+    assert_match_none(r, &["0.0.9", "1.2.0-pre"]);
+
+    for s in &["1.x", "1.X", "1.*.*"] {
+        assert_eq!(*r, req(s));
+    }
+
+    let ref r = req("1.2.*");
+    assert_match_all(r, &["1.2.0", "1.2.2", "1.2.4"]);
+    assert_match_none(r, &["1.9.0", "1.0.9", "2.0.1", "0.1.3", "1.2.2-pre"]);
+
+    for s in &["1.2.x", "1.2.X"] {
+        assert_eq!(*r, req(s));
+    }
+}
+
+#[test]
+pub fn test_logical_or() {
+    // https://github.com/steveklabnik/semver/issues/57
+    let err = req_err("=1.2.3 || =2.3.4");
+    assert_to_string(err, "expected comma after patch version number, found '|'");
+
+    let err = req_err("1.1 || =1.2.3");
+    assert_to_string(err, "expected comma after minor version number, found '|'");
+
+    let err = req_err("6.* || 8.* || >= 10.*");
+    assert_to_string(err, "expected comma after minor version number, found '|'");
+}
+
+#[test]
+pub fn test_any() {
+    #[cfg(not(no_const_vec_new))]
+    let ref r = VersionReq::STAR;
+    #[cfg(no_const_vec_new)]
+    let ref r = VersionReq {
+        comparators: Vec::new(),
+    };
+    assert_match_all(r, &["0.0.1", "0.1.0", "1.0.0"]);
+}
+
+#[test]
+pub fn test_pre() {
+    let ref r = req("=2.1.1-really.0");
+    assert_match_all(r, &["2.1.1-really.0"]);
+}
+
+#[test]
+pub fn test_parse_errors() {
+    let err = req_err("\0");
+    assert_to_string(
+        err,
+        "unexpected character '\\0' while parsing major version number",
+    );
+
+    let err = req_err(">= >= 0.0.2");
+    assert_to_string(
+        err,
+        "unexpected character '>' while parsing major version number",
+    );
+
+    let err = req_err(">== 0.0.2");
+    assert_to_string(
+        err,
+        "unexpected character '=' while parsing major version number",
+    );
+
+    let err = req_err("a.0.0");
+    assert_to_string(
+        err,
+        "unexpected character 'a' while parsing major version number",
+    );
+
+    let err = req_err("1.0.0-");
+    assert_to_string(err, "empty identifier segment in pre-release identifier");
+
+    let err = req_err(">=");
+    assert_to_string(
+        err,
+        "unexpected end of input while parsing major version number",
+    );
+}
+
+#[test]
+fn test_cargo3202() {
+    let ref r = req("0.*.*");
+    assert_to_string(r, "0.*");
+    assert_match_all(r, &["0.5.0"]);
+
+    let ref r = req("0.0.*");
+    assert_to_string(r, "0.0.*");
+}
+
+#[test]
+fn test_digit_after_wildcard() {
+    let err = req_err("*.1");
+    assert_to_string(err, "unexpected character after wildcard in version req");
+
+    let err = req_err("1.*.1");
+    assert_to_string(err, "unexpected character after wildcard in version req");
+
+    let err = req_err(">=1.*.1");
+    assert_to_string(err, "unexpected character after wildcard in version req");
+}
+
+#[test]
+fn test_eq_hash() {
+    fn calculate_hash(value: impl Hash) -> u64 {
+        let mut hasher = DefaultHasher::new();
+        value.hash(&mut hasher);
+        hasher.finish()
+    }
+
+    assert!(req("^1") == req("^1"));
+    assert!(calculate_hash(req("^1")) == calculate_hash(req("^1")));
+    assert!(req("^1") != req("^2"));
+}
+
+#[test]
+fn test_leading_digit_in_pre_and_build() {
+    for op in &["=", ">", ">=", "<", "<=", "~", "^"] {
+        // digit then alpha
+        req(&format!("{} 1.2.3-1a", op));
+        req(&format!("{} 1.2.3+1a", op));
+
+        // digit then alpha (leading zero)
+        req(&format!("{} 1.2.3-01a", op));
+        req(&format!("{} 1.2.3+01", op));
+
+        // multiple
+        req(&format!("{} 1.2.3-1+1", op));
+        req(&format!("{} 1.2.3-1-1+1-1-1", op));
+        req(&format!("{} 1.2.3-1a+1a", op));
+        req(&format!("{} 1.2.3-1a-1a+1a-1a-1a", op));
+    }
+}
+
+#[test]
+fn test_wildcard_and_another() {
+    let err = req_err("*, 0.20.0-any");
+    assert_to_string(
+        err,
+        "wildcard req (*) must be the only comparator in the version req",
+    );
+
+    let err = req_err("0.20.0-any, *");
+    assert_to_string(
+        err,
+        "wildcard req (*) must be the only comparator in the version req",
+    );
+
+    let err = req_err("0.20.0-any, *, 1.0");
+    assert_to_string(
+        err,
+        "wildcard req (*) must be the only comparator in the version req",
+    );
+}
diff --git a/third_party/rust/semver/tests/util/mod.rs b/third_party/rust/semver/tests/util/mod.rs
new file mode 100644
index 000000000000..5cc142c484e5
--- /dev/null
+++ b/third_party/rust/semver/tests/util/mod.rs
@@ -0,0 +1,39 @@
+#![allow(dead_code)]
+
+use semver::{BuildMetadata, Error, Prerelease, Version, VersionReq};
+use std::fmt::Display;
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+pub(super) fn version(text: &str) -> Version {
+    Version::parse(text).unwrap()
+}
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+pub(super) fn version_err(text: &str) -> Error {
+    Version::parse(text).unwrap_err()
+}
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+pub(super) fn req(text: &str) -> VersionReq {
+    VersionReq::parse(text).unwrap()
+}
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+pub(super) fn req_err(text: &str) -> Error {
+    VersionReq::parse(text).unwrap_err()
+}
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+pub(super) fn prerelease(text: &str) -> Prerelease {
+    Prerelease::new(text).unwrap()
+}
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+pub(super) fn build_metadata(text: &str) -> BuildMetadata {
+    BuildMetadata::new(text).unwrap()
+}
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+pub(super) fn assert_to_string(value: impl Display, expected: &str) {
+    assert_eq!(value.to_string(), expected);
+}
-- 
2.37.1

