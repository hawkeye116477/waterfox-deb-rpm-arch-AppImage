From 250b60c9566dc5ea01cee69a2775d2255d4bab06 Mon Sep 17 00:00:00 2001
Date: Tue, 23 Aug 2022 19:18:28 +0200
Subject: [PATCH 2/2] Bug 1783784 - Update packed_simd_2 to 0.3.8.

---
 .cargo/config.in                              |   2 +-
 Cargo.lock                                    |  36 +-
 Cargo.toml                                    |   2 +-
 .../rust/packed_simd_2/.cargo-checksum.json   |   2 +-
 third_party/rust/packed_simd_2/Cargo.toml     |   5 +-
 third_party/rust/packed_simd_2/README.md      |   2 +-
 third_party/rust/packed_simd_2/build.rs       |   5 +
 third_party/rust/packed_simd_2/src/api.rs     |   4 +-
 third_party/rust/packed_simd_2/src/codegen.rs |  50 +-
 .../packed_simd_2/src/codegen/bit_manip.rs    |   4 +-
 .../rust/packed_simd_2/src/codegen/llvm.rs    |  98 +--
 .../rust/packed_simd_2/src/codegen/math.rs    |   2 +-
 .../packed_simd_2/src/codegen/math/float.rs   |  28 +-
 .../src/codegen/math/float/abs.rs             |   2 +-
 .../src/codegen/math/float/cos.rs             |   2 +-
 .../src/codegen/math/float/cos_pi.rs          |   2 +-
 .../src/codegen/math/float/exp.rs             |   2 +-
 .../src/codegen/math/float/ln.rs              |   2 +-
 .../src/codegen/math/float/mul_add.rs         |   2 +-
 .../src/codegen/math/float/mul_adde.rs        |   2 +-
 .../src/codegen/math/float/powf.rs            |   2 +-
 .../src/codegen/math/float/sin.rs             |   2 +-
 .../src/codegen/math/float/sin_cos_pi.rs      |   2 +-
 .../src/codegen/math/float/sin_pi.rs          |   2 +-
 .../src/codegen/math/float/sqrt.rs            |   2 +-
 .../src/codegen/math/float/sqrte.rs           |   2 +-
 .../src/codegen/pointer_sized_int.rs          |  24 +-
 .../packed_simd_2/src/codegen/reductions.rs   |   2 +-
 .../src/codegen/reductions/mask.rs            |   4 +-
 .../packed_simd_2/src/codegen/swap_bytes.rs   |   4 +-
 .../rust/packed_simd_2/src/codegen/vPtr.rs    |   2 +-
 third_party/rust/packed_simd_2/src/lib.rs     |   7 +-
 third_party/rust/packed_simd_2/src/testing.rs |   2 +-
 .../rustc_version-0.2.3/.cargo-checksum.json  |   1 +
 .../rust/rustc_version-0.2.3/Cargo.toml       |  26 +
 .../rust/rustc_version-0.2.3/LICENSE-APACHE   | 201 ++++++
 .../rust/rustc_version-0.2.3/LICENSE-MIT      |  25 +
 .../rust/rustc_version-0.2.3/README.md        |  75 ++
 .../src/errors.rs                             |   0
 .../rust/rustc_version-0.2.3/src/lib.rs       | 347 +++++++++
 .../rust/rustc_version/.cargo-checksum.json   |   2 +-
 third_party/rust/rustc_version/Cargo.toml     |  13 +-
 third_party/rust/rustc_version/README.md      |  16 +-
 third_party/rust/rustc_version/deny.toml      |   3 +
 third_party/rust/rustc_version/src/lib.rs     | 502 +++++++------
 third_party/rust/rustc_version/tests/all.rs   | 456 ++++++++++++
 .../rust/semver-0.9.0/.cargo-checksum.json    |   1 +
 third_party/rust/semver-0.9.0/Cargo.toml      |  45 ++
 third_party/rust/semver-0.9.0/LICENSE-APACHE  | 201 ++++++
 third_party/rust/semver-0.9.0/LICENSE-MIT     |  25 +
 third_party/rust/semver-0.9.0/README.md       | 103 +++
 third_party/rust/semver-0.9.0/src/lib.rs      | 182 +++++
 .../{semver => semver-0.9.0}/src/version.rs   |   0
 .../src/version_req.rs                        |   0
 .../tests/deprecation.rs                      |   0
 .../tests/regression.rs                       |   0
 .../{semver => semver-0.9.0}/tests/serde.rs   |   0
 third_party/rust/semver/.cargo-checksum.json  |   2 +-
 third_party/rust/semver/Cargo.toml            |  58 +-
 third_party/rust/semver/LICENSE-MIT           |   2 -
 third_party/rust/semver/README.md             | 135 ++--
 third_party/rust/semver/benches/parse.rs      |  24 +
 third_party/rust/semver/build.rs              |  73 ++
 third_party/rust/semver/src/backport.rs       |  51 ++
 third_party/rust/semver/src/display.rs        | 165 +++++
 third_party/rust/semver/src/error.rs          | 124 ++++
 third_party/rust/semver/src/eval.rs           | 181 +++++
 third_party/rust/semver/src/identifier.rs     | 400 +++++++++++
 third_party/rust/semver/src/impls.rs          | 156 ++++
 third_party/rust/semver/src/lib.rs            | 677 ++++++++++++++----
 third_party/rust/semver/src/parse.rs          | 405 +++++++++++
 third_party/rust/semver/src/serde.rs          | 109 +++
 third_party/rust/semver/tests/node/mod.rs     |  43 ++
 .../rust/semver/tests/test_autotrait.rs       |  12 +
 .../rust/semver/tests/test_identifier.rs      |  45 ++
 third_party/rust/semver/tests/test_version.rs | 241 +++++++
 .../rust/semver/tests/test_version_req.rs     | 443 ++++++++++++
 third_party/rust/semver/tests/util/mod.rs     |  39 +
 78 files changed, 5281 insertions(+), 639 deletions(-)
 create mode 100644 third_party/rust/rustc_version-0.2.3/.cargo-checksum.json
 create mode 100644 third_party/rust/rustc_version-0.2.3/Cargo.toml
 create mode 100644 third_party/rust/rustc_version-0.2.3/LICENSE-APACHE
 create mode 100644 third_party/rust/rustc_version-0.2.3/LICENSE-MIT
 create mode 100644 third_party/rust/rustc_version-0.2.3/README.md
 rename third_party/rust/{rustc_version => rustc_version-0.2.3}/src/errors.rs (100%)
 create mode 100644 third_party/rust/rustc_version-0.2.3/src/lib.rs
 create mode 100644 third_party/rust/rustc_version/deny.toml
 create mode 100644 third_party/rust/rustc_version/tests/all.rs
 create mode 100644 third_party/rust/semver-0.9.0/.cargo-checksum.json
 create mode 100644 third_party/rust/semver-0.9.0/Cargo.toml
 create mode 100644 third_party/rust/semver-0.9.0/LICENSE-APACHE
 create mode 100644 third_party/rust/semver-0.9.0/LICENSE-MIT
 create mode 100644 third_party/rust/semver-0.9.0/README.md
 create mode 100644 third_party/rust/semver-0.9.0/src/lib.rs
 rename third_party/rust/{semver => semver-0.9.0}/src/version.rs (100%)
 rename third_party/rust/{semver => semver-0.9.0}/src/version_req.rs (100%)
 rename third_party/rust/{semver => semver-0.9.0}/tests/deprecation.rs (100%)
 rename third_party/rust/{semver => semver-0.9.0}/tests/regression.rs (100%)
 rename third_party/rust/{semver => semver-0.9.0}/tests/serde.rs (100%)
 create mode 100644 third_party/rust/semver/benches/parse.rs
 create mode 100644 third_party/rust/semver/build.rs
 create mode 100644 third_party/rust/semver/src/backport.rs
 create mode 100644 third_party/rust/semver/src/display.rs
 create mode 100644 third_party/rust/semver/src/error.rs
 create mode 100644 third_party/rust/semver/src/eval.rs
 create mode 100644 third_party/rust/semver/src/identifier.rs
 create mode 100644 third_party/rust/semver/src/impls.rs
 create mode 100644 third_party/rust/semver/src/parse.rs
 create mode 100644 third_party/rust/semver/src/serde.rs
 create mode 100644 third_party/rust/semver/tests/node/mod.rs
 create mode 100644 third_party/rust/semver/tests/test_autotrait.rs
 create mode 100644 third_party/rust/semver/tests/test_identifier.rs
 create mode 100644 third_party/rust/semver/tests/test_version.rs
 create mode 100644 third_party/rust/semver/tests/test_version_req.rs
 create mode 100644 third_party/rust/semver/tests/util/mod.rs

diff --git a/.cargo/config.in b/.cargo/config.in
index dc8837051460..079038b7165a 100644
--- a/.cargo/config.in
+++ b/.cargo/config.in
@@ -65,7 +65,7 @@ rev = "746743227485a83123784df0c53227ab466612ed"
 [source."https://github.com/hsivonen/packed_simd"]
 git = "https://github.com/hsivonen/packed_simd"
 replace-with = "vendored-sources"
-rev = "c149d0a519bf878567c7630096737669ec2ff15f"
+rev = "90eebb82a107cbec1c8e406d9223819417e96de1"
 
 [source."https://github.com/hsivonen/chardetng_c"]
 git = "https://github.com/hsivonen/chardetng_c"
diff --git a/Cargo.lock b/Cargo.lock
index f22d010be310..cc7efd9b3b0b 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -486,7 +486,7 @@ version = "0.2.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "cc38c385bfd7e444464011bb24820f40dd1c76bcdfa1b78611cb7c2e5cafab75"
 dependencies = [
- "rustc_version",
+ "rustc_version 0.2.3",
 ]
 
 [[package]]
@@ -1033,7 +1033,7 @@ dependencies = [
  "pulse",
  "pulse-ffi",
  "ringbuf",
- "semver",
+ "semver 0.9.0",
 ]
 
 [[package]]
@@ -1969,7 +1969,7 @@ dependencies = [
  "rsdparsa_capi",
  "rusqlite",
  "rust_minidump_writer_linux",
- "rustc_version",
+ "rustc_version 0.2.3",
  "static_prefs",
  "storage",
  "unic-langid",
@@ -1987,7 +1987,7 @@ name = "gkrust_utils"
 version = "0.1.0"
 dependencies = [
  "nsstring",
- "semver",
+ "semver 0.9.0",
  "uuid",
 ]
 
@@ -3147,7 +3147,7 @@ version = "0.4.1"
 dependencies = [
  "regex",
  "rust-ini",
- "semver",
+ "semver 0.9.0",
 ]
 
 [[package]]
@@ -3541,10 +3541,11 @@ dependencies = [
 
 [[package]]
 name = "packed_simd_2"
-version = "0.3.7"
-source = "git+https://github.com/hsivonen/packed_simd?rev=c149d0a519bf878567c7630096737669ec2ff15f#c149d0a519bf878567c7630096737669ec2ff15f"
+version = "0.3.8"
+source = "git+https://github.com/hsivonen/packed_simd?rev=90eebb82a107cbec1c8e406d9223819417e96de1#90eebb82a107cbec1c8e406d9223819417e96de1"
 dependencies = [
  "cfg-if 1.0.0",
+ "rustc_version 0.4.0",
 ]
 
 [[package]]
@@ -3886,7 +3887,7 @@ name = "qcms"
 version = "0.2.0"
 dependencies = [
  "libc",
- "rustc_version",
+ "rustc_version 0.2.3",
 ]
 
 [[package]]
@@ -3980,7 +3981,7 @@ checksum = "beb71f708fe39b2c5e98076204c3cc094ee5a4c12c4cdb119a2b72dc34164f41"
 dependencies = [
  "bitflags",
  "cc",
- "rustc_version",
+ "rustc_version 0.2.3",
 ]
 
 [[package]]
@@ -4276,7 +4277,16 @@ version = "0.2.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a"
 dependencies = [
- "semver",
+ "semver 0.9.0",
+]
+
+[[package]]
+name = "rustc_version"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366"
+dependencies = [
+ "semver 1.0.13",
 ]
 
 [[package]]
@@ -4360,6 +4370,12 @@ dependencies = [
  "semver-parser",
 ]
 
+[[package]]
+name = "semver"
+version = "1.0.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "93f6841e709003d68bb2deee8c343572bf446003ec20a583e76f7b15cebf3711"
+
 [[package]]
 name = "semver-parser"
 version = "0.7.0"
diff --git a/Cargo.toml b/Cargo.toml
index cb7555a6b4ef..06d64f3778d7 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -78,7 +78,7 @@ opt-level = 2
 chardetng = { git = "https://github.com/hsivonen/chardetng", rev="302c995f91f44cf26e77dc4758ad56c3ff0153ad" }
 chardetng_c = { git = "https://github.com/hsivonen/chardetng_c", rev="ed8a4c6f900a90d4dbc1d64b856e61490a1c3570" }
 libudev-sys = { path = "dom/webauthn/libudev-sys" }
-packed_simd = { package = "packed_simd_2", git = "https://github.com/hsivonen/packed_simd", rev="c149d0a519bf878567c7630096737669ec2ff15f" }
+packed_simd = { package = "packed_simd_2", git = "https://github.com/hsivonen/packed_simd", rev="90eebb82a107cbec1c8e406d9223819417e96de1" }
 rlbox_lucet_sandbox = { git = "https://github.com/PLSysSec/rlbox_lucet_sandbox/", rev="5c8e79048d3ff6f434109e19d4aee4ff8624d3d7" }
 nix = { git = "https://github.com/shravanrn/nix/", rev="4af6c367603869a30fddb5ffb0aba2b9477ba92e" }
 spirv_cross = { git = "https://github.com/kvark/spirv_cross", branch = "wgpu5" }
diff --git a/third_party/rust/packed_simd_2/.cargo-checksum.json b/third_party/rust/packed_simd_2/.cargo-checksum.json
index 3090b655a160..d61a3b677a32 100644
--- a/third_party/rust/packed_simd_2/.cargo-checksum.json
+++ b/third_party/rust/packed_simd_2/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{".appveyor.yml":"f1ed01850e0d725f9498f52a1a63ddf40702ad6e0bf5b2d7c4c04d76e96794a3",".travis.yml":"30a61a5ec53355fc1f3585e1690280308c2b7961701abc11e8389b235b647178","Cargo.toml":"f85e54e13a05f6e4f27c230ab81430af27b6ff80a1c036bd70c42ea115f89487","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"6485b8ed310d3f0340bf1ad1f47645069ce4069dcc6bb46c7d5c6faf41de1fdb","README.md":"882f8894b333becf490d23c9024a86fd1327c8edea33aa8dbb98dc2f2ddb3956","bors.toml":"dee881dc69b9b7834e4eba5d95c3ed5a416d4628815a167d6a22d4cb4fb064b8","build.rs":"019ed29c43989782d8eec3a961654cfc172d7a7898da4eca8f654700af7e1988","ci/all.sh":"2ae6b2445b4db83833e40b37efd0016c6b9879ee988b9b3ef94db5439a3e1606","ci/android-install-ndk.sh":"0f1746108cc30bf9b9ba45bcde7b19fc1a8bdf5b0258035b4eb8dc69b75efac4","ci/android-install-sdk.sh":"3490432022c5c8f5a115c084f7a9aca1626f96c0c87ffb62019228c4346b47e4","ci/android-sysimage.sh":"ebf4e5daa1f0fe1b2092b79f0f3f161c4c4275cb744e52352c4d81ab451e4c5a","ci/benchmark.sh":"b61d19ef6b90deba8fb79dee74c8b062d94844676293da346da87bb78a9a49a4","ci/deploy_and_run_on_ios_simulator.rs":"ec8ecf82d92072676aa47f0d1a3d021b60a7ae3531153ef12d2ff4541fc294dc","ci/docker/aarch64-linux-android/Dockerfile":"ace2e7d33c87bc0f6d3962a4a3408c04557646f7f51ab99cfbf574906796b016","ci/docker/aarch64-unknown-linux-gnu/Dockerfile":"da88c0d50f16dc08448c7fdf1fa5ed2cbe576acf9e7dd85b5b818621b2a8c702","ci/docker/arm-linux-androideabi/Dockerfile":"370e55d3330a413a3ccf677b3afb3e0ef9018a5fab263faa97ae8ac017fc2286","ci/docker/arm-unknown-linux-gnueabi/Dockerfile":"bb5f8ae890707c128652290ffc544447643bf12037ddd73c6ad6989f848cb380","ci/docker/arm-unknown-linux-gnueabihf/Dockerfile":"1afaefcbc05b740859acd4e067bc92439be6bcbe8f2e9678474fb434bcd398d9","ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile":"8282ea707a94109beed47a57574755e2d58401735904a03f85fb64c578c53b4f","ci/docker/i586-unknown-linux-gnu/Dockerfile":"49792922269f371bd29da4727e9085101b27be67a6b97755d0196c63317f7abb","ci/docker/i686-unknown-linux-gnu/Dockerfile":"49792922269f371bd29da4727e9085101b27be67a6b97755d0196c63317f7abb","ci/docker/mips-unknown-linux-gnu/Dockerfile":"b2ebc25797612c4f8395fe9d407725156044955bfbcf442036b7f55b43a5f9da","ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile":"b0c1692ac65bc56dd30494b1993d8e929c48cc9c4b92029b7c7592af6d4f9220","ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile":"4e9249c179300138141d0b2b7401b11897f64aed69f541f078c1db4594df2827","ci/docker/mipsel-unknown-linux-musl/Dockerfile":"3164c52b0dcbb01afa78292b15b5c43503ccf0491cf6eb801ec2bf22ae274e52","ci/docker/powerpc-unknown-linux-gnu/Dockerfile":"786f799d0b56eb54d7b6c4b00e1aed4ce81776e14e44767e083c89d014b72004","ci/docker/powerpc64-unknown-linux-gnu/Dockerfile":"e8bc363837cd9c2d8b22402acb8c1c329efc11ba5d12170603d2fe2eae9da059","ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile":"47998d45b781d797b9e6085ebe898d90de0c952b54537a8db4e8d7503eb032d9","ci/docker/s390x-unknown-linux-gnu/Dockerfile":"93fb44df3d7fd31ead158570667c97b5076a05c3d968af4a84bc13819a8f2db8","ci/docker/sparc64-unknown-linux-gnu/Dockerfile":"da1c39a3ff1fe22e41395fa7c8934e90b4c1788e551b9aec6e38bfd94effc437","ci/docker/thumbv7neon-linux-androideabi/Dockerfile":"c2decd5591bd7a09378901bef629cd944acf052eb55e4f35b79eb9cb4d62246a","ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile":"51955a8bf3c4d440f47382af6f5426ebff94ab01a04da36175babda9a057740f","ci/docker/wasm32-unknown-unknown/Dockerfile":"5a022299f56730cf8c432a07391e95e199cfa36dc8da2a96c9d185c8de93e913","ci/docker/x86_64-linux-android/Dockerfile":"685040273cf350d5509e580ac451555efa19790c8723ca2af066adadc6880ad2","ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile":"44b6203d9290bfdc53d81219f0937e1110847a23dd982ec8c4de388354f01536","ci/docker/x86_64-unknown-linux-gnu/Dockerfile":"7f4e3ca5fa288ea70edb4d1f75309708cd30b192e2e4444e61c4d5b3b58f89cf","ci/dox.sh":"434e9611c52e389312d2b03564adf09429f10cc76fe66a8644adb104903b87b7","ci/linux-s390x.sh":"d6b732d7795b4ba131326aff893bca6228a7d2eb0e9402f135705413dbbe0dce","ci/linux-sparc64.sh":"c92966838b1ab7ad3b7a344833ee726aba6b647cf5952e56f0ad1ba420b13325","ci/lld-shim.rs":"3d7f71ec23a49e2b67f694a0168786f9a954dda15f5a138815d966643fd3fcc3","ci/max_line_width.sh":"0a1518bba4c9ecaa55694cb2e9930d0e19c265baabf73143f17f9cf285aaa5bb","ci/run-docker.sh":"92e036390ad9b0d16f109579df1b5ced2e72e9afea40c7d011400ebd3a2a90de","ci/run.sh":"41dd6a60efaaeae9661a01370cce98b631f78392859a0cf68c946c0a16edf5f7","ci/run_examples.sh":"d1a23c6c35374a0678ba5114b9b8fefd8be0a79e774872a8bf0898d1baca18d0","ci/runtest-android.rs":"145a8e9799a5223975061fe7e586ade5669ee4877a7d7a4cf6b4ab48e8e36c7c","ci/setup_benchmarks.sh":"fae3960023f6f3d1388cd2ad22fdbab4b075f1f29dd4292d7994a20783beb6cf","ci/test-runner-linux":"c8aa6025cff5306f4f31d0c61dc5f9d4dd5a1d189ab613ef8d4c367c694d9ccd","contributing.md":"2d2629310ad4d464c482bdbb5819f0d6ce223c576aeef2cdce6a1f6857085ea5","perf-guide/.gitignore":"fe82c7da551079d832cf74200b0b359b4df9828cb4a0416fa7384f07a2ae6a13","perf-guide/book.toml":"115a98284126c6b180178b44713314cc494f08a71662ee2ce15cf67f17a51064","perf-guide/src/SUMMARY.md":"3e03bffc991fdc2050f3d51842d72d9d21ea6abab56a3baf3b2d5973a78b89e1","perf-guide/src/ascii.css":"29afb08833b2fe2250f0412e1fa1161a2432a0820a14953c87124407417c741a","perf-guide/src/bound_checks.md":"5e4991ff58a183ef0cd9fdc1feb4cd12d083b44bdf87393bbb0927808ef3ce7d","perf-guide/src/float-math/approx.md":"8c09032fa2d795a0c5db1775826c850d28eb2627846d0965c60ee72de63735ad","perf-guide/src/float-math/fma.md":"311076ba4b741d604a82e74b83a8d7e8c318fcbd7f64c4392d1cf5af95c60243","perf-guide/src/float-math/fp.md":"04153e775ab6e4f0d7837bcc515230d327b04edfa34c84ce9c9e10ebaeef2be8","perf-guide/src/float-math/svml.md":"0798873b8eedaeda5fed62dc91645b57c20775a02d3cd74d8bd06958f1516506","perf-guide/src/introduction.md":"9f5a19e9e6751f25d2daad39891a0cc600974527ec4c8305843f9618910671bd","perf-guide/src/prof/linux.md":"447731eb5de7d69166728fdbc5ecb0c0c9db678ea493b45a592d67dd002184c0","perf-guide/src/prof/mca.md":"f56d54f3d20e7aa4d32052186e8237b03d65971eb5d112802b442570ff11d344","perf-guide/src/prof/profiling.md":"8a650c0fd6ede0964789bb6577557eeef1d8226a896788602ce61528e260e43c","perf-guide/src/target-feature/attribute.md":"615f88dca0a707b6c416fa605435dd6e1fb5361cc639429cbf68cd87624bd78b","perf-guide/src/target-feature/features.md":"17077760ff24c006b606dd21889c53d87228f4311f3ba3a574f9afdeacd86165","perf-guide/src/target-feature/inlining.md":"7ed1d7068d8173a00d84c16cfe5871cd68b9f04f8d0cca2d01ebc84957ebf2f6","perf-guide/src/target-feature/practice.md":"c4b371842e0086df178488fec97f20def8f0c62ee588bcd25fd948b9b1fa227e","perf-guide/src/target-feature/runtime.md":"835425f5ee597fb3e51d36e725a81ebee29f4561231d19563cd4da81dbb1cfcb","perf-guide/src/target-feature/rustflags.md":"01197acf6f0adec8db32b8591811f69cecb6555a2b05dc5d5ec27d0e3f7b065e","perf-guide/src/vert-hor-ops.md":"c6211c0ee91e60552ec592d89d9d957eedc21dee3cbd89e1ad6765ea06a27471","rustfmt.toml":"d99a43f3f8ef9e425cf01c333fba9f0051f888f5d87ab4e8f63c2f7d0fe6620f","src/api.rs":"f6e92f056565e6fd93f98829a408aee9e790251e0cbd8a8bc30c8662b4d6fabb","src/api/bit_manip.rs":"c47a4d0f7451f7e35d07715e4f39a472e07457fd456fdb726864a4f6887252a3","src/api/bitmask.rs":"6d2beefd62ee5d9c8eb060bee6abc641616bf828c99f82abf97b21bf004e894b","src/api/cast.rs":"03b94a3d316ac7b7be7068810044911e965e889a0ace7bae762749ca74a92747","src/api/cast/macros.rs":"b0a14d0c83ad2ebb7a275180f6d9e3f2bc312ba57a7d3d6c39fad4e0f20f9408","src/api/cast/v128.rs":"edd0994efac4379dff26e178423a52dbb3ffeb38b1fc97cae975d744c00b4fb6","src/api/cast/v16.rs":"96bd98c2d21b0663abe6c0ab33005b1fa693f3db7ee6795351391343863484da","src/api/cast/v256.rs":"8c31fe91f5e78ef737dfba6979cc1240210cb094a89d284fe459bf8a991ca24b","src/api/cast/v32.rs":"a99a79dd84d2a5e6adf9db98705675915bd03fd1287d489c7fe38e84d7e4a086","src/api/cast/v512.rs":"c0dd526f41ed7b8a71c3743d91267554ec0a0c75834ccc2e3ecb0ef3004af642","src/api/cast/v64.rs":"6572fdba2a1241a6cd666d3f0cce3306cd2cb7e5e236172e59d5d4351c8a88af","src/api/cmp.rs":"357c3a2a09c6d4611c32dd7fa95be2fae933d513e229026ec9b44451a77b884e","src/api/cmp/eq.rs":"60f70f355bae4cb5b17db53204cacc3890f70670611c17df638d4c04f7cc8075","src/api/cmp/ord.rs":"589f7234761c294fa5df8f525bc4acd5a47cdb602207d524a0d4e19804cd9695","src/api/cmp/partial_eq.rs":"902ccb8aa01fd5738b30ba0b712669c21d4801958907e03bad23432c7dba0198","src/api/cmp/partial_ord.rs":"9db0c37d7434cdfc62d8d66912e972fa3d8c115ab2af051a6f45e414bd3e4f1c","src/api/cmp/vertical.rs":"de3d62f38eba817299aa16f1e1939954c9a447e316509397465c2830852ba053","src/api/default.rs":"67bf21c134127d12a7028c8b88a57f0ceee8ccbd74976da8ca74eb9f16a174d5","src/api/fmt.rs":"67fb804bb86b6cd77cf8cd492b5733ce437071b66fe3297278b8a6552c325dda","src/api/fmt/binary.rs":"02b2b287f7404f8a983813cf70c87108c8da3835578b63ab303116885f609413","src/api/fmt/debug.rs":"56e1c3bdc092747344fffaafff9da7163ee7827857f6fb7cb1c9923eca4f6fa0","src/api/fmt/lower_hex.rs":"558fd592f7f485712fb051509cecc7174a21e6bf62e5ce64766e75afc97bb8e1","src/api/fmt/octal.rs":"3b2e70877a4f368c7704f8e254236c014c365c74d93371c1feb5f030e6c66422","src/api/fmt/upper_hex.rs":"2a442f666bc80e22d41f903f881238fe114dd49344c3ed69849250e853cafc5d","src/api/from.rs":"2e599d8329cb05eaf06224cc441355c4b7b51254fc19256619333be8c149d444","src/api/from/from_array.rs":"dd3fc64fb17d6184bb60343f8da26a05edf0e5f3c14caf55d49fa15e21d948dc","src/api/from/from_vector.rs":"9764371aa9e6005aace74dea14f59e5611a095b7cf42707940924749282c52f0","src/api/hash.rs":"5076ece87969592c876486f5b1ea8affbeaec379d1a14a30859e0aa5592019de","src/api/into_bits.rs":"1ee15923352786b9ab4a31fa506762297116b18cfdb8e72853abc8ad001651d2","src/api/into_bits/arch_specific.rs":"e7445021f3908326bfee758835e5fc5ad56aa1baa77fc1c58abe4350c66c670a","src/api/into_bits/macros.rs":"bb4fe99be2af6a21d805efab44c8e4e61a7b2adb42a65504a0cf26d13efdadcd","src/api/into_bits/v128.rs":"145a44922b09a5ca5b62d88a461d327d399a997a15db4b11d7b17e554a9fa4c0","src/api/into_bits/v16.rs":"f4f4f61ba88aa51b158ec56ca3dce234349aea0daf2b3029a14ab5125d1e41e5","src/api/into_bits/v256.rs":"8cea9c5d9809f11323cb7cdc53b83df593fd17caf926251e412ae9777bed547f","src/api/into_bits/v32.rs":"905ba683d342fa32f4202b80bb46530807bd0a5b588f6c2e8c9f475223c47775","src/api/into_bits/v512.rs":"e25afa1fbf088a5d58e7d75d197b6cd4c56637ea28542ba18e46a451f29d04e7","src/api/into_bits/v64.rs":"d6238022ccff7b92e55b3f6017fc269acb6f36330a6d7e8fb389853a0f1b6478","src/api/math.rs":"8b2a2fc651917a850539f993aa0b9e5bf4da67b11685285b8de8cdca311719ec","src/api/math/float.rs":"61d2794d68262a1090ae473bd30793b5f65cf732f32a6694a3af2ce5d9225616","src/api/math/float/abs.rs":"5b6b2701e2e11135b7ce58a05052ea8120e10e4702c95d046b9d21b827b26bf8","src/api/math/float/consts.rs":"6302c9261da4291d144d5bb53493cdd073498feb40955fb6860ea3c4d06c978a","src/api/math/float/cos.rs":"4c2dd7173728ef189314f1576c9486e03be21b7da98843b2f9011282a7979e31","src/api/math/float/exp.rs":"7c6d5f1e304f498a01cfa23b92380c815d7da0ad94eae3483783bc377d287eef","src/api/math/float/ln.rs":"54c7583f3df793b39ff57534fade27b41bb992439e5dc178252f5ca3190a3e54","src/api/math/float/mul_add.rs":"62cac77660d20159276d4c9ef066eb90c81cbddb808e8e157182c607625ad2eb","src/api/math/float/mul_adde.rs":"bae056ee9f3a70df39ec3c3b2f6437c65303888a7b843ef1a5bcf1f5aca0e602","src/api/math/float/powf.rs":"9ddb938984b36d39d82a82f862f80df8f7fb013f1d222d45698d41d88472f568","src/api/math/float/recpre.rs":"589225794ff1dbf31158dff660e6d4509ecc8befbb57c633900dea5ac0b840d6","src/api/math/float/rsqrte.rs":"a32abdcc318d7ccc8448231f54d75b884b7cbeb03a7d595713ab6243036f4dbf","src/api/math/float/sin.rs":"cbd3622b7df74f19691743001c8cf747a201f8977ad90542fee915f37dcd1e49","src/api/math/float/sqrt.rs":"0c66d5d63fb08e4d99c6b82a8828e41173aff1ac9fa1a2764a11fac217ccf2ac","src/api/math/float/sqrte.rs":"731e1c9f321b662accdd27dacb3aac2e8043b7aecb2f2161dde733bd9f025362","src/api/minimal.rs":"1f22bcc528555444e76de569ec0ae2029b9ae9d04805efeafa93369c8098036b","src/api/minimal/iuf.rs":"819cff26d3e196f807645bcc1d79eb27d9f175edb89910f2274d52a1e913cd11","src/api/minimal/mask.rs":"0cae10ae1fc65f5070e686c0c79bfba27b86b33d6c399367bd4848fb367dcec4","src/api/minimal/ptr.rs":"f65ebf21866a863485344432d9a7a9b7418f7fad5fdf841a4e2fa56ec0766ad0","src/api/ops.rs":"3e273b277a0f3019d42c3c59ca94a5afd4885d5ae6d2182e5089bbeec9de42ee","src/api/ops/scalar_arithmetic.rs":"d2d5ad897a59dd0787544f927e0e7ca4072c3e58b0f4a2324083312b0d5a21d7","src/api/ops/scalar_bitwise.rs":"482204e459ca6be79568e1c9f70adbe2d2151412ddf122fb2161be8ebb51c40c","src/api/ops/scalar_mask_bitwise.rs":"c250f52042e37b22d57256c80d4604104cfd2fbe2a2e127c676267270ca5d350","src/api/ops/scalar_shifts.rs":"c4773d435c3f9da4454327e6fbb2b5b41a1c0ebb1cca7372e69dc7a344a1b6e4","src/api/ops/vector_arithmetic.rs":"ddca15d09ddeef502c2ed66117a62300ca65d87e959e8b622d767bdf1c307910","src/api/ops/vector_bitwise.rs":"b3968f7005b649edcc22a54e2379b14d5ee19045f2e784029805781ae043b5ee","src/api/ops/vector_float_min_max.rs":"76bf8cb607e2c442923c1da1061a6b80d742d607408033c2a3761161114cf2a0","src/api/ops/vector_int_min_max.rs":"a378789c6ff9b32a51fbd0a97ffd36ed102cd1fe6a067d2b02017c1df342def6","src/api/ops/vector_mask_bitwise.rs":"5052d18517d765415d40327e6e8e55a312daaca0a5e2aec959bfa54b1675f9c8","src/api/ops/vector_neg.rs":"5c62f6b0221983cdbd23cd0a3af3672e6ba1255f0dfe8b19aae6fbd6503e231b","src/api/ops/vector_rotates.rs":"ee319eaaa449dc50ea8ef05b89d38519c6faa6753dfdce432ea7bb8520e4e8e7","src/api/ops/vector_shifts.rs":"e510be14127c0ffd58a2573a39701da3557d66bedec09837ac8bbd44d579da00","src/api/ptr.rs":"8a793251bed6130dcfb2f1519ceaa18b751bbb15875928d0fb6deb5a5e07523a","src/api/ptr/gather_scatter.rs":"3d614f9d5b4ca201a9f7e46af4405e1d2c28ecee1620297c23b52e37b92cc0ea","src/api/reductions.rs":"ae5baca81352ecd44526d6c30c0a1feeda475ec73ddd3c3ec6b14e944e5448ee","src/api/reductions/bitwise.rs":"8bf910ae226188bd15fc7e125f058cd2566b6186fcd0cd8fd020f352c39ce139","src/api/reductions/float_arithmetic.rs":"47a5679896db2cbb56c31372fe42143da015b6beae7db5d2f3a0309ddf427ae1","src/api/reductions/integer_arithmetic.rs":"c2df3cf7493cca4174f2c65aea422a3d20d8a23af03f8d57cef72c19fee8f20d","src/api/reductions/mask.rs":"db83327a950e33a317f37fd33ca4e20c347fb415975ec024f3e23da8509425af","src/api/reductions/min_max.rs":"6af8c9aa45c69961b1b6fc205395f4767d4421869fb105fb3d563c5605fc13cd","src/api/select.rs":"6b07e7e8026df561f7307221a896f0fbb272536f41b9109040ac094c24c69331","src/api/shuffle.rs":"26458aec2557bfab41b7765f72aefbff3a7ee08cdc689981a81f133f58ee368b","src/api/shuffle1_dyn.rs":"bfea5a91905b31444e9ef7ca6eddb7a9606b7e22d3f71bb842eb2795a0346620","src/api/slice.rs":"ee87484e8af329547b9a5d4f2a69e8bed6ea10bbd96270d706083843d4eea2ac","src/api/slice/from_slice.rs":"9b6f01ace2d12ef45c84608bb7aad3a122e2cc319b2d99170fc332a568b8de63","src/api/slice/write_to_slice.rs":"244b6bd6ccffa6e5a195f8b1abc66d94251b6d16b2ec3fe4d76d32caec68261e","src/api/swap_bytes.rs":"4a6792a2e49a77475e1b237592b4b2804dbddb79c474331acd0dd71b36934259","src/codegen.rs":"a29d38fa0a85eaf787fb49989e625bf64effd5f39c126fbb2a24be206d2a3917","src/codegen/bit_manip.rs":"9991570a21ca98134b08b5c5935e2c259cea39c82d9d1529f52c561a84fec642","src/codegen/llvm.rs":"5bc6751293f9f184cf23d5df448c7d58b58b799e41c7a91f8ca41a5ba56e64ec","src/codegen/math.rs":"35f96e37a78fcf0cdb02146b7f27a45108fe06a37fc2a54d8851ce131a326178","src/codegen/math/float.rs":"dd86c0449e576c83b719700962ac017c332987fac08d91f2b7a2b1b883598170","src/codegen/math/float/abs.rs":"f56e2b4b8055ea861c1f5cbc6b6e1d8e7e5af163b62c13574ddee4e09513bfbc","src/codegen/math/float/cos.rs":"ef3b511a24d23045b310315e80348a9b7fedb576fc2de52d74290616a0abeb2a","src/codegen/math/float/cos_pi.rs":"4e7631a5d73dac21531e09ef1802d1180f8997509c2c8fa9f67f322194263a97","src/codegen/math/float/exp.rs":"61b691598c41b5622f24e4320c1bdd08701e612a516438bdddcc728fc3405c8c","src/codegen/math/float/ln.rs":"46b718b1ba8c9d99e1ad40f53d20dfde08a3063ca7bd2a9fdd6698e060da687e","src/codegen/math/float/macros.rs":"fc9924869ed85e4795983af228cacf23158f4f35919adce16c920ad4a3f0a009","src/codegen/math/float/mul_add.rs":"a37bf764345d4b1714f97e83897b7cf0855fc2811704bcbc0012db91825339e1","src/codegen/math/float/mul_adde.rs":"9aa6ed39825e61edb2522e002c59c9392d7c655c01af1cf8380ba22c8ddf69cd","src/codegen/math/float/powf.rs":"642346e982bc4c39203de0864d2149c4179cd7b21cf67a2951687932b4675872","src/codegen/math/float/sin.rs":"9d68164c90cdca6a85155040cdac42e27342ebe0b925273ef1593df721af4258","src/codegen/math/float/sin_cos_pi.rs":"e0c661d1d894fd4018723b9f3143ab6771c9405e41907cb1a7b9f9b380a97523","src/codegen/math/float/sin_pi.rs":"9890347905b4d4a3c7341c3eb06406e46e60582bcf6960688bd727e5dadc6c57","src/codegen/math/float/sqrt.rs":"e3c60dcfb0c6d2fc62adabcc931b2d4040b83cab294dea36443fb4b89eb79e34","src/codegen/math/float/sqrte.rs":"f0f4ef9eb475ae41bcc7ec6a95ad744ba6b36925faa8b2c2814004396d196b63","src/codegen/pointer_sized_int.rs":"a70697169c28218b56fd2e8d5353f2e00671d1150d0c8cef77d613bdfacd84cb","src/codegen/reductions.rs":"645e2514746d01387ddd07f0aa4ffd8430cc9ab428d4fb13773ea319fa25dd95","src/codegen/reductions/mask.rs":"dd68fd8bc5335fa2d0405e59dd1e9fff16fdf7651aa8db670ca86145fd5b5dda","src/codegen/reductions/mask/aarch64.rs":"84b101c17cad1ede4eb6d38cada0ac7da239dba8cea3badd3829b967e558431f","src/codegen/reductions/mask/arm.rs":"aaa07129bd078ae7e677cf8b8e67ec9f30536606a0c7ed1baaa18fd1793bb218","src/codegen/reductions/mask/fallback.rs":"3eb9319d2c7cf19216b607b8459612c4e027b643cf11b036937d36896bf76786","src/codegen/reductions/mask/fallback_impl.rs":"76547f396e55ef403327c77c314cf8db8c7a5c9b9819bfb925abeacf130249e5","src/codegen/reductions/mask/x86.rs":"36dcd8af4ab99730a078ed113d3955f74eb1a2876e2e6d9f224e0ff462c216d1","src/codegen/reductions/mask/x86/avx.rs":"3a40868b38c86e35aefb96d7578de6322efe89d8135e0366359b54ddd06f861a","src/codegen/reductions/mask/x86/avx2.rs":"677aed3f056285285daa3adff8bc65e739630b4424defa6d9665e160f027507e","src/codegen/reductions/mask/x86/sse.rs":"8522f6ed03f6c32dd577d4298df477c08aeaaa38563706f29096e1911ed731f2","src/codegen/reductions/mask/x86/sse2.rs":"54ec56e49b0c6841eccb719e4f310d65fe767c04136b2ec20bd8b9d7d9897b9e","src/codegen/shuffle.rs":"1ec2930f4e1acc43ac30b518af298d466a79e9e75734a51c380b7810efd1a27f","src/codegen/shuffle1_dyn.rs":"3f13ca1597378758d05106bf5ff3715eee531f3cb6d88f48b9182bd6c9386b51","src/codegen/swap_bytes.rs":"ac659780deb0c52daa9c73afb4ba8645c9fa35350cd897b23e567860492553b7","src/codegen/v128.rs":"94226b31ec403d18d9d2fe06713f147c9c79e9b5f9105089088266313f843185","src/codegen/v16.rs":"ddec4ffb66b6f7aaffb9a1780c5ddba82557abd74f45073d335047e04cf74924","src/codegen/v256.rs":"6b63917f0444118d6b1595bff2045e59b97c4d24012bd575f69f1f0efc5a0241","src/codegen/v32.rs":"3477b3c5540aed86e61e2f5807dd31db947413cec9181c587d93ed6ec74f0eba","src/codegen/v512.rs":"5854f99d3aabc4cd42b28a20d9ce447756dc2ba024a409a69b6a8ae1f1842fc5","src/codegen/v64.rs":"e9e89caebfe63d10c0cbca61e4dfdba3b7e02ee0989170f80beed23237ddd950","src/codegen/vPtr.rs":"711c753a08d53a2879c4fb87a0762c46ce4e34c22f0ca88d2e4c557a0f679969","src/codegen/vSize.rs":"c89f5fdeb28ac4c8272ed1816fce03d9d95308cc32bb2533bd8b20cd5ac102ac","src/lib.rs":"5efc09cb3d164e4e38b71fd4999afbfd234f5080dc84ce22fda2fc15d381e8c7","src/masks.rs":"70fc0abe4c2907ce2a491c574e1cfb9f3423385da2e1a923a48c9c13f8ba6ed8","src/sealed.rs":"ae7fdeaf5d84cd7710ed730ca72ca7eaba93df6cb0acb183e5c0a7327acf197f","src/testing.rs":"1d3a7862ef625e235a5734ad7204e68d350f902c0695182b1f08a0552432416e","src/testing/macros.rs":"403bbc5ecb7c786fe36156df302d0c07a8122408dbb15f7474d7682224ba1106","src/testing/utils.rs":"41912a92266dfe884647fc035e4242fd746100df8e839808ae0397af3759a3c8","src/v128.rs":"16cf9a8e7156b899ee9b9cd3f2dba9d13ec63289bea8c3ee9ae2e43ad9510288","src/v16.rs":"cb6465cf1e00bf530183af1819b9fe3d7eec978f8765d5e85d9b58a39a4b4045","src/v256.rs":"fe235017da18c7f3c361831c60e3173ad304d8ea1e95d64ebebc79da2d708511","src/v32.rs":"145d347855bac59b2de6508f9e594654e6c330423af9edc0e2ac8f4d1abdf45e","src/v512.rs":"f372f277f3e62eb5c945bb1c460333fdb17b6974fcc876633788ff53bded9599","src/v64.rs":"0b8079881b71575e3414be0b7f8f7eaba65281ba6732f2b2f61f73e95b6f48f7","src/vPtr.rs":"8b3e433d487180bb4304ff71245ecad90f0010f43e139a72027b672abe58facc","src/vSize.rs":"eda5aa020706cbf94d15bada41a0c2a35fc8f3f37cb7c2cd6f34d201399a495e","tests/endianness.rs":"2783d727e8ff8789211e03120634cd3ad9f8972fc484012681b5b63cf89408a7"},"package":null}
\ No newline at end of file
+{"files":{".appveyor.yml":"f1ed01850e0d725f9498f52a1a63ddf40702ad6e0bf5b2d7c4c04d76e96794a3",".travis.yml":"30a61a5ec53355fc1f3585e1690280308c2b7961701abc11e8389b235b647178","Cargo.toml":"2cab084b3d55d0b307788b02a6206a3ec39fee027535dc62d6421bce70e2e2c1","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"6485b8ed310d3f0340bf1ad1f47645069ce4069dcc6bb46c7d5c6faf41de1fdb","README.md":"fa4dd64f66972217d35b7653338c9e2011ccd8f3008ae7c0103272d4287f9b1d","bors.toml":"dee881dc69b9b7834e4eba5d95c3ed5a416d4628815a167d6a22d4cb4fb064b8","build.rs":"a766fba121243a9b617432c592873801adb74c3a2f4a24d9d45859b8ce9357fc","ci/all.sh":"2ae6b2445b4db83833e40b37efd0016c6b9879ee988b9b3ef94db5439a3e1606","ci/android-install-ndk.sh":"0f1746108cc30bf9b9ba45bcde7b19fc1a8bdf5b0258035b4eb8dc69b75efac4","ci/android-install-sdk.sh":"3490432022c5c8f5a115c084f7a9aca1626f96c0c87ffb62019228c4346b47e4","ci/android-sysimage.sh":"ebf4e5daa1f0fe1b2092b79f0f3f161c4c4275cb744e52352c4d81ab451e4c5a","ci/benchmark.sh":"b61d19ef6b90deba8fb79dee74c8b062d94844676293da346da87bb78a9a49a4","ci/deploy_and_run_on_ios_simulator.rs":"ec8ecf82d92072676aa47f0d1a3d021b60a7ae3531153ef12d2ff4541fc294dc","ci/docker/aarch64-linux-android/Dockerfile":"ace2e7d33c87bc0f6d3962a4a3408c04557646f7f51ab99cfbf574906796b016","ci/docker/aarch64-unknown-linux-gnu/Dockerfile":"da88c0d50f16dc08448c7fdf1fa5ed2cbe576acf9e7dd85b5b818621b2a8c702","ci/docker/arm-linux-androideabi/Dockerfile":"370e55d3330a413a3ccf677b3afb3e0ef9018a5fab263faa97ae8ac017fc2286","ci/docker/arm-unknown-linux-gnueabi/Dockerfile":"bb5f8ae890707c128652290ffc544447643bf12037ddd73c6ad6989f848cb380","ci/docker/arm-unknown-linux-gnueabihf/Dockerfile":"1afaefcbc05b740859acd4e067bc92439be6bcbe8f2e9678474fb434bcd398d9","ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile":"8282ea707a94109beed47a57574755e2d58401735904a03f85fb64c578c53b4f","ci/docker/i586-unknown-linux-gnu/Dockerfile":"49792922269f371bd29da4727e9085101b27be67a6b97755d0196c63317f7abb","ci/docker/i686-unknown-linux-gnu/Dockerfile":"49792922269f371bd29da4727e9085101b27be67a6b97755d0196c63317f7abb","ci/docker/mips-unknown-linux-gnu/Dockerfile":"b2ebc25797612c4f8395fe9d407725156044955bfbcf442036b7f55b43a5f9da","ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile":"b0c1692ac65bc56dd30494b1993d8e929c48cc9c4b92029b7c7592af6d4f9220","ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile":"4e9249c179300138141d0b2b7401b11897f64aed69f541f078c1db4594df2827","ci/docker/mipsel-unknown-linux-musl/Dockerfile":"3164c52b0dcbb01afa78292b15b5c43503ccf0491cf6eb801ec2bf22ae274e52","ci/docker/powerpc-unknown-linux-gnu/Dockerfile":"786f799d0b56eb54d7b6c4b00e1aed4ce81776e14e44767e083c89d014b72004","ci/docker/powerpc64-unknown-linux-gnu/Dockerfile":"e8bc363837cd9c2d8b22402acb8c1c329efc11ba5d12170603d2fe2eae9da059","ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile":"47998d45b781d797b9e6085ebe898d90de0c952b54537a8db4e8d7503eb032d9","ci/docker/s390x-unknown-linux-gnu/Dockerfile":"93fb44df3d7fd31ead158570667c97b5076a05c3d968af4a84bc13819a8f2db8","ci/docker/sparc64-unknown-linux-gnu/Dockerfile":"da1c39a3ff1fe22e41395fa7c8934e90b4c1788e551b9aec6e38bfd94effc437","ci/docker/thumbv7neon-linux-androideabi/Dockerfile":"c2decd5591bd7a09378901bef629cd944acf052eb55e4f35b79eb9cb4d62246a","ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile":"51955a8bf3c4d440f47382af6f5426ebff94ab01a04da36175babda9a057740f","ci/docker/wasm32-unknown-unknown/Dockerfile":"5a022299f56730cf8c432a07391e95e199cfa36dc8da2a96c9d185c8de93e913","ci/docker/x86_64-linux-android/Dockerfile":"685040273cf350d5509e580ac451555efa19790c8723ca2af066adadc6880ad2","ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile":"44b6203d9290bfdc53d81219f0937e1110847a23dd982ec8c4de388354f01536","ci/docker/x86_64-unknown-linux-gnu/Dockerfile":"7f4e3ca5fa288ea70edb4d1f75309708cd30b192e2e4444e61c4d5b3b58f89cf","ci/dox.sh":"434e9611c52e389312d2b03564adf09429f10cc76fe66a8644adb104903b87b7","ci/linux-s390x.sh":"d6b732d7795b4ba131326aff893bca6228a7d2eb0e9402f135705413dbbe0dce","ci/linux-sparc64.sh":"c92966838b1ab7ad3b7a344833ee726aba6b647cf5952e56f0ad1ba420b13325","ci/lld-shim.rs":"3d7f71ec23a49e2b67f694a0168786f9a954dda15f5a138815d966643fd3fcc3","ci/max_line_width.sh":"0a1518bba4c9ecaa55694cb2e9930d0e19c265baabf73143f17f9cf285aaa5bb","ci/run-docker.sh":"92e036390ad9b0d16f109579df1b5ced2e72e9afea40c7d011400ebd3a2a90de","ci/run.sh":"41dd6a60efaaeae9661a01370cce98b631f78392859a0cf68c946c0a16edf5f7","ci/run_examples.sh":"d1a23c6c35374a0678ba5114b9b8fefd8be0a79e774872a8bf0898d1baca18d0","ci/runtest-android.rs":"145a8e9799a5223975061fe7e586ade5669ee4877a7d7a4cf6b4ab48e8e36c7c","ci/setup_benchmarks.sh":"fae3960023f6f3d1388cd2ad22fdbab4b075f1f29dd4292d7994a20783beb6cf","ci/test-runner-linux":"c8aa6025cff5306f4f31d0c61dc5f9d4dd5a1d189ab613ef8d4c367c694d9ccd","contributing.md":"2d2629310ad4d464c482bdbb5819f0d6ce223c576aeef2cdce6a1f6857085ea5","perf-guide/.gitignore":"fe82c7da551079d832cf74200b0b359b4df9828cb4a0416fa7384f07a2ae6a13","perf-guide/book.toml":"115a98284126c6b180178b44713314cc494f08a71662ee2ce15cf67f17a51064","perf-guide/src/SUMMARY.md":"3e03bffc991fdc2050f3d51842d72d9d21ea6abab56a3baf3b2d5973a78b89e1","perf-guide/src/ascii.css":"29afb08833b2fe2250f0412e1fa1161a2432a0820a14953c87124407417c741a","perf-guide/src/bound_checks.md":"5e4991ff58a183ef0cd9fdc1feb4cd12d083b44bdf87393bbb0927808ef3ce7d","perf-guide/src/float-math/approx.md":"8c09032fa2d795a0c5db1775826c850d28eb2627846d0965c60ee72de63735ad","perf-guide/src/float-math/fma.md":"311076ba4b741d604a82e74b83a8d7e8c318fcbd7f64c4392d1cf5af95c60243","perf-guide/src/float-math/fp.md":"04153e775ab6e4f0d7837bcc515230d327b04edfa34c84ce9c9e10ebaeef2be8","perf-guide/src/float-math/svml.md":"0798873b8eedaeda5fed62dc91645b57c20775a02d3cd74d8bd06958f1516506","perf-guide/src/introduction.md":"9f5a19e9e6751f25d2daad39891a0cc600974527ec4c8305843f9618910671bd","perf-guide/src/prof/linux.md":"447731eb5de7d69166728fdbc5ecb0c0c9db678ea493b45a592d67dd002184c0","perf-guide/src/prof/mca.md":"f56d54f3d20e7aa4d32052186e8237b03d65971eb5d112802b442570ff11d344","perf-guide/src/prof/profiling.md":"8a650c0fd6ede0964789bb6577557eeef1d8226a896788602ce61528e260e43c","perf-guide/src/target-feature/attribute.md":"615f88dca0a707b6c416fa605435dd6e1fb5361cc639429cbf68cd87624bd78b","perf-guide/src/target-feature/features.md":"17077760ff24c006b606dd21889c53d87228f4311f3ba3a574f9afdeacd86165","perf-guide/src/target-feature/inlining.md":"7ed1d7068d8173a00d84c16cfe5871cd68b9f04f8d0cca2d01ebc84957ebf2f6","perf-guide/src/target-feature/practice.md":"c4b371842e0086df178488fec97f20def8f0c62ee588bcd25fd948b9b1fa227e","perf-guide/src/target-feature/runtime.md":"835425f5ee597fb3e51d36e725a81ebee29f4561231d19563cd4da81dbb1cfcb","perf-guide/src/target-feature/rustflags.md":"01197acf6f0adec8db32b8591811f69cecb6555a2b05dc5d5ec27d0e3f7b065e","perf-guide/src/vert-hor-ops.md":"c6211c0ee91e60552ec592d89d9d957eedc21dee3cbd89e1ad6765ea06a27471","rustfmt.toml":"d99a43f3f8ef9e425cf01c333fba9f0051f888f5d87ab4e8f63c2f7d0fe6620f","src/api.rs":"bb1795e9657a8298d37d2349b45443f08e9e455399ad4b727018600728478c10","src/api/bit_manip.rs":"c47a4d0f7451f7e35d07715e4f39a472e07457fd456fdb726864a4f6887252a3","src/api/bitmask.rs":"6d2beefd62ee5d9c8eb060bee6abc641616bf828c99f82abf97b21bf004e894b","src/api/cast.rs":"03b94a3d316ac7b7be7068810044911e965e889a0ace7bae762749ca74a92747","src/api/cast/macros.rs":"b0a14d0c83ad2ebb7a275180f6d9e3f2bc312ba57a7d3d6c39fad4e0f20f9408","src/api/cast/v128.rs":"edd0994efac4379dff26e178423a52dbb3ffeb38b1fc97cae975d744c00b4fb6","src/api/cast/v16.rs":"96bd98c2d21b0663abe6c0ab33005b1fa693f3db7ee6795351391343863484da","src/api/cast/v256.rs":"8c31fe91f5e78ef737dfba6979cc1240210cb094a89d284fe459bf8a991ca24b","src/api/cast/v32.rs":"a99a79dd84d2a5e6adf9db98705675915bd03fd1287d489c7fe38e84d7e4a086","src/api/cast/v512.rs":"c0dd526f41ed7b8a71c3743d91267554ec0a0c75834ccc2e3ecb0ef3004af642","src/api/cast/v64.rs":"6572fdba2a1241a6cd666d3f0cce3306cd2cb7e5e236172e59d5d4351c8a88af","src/api/cmp.rs":"357c3a2a09c6d4611c32dd7fa95be2fae933d513e229026ec9b44451a77b884e","src/api/cmp/eq.rs":"60f70f355bae4cb5b17db53204cacc3890f70670611c17df638d4c04f7cc8075","src/api/cmp/ord.rs":"589f7234761c294fa5df8f525bc4acd5a47cdb602207d524a0d4e19804cd9695","src/api/cmp/partial_eq.rs":"902ccb8aa01fd5738b30ba0b712669c21d4801958907e03bad23432c7dba0198","src/api/cmp/partial_ord.rs":"9db0c37d7434cdfc62d8d66912e972fa3d8c115ab2af051a6f45e414bd3e4f1c","src/api/cmp/vertical.rs":"de3d62f38eba817299aa16f1e1939954c9a447e316509397465c2830852ba053","src/api/default.rs":"67bf21c134127d12a7028c8b88a57f0ceee8ccbd74976da8ca74eb9f16a174d5","src/api/fmt.rs":"67fb804bb86b6cd77cf8cd492b5733ce437071b66fe3297278b8a6552c325dda","src/api/fmt/binary.rs":"02b2b287f7404f8a983813cf70c87108c8da3835578b63ab303116885f609413","src/api/fmt/debug.rs":"56e1c3bdc092747344fffaafff9da7163ee7827857f6fb7cb1c9923eca4f6fa0","src/api/fmt/lower_hex.rs":"558fd592f7f485712fb051509cecc7174a21e6bf62e5ce64766e75afc97bb8e1","src/api/fmt/octal.rs":"3b2e70877a4f368c7704f8e254236c014c365c74d93371c1feb5f030e6c66422","src/api/fmt/upper_hex.rs":"2a442f666bc80e22d41f903f881238fe114dd49344c3ed69849250e853cafc5d","src/api/from.rs":"2e599d8329cb05eaf06224cc441355c4b7b51254fc19256619333be8c149d444","src/api/from/from_array.rs":"dd3fc64fb17d6184bb60343f8da26a05edf0e5f3c14caf55d49fa15e21d948dc","src/api/from/from_vector.rs":"9764371aa9e6005aace74dea14f59e5611a095b7cf42707940924749282c52f0","src/api/hash.rs":"5076ece87969592c876486f5b1ea8affbeaec379d1a14a30859e0aa5592019de","src/api/into_bits.rs":"1ee15923352786b9ab4a31fa506762297116b18cfdb8e72853abc8ad001651d2","src/api/into_bits/arch_specific.rs":"e7445021f3908326bfee758835e5fc5ad56aa1baa77fc1c58abe4350c66c670a","src/api/into_bits/macros.rs":"bb4fe99be2af6a21d805efab44c8e4e61a7b2adb42a65504a0cf26d13efdadcd","src/api/into_bits/v128.rs":"145a44922b09a5ca5b62d88a461d327d399a997a15db4b11d7b17e554a9fa4c0","src/api/into_bits/v16.rs":"f4f4f61ba88aa51b158ec56ca3dce234349aea0daf2b3029a14ab5125d1e41e5","src/api/into_bits/v256.rs":"8cea9c5d9809f11323cb7cdc53b83df593fd17caf926251e412ae9777bed547f","src/api/into_bits/v32.rs":"905ba683d342fa32f4202b80bb46530807bd0a5b588f6c2e8c9f475223c47775","src/api/into_bits/v512.rs":"e25afa1fbf088a5d58e7d75d197b6cd4c56637ea28542ba18e46a451f29d04e7","src/api/into_bits/v64.rs":"d6238022ccff7b92e55b3f6017fc269acb6f36330a6d7e8fb389853a0f1b6478","src/api/math.rs":"8b2a2fc651917a850539f993aa0b9e5bf4da67b11685285b8de8cdca311719ec","src/api/math/float.rs":"61d2794d68262a1090ae473bd30793b5f65cf732f32a6694a3af2ce5d9225616","src/api/math/float/abs.rs":"5b6b2701e2e11135b7ce58a05052ea8120e10e4702c95d046b9d21b827b26bf8","src/api/math/float/consts.rs":"6302c9261da4291d144d5bb53493cdd073498feb40955fb6860ea3c4d06c978a","src/api/math/float/cos.rs":"4c2dd7173728ef189314f1576c9486e03be21b7da98843b2f9011282a7979e31","src/api/math/float/exp.rs":"7c6d5f1e304f498a01cfa23b92380c815d7da0ad94eae3483783bc377d287eef","src/api/math/float/ln.rs":"54c7583f3df793b39ff57534fade27b41bb992439e5dc178252f5ca3190a3e54","src/api/math/float/mul_add.rs":"62cac77660d20159276d4c9ef066eb90c81cbddb808e8e157182c607625ad2eb","src/api/math/float/mul_adde.rs":"bae056ee9f3a70df39ec3c3b2f6437c65303888a7b843ef1a5bcf1f5aca0e602","src/api/math/float/powf.rs":"9ddb938984b36d39d82a82f862f80df8f7fb013f1d222d45698d41d88472f568","src/api/math/float/recpre.rs":"589225794ff1dbf31158dff660e6d4509ecc8befbb57c633900dea5ac0b840d6","src/api/math/float/rsqrte.rs":"a32abdcc318d7ccc8448231f54d75b884b7cbeb03a7d595713ab6243036f4dbf","src/api/math/float/sin.rs":"cbd3622b7df74f19691743001c8cf747a201f8977ad90542fee915f37dcd1e49","src/api/math/float/sqrt.rs":"0c66d5d63fb08e4d99c6b82a8828e41173aff1ac9fa1a2764a11fac217ccf2ac","src/api/math/float/sqrte.rs":"731e1c9f321b662accdd27dacb3aac2e8043b7aecb2f2161dde733bd9f025362","src/api/minimal.rs":"1f22bcc528555444e76de569ec0ae2029b9ae9d04805efeafa93369c8098036b","src/api/minimal/iuf.rs":"819cff26d3e196f807645bcc1d79eb27d9f175edb89910f2274d52a1e913cd11","src/api/minimal/mask.rs":"0cae10ae1fc65f5070e686c0c79bfba27b86b33d6c399367bd4848fb367dcec4","src/api/minimal/ptr.rs":"f65ebf21866a863485344432d9a7a9b7418f7fad5fdf841a4e2fa56ec0766ad0","src/api/ops.rs":"3e273b277a0f3019d42c3c59ca94a5afd4885d5ae6d2182e5089bbeec9de42ee","src/api/ops/scalar_arithmetic.rs":"d2d5ad897a59dd0787544f927e0e7ca4072c3e58b0f4a2324083312b0d5a21d7","src/api/ops/scalar_bitwise.rs":"482204e459ca6be79568e1c9f70adbe2d2151412ddf122fb2161be8ebb51c40c","src/api/ops/scalar_mask_bitwise.rs":"c250f52042e37b22d57256c80d4604104cfd2fbe2a2e127c676267270ca5d350","src/api/ops/scalar_shifts.rs":"c4773d435c3f9da4454327e6fbb2b5b41a1c0ebb1cca7372e69dc7a344a1b6e4","src/api/ops/vector_arithmetic.rs":"ddca15d09ddeef502c2ed66117a62300ca65d87e959e8b622d767bdf1c307910","src/api/ops/vector_bitwise.rs":"b3968f7005b649edcc22a54e2379b14d5ee19045f2e784029805781ae043b5ee","src/api/ops/vector_float_min_max.rs":"76bf8cb607e2c442923c1da1061a6b80d742d607408033c2a3761161114cf2a0","src/api/ops/vector_int_min_max.rs":"a378789c6ff9b32a51fbd0a97ffd36ed102cd1fe6a067d2b02017c1df342def6","src/api/ops/vector_mask_bitwise.rs":"5052d18517d765415d40327e6e8e55a312daaca0a5e2aec959bfa54b1675f9c8","src/api/ops/vector_neg.rs":"5c62f6b0221983cdbd23cd0a3af3672e6ba1255f0dfe8b19aae6fbd6503e231b","src/api/ops/vector_rotates.rs":"ee319eaaa449dc50ea8ef05b89d38519c6faa6753dfdce432ea7bb8520e4e8e7","src/api/ops/vector_shifts.rs":"e510be14127c0ffd58a2573a39701da3557d66bedec09837ac8bbd44d579da00","src/api/ptr.rs":"8a793251bed6130dcfb2f1519ceaa18b751bbb15875928d0fb6deb5a5e07523a","src/api/ptr/gather_scatter.rs":"3d614f9d5b4ca201a9f7e46af4405e1d2c28ecee1620297c23b52e37b92cc0ea","src/api/reductions.rs":"ae5baca81352ecd44526d6c30c0a1feeda475ec73ddd3c3ec6b14e944e5448ee","src/api/reductions/bitwise.rs":"8bf910ae226188bd15fc7e125f058cd2566b6186fcd0cd8fd020f352c39ce139","src/api/reductions/float_arithmetic.rs":"47a5679896db2cbb56c31372fe42143da015b6beae7db5d2f3a0309ddf427ae1","src/api/reductions/integer_arithmetic.rs":"c2df3cf7493cca4174f2c65aea422a3d20d8a23af03f8d57cef72c19fee8f20d","src/api/reductions/mask.rs":"db83327a950e33a317f37fd33ca4e20c347fb415975ec024f3e23da8509425af","src/api/reductions/min_max.rs":"6af8c9aa45c69961b1b6fc205395f4767d4421869fb105fb3d563c5605fc13cd","src/api/select.rs":"6b07e7e8026df561f7307221a896f0fbb272536f41b9109040ac094c24c69331","src/api/shuffle.rs":"26458aec2557bfab41b7765f72aefbff3a7ee08cdc689981a81f133f58ee368b","src/api/shuffle1_dyn.rs":"bfea5a91905b31444e9ef7ca6eddb7a9606b7e22d3f71bb842eb2795a0346620","src/api/slice.rs":"ee87484e8af329547b9a5d4f2a69e8bed6ea10bbd96270d706083843d4eea2ac","src/api/slice/from_slice.rs":"9b6f01ace2d12ef45c84608bb7aad3a122e2cc319b2d99170fc332a568b8de63","src/api/slice/write_to_slice.rs":"244b6bd6ccffa6e5a195f8b1abc66d94251b6d16b2ec3fe4d76d32caec68261e","src/api/swap_bytes.rs":"4a6792a2e49a77475e1b237592b4b2804dbddb79c474331acd0dd71b36934259","src/codegen.rs":"db4f232fb9f5728db310b87dc8c4733be48afacab1053798c06106bef9a42b05","src/codegen/bit_manip.rs":"525ea6ff7ad1e043b6f6136992166f1803ed5563b7f6fc292c1c40257d20e264","src/codegen/llvm.rs":"b4ccbc0bad90038f00fc3c158736462d01d0053df3afa00f9169e67d1a264444","src/codegen/math.rs":"dfcf02ad34e2fdfe22c3f1cc2822001cc895e65031b4d06e585e5047839febb7","src/codegen/math/float.rs":"2c1cbce155bc527ce34d472c0fef6bc3dadb79cd7a357dd7aa5b1ebeb1d77a13","src/codegen/math/float/abs.rs":"d5aaadcf540bdb9b4264dca6471a255fd7bf509e763bef0239c0144a68466fea","src/codegen/math/float/cos.rs":"17f28d2900c852dca221fa9c92a9cd5fe7fd2df8d427bbc60216c749b2be013d","src/codegen/math/float/cos_pi.rs":"dbaf9f443f9846a491d4ec52210a7b5835dd593b03366e3135b05c37d70f9d6c","src/codegen/math/float/exp.rs":"d300058a4bcc7ae7976f216f81902cd73a9e603ad63880dff3bbc866c27a9f37","src/codegen/math/float/ln.rs":"c851e211e43f8256093ba75b03ae0c307c9962ee66d94f09b4dd80068190cbdf","src/codegen/math/float/macros.rs":"fc9924869ed85e4795983af228cacf23158f4f35919adce16c920ad4a3f0a009","src/codegen/math/float/mul_add.rs":"041a5b69d5991d93ef795351b17560c10faf80b78fd26ad7df42a239b32cf9de","src/codegen/math/float/mul_adde.rs":"d71d5f0f3333b62a7439b823cb7adf5340ea1555ce820fb4a3f4cb922f73f5f5","src/codegen/math/float/powf.rs":"9742c3877f1a5509ca5c9492a40884b6579ba6dd11c26b7112e63f70666b395d","src/codegen/math/float/sin.rs":"0e9868d35531566509f3a01d85d5253045eb4afa8525d8407dcc1f5f33c56036","src/codegen/math/float/sin_cos_pi.rs":"8e6b6142d7dd240cdb36669722e82ab9810a2261e86e659f7d97a942ad8b1258","src/codegen/math/float/sin_pi.rs":"bb6d39db8f921e03a301fc5206ac1a61a97def8a2cb83b87ccf189f3fc48d548","src/codegen/math/float/sqrt.rs":"e6ebb0c5f428efad1f672b9a8fe4e58534dbf1ea5a8fe092ce5ce76b52fe89cb","src/codegen/math/float/sqrte.rs":"23acfaea38d0e081a6d9021c1094e813d0cfd12c58c1eca9662aade5e625d51c","src/codegen/pointer_sized_int.rs":"6ca13c214b6cf7e0929dbe18e96a16fc0bb7d8799608df29c4c8115490f99e01","src/codegen/reductions.rs":"8eb18ebac76985d2aa30262a2edd8cb004230b511a765d657525f677a585c12c","src/codegen/reductions/mask.rs":"e67f35a1f4d156a4894a2d6ea5a935b4d898cf70eefb2715f5c1cc165e776c11","src/codegen/reductions/mask/aarch64.rs":"84b101c17cad1ede4eb6d38cada0ac7da239dba8cea3badd3829b967e558431f","src/codegen/reductions/mask/arm.rs":"aaa07129bd078ae7e677cf8b8e67ec9f30536606a0c7ed1baaa18fd1793bb218","src/codegen/reductions/mask/fallback.rs":"3eb9319d2c7cf19216b607b8459612c4e027b643cf11b036937d36896bf76786","src/codegen/reductions/mask/fallback_impl.rs":"76547f396e55ef403327c77c314cf8db8c7a5c9b9819bfb925abeacf130249e5","src/codegen/reductions/mask/x86.rs":"36dcd8af4ab99730a078ed113d3955f74eb1a2876e2e6d9f224e0ff462c216d1","src/codegen/reductions/mask/x86/avx.rs":"3a40868b38c86e35aefb96d7578de6322efe89d8135e0366359b54ddd06f861a","src/codegen/reductions/mask/x86/avx2.rs":"677aed3f056285285daa3adff8bc65e739630b4424defa6d9665e160f027507e","src/codegen/reductions/mask/x86/sse.rs":"8522f6ed03f6c32dd577d4298df477c08aeaaa38563706f29096e1911ed731f2","src/codegen/reductions/mask/x86/sse2.rs":"54ec56e49b0c6841eccb719e4f310d65fe767c04136b2ec20bd8b9d7d9897b9e","src/codegen/shuffle.rs":"1ec2930f4e1acc43ac30b518af298d466a79e9e75734a51c380b7810efd1a27f","src/codegen/shuffle1_dyn.rs":"3f13ca1597378758d05106bf5ff3715eee531f3cb6d88f48b9182bd6c9386b51","src/codegen/swap_bytes.rs":"c67c86e91ca3fc77539e0efcea081a3c62548cccf503963ae408f2e86f4e6a21","src/codegen/v128.rs":"94226b31ec403d18d9d2fe06713f147c9c79e9b5f9105089088266313f843185","src/codegen/v16.rs":"ddec4ffb66b6f7aaffb9a1780c5ddba82557abd74f45073d335047e04cf74924","src/codegen/v256.rs":"6b63917f0444118d6b1595bff2045e59b97c4d24012bd575f69f1f0efc5a0241","src/codegen/v32.rs":"3477b3c5540aed86e61e2f5807dd31db947413cec9181c587d93ed6ec74f0eba","src/codegen/v512.rs":"5854f99d3aabc4cd42b28a20d9ce447756dc2ba024a409a69b6a8ae1f1842fc5","src/codegen/v64.rs":"e9e89caebfe63d10c0cbca61e4dfdba3b7e02ee0989170f80beed23237ddd950","src/codegen/vPtr.rs":"f0753b405cdc865bdf8e82c6505f299ea1f96136239ebbaf7f9ce93d310764b8","src/codegen/vSize.rs":"c89f5fdeb28ac4c8272ed1816fce03d9d95308cc32bb2533bd8b20cd5ac102ac","src/lib.rs":"b6f846d5d30cf6b035a2d18039aba7b2045cf89384733d643572bd68873ae064","src/masks.rs":"70fc0abe4c2907ce2a491c574e1cfb9f3423385da2e1a923a48c9c13f8ba6ed8","src/sealed.rs":"ae7fdeaf5d84cd7710ed730ca72ca7eaba93df6cb0acb183e5c0a7327acf197f","src/testing.rs":"896669c08d8c801448a4d2fadc9d633eda0fbe879d229997e2a182e31278e469","src/testing/macros.rs":"403bbc5ecb7c786fe36156df302d0c07a8122408dbb15f7474d7682224ba1106","src/testing/utils.rs":"41912a92266dfe884647fc035e4242fd746100df8e839808ae0397af3759a3c8","src/v128.rs":"16cf9a8e7156b899ee9b9cd3f2dba9d13ec63289bea8c3ee9ae2e43ad9510288","src/v16.rs":"cb6465cf1e00bf530183af1819b9fe3d7eec978f8765d5e85d9b58a39a4b4045","src/v256.rs":"fe235017da18c7f3c361831c60e3173ad304d8ea1e95d64ebebc79da2d708511","src/v32.rs":"145d347855bac59b2de6508f9e594654e6c330423af9edc0e2ac8f4d1abdf45e","src/v512.rs":"f372f277f3e62eb5c945bb1c460333fdb17b6974fcc876633788ff53bded9599","src/v64.rs":"0b8079881b71575e3414be0b7f8f7eaba65281ba6732f2b2f61f73e95b6f48f7","src/vPtr.rs":"8b3e433d487180bb4304ff71245ecad90f0010f43e139a72027b672abe58facc","src/vSize.rs":"eda5aa020706cbf94d15bada41a0c2a35fc8f3f37cb7c2cd6f34d201399a495e","tests/endianness.rs":"2783d727e8ff8789211e03120634cd3ad9f8972fc484012681b5b63cf89408a7"},"package":null}
\ No newline at end of file
diff --git a/third_party/rust/packed_simd_2/Cargo.toml b/third_party/rust/packed_simd_2/Cargo.toml
index f38706d05002..d3d07ef9ae97 100644
--- a/third_party/rust/packed_simd_2/Cargo.toml
+++ b/third_party/rust/packed_simd_2/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "packed_simd_2"
-version = "0.3.7"
+version = "0.3.8"
 description = "Portable Packed SIMD vectors"
 documentation = "https://docs.rs/crate/packed_simd/"
 homepage = "https://github.com/rust-lang/packed_simd"
@@ -23,6 +23,9 @@ maintenance = { status = "experimental" }
 cfg-if = "1.0.0"
 core_arch = { version = "0.1.5", optional = true }
 
+[build-dependencies]
+rustc_version = "0.4"
+
 [features]
 default = []
 into_bits = []
diff --git a/third_party/rust/packed_simd_2/README.md b/third_party/rust/packed_simd_2/README.md
index 41a1512d79fb..eb3101c33d15 100644
--- a/third_party/rust/packed_simd_2/README.md
+++ b/third_party/rust/packed_simd_2/README.md
@@ -8,7 +8,7 @@ If you need to continue to use the crate, we have published a "next version" und
 
 Adjust your `[dependencies]` section of `Cargo.toml` to be the following:
 ```toml
-packed_simd = { version = "0.3.6", package = "packed_simd_2" }
+packed_simd = { version = "0.3.8", package = "packed_simd_2" }
 ```
 
 # `Simd<[T; N]>`
diff --git a/third_party/rust/packed_simd_2/build.rs b/third_party/rust/packed_simd_2/build.rs
index e87298a2de23..afdee9f55b62 100644
--- a/third_party/rust/packed_simd_2/build.rs
+++ b/third_party/rust/packed_simd_2/build.rs
@@ -1,6 +1,11 @@
+use rustc_version::{version, Version};
+
 fn main() {
     let target = std::env::var("TARGET").expect("TARGET environment variable not defined");
     if target.contains("neon") {
         println!("cargo:rustc-cfg=libcore_neon");
     }
+    if version().unwrap() < Version::parse("1.61.0-alpha").unwrap() {
+        println!("cargo:rustc-cfg=aarch64_target_feature");
+    }
 }
diff --git a/third_party/rust/packed_simd_2/src/api.rs b/third_party/rust/packed_simd_2/src/api.rs
index 4e9c4292e06c..aa1403e6e243 100644
--- a/third_party/rust/packed_simd_2/src/api.rs
+++ b/third_party/rust/packed_simd_2/src/api.rs
@@ -2,7 +2,7 @@
 
 #[macro_use]
 mod bitmask;
-crate mod cast;
+pub(crate) mod cast;
 #[macro_use]
 mod cmp;
 #[macro_use]
@@ -37,7 +37,7 @@ mod swap_bytes;
 mod bit_manip;
 
 #[cfg(feature = "into_bits")]
-crate mod into_bits;
+pub(crate) mod into_bits;
 
 macro_rules! impl_i {
     ([$elem_ty:ident; $elem_n:expr]: $tuple_id:ident, $mask_ty:ident
diff --git a/third_party/rust/packed_simd_2/src/codegen.rs b/third_party/rust/packed_simd_2/src/codegen.rs
index 9d1517e203d1..8a9e971486d7 100644
--- a/third_party/rust/packed_simd_2/src/codegen.rs
+++ b/third_party/rust/packed_simd_2/src/codegen.rs
@@ -1,19 +1,19 @@
 //! Code-generation utilities
 
-crate mod bit_manip;
-crate mod llvm;
-crate mod math;
-crate mod reductions;
-crate mod shuffle;
-crate mod shuffle1_dyn;
-crate mod swap_bytes;
+pub(crate) mod bit_manip;
+pub(crate) mod llvm;
+pub(crate) mod math;
+pub(crate) mod reductions;
+pub(crate) mod shuffle;
+pub(crate) mod shuffle1_dyn;
+pub(crate) mod swap_bytes;
 
 macro_rules! impl_simd_array {
     ([$elem_ty:ident; $elem_count:expr]:
      $tuple_id:ident | $($elem_tys:ident),*) => {
         #[derive(Copy, Clone)]
         #[repr(simd)]
-        pub struct $tuple_id($(crate $elem_tys),*);
+        pub struct $tuple_id($(pub(crate) $elem_tys),*);
         //^^^^^^^ leaked through SimdArray
 
         impl crate::sealed::Seal for [$elem_ty; $elem_count] {}
@@ -35,28 +35,28 @@ macro_rules! impl_simd_array {
     }
 }
 
-crate mod pointer_sized_int;
+pub(crate) mod pointer_sized_int;
 
-crate mod v16;
-crate use self::v16::*;
+pub(crate) mod v16;
+pub(crate) use self::v16::*;
 
-crate mod v32;
-crate use self::v32::*;
+pub(crate) mod v32;
+pub(crate) use self::v32::*;
 
-crate mod v64;
-crate use self::v64::*;
+pub(crate) mod v64;
+pub(crate) use self::v64::*;
 
-crate mod v128;
-crate use self::v128::*;
+pub(crate) mod v128;
+pub(crate) use self::v128::*;
 
-crate mod v256;
-crate use self::v256::*;
+pub(crate) mod v256;
+pub(crate) use self::v256::*;
 
-crate mod v512;
-crate use self::v512::*;
+pub(crate) mod v512;
+pub(crate) use self::v512::*;
 
-crate mod vSize;
-crate use self::vSize::*;
+pub(crate) mod vSize;
+pub(crate) use self::vSize::*;
 
-crate mod vPtr;
-crate use self::vPtr::*;
+pub(crate) mod vPtr;
+pub(crate) use self::vPtr::*;
diff --git a/third_party/rust/packed_simd_2/src/codegen/bit_manip.rs b/third_party/rust/packed_simd_2/src/codegen/bit_manip.rs
index 5986916da438..32d8d717a076 100644
--- a/third_party/rust/packed_simd_2/src/codegen/bit_manip.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/bit_manip.rs
@@ -1,7 +1,7 @@
 //! LLVM bit manipulation intrinsics.
 #[rustfmt::skip]
 
-use crate::*;
+pub(crate) use crate::*;
 
 #[allow(improper_ctypes, dead_code)]
 extern "C" {
@@ -147,7 +147,7 @@ extern "C" {
     fn ctpop_u128x4(x: u128x4) -> u128x4;
 }
 
-crate trait BitManip {
+pub(crate) trait BitManip {
     fn ctpop(self) -> Self;
     fn ctlz(self) -> Self;
     fn cttz(self) -> Self;
diff --git a/third_party/rust/packed_simd_2/src/codegen/llvm.rs b/third_party/rust/packed_simd_2/src/codegen/llvm.rs
index 52b11a95b917..b4c09849bc4a 100644
--- a/third_party/rust/packed_simd_2/src/codegen/llvm.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/llvm.rs
@@ -76,53 +76,53 @@ where
 }
 
 extern "platform-intrinsic" {
-    crate fn simd_eq<T, U>(x: T, y: T) -> U;
-    crate fn simd_ne<T, U>(x: T, y: T) -> U;
-    crate fn simd_lt<T, U>(x: T, y: T) -> U;
-    crate fn simd_le<T, U>(x: T, y: T) -> U;
-    crate fn simd_gt<T, U>(x: T, y: T) -> U;
-    crate fn simd_ge<T, U>(x: T, y: T) -> U;
-
-    crate fn simd_insert<T, U>(x: T, idx: u32, val: U) -> T;
-    crate fn simd_extract<T, U>(x: T, idx: u32) -> U;
-
-    crate fn simd_cast<T, U>(x: T) -> U;
-
-    crate fn simd_add<T>(x: T, y: T) -> T;
-    crate fn simd_sub<T>(x: T, y: T) -> T;
-    crate fn simd_mul<T>(x: T, y: T) -> T;
-    crate fn simd_div<T>(x: T, y: T) -> T;
-    crate fn simd_rem<T>(x: T, y: T) -> T;
-    crate fn simd_shl<T>(x: T, y: T) -> T;
-    crate fn simd_shr<T>(x: T, y: T) -> T;
-    crate fn simd_and<T>(x: T, y: T) -> T;
-    crate fn simd_or<T>(x: T, y: T) -> T;
-    crate fn simd_xor<T>(x: T, y: T) -> T;
-
-    crate fn simd_reduce_add_unordered<T, U>(x: T) -> U;
-    crate fn simd_reduce_mul_unordered<T, U>(x: T) -> U;
-    crate fn simd_reduce_add_ordered<T, U>(x: T, acc: U) -> U;
-    crate fn simd_reduce_mul_ordered<T, U>(x: T, acc: U) -> U;
-    crate fn simd_reduce_min<T, U>(x: T) -> U;
-    crate fn simd_reduce_max<T, U>(x: T) -> U;
-    crate fn simd_reduce_min_nanless<T, U>(x: T) -> U;
-    crate fn simd_reduce_max_nanless<T, U>(x: T) -> U;
-    crate fn simd_reduce_and<T, U>(x: T) -> U;
-    crate fn simd_reduce_or<T, U>(x: T) -> U;
-    crate fn simd_reduce_xor<T, U>(x: T) -> U;
-    crate fn simd_reduce_all<T>(x: T) -> bool;
-    crate fn simd_reduce_any<T>(x: T) -> bool;
-
-    crate fn simd_select<M, T>(m: M, a: T, b: T) -> T;
-
-    crate fn simd_fmin<T>(a: T, b: T) -> T;
-    crate fn simd_fmax<T>(a: T, b: T) -> T;
-
-    crate fn simd_fsqrt<T>(a: T) -> T;
-    crate fn simd_fma<T>(a: T, b: T, c: T) -> T;
-
-    crate fn simd_gather<T, P, M>(value: T, pointers: P, mask: M) -> T;
-    crate fn simd_scatter<T, P, M>(value: T, pointers: P, mask: M);
-
-    crate fn simd_bitmask<T, U>(value: T) -> U;
+    pub(crate) fn simd_eq<T, U>(x: T, y: T) -> U;
+    pub(crate) fn simd_ne<T, U>(x: T, y: T) -> U;
+    pub(crate) fn simd_lt<T, U>(x: T, y: T) -> U;
+    pub(crate) fn simd_le<T, U>(x: T, y: T) -> U;
+    pub(crate) fn simd_gt<T, U>(x: T, y: T) -> U;
+    pub(crate) fn simd_ge<T, U>(x: T, y: T) -> U;
+
+    pub(crate) fn simd_insert<T, U>(x: T, idx: u32, val: U) -> T;
+    pub(crate) fn simd_extract<T, U>(x: T, idx: u32) -> U;
+
+    pub(crate) fn simd_cast<T, U>(x: T) -> U;
+
+    pub(crate) fn simd_add<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_sub<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_mul<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_div<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_rem<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_shl<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_shr<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_and<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_or<T>(x: T, y: T) -> T;
+    pub(crate) fn simd_xor<T>(x: T, y: T) -> T;
+
+    pub(crate) fn simd_reduce_add_unordered<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_mul_unordered<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_add_ordered<T, U>(x: T, acc: U) -> U;
+    pub(crate) fn simd_reduce_mul_ordered<T, U>(x: T, acc: U) -> U;
+    pub(crate) fn simd_reduce_min<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_max<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_min_nanless<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_max_nanless<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_and<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_or<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_xor<T, U>(x: T) -> U;
+    pub(crate) fn simd_reduce_all<T>(x: T) -> bool;
+    pub(crate) fn simd_reduce_any<T>(x: T) -> bool;
+
+    pub(crate) fn simd_select<M, T>(m: M, a: T, b: T) -> T;
+
+    pub(crate) fn simd_fmin<T>(a: T, b: T) -> T;
+    pub(crate) fn simd_fmax<T>(a: T, b: T) -> T;
+
+    pub(crate) fn simd_fsqrt<T>(a: T) -> T;
+    pub(crate) fn simd_fma<T>(a: T, b: T, c: T) -> T;
+
+    pub(crate) fn simd_gather<T, P, M>(value: T, pointers: P, mask: M) -> T;
+    pub(crate) fn simd_scatter<T, P, M>(value: T, pointers: P, mask: M);
+
+    pub(crate) fn simd_bitmask<T, U>(value: T) -> U;
 }
diff --git a/third_party/rust/packed_simd_2/src/codegen/math.rs b/third_party/rust/packed_simd_2/src/codegen/math.rs
index f3997c7f1135..9a0ea7a4e2d2 100644
--- a/third_party/rust/packed_simd_2/src/codegen/math.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math.rs
@@ -1,3 +1,3 @@
 //! Vertical math operations
 
-crate mod float;
+pub(crate) mod float;
diff --git a/third_party/rust/packed_simd_2/src/codegen/math/float.rs b/third_party/rust/packed_simd_2/src/codegen/math/float.rs
index 5e89bf6ae6b0..ffbf18bfe989 100644
--- a/third_party/rust/packed_simd_2/src/codegen/math/float.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float.rs
@@ -2,17 +2,17 @@
 #![allow(clippy::useless_transmute)]
 
 #[macro_use]
-crate mod macros;
-crate mod abs;
-crate mod cos;
-crate mod cos_pi;
-crate mod exp;
-crate mod ln;
-crate mod mul_add;
-crate mod mul_adde;
-crate mod powf;
-crate mod sin;
-crate mod sin_cos_pi;
-crate mod sin_pi;
-crate mod sqrt;
-crate mod sqrte;
+pub(crate) mod macros;
+pub(crate) mod abs;
+pub(crate) mod cos;
+pub(crate) mod cos_pi;
+pub(crate) mod exp;
+pub(crate) mod ln;
+pub(crate) mod mul_add;
+pub(crate) mod mul_adde;
+pub(crate) mod powf;
+pub(crate) mod sin;
+pub(crate) mod sin_cos_pi;
+pub(crate) mod sin_pi;
+pub(crate) mod sqrt;
+pub(crate) mod sqrte;
diff --git a/third_party/rust/packed_simd_2/src/codegen/math/float/abs.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/abs.rs
index bc4421f61de2..34aacc25be75 100644
--- a/third_party/rust/packed_simd_2/src/codegen/math/float/abs.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/abs.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait Abs {
+pub(crate) trait Abs {
     fn abs(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd_2/src/codegen/math/float/cos.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/cos.rs
index 50f6c16da255..dec390cb74d4 100644
--- a/third_party/rust/packed_simd_2/src/codegen/math/float/cos.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/cos.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait Cos {
+pub(crate) trait Cos {
     fn cos(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd_2/src/codegen/math/float/cos_pi.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/cos_pi.rs
index ebff5fd1c751..e283280ee44b 100644
--- a/third_party/rust/packed_simd_2/src/codegen/math/float/cos_pi.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/cos_pi.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait CosPi {
+pub(crate) trait CosPi {
     fn cos_pi(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd_2/src/codegen/math/float/exp.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/exp.rs
index 00d10e9fa644..a7b20580e3f1 100644
--- a/third_party/rust/packed_simd_2/src/codegen/math/float/exp.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/exp.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait Exp {
+pub(crate) trait Exp {
     fn exp(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd_2/src/codegen/math/float/ln.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/ln.rs
index 88a5a6c6c158..a5e38cb40d1e 100644
--- a/third_party/rust/packed_simd_2/src/codegen/math/float/ln.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/ln.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait Ln {
+pub(crate) trait Ln {
     fn ln(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd_2/src/codegen/math/float/mul_add.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/mul_add.rs
index f48a57dc46c6..d37f30fa8614 100644
--- a/third_party/rust/packed_simd_2/src/codegen/math/float/mul_add.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/mul_add.rs
@@ -4,7 +4,7 @@ use crate::*;
 
 // FIXME: 64-bit 1 element mul_add
 
-crate trait MulAdd {
+pub(crate) trait MulAdd {
     fn mul_add(self, y: Self, z: Self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd_2/src/codegen/math/float/mul_adde.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/mul_adde.rs
index b030c26ccf46..c0baeacec20b 100644
--- a/third_party/rust/packed_simd_2/src/codegen/math/float/mul_adde.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/mul_adde.rs
@@ -3,7 +3,7 @@ use crate::*;
 
 // FIXME: 64-bit 1 element mul_adde
 
-crate trait MulAddE {
+pub(crate) trait MulAddE {
     fn mul_adde(self, y: Self, z: Self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd_2/src/codegen/math/float/powf.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/powf.rs
index bc15067d73a3..89ca52e96d81 100644
--- a/third_party/rust/packed_simd_2/src/codegen/math/float/powf.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/powf.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait Powf {
+pub(crate) trait Powf {
     fn powf(self, x: Self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd_2/src/codegen/math/float/sin.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/sin.rs
index 7b014d07da8d..d881415909af 100644
--- a/third_party/rust/packed_simd_2/src/codegen/math/float/sin.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/sin.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait Sin {
+pub(crate) trait Sin {
     fn sin(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd_2/src/codegen/math/float/sin_cos_pi.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/sin_cos_pi.rs
index 75c2c2c5fbb0..b283d11111fd 100644
--- a/third_party/rust/packed_simd_2/src/codegen/math/float/sin_cos_pi.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/sin_cos_pi.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait SinCosPi: Sized {
+pub(crate) trait SinCosPi: Sized {
     type Output;
     fn sin_cos_pi(self) -> Self::Output;
 }
diff --git a/third_party/rust/packed_simd_2/src/codegen/math/float/sin_pi.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/sin_pi.rs
index 72df98c93c91..0c8f6bb12050 100644
--- a/third_party/rust/packed_simd_2/src/codegen/math/float/sin_pi.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/sin_pi.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait SinPi {
+pub(crate) trait SinPi {
     fn sin_pi(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd_2/src/codegen/math/float/sqrt.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/sqrt.rs
index 7ce31df62662..67bb0a2a9c59 100644
--- a/third_party/rust/packed_simd_2/src/codegen/math/float/sqrt.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/sqrt.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait Sqrt {
+pub(crate) trait Sqrt {
     fn sqrt(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd_2/src/codegen/math/float/sqrte.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/sqrte.rs
index c1e379c34241..58a1de1f400f 100644
--- a/third_party/rust/packed_simd_2/src/codegen/math/float/sqrte.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/sqrte.rs
@@ -6,7 +6,7 @@
 use crate::llvm::simd_fsqrt;
 use crate::*;
 
-crate trait Sqrte {
+pub(crate) trait Sqrte {
     fn sqrte(self) -> Self;
 }
 
diff --git a/third_party/rust/packed_simd_2/src/codegen/pointer_sized_int.rs b/third_party/rust/packed_simd_2/src/codegen/pointer_sized_int.rs
index 39f493d3b17f..55cbc297aaf5 100644
--- a/third_party/rust/packed_simd_2/src/codegen/pointer_sized_int.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/pointer_sized_int.rs
@@ -4,24 +4,24 @@ use cfg_if::cfg_if;
 
 cfg_if! {
     if #[cfg(target_pointer_width = "8")] {
-        crate type isize_ = i8;
-        crate type usize_ = u8;
+        pub(crate) type isize_ = i8;
+        pub(crate) type usize_ = u8;
     } else if #[cfg(target_pointer_width = "16")] {
-        crate type isize_ = i16;
-        crate type usize_ = u16;
+        pub(crate) type isize_ = i16;
+        pub(crate) type usize_ = u16;
     } else if #[cfg(target_pointer_width = "32")] {
-        crate type isize_ = i32;
-        crate type usize_ = u32;
+        pub(crate) type isize_ = i32;
+        pub(crate) type usize_ = u32;
 
     } else if #[cfg(target_pointer_width = "64")] {
-        crate type isize_ = i64;
-        crate type usize_ = u64;
+        pub(crate) type isize_ = i64;
+        pub(crate) type usize_ = u64;
     } else if #[cfg(target_pointer_width = "64")] {
-        crate type isize_ = i64;
-        crate type usize_ = u64;
+        pub(crate) type isize_ = i64;
+        pub(crate) type usize_ = u64;
     } else if #[cfg(target_pointer_width = "128")] {
-        crate type isize_ = i128;
-        crate type usize_ = u128;
+        pub(crate) type isize_ = i128;
+        pub(crate) type usize_ = u128;
     } else {
         compile_error!("unsupported target_pointer_width");
     }
diff --git a/third_party/rust/packed_simd_2/src/codegen/reductions.rs b/third_party/rust/packed_simd_2/src/codegen/reductions.rs
index 7be4f5fabbea..302ca6d88f33 100644
--- a/third_party/rust/packed_simd_2/src/codegen/reductions.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions.rs
@@ -1 +1 @@
-crate mod mask;
+pub(crate) mod mask;
diff --git a/third_party/rust/packed_simd_2/src/codegen/reductions/mask.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask.rs
index 0aec60969b86..a78bcc563267 100644
--- a/third_party/rust/packed_simd_2/src/codegen/reductions/mask.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask.rs
@@ -7,11 +7,11 @@
 
 use crate::*;
 
-crate trait All: crate::marker::Sized {
+pub(crate) trait All: crate::marker::Sized {
     unsafe fn all(self) -> bool;
 }
 
-crate trait Any: crate::marker::Sized {
+pub(crate) trait Any: crate::marker::Sized {
     unsafe fn any(self) -> bool;
 }
 
diff --git a/third_party/rust/packed_simd_2/src/codegen/swap_bytes.rs b/third_party/rust/packed_simd_2/src/codegen/swap_bytes.rs
index a4435e3c3535..9cf34a3e0401 100644
--- a/third_party/rust/packed_simd_2/src/codegen/swap_bytes.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/swap_bytes.rs
@@ -5,7 +5,7 @@
 
 use crate::*;
 
-crate trait SwapBytes {
+pub(crate) trait SwapBytes {
     fn swap_bytes(self) -> Self;
 }
 
@@ -15,7 +15,7 @@ macro_rules! impl_swap_bytes {
             impl SwapBytes for $id {
                 #[inline]
                 fn swap_bytes(self) -> Self {
-                    unsafe { shuffle!(self, [1, 0]) }
+                    shuffle!(self, [1, 0])
                 }
             }
         )+
diff --git a/third_party/rust/packed_simd_2/src/codegen/vPtr.rs b/third_party/rust/packed_simd_2/src/codegen/vPtr.rs
index cf4765538178..abd3aa877920 100644
--- a/third_party/rust/packed_simd_2/src/codegen/vPtr.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/vPtr.rs
@@ -5,7 +5,7 @@ macro_rules! impl_simd_ptr {
      | $($tys:ty),*) => {
         #[derive(Copy, Clone)]
         #[repr(simd)]
-        pub struct $tuple_id<$ty>($(crate $tys),*);
+        pub struct $tuple_id<$ty>($(pub(crate) $tys),*);
         //^^^^^^^ leaked through SimdArray
 
         impl<$ty> crate::sealed::Seal for [$ptr_ty; $elem_count] {}
diff --git a/third_party/rust/packed_simd_2/src/lib.rs b/third_party/rust/packed_simd_2/src/lib.rs
index 840bae38d6a3..cd8a86805dd5 100644
--- a/third_party/rust/packed_simd_2/src/lib.rs
+++ b/third_party/rust/packed_simd_2/src/lib.rs
@@ -217,14 +217,13 @@
     rustc_attrs,
     platform_intrinsics,
     stdsimd,
-    aarch64_target_feature,
     arm_target_feature,
     link_llvm_intrinsics,
     core_intrinsics,
     stmt_expr_attributes,
-    crate_visibility_modifier,
     custom_inner_attributes,
 )]
+#![cfg_attr(aarch64_target_feature, feature(aarch64_target_feature))]
 #![allow(non_camel_case_types, non_snake_case,
         // FIXME: these types are unsound in C FFI already
         // See https://github.com/rust-lang/rust/issues/53346
@@ -344,6 +343,6 @@ pub use self::codegen::llvm::{
     __shuffle_vector8,
 };
 
-crate mod llvm {
-    crate use crate::codegen::llvm::*;
+pub(crate) mod llvm {
+    pub(crate) use crate::codegen::llvm::*;
 }
diff --git a/third_party/rust/packed_simd_2/src/testing.rs b/third_party/rust/packed_simd_2/src/testing.rs
index fcbcf9e2ac8e..6320b2805556 100644
--- a/third_party/rust/packed_simd_2/src/testing.rs
+++ b/third_party/rust/packed_simd_2/src/testing.rs
@@ -5,4 +5,4 @@ mod macros;
 
 #[cfg(test)]
 #[macro_use]
-crate mod utils;
+pub(crate) mod utils;
diff --git a/third_party/rust/rustc_version-0.2.3/.cargo-checksum.json b/third_party/rust/rustc_version-0.2.3/.cargo-checksum.json
new file mode 100644
index 000000000000..f86fe1cf8b59
--- /dev/null
+++ b/third_party/rust/rustc_version-0.2.3/.cargo-checksum.json
@@ -0,0 +1 @@
+{"files":{"Cargo.toml":"80b9fb136c8c2945b4875b05b0f5a4b11e4722997e751f17d8d3f241d7c684db","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"c9a75f18b9ab2927829a208fc6aa2cf4e63b8420887ba29cdb265d6619ae82d5","README.md":"58bd14a1dfa1d828e6e99f35c3b7c2149d08e2d990d6ca93f92ab8ffb43275b7","src/errors.rs":"b28c2eeb1278fc3e8d68a64b177034faed67f6762335729d3a6d1e61be8fb034","src/lib.rs":"92a32673f77961724bc52b872781f06d22d166f06838c9582c5adae3c5214f51"},"package":"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a"}
\ No newline at end of file
diff --git a/third_party/rust/rustc_version-0.2.3/Cargo.toml b/third_party/rust/rustc_version-0.2.3/Cargo.toml
new file mode 100644
index 000000000000..3b252b85a26e
--- /dev/null
+++ b/third_party/rust/rustc_version-0.2.3/Cargo.toml
@@ -0,0 +1,26 @@
+# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
+#
+# When uploading crates to the registry Cargo will automatically
+# "normalize" Cargo.toml files for maximal compatibility
+# with all versions of Cargo and also rewrite `path` dependencies
+# to registry (e.g. crates.io) dependencies
+#
+# If you believe there's an error in this file please file an
+# issue against the rust-lang/cargo repository. If you're
+# editing this file be aware that the upstream Cargo.toml
+# will likely look very different (and much more reasonable)
+
+[package]
+name = "rustc_version"
+version = "0.2.3"
+authors = ["Marvin Löbel <loebel.marvin@gmail.com>"]
+description = "A library for querying the version of a installed rustc compiler"
+documentation = "https://docs.rs/rustc_version/"
+readme = "README.md"
+keywords = ["version", "rustc"]
+license = "MIT/Apache-2.0"
+repository = "https://github.com/Kimundi/rustc-version-rs"
+[dependencies.semver]
+version = "0.9"
+[badges.travis-ci]
+repository = "Kimundi/rustc-version-rs"
diff --git a/third_party/rust/rustc_version-0.2.3/LICENSE-APACHE b/third_party/rust/rustc_version-0.2.3/LICENSE-APACHE
new file mode 100644
index 000000000000..16fe87b06e80
--- /dev/null
+++ b/third_party/rust/rustc_version-0.2.3/LICENSE-APACHE
@@ -0,0 +1,201 @@
+                              Apache License
+                        Version 2.0, January 2004
+                     http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+   "License" shall mean the terms and conditions for use, reproduction,
+   and distribution as defined by Sections 1 through 9 of this document.
+
+   "Licensor" shall mean the copyright owner or entity authorized by
+   the copyright owner that is granting the License.
+
+   "Legal Entity" shall mean the union of the acting entity and all
+   other entities that control, are controlled by, or are under common
+   control with that entity. For the purposes of this definition,
+   "control" means (i) the power, direct or indirect, to cause the
+   direction or management of such entity, whether by contract or
+   otherwise, or (ii) ownership of fifty percent (50%) or more of the
+   outstanding shares, or (iii) beneficial ownership of such entity.
+
+   "You" (or "Your") shall mean an individual or Legal Entity
+   exercising permissions granted by this License.
+
+   "Source" form shall mean the preferred form for making modifications,
+   including but not limited to software source code, documentation
+   source, and configuration files.
+
+   "Object" form shall mean any form resulting from mechanical
+   transformation or translation of a Source form, including but
+   not limited to compiled object code, generated documentation,
+   and conversions to other media types.
+
+   "Work" shall mean the work of authorship, whether in Source or
+   Object form, made available under the License, as indicated by a
+   copyright notice that is included in or attached to the work
+   (an example is provided in the Appendix below).
+
+   "Derivative Works" shall mean any work, whether in Source or Object
+   form, that is based on (or derived from) the Work and for which the
+   editorial revisions, annotations, elaborations, or other modifications
+   represent, as a whole, an original work of authorship. For the purposes
+   of this License, Derivative Works shall not include works that remain
+   separable from, or merely link (or bind by name) to the interfaces of,
+   the Work and Derivative Works thereof.
+
+   "Contribution" shall mean any work of authorship, including
+   the original version of the Work and any modifications or additions
+   to that Work or Derivative Works thereof, that is intentionally
+   submitted to Licensor for inclusion in the Work by the copyright owner
+   or by an individual or Legal Entity authorized to submit on behalf of
+   the copyright owner. For the purposes of this definition, "submitted"
+   means any form of electronic, verbal, or written communication sent
+   to the Licensor or its representatives, including but not limited to
+   communication on electronic mailing lists, source code control systems,
+   and issue tracking systems that are managed by, or on behalf of, the
+   Licensor for the purpose of discussing and improving the Work, but
+   excluding communication that is conspicuously marked or otherwise
+   designated in writing by the copyright owner as "Not a Contribution."
+
+   "Contributor" shall mean Licensor and any individual or Legal Entity
+   on behalf of whom a Contribution has been received by Licensor and
+   subsequently incorporated within the Work.
+
+2. Grant of Copyright License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   copyright license to reproduce, prepare Derivative Works of,
+   publicly display, publicly perform, sublicense, and distribute the
+   Work and such Derivative Works in Source or Object form.
+
+3. Grant of Patent License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   (except as stated in this section) patent license to make, have made,
+   use, offer to sell, sell, import, and otherwise transfer the Work,
+   where such license applies only to those patent claims licensable
+   by such Contributor that are necessarily infringed by their
+   Contribution(s) alone or by combination of their Contribution(s)
+   with the Work to which such Contribution(s) was submitted. If You
+   institute patent litigation against any entity (including a
+   cross-claim or counterclaim in a lawsuit) alleging that the Work
+   or a Contribution incorporated within the Work constitutes direct
+   or contributory patent infringement, then any patent licenses
+   granted to You under this License for that Work shall terminate
+   as of the date such litigation is filed.
+
+4. Redistribution. You may reproduce and distribute copies of the
+   Work or Derivative Works thereof in any medium, with or without
+   modifications, and in Source or Object form, provided that You
+   meet the following conditions:
+
+   (a) You must give any other recipients of the Work or
+       Derivative Works a copy of this License; and
+
+   (b) You must cause any modified files to carry prominent notices
+       stating that You changed the files; and
+
+   (c) You must retain, in the Source form of any Derivative Works
+       that You distribute, all copyright, patent, trademark, and
+       attribution notices from the Source form of the Work,
+       excluding those notices that do not pertain to any part of
+       the Derivative Works; and
+
+   (d) If the Work includes a "NOTICE" text file as part of its
+       distribution, then any Derivative Works that You distribute must
+       include a readable copy of the attribution notices contained
+       within such NOTICE file, excluding those notices that do not
+       pertain to any part of the Derivative Works, in at least one
+       of the following places: within a NOTICE text file distributed
+       as part of the Derivative Works; within the Source form or
+       documentation, if provided along with the Derivative Works; or,
+       within a display generated by the Derivative Works, if and
+       wherever such third-party notices normally appear. The contents
+       of the NOTICE file are for informational purposes only and
+       do not modify the License. You may add Your own attribution
+       notices within Derivative Works that You distribute, alongside
+       or as an addendum to the NOTICE text from the Work, provided
+       that such additional attribution notices cannot be construed
+       as modifying the License.
+
+   You may add Your own copyright statement to Your modifications and
+   may provide additional or different license terms and conditions
+   for use, reproduction, or distribution of Your modifications, or
+   for any such Derivative Works as a whole, provided Your use,
+   reproduction, and distribution of the Work otherwise complies with
+   the conditions stated in this License.
+
+5. Submission of Contributions. Unless You explicitly state otherwise,
+   any Contribution intentionally submitted for inclusion in the Work
+   by You to the Licensor shall be under the terms and conditions of
+   this License, without any additional terms or conditions.
+   Notwithstanding the above, nothing herein shall supersede or modify
+   the terms of any separate license agreement you may have executed
+   with Licensor regarding such Contributions.
+
+6. Trademarks. This License does not grant permission to use the trade
+   names, trademarks, service marks, or product names of the Licensor,
+   except as required for reasonable and customary use in describing the
+   origin of the Work and reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty. Unless required by applicable law or
+   agreed to in writing, Licensor provides the Work (and each
+   Contributor provides its Contributions) on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+   implied, including, without limitation, any warranties or conditions
+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+   PARTICULAR PURPOSE. You are solely responsible for determining the
+   appropriateness of using or redistributing the Work and assume any
+   risks associated with Your exercise of permissions under this License.
+
+8. Limitation of Liability. In no event and under no legal theory,
+   whether in tort (including negligence), contract, or otherwise,
+   unless required by applicable law (such as deliberate and grossly
+   negligent acts) or agreed to in writing, shall any Contributor be
+   liable to You for damages, including any direct, indirect, special,
+   incidental, or consequential damages of any character arising as a
+   result of this License or out of the use or inability to use the
+   Work (including but not limited to damages for loss of goodwill,
+   work stoppage, computer failure or malfunction, or any and all
+   other commercial damages or losses), even if such Contributor
+   has been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability. While redistributing
+   the Work or Derivative Works thereof, You may choose to offer,
+   and charge a fee for, acceptance of support, warranty, indemnity,
+   or other liability obligations and/or rights consistent with this
+   License. However, in accepting such obligations, You may act only
+   on Your own behalf and on Your sole responsibility, not on behalf
+   of any other Contributor, and only if You agree to indemnify,
+   defend, and hold each Contributor harmless for any liability
+   incurred by, or claims asserted against, such Contributor by reason
+   of your accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
+
+APPENDIX: How to apply the Apache License to your work.
+
+   To apply the Apache License to your work, attach the following
+   boilerplate notice, with the fields enclosed by brackets "[]"
+   replaced with your own identifying information. (Don't include
+   the brackets!)  The text should be enclosed in the appropriate
+   comment syntax for the file format. We also recommend that a
+   file or class name and description of purpose be included on the
+   same "printed page" as the copyright notice for easier
+   identification within third-party archives.
+
+Copyright [yyyy] [name of copyright owner]
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+	http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/third_party/rust/rustc_version-0.2.3/LICENSE-MIT b/third_party/rust/rustc_version-0.2.3/LICENSE-MIT
new file mode 100644
index 000000000000..40b8817a47be
--- /dev/null
+++ b/third_party/rust/rustc_version-0.2.3/LICENSE-MIT
@@ -0,0 +1,25 @@
+Copyright (c) 2016 The Rust Project Developers
+
+Permission is hereby granted, free of charge, to any
+person obtaining a copy of this software and associated
+documentation files (the "Software"), to deal in the
+Software without restriction, including without
+limitation the rights to use, copy, modify, merge,
+publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software
+is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice
+shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
diff --git a/third_party/rust/rustc_version-0.2.3/README.md b/third_party/rust/rustc_version-0.2.3/README.md
new file mode 100644
index 000000000000..f491ca964d85
--- /dev/null
+++ b/third_party/rust/rustc_version-0.2.3/README.md
@@ -0,0 +1,75 @@
+rustc-version-rs
+==============
+
+A library for querying the version of a `rustc` compiler.
+
+This can be used by build scripts or other tools dealing with Rust sources
+to make decisions based on the version of the compiler.
+
+[![Travis-CI Status](https://travis-ci.org/Kimundi/rustc-version-rs.png?branch=master)](https://travis-ci.org/Kimundi/rustc-version-rs)
+
+# Getting Started
+
+[rustc-version-rs is available on crates.io](https://crates.io/crates/rustc_version).
+It is recommended to look there for the newest released version, as well as links to the newest builds of the docs.
+
+At the point of the last update of this README, the latest published version could be used like this:
+
+Add the following dependency to your Cargo manifest...
+
+```toml
+[build-dependencies]
+rustc_version = "0.2"
+```
+
+...and see the [docs](http://kimundi.github.io/rustc-version-rs/rustc_version/index.html) for how to use it.
+
+# Example
+
+```rust
+// This could be a cargo build script
+
+extern crate rustc_version;
+use rustc_version::{version, version_meta, Channel, Version};
+
+fn main() {
+    // Assert we haven't travelled back in time
+    assert!(version().unwrap().major >= 1);
+
+    // Set cfg flags depending on release channel
+    match version_meta().unwrap().channel {
+        Channel::Stable => {
+            println!("cargo:rustc-cfg=RUSTC_IS_STABLE");
+        }
+        Channel::Beta => {
+            println!("cargo:rustc-cfg=RUSTC_IS_BETA");
+        }
+        Channel::Nightly => {
+            println!("cargo:rustc-cfg=RUSTC_IS_NIGHTLY");
+        }
+        Channel::Dev => {
+            println!("cargo:rustc-cfg=RUSTC_IS_DEV");
+        }
+    }
+
+    // Check for a minimum version
+    if version().unwrap() >= Version::parse("1.4.0").unwrap() {
+        println!("cargo:rustc-cfg=compiler_has_important_bugfix");
+    }
+}
+```
+
+## License
+
+Licensed under either of
+
+ * Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE) or http://www.apache.org/licenses/LICENSE-2.0)
+ * MIT license ([LICENSE-MIT](LICENSE-MIT) or http://opensource.org/licenses/MIT)
+
+at your option.
+
+### Contribution
+
+Unless you explicitly state otherwise, any contribution intentionally submitted
+for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any
+additional terms or conditions.
diff --git a/third_party/rust/rustc_version/src/errors.rs b/third_party/rust/rustc_version-0.2.3/src/errors.rs
similarity index 100%
rename from third_party/rust/rustc_version/src/errors.rs
rename to third_party/rust/rustc_version-0.2.3/src/errors.rs
diff --git a/third_party/rust/rustc_version-0.2.3/src/lib.rs b/third_party/rust/rustc_version-0.2.3/src/lib.rs
new file mode 100644
index 000000000000..c03828898fba
--- /dev/null
+++ b/third_party/rust/rustc_version-0.2.3/src/lib.rs
@@ -0,0 +1,347 @@
+// Copyright 2016 rustc-version-rs developers
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+#![warn(missing_docs)]
+
+//! Simple library for getting the version information of a `rustc`
+//! compiler.
+//!
+//! This can be used by build scripts or other tools dealing with Rust sources
+//! to make decisions based on the version of the compiler.
+//!
+//! It calls `$RUSTC --version -v` and parses the output, falling
+//! back to `rustc` if `$RUSTC` is not set.
+//!
+//! # Example
+//!
+//! ```rust
+//! // This could be a cargo build script
+//!
+//! extern crate rustc_version;
+//! use rustc_version::{version, version_meta, Channel, Version};
+//!
+//! fn main() {
+//!     // Assert we haven't travelled back in time
+//!     assert!(version().unwrap().major >= 1);
+//!
+//!     // Set cfg flags depending on release channel
+//!     match version_meta().unwrap().channel {
+//!         Channel::Stable => {
+//!             println!("cargo:rustc-cfg=RUSTC_IS_STABLE");
+//!         }
+//!         Channel::Beta => {
+//!             println!("cargo:rustc-cfg=RUSTC_IS_BETA");
+//!         }
+//!         Channel::Nightly => {
+//!             println!("cargo:rustc-cfg=RUSTC_IS_NIGHTLY");
+//!         }
+//!         Channel::Dev => {
+//!             println!("cargo:rustc-cfg=RUSTC_IS_DEV");
+//!         }
+//!     }
+//!
+//!     // Check for a minimum version
+//!     if version().unwrap() >= Version::parse("1.4.0").unwrap() {
+//!         println!("cargo:rustc-cfg=compiler_has_important_bugfix");
+//!     }
+//! }
+//! ```
+
+extern crate semver;
+use semver::Identifier;
+use std::process::Command;
+use std::{env, str};
+use std::ffi::OsString;
+
+// Convenience re-export to allow version comparison without needing to add
+// semver crate.
+pub use semver::Version;
+
+mod errors;
+pub use errors::{Error, Result};
+
+/// Release channel of the compiler.
+#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
+pub enum Channel {
+    /// Development release channel
+    Dev,
+    /// Nightly release channel
+    Nightly,
+    /// Beta release channel
+    Beta,
+    /// Stable release channel
+    Stable,
+}
+
+/// Rustc version plus metada like git short hash and build date.
+#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
+pub struct VersionMeta {
+    /// Version of the compiler
+    pub semver: Version,
+
+    /// Git short hash of the build of the compiler
+    pub commit_hash: Option<String>,
+
+    /// Commit date of the compiler
+    pub commit_date: Option<String>,
+
+    /// Build date of the compiler; this was removed between Rust 1.0.0 and 1.1.0.
+    pub build_date: Option<String>,
+
+    /// Release channel of the compiler
+    pub channel: Channel,
+
+    /// Host target triple of the compiler
+    pub host: String,
+
+    /// Short version string of the compiler
+    pub short_version_string: String,
+}
+
+impl VersionMeta {
+    /// Returns the version metadata for `cmd`, which should be a `rustc` command.
+    pub fn for_command(cmd: Command) -> Result<VersionMeta> {
+        let mut cmd = cmd;
+
+        let out = cmd.arg("-vV").output().map_err(Error::CouldNotExecuteCommand)?;
+        let out = str::from_utf8(&out.stdout)?;
+
+        version_meta_for(out)
+    }
+}
+
+/// Returns the `rustc` SemVer version.
+pub fn version() -> Result<Version> {
+    Ok(version_meta()?.semver)
+}
+
+/// Returns the `rustc` SemVer version and additional metadata
+/// like the git short hash and build date.
+pub fn version_meta() -> Result<VersionMeta> {
+    let cmd = env::var_os("RUSTC").unwrap_or_else(|| OsString::from("rustc"));
+
+    VersionMeta::for_command(Command::new(cmd))
+}
+
+/// Parses a "rustc -vV" output string and returns
+/// the SemVer version and additional metadata
+/// like the git short hash and build date.
+pub fn version_meta_for(verbose_version_string: &str) -> Result<VersionMeta> {
+    let out: Vec<_> = verbose_version_string.lines().collect();
+
+    if !(out.len() >= 6 && out.len() <= 8) {
+        return Err(Error::UnexpectedVersionFormat);
+    }
+
+    let short_version_string = out[0];
+
+    fn expect_prefix<'a>(line: &'a str, prefix: &str) -> Result<&'a str> {
+        if line.starts_with(prefix) {
+            Ok(&line[prefix.len()..])
+        } else {
+            Err(Error::UnexpectedVersionFormat)
+        }
+    }
+
+    let commit_hash = match expect_prefix(out[2], "commit-hash: ")? {
+        "unknown" => None,
+        hash => Some(hash.to_owned()),
+    };
+
+    let commit_date = match expect_prefix(out[3], "commit-date: ")? {
+        "unknown" => None,
+        hash => Some(hash.to_owned()),
+    };
+
+    // Handle that the build date may or may not be present.
+    let mut idx = 4;
+    let mut build_date = None;
+    if out[idx].starts_with("build-date") {
+        build_date = match expect_prefix(out[idx], "build-date: ")? {
+            "unknown" => None,
+            s => Some(s.to_owned()),
+        };
+        idx += 1;
+    }
+
+    let host = expect_prefix(out[idx], "host: ")?;
+    idx += 1;
+    let release = expect_prefix(out[idx], "release: ")?;
+
+    let semver: Version = release.parse()?;
+
+    let channel = if semver.pre.is_empty() {
+        Channel::Stable
+    } else {
+        match semver.pre[0] {
+            Identifier::AlphaNumeric(ref s) if s == "dev" => Channel::Dev,
+            Identifier::AlphaNumeric(ref s) if s == "beta" => Channel::Beta,
+            Identifier::AlphaNumeric(ref s) if s == "nightly" => Channel::Nightly,
+            ref x => return Err(Error::UnknownPreReleaseTag(x.clone())),
+        }
+    };
+
+    Ok(VersionMeta {
+        semver: semver,
+        commit_hash: commit_hash,
+        commit_date: commit_date,
+        build_date: build_date,
+        channel: channel,
+        host: host.into(),
+        short_version_string: short_version_string.into(),
+    })
+}
+
+#[test]
+fn smoketest() {
+    let v = version().unwrap();
+    assert!(v.major >= 1);
+
+    let v = version_meta().unwrap();
+    assert!(v.semver.major >= 1);
+
+    assert!(version().unwrap() >= Version::parse("1.0.0").unwrap());
+}
+
+#[test]
+fn parse_unexpected() {
+    let res = version_meta_for(
+"rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)
+binary: rustc
+commit-hash: a59de37e99060162a2674e3ff45409ac73595c0e
+commit-date: 2015-05-13
+rust-birthday: 2015-05-14
+host: x86_64-unknown-linux-gnu
+release: 1.0.0");
+
+    assert!(match res {
+        Err(Error::UnexpectedVersionFormat) => true,
+        _ => false,
+    });
+
+}
+
+#[test]
+fn parse_1_0_0() {
+    let version = version_meta_for(
+"rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)
+binary: rustc
+commit-hash: a59de37e99060162a2674e3ff45409ac73595c0e
+commit-date: 2015-05-13
+build-date: 2015-05-14
+host: x86_64-unknown-linux-gnu
+release: 1.0.0").unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.0.0").unwrap());
+    assert_eq!(version.commit_hash, Some("a59de37e99060162a2674e3ff45409ac73595c0e".into()));
+    assert_eq!(version.commit_date, Some("2015-05-13".into()));
+    assert_eq!(version.build_date, Some("2015-05-14".into()));
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(version.short_version_string, "rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)");
+}
+
+
+#[test]
+fn parse_unknown() {
+    let version = version_meta_for(
+"rustc 1.3.0
+binary: rustc
+commit-hash: unknown
+commit-date: unknown
+host: x86_64-unknown-linux-gnu
+release: 1.3.0").unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.3.0").unwrap());
+    assert_eq!(version.commit_hash, None);
+    assert_eq!(version.commit_date, None);
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(version.short_version_string, "rustc 1.3.0");
+}
+
+#[test]
+fn parse_nightly() {
+    let version = version_meta_for(
+"rustc 1.5.0-nightly (65d5c0833 2015-09-29)
+binary: rustc
+commit-hash: 65d5c083377645a115c4ac23a620d3581b9562b6
+commit-date: 2015-09-29
+host: x86_64-unknown-linux-gnu
+release: 1.5.0-nightly").unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.5.0-nightly").unwrap());
+    assert_eq!(version.commit_hash, Some("65d5c083377645a115c4ac23a620d3581b9562b6".into()));
+    assert_eq!(version.commit_date, Some("2015-09-29".into()));
+    assert_eq!(version.channel, Channel::Nightly);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(version.short_version_string, "rustc 1.5.0-nightly (65d5c0833 2015-09-29)");
+}
+
+#[test]
+fn parse_stable() {
+    let version = version_meta_for(
+"rustc 1.3.0 (9a92aaf19 2015-09-15)
+binary: rustc
+commit-hash: 9a92aaf19a64603b02b4130fe52958cc12488900
+commit-date: 2015-09-15
+host: x86_64-unknown-linux-gnu
+release: 1.3.0").unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.3.0").unwrap());
+    assert_eq!(version.commit_hash, Some("9a92aaf19a64603b02b4130fe52958cc12488900".into()));
+    assert_eq!(version.commit_date, Some("2015-09-15".into()));
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(version.short_version_string, "rustc 1.3.0 (9a92aaf19 2015-09-15)");
+}
+
+#[test]
+fn parse_1_16_0_nightly() {
+    let version = version_meta_for(
+"rustc 1.16.0-nightly (5d994d8b7 2017-01-05)
+binary: rustc
+commit-hash: 5d994d8b7e482e87467d4a521911477bd8284ce3
+commit-date: 2017-01-05
+host: x86_64-unknown-linux-gnu
+release: 1.16.0-nightly
+LLVM version: 3.9").unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.16.0-nightly").unwrap());
+    assert_eq!(version.commit_hash, Some("5d994d8b7e482e87467d4a521911477bd8284ce3".into()));
+    assert_eq!(version.commit_date, Some("2017-01-05".into()));
+    assert_eq!(version.channel, Channel::Nightly);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(version.short_version_string, "rustc 1.16.0-nightly (5d994d8b7 2017-01-05)");
+}
+
+/*
+#[test]
+fn version_matches_replacement() {
+    let f = |s1: &str, s2: &str| {
+        let a = Version::parse(s1).unwrap();
+        let b = Version::parse(s2).unwrap();
+        println!("{} <= {} : {}", s1, s2, a <= b);
+    };
+
+    println!();
+
+    f("1.5.0",         "1.5.0");
+    f("1.5.0-nightly", "1.5.0");
+    f("1.5.0",         "1.5.0-nightly");
+    f("1.5.0-nightly", "1.5.0-nightly");
+
+    f("1.5.0",         "1.6.0");
+    f("1.5.0-nightly", "1.6.0");
+    f("1.5.0",         "1.6.0-nightly");
+    f("1.5.0-nightly", "1.6.0-nightly");
+
+    panic!();
+
+}
+*/
diff --git a/third_party/rust/rustc_version/.cargo-checksum.json b/third_party/rust/rustc_version/.cargo-checksum.json
index f86fe1cf8b59..496c646ce633 100644
--- a/third_party/rust/rustc_version/.cargo-checksum.json
+++ b/third_party/rust/rustc_version/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"Cargo.toml":"80b9fb136c8c2945b4875b05b0f5a4b11e4722997e751f17d8d3f241d7c684db","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"c9a75f18b9ab2927829a208fc6aa2cf4e63b8420887ba29cdb265d6619ae82d5","README.md":"58bd14a1dfa1d828e6e99f35c3b7c2149d08e2d990d6ca93f92ab8ffb43275b7","src/errors.rs":"b28c2eeb1278fc3e8d68a64b177034faed67f6762335729d3a6d1e61be8fb034","src/lib.rs":"92a32673f77961724bc52b872781f06d22d166f06838c9582c5adae3c5214f51"},"package":"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a"}
\ No newline at end of file
+{"files":{"Cargo.toml":"6a2e927f37b4897e75470e62face13eff0fe846c57f8fcfb98bcd5e0fe8ed0a2","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"c9a75f18b9ab2927829a208fc6aa2cf4e63b8420887ba29cdb265d6619ae82d5","README.md":"40f1138d4ddcfcfd0534429cea8dcbdcaf4a175aca1c26662f011f6e83d2fd7a","deny.toml":"22979f2da49546b27a5c892d5216bf74215987810a2d011b58870471883b9437","src/lib.rs":"bc18589948e3c04c3ffb491ffc3d4eccd8037c8e377d0bbae8aca2b21978b1de","tests/all.rs":"7b2969022feab85a948fafd331d9bb30d80357d01afaf7e0f723908e75f39e89"},"package":"bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366"}
\ No newline at end of file
diff --git a/third_party/rust/rustc_version/Cargo.toml b/third_party/rust/rustc_version/Cargo.toml
index 3b252b85a26e..c81ff85ceb7e 100644
--- a/third_party/rust/rustc_version/Cargo.toml
+++ b/third_party/rust/rustc_version/Cargo.toml
@@ -3,7 +3,7 @@
 # When uploading crates to the registry Cargo will automatically
 # "normalize" Cargo.toml files for maximal compatibility
 # with all versions of Cargo and also rewrite `path` dependencies
-# to registry (e.g. crates.io) dependencies
+# to registry (e.g., crates.io) dependencies
 #
 # If you believe there's an error in this file please file an
 # issue against the rust-lang/cargo repository. If you're
@@ -11,9 +11,10 @@
 # will likely look very different (and much more reasonable)
 
 [package]
+edition = "2018"
 name = "rustc_version"
-version = "0.2.3"
-authors = ["Marvin Löbel <loebel.marvin@gmail.com>"]
+version = "0.4.0"
+authors = ["Dirkjan Ochtman <dirkjan@ochtman.nl>", "Marvin Löbel <loebel.marvin@gmail.com>"]
 description = "A library for querying the version of a installed rustc compiler"
 documentation = "https://docs.rs/rustc_version/"
 readme = "README.md"
@@ -21,6 +22,6 @@ keywords = ["version", "rustc"]
 license = "MIT/Apache-2.0"
 repository = "https://github.com/Kimundi/rustc-version-rs"
 [dependencies.semver]
-version = "0.9"
-[badges.travis-ci]
-repository = "Kimundi/rustc-version-rs"
+version = "1.0"
+[dev-dependencies.doc-comment]
+version = "0.3"
diff --git a/third_party/rust/rustc_version/README.md b/third_party/rust/rustc_version/README.md
index f491ca964d85..e76ef950dfd2 100644
--- a/third_party/rust/rustc_version/README.md
+++ b/third_party/rust/rustc_version/README.md
@@ -1,12 +1,19 @@
 rustc-version-rs
-==============
+================
+
+[![Documentation](https://docs.rs/rustc_version/badge.svg)](https://docs.rs/rustc_version/)
+[![Crates.io](https://img.shields.io/crates/v/rustc_version.svg)](https://crates.io/crates/rustc_version)
+[![Build status](https://github.com/Kimundi/rustc-version-rs/workflows/CI/badge.svg)](https://github.com/Kimundi/rustc-version-rs/actions?query=workflow%3ACI)
 
 A library for querying the version of a `rustc` compiler.
 
 This can be used by build scripts or other tools dealing with Rust sources
-to make decisions based on the version of the compiler.
+to make decisions based on the version of the compiler. Current MSRV is 1.32.0.
+
+If this is of interest, also consider looking at these other crates:
 
-[![Travis-CI Status](https://travis-ci.org/Kimundi/rustc-version-rs.png?branch=master)](https://travis-ci.org/Kimundi/rustc-version-rs)
+* [autocfg](https://crates.io/crates/autocfg/), which helps with feature detection instead of depending on compiler versions
+* [rustversion](https://github.com/dtolnay/rustversion) provides a procedural macro with no other dependencies
 
 # Getting Started
 
@@ -22,14 +29,13 @@ Add the following dependency to your Cargo manifest...
 rustc_version = "0.2"
 ```
 
-...and see the [docs](http://kimundi.github.io/rustc-version-rs/rustc_version/index.html) for how to use it.
+... and see the [docs](https://docs.rs/rustc_version) for how to use it.
 
 # Example
 
 ```rust
 // This could be a cargo build script
 
-extern crate rustc_version;
 use rustc_version::{version, version_meta, Channel, Version};
 
 fn main() {
diff --git a/third_party/rust/rustc_version/deny.toml b/third_party/rust/rustc_version/deny.toml
new file mode 100644
index 000000000000..38c47a8dc665
--- /dev/null
+++ b/third_party/rust/rustc_version/deny.toml
@@ -0,0 +1,3 @@
+[licenses]
+allow-osi-fsf-free = "either"
+copyleft = "deny"
diff --git a/third_party/rust/rustc_version/src/lib.rs b/third_party/rust/rustc_version/src/lib.rs
index c03828898fba..cee1ec81431e 100644
--- a/third_party/rust/rustc_version/src/lib.rs
+++ b/third_party/rust/rustc_version/src/lib.rs
@@ -22,48 +22,50 @@
 //! ```rust
 //! // This could be a cargo build script
 //!
-//! extern crate rustc_version;
 //! use rustc_version::{version, version_meta, Channel, Version};
 //!
-//! fn main() {
-//!     // Assert we haven't travelled back in time
-//!     assert!(version().unwrap().major >= 1);
+//! // Assert we haven't travelled back in time
+//! assert!(version().unwrap().major >= 1);
 //!
-//!     // Set cfg flags depending on release channel
-//!     match version_meta().unwrap().channel {
-//!         Channel::Stable => {
-//!             println!("cargo:rustc-cfg=RUSTC_IS_STABLE");
-//!         }
-//!         Channel::Beta => {
-//!             println!("cargo:rustc-cfg=RUSTC_IS_BETA");
-//!         }
-//!         Channel::Nightly => {
-//!             println!("cargo:rustc-cfg=RUSTC_IS_NIGHTLY");
-//!         }
-//!         Channel::Dev => {
-//!             println!("cargo:rustc-cfg=RUSTC_IS_DEV");
-//!         }
+//! // Set cfg flags depending on release channel
+//! match version_meta().unwrap().channel {
+//!     Channel::Stable => {
+//!         println!("cargo:rustc-cfg=RUSTC_IS_STABLE");
 //!     }
-//!
-//!     // Check for a minimum version
-//!     if version().unwrap() >= Version::parse("1.4.0").unwrap() {
-//!         println!("cargo:rustc-cfg=compiler_has_important_bugfix");
+//!     Channel::Beta => {
+//!         println!("cargo:rustc-cfg=RUSTC_IS_BETA");
+//!     }
+//!     Channel::Nightly => {
+//!         println!("cargo:rustc-cfg=RUSTC_IS_NIGHTLY");
 //!     }
+//!     Channel::Dev => {
+//!         println!("cargo:rustc-cfg=RUSTC_IS_DEV");
+//!     }
+//! }
+//!
+//! // Check for a minimum version
+//! if version().unwrap() >= Version::parse("1.4.0").unwrap() {
+//!     println!("cargo:rustc-cfg=compiler_has_important_bugfix");
 //! }
 //! ```
 
-extern crate semver;
-use semver::Identifier;
+#[cfg(test)]
+#[macro_use]
+extern crate doc_comment;
+
+#[cfg(test)]
+doctest!("../README.md");
+
+use std::collections::HashMap;
 use std::process::Command;
-use std::{env, str};
-use std::ffi::OsString;
+use std::{env, error, fmt, io, num, str};
+use std::{ffi::OsString, str::FromStr};
 
 // Convenience re-export to allow version comparison without needing to add
 // semver crate.
 pub use semver::Version;
 
-mod errors;
-pub use errors::{Error, Result};
+use Error::*;
 
 /// Release channel of the compiler.
 #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
@@ -78,7 +80,70 @@ pub enum Channel {
     Stable,
 }
 
-/// Rustc version plus metada like git short hash and build date.
+/// LLVM version
+///
+/// LLVM's version numbering scheme is not semver compatible until version 4.0
+///
+/// rustc [just prints the major and minor versions], so other parts of the version are not included.
+///
+/// [just prints the major and minor versions]: https://github.com/rust-lang/rust/blob/b5c9e2448c9ace53ad5c11585803894651b18b0a/compiler/rustc_codegen_llvm/src/llvm_util.rs#L173-L178
+#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
+pub struct LlvmVersion {
+    // fields must be ordered major, minor for comparison to be correct
+    /// Major version
+    pub major: u64,
+    /// Minor version
+    pub minor: u64,
+    // TODO: expose micro version here
+}
+
+impl fmt::Display for LlvmVersion {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "{}.{}", self.major, self.minor)
+    }
+}
+
+impl FromStr for LlvmVersion {
+    type Err = LlvmVersionParseError;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        let mut parts = s
+            .split('.')
+            .map(|part| -> Result<u64, LlvmVersionParseError> {
+                if part == "0" {
+                    Ok(0)
+                } else if part.starts_with('0') {
+                    Err(LlvmVersionParseError::ComponentMustNotHaveLeadingZeros)
+                } else if part.starts_with('-') || part.starts_with('+') {
+                    Err(LlvmVersionParseError::ComponentMustNotHaveSign)
+                } else {
+                    Ok(part.parse()?)
+                }
+            });
+
+        let major = parts.next().unwrap()?;
+        let mut minor = 0;
+
+        if let Some(part) = parts.next() {
+            minor = part?;
+        } else if major < 4 {
+            // LLVM versions earlier than 4.0 have significant minor versions, so require the minor version in this case.
+            return Err(LlvmVersionParseError::MinorVersionRequiredBefore4);
+        }
+
+        if let Some(Err(e)) = parts.next() {
+            return Err(e);
+        }
+
+        if parts.next().is_some() {
+            return Err(LlvmVersionParseError::TooManyComponents);
+        }
+
+        Ok(Self { major, minor })
+    }
+}
+
+/// Rustc version plus metadata like git short hash and build date.
 #[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
 pub struct VersionMeta {
     /// Version of the compiler
@@ -101,17 +166,27 @@ pub struct VersionMeta {
 
     /// Short version string of the compiler
     pub short_version_string: String,
+
+    /// Version of LLVM used by the compiler
+    pub llvm_version: Option<LlvmVersion>,
 }
 
 impl VersionMeta {
     /// Returns the version metadata for `cmd`, which should be a `rustc` command.
-    pub fn for_command(cmd: Command) -> Result<VersionMeta> {
-        let mut cmd = cmd;
-
-        let out = cmd.arg("-vV").output().map_err(Error::CouldNotExecuteCommand)?;
-        let out = str::from_utf8(&out.stdout)?;
+    pub fn for_command(mut cmd: Command) -> Result<VersionMeta> {
+        let out = cmd
+            .arg("-vV")
+            .output()
+            .map_err(Error::CouldNotExecuteCommand)?;
+
+        if !out.status.success() {
+            return Err(Error::CommandError {
+                stdout: String::from_utf8_lossy(&out.stdout).into(),
+                stderr: String::from_utf8_lossy(&out.stderr).into(),
+            });
+        }
 
-        version_meta_for(out)
+        version_meta_for(str::from_utf8(&out.stdout)?)
     }
 }
 
@@ -132,216 +207,211 @@ pub fn version_meta() -> Result<VersionMeta> {
 /// the SemVer version and additional metadata
 /// like the git short hash and build date.
 pub fn version_meta_for(verbose_version_string: &str) -> Result<VersionMeta> {
-    let out: Vec<_> = verbose_version_string.lines().collect();
-
-    if !(out.len() >= 6 && out.len() <= 8) {
-        return Err(Error::UnexpectedVersionFormat);
-    }
+    let mut map = HashMap::new();
+    for (i, line) in verbose_version_string.lines().enumerate() {
+        if i == 0 {
+            map.insert("short", line);
+            continue;
+        }
 
-    let short_version_string = out[0];
+        let mut parts = line.splitn(2, ": ");
+        let key = match parts.next() {
+            Some(key) => key,
+            None => continue,
+        };
 
-    fn expect_prefix<'a>(line: &'a str, prefix: &str) -> Result<&'a str> {
-        if line.starts_with(prefix) {
-            Ok(&line[prefix.len()..])
-        } else {
-            Err(Error::UnexpectedVersionFormat)
+        if let Some(value) = parts.next() {
+            map.insert(key, value);
         }
     }
 
-    let commit_hash = match expect_prefix(out[2], "commit-hash: ")? {
-        "unknown" => None,
-        hash => Some(hash.to_owned()),
-    };
+    let short_version_string = expect_key("short", &map)?;
+    let host = expect_key("host", &map)?;
+    let release = expect_key("release", &map)?;
+    let semver: Version = release.parse()?;
 
-    let commit_date = match expect_prefix(out[3], "commit-date: ")? {
-        "unknown" => None,
-        hash => Some(hash.to_owned()),
+    let channel = match semver.pre.split('.').next().unwrap() {
+        "" => Channel::Stable,
+        "dev" => Channel::Dev,
+        "beta" => Channel::Beta,
+        "nightly" => Channel::Nightly,
+        x => return Err(Error::UnknownPreReleaseTag(x.to_owned())),
     };
 
-    // Handle that the build date may or may not be present.
-    let mut idx = 4;
-    let mut build_date = None;
-    if out[idx].starts_with("build-date") {
-        build_date = match expect_prefix(out[idx], "build-date: ")? {
-            "unknown" => None,
-            s => Some(s.to_owned()),
-        };
-        idx += 1;
-    }
-
-    let host = expect_prefix(out[idx], "host: ")?;
-    idx += 1;
-    let release = expect_prefix(out[idx], "release: ")?;
-
-    let semver: Version = release.parse()?;
-
-    let channel = if semver.pre.is_empty() {
-        Channel::Stable
-    } else {
-        match semver.pre[0] {
-            Identifier::AlphaNumeric(ref s) if s == "dev" => Channel::Dev,
-            Identifier::AlphaNumeric(ref s) if s == "beta" => Channel::Beta,
-            Identifier::AlphaNumeric(ref s) if s == "nightly" => Channel::Nightly,
-            ref x => return Err(Error::UnknownPreReleaseTag(x.clone())),
-        }
+    let commit_hash = expect_key_or_unknown("commit-hash", &map)?;
+    let commit_date = expect_key_or_unknown("commit-date", &map)?;
+    let build_date = map
+        .get("build-date")
+        .filter(|&v| *v != "unknown")
+        .map(|&v| String::from(v));
+    let llvm_version = match map.get("LLVM version") {
+        Some(&v) => Some(v.parse()?),
+        None => None,
     };
 
     Ok(VersionMeta {
-        semver: semver,
-        commit_hash: commit_hash,
-        commit_date: commit_date,
-        build_date: build_date,
-        channel: channel,
-        host: host.into(),
-        short_version_string: short_version_string.into(),
+        semver,
+        commit_hash,
+        commit_date,
+        build_date,
+        channel,
+        host,
+        short_version_string,
+        llvm_version,
     })
 }
 
-#[test]
-fn smoketest() {
-    let v = version().unwrap();
-    assert!(v.major >= 1);
-
-    let v = version_meta().unwrap();
-    assert!(v.semver.major >= 1);
-
-    assert!(version().unwrap() >= Version::parse("1.0.0").unwrap());
+fn expect_key_or_unknown(key: &str, map: &HashMap<&str, &str>) -> Result<Option<String>, Error> {
+    match map.get(key) {
+        Some(&v) if v == "unknown" => Ok(None),
+        Some(&v) => Ok(Some(String::from(v))),
+        None => Err(Error::UnexpectedVersionFormat),
+    }
 }
 
-#[test]
-fn parse_unexpected() {
-    let res = version_meta_for(
-"rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)
-binary: rustc
-commit-hash: a59de37e99060162a2674e3ff45409ac73595c0e
-commit-date: 2015-05-13
-rust-birthday: 2015-05-14
-host: x86_64-unknown-linux-gnu
-release: 1.0.0");
-
-    assert!(match res {
-        Err(Error::UnexpectedVersionFormat) => true,
-        _ => false,
-    });
-
+fn expect_key(key: &str, map: &HashMap<&str, &str>) -> Result<String, Error> {
+    map.get(key)
+        .map(|&v| String::from(v))
+        .ok_or(Error::UnexpectedVersionFormat)
 }
 
-#[test]
-fn parse_1_0_0() {
-    let version = version_meta_for(
-"rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)
-binary: rustc
-commit-hash: a59de37e99060162a2674e3ff45409ac73595c0e
-commit-date: 2015-05-13
-build-date: 2015-05-14
-host: x86_64-unknown-linux-gnu
-release: 1.0.0").unwrap();
-
-    assert_eq!(version.semver, Version::parse("1.0.0").unwrap());
-    assert_eq!(version.commit_hash, Some("a59de37e99060162a2674e3ff45409ac73595c0e".into()));
-    assert_eq!(version.commit_date, Some("2015-05-13".into()));
-    assert_eq!(version.build_date, Some("2015-05-14".into()));
-    assert_eq!(version.channel, Channel::Stable);
-    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
-    assert_eq!(version.short_version_string, "rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)");
+/// LLVM Version Parse Error
+#[derive(Debug)]
+pub enum LlvmVersionParseError {
+    /// An error occurred in parsing a version component as an integer
+    ParseIntError(num::ParseIntError),
+    /// A version component must not have leading zeros
+    ComponentMustNotHaveLeadingZeros,
+    /// A version component has a sign
+    ComponentMustNotHaveSign,
+    /// Minor version component must be zero on LLVM versions later than 4.0
+    MinorVersionMustBeZeroAfter4,
+    /// Minor version component is required on LLVM versions earlier than 4.0
+    MinorVersionRequiredBefore4,
+    /// Too many components
+    TooManyComponents,
 }
 
-
-#[test]
-fn parse_unknown() {
-    let version = version_meta_for(
-"rustc 1.3.0
-binary: rustc
-commit-hash: unknown
-commit-date: unknown
-host: x86_64-unknown-linux-gnu
-release: 1.3.0").unwrap();
-
-    assert_eq!(version.semver, Version::parse("1.3.0").unwrap());
-    assert_eq!(version.commit_hash, None);
-    assert_eq!(version.commit_date, None);
-    assert_eq!(version.channel, Channel::Stable);
-    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
-    assert_eq!(version.short_version_string, "rustc 1.3.0");
+impl From<num::ParseIntError> for LlvmVersionParseError {
+    fn from(e: num::ParseIntError) -> Self {
+        LlvmVersionParseError::ParseIntError(e)
+    }
 }
 
-#[test]
-fn parse_nightly() {
-    let version = version_meta_for(
-"rustc 1.5.0-nightly (65d5c0833 2015-09-29)
-binary: rustc
-commit-hash: 65d5c083377645a115c4ac23a620d3581b9562b6
-commit-date: 2015-09-29
-host: x86_64-unknown-linux-gnu
-release: 1.5.0-nightly").unwrap();
-
-    assert_eq!(version.semver, Version::parse("1.5.0-nightly").unwrap());
-    assert_eq!(version.commit_hash, Some("65d5c083377645a115c4ac23a620d3581b9562b6".into()));
-    assert_eq!(version.commit_date, Some("2015-09-29".into()));
-    assert_eq!(version.channel, Channel::Nightly);
-    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
-    assert_eq!(version.short_version_string, "rustc 1.5.0-nightly (65d5c0833 2015-09-29)");
+impl fmt::Display for LlvmVersionParseError {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match self {
+            LlvmVersionParseError::ParseIntError(e) => {
+                write!(f, "error parsing LLVM version component: {}", e)
+            }
+            LlvmVersionParseError::ComponentMustNotHaveLeadingZeros => {
+                write!(f, "a version component must not have leading zeros")
+            }
+            LlvmVersionParseError::ComponentMustNotHaveSign => {
+                write!(f, "a version component must not have a sign")
+            }
+            LlvmVersionParseError::MinorVersionMustBeZeroAfter4 => write!(
+                f,
+                "LLVM's minor version component must be 0 for versions greater than 4.0"
+            ),
+            LlvmVersionParseError::MinorVersionRequiredBefore4 => write!(
+                f,
+                "LLVM's minor version component is required for versions less than 4.0"
+            ),
+            LlvmVersionParseError::TooManyComponents => write!(f, "too many version components"),
+        }
+    }
 }
 
-#[test]
-fn parse_stable() {
-    let version = version_meta_for(
-"rustc 1.3.0 (9a92aaf19 2015-09-15)
-binary: rustc
-commit-hash: 9a92aaf19a64603b02b4130fe52958cc12488900
-commit-date: 2015-09-15
-host: x86_64-unknown-linux-gnu
-release: 1.3.0").unwrap();
-
-    assert_eq!(version.semver, Version::parse("1.3.0").unwrap());
-    assert_eq!(version.commit_hash, Some("9a92aaf19a64603b02b4130fe52958cc12488900".into()));
-    assert_eq!(version.commit_date, Some("2015-09-15".into()));
-    assert_eq!(version.channel, Channel::Stable);
-    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
-    assert_eq!(version.short_version_string, "rustc 1.3.0 (9a92aaf19 2015-09-15)");
+impl error::Error for LlvmVersionParseError {
+    fn source(&self) -> Option<&(dyn error::Error + 'static)> {
+        match self {
+            LlvmVersionParseError::ParseIntError(e) => Some(e),
+            LlvmVersionParseError::ComponentMustNotHaveLeadingZeros
+            | LlvmVersionParseError::ComponentMustNotHaveSign
+            | LlvmVersionParseError::MinorVersionMustBeZeroAfter4
+            | LlvmVersionParseError::MinorVersionRequiredBefore4
+            | LlvmVersionParseError::TooManyComponents => None,
+        }
+    }
 }
 
-#[test]
-fn parse_1_16_0_nightly() {
-    let version = version_meta_for(
-"rustc 1.16.0-nightly (5d994d8b7 2017-01-05)
-binary: rustc
-commit-hash: 5d994d8b7e482e87467d4a521911477bd8284ce3
-commit-date: 2017-01-05
-host: x86_64-unknown-linux-gnu
-release: 1.16.0-nightly
-LLVM version: 3.9").unwrap();
-
-    assert_eq!(version.semver, Version::parse("1.16.0-nightly").unwrap());
-    assert_eq!(version.commit_hash, Some("5d994d8b7e482e87467d4a521911477bd8284ce3".into()));
-    assert_eq!(version.commit_date, Some("2017-01-05".into()));
-    assert_eq!(version.channel, Channel::Nightly);
-    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
-    assert_eq!(version.short_version_string, "rustc 1.16.0-nightly (5d994d8b7 2017-01-05)");
+/// The error type for this crate.
+#[derive(Debug)]
+pub enum Error {
+    /// An error occurred while trying to find the `rustc` to run.
+    CouldNotExecuteCommand(io::Error),
+    /// Error output from the command that was run.
+    CommandError {
+        /// stdout output from the command
+        stdout: String,
+        /// stderr output from the command
+        stderr: String,
+    },
+    /// The output of `rustc -vV` was not valid utf-8.
+    Utf8Error(str::Utf8Error),
+    /// The output of `rustc -vV` was not in the expected format.
+    UnexpectedVersionFormat,
+    /// An error occurred in parsing the semver.
+    SemVerError(semver::Error),
+    /// The pre-release tag is unknown.
+    UnknownPreReleaseTag(String),
+    /// An error occurred in parsing a `LlvmVersion`.
+    LlvmVersionError(LlvmVersionParseError),
 }
 
-/*
-#[test]
-fn version_matches_replacement() {
-    let f = |s1: &str, s2: &str| {
-        let a = Version::parse(s1).unwrap();
-        let b = Version::parse(s2).unwrap();
-        println!("{} <= {} : {}", s1, s2, a <= b);
-    };
-
-    println!();
-
-    f("1.5.0",         "1.5.0");
-    f("1.5.0-nightly", "1.5.0");
-    f("1.5.0",         "1.5.0-nightly");
-    f("1.5.0-nightly", "1.5.0-nightly");
+impl fmt::Display for Error {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match *self {
+            CouldNotExecuteCommand(ref e) => write!(f, "could not execute command: {}", e),
+            CommandError {
+                ref stdout,
+                ref stderr,
+            } => write!(
+                f,
+                "error from command -- stderr:\n\n{}\n\nstderr:\n\n{}",
+                stderr, stdout,
+            ),
+            Utf8Error(_) => write!(f, "invalid UTF-8 output from `rustc -vV`"),
+            UnexpectedVersionFormat => write!(f, "unexpected `rustc -vV` format"),
+            SemVerError(ref e) => write!(f, "error parsing version: {}", e),
+            UnknownPreReleaseTag(ref i) => write!(f, "unknown pre-release tag: {}", i),
+            LlvmVersionError(ref e) => write!(f, "error parsing LLVM's version: {}", e),
+        }
+    }
+}
 
-    f("1.5.0",         "1.6.0");
-    f("1.5.0-nightly", "1.6.0");
-    f("1.5.0",         "1.6.0-nightly");
-    f("1.5.0-nightly", "1.6.0-nightly");
+impl error::Error for Error {
+    fn source(&self) -> Option<&(dyn error::Error + 'static)> {
+        match *self {
+            CouldNotExecuteCommand(ref e) => Some(e),
+            CommandError { .. } => None,
+            Utf8Error(ref e) => Some(e),
+            UnexpectedVersionFormat => None,
+            SemVerError(ref e) => Some(e),
+            UnknownPreReleaseTag(_) => None,
+            LlvmVersionError(ref e) => Some(e),
+        }
+    }
+}
 
-    panic!();
+macro_rules! impl_from {
+    ($($err_ty:ty => $variant:ident),* $(,)*) => {
+        $(
+            impl From<$err_ty> for Error {
+                fn from(e: $err_ty) -> Error {
+                    Error::$variant(e)
+                }
+            }
+        )*
+    }
+}
 
+impl_from! {
+    str::Utf8Error => Utf8Error,
+    semver::Error => SemVerError,
+    LlvmVersionParseError => LlvmVersionError,
 }
-*/
+
+/// The result type for this crate.
+pub type Result<T, E = Error> = std::result::Result<T, E>;
diff --git a/third_party/rust/rustc_version/tests/all.rs b/third_party/rust/rustc_version/tests/all.rs
new file mode 100644
index 000000000000..c3cff7048a8d
--- /dev/null
+++ b/third_party/rust/rustc_version/tests/all.rs
@@ -0,0 +1,456 @@
+#![allow(clippy::match_like_matches_macro)]
+
+use std::process::Command;
+
+use rustc_version::{
+    version, version_meta, version_meta_for, Channel, Error, LlvmVersion, LlvmVersionParseError,
+    Version, VersionMeta,
+};
+
+#[test]
+fn rustc_error() {
+    let mut cmd = Command::new("rustc");
+    cmd.arg("--FOO");
+    let stderr = match VersionMeta::for_command(cmd) {
+        Err(Error::CommandError { stdout: _, stderr }) => stderr,
+        _ => panic!("command error expected"),
+    };
+    assert_eq!(stderr, "error: Unrecognized option: \'FOO\'\n\n");
+}
+
+#[test]
+fn smoketest() {
+    let v = version().unwrap();
+    assert!(v.major >= 1);
+
+    let v = version_meta().unwrap();
+    assert!(v.semver.major >= 1);
+
+    assert!(version().unwrap() >= Version::parse("1.0.0").unwrap());
+}
+
+#[test]
+fn parse_1_0_0() {
+    let version = version_meta_for(
+        "rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)
+binary: rustc
+commit-hash: a59de37e99060162a2674e3ff45409ac73595c0e
+commit-date: 2015-05-13
+build-date: 2015-05-14
+host: x86_64-unknown-linux-gnu
+release: 1.0.0",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.0.0").unwrap());
+    assert_eq!(
+        version.commit_hash,
+        Some("a59de37e99060162a2674e3ff45409ac73595c0e".into())
+    );
+    assert_eq!(version.commit_date, Some("2015-05-13".into()));
+    assert_eq!(version.build_date, Some("2015-05-14".into()));
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(
+        version.short_version_string,
+        "rustc 1.0.0 (a59de37e9 2015-05-13) (built 2015-05-14)"
+    );
+    assert_eq!(version.llvm_version, None);
+}
+
+#[test]
+fn parse_unknown() {
+    let version = version_meta_for(
+        "rustc 1.3.0
+binary: rustc
+commit-hash: unknown
+commit-date: unknown
+host: x86_64-unknown-linux-gnu
+release: 1.3.0",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.3.0").unwrap());
+    assert_eq!(version.commit_hash, None);
+    assert_eq!(version.commit_date, None);
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(version.short_version_string, "rustc 1.3.0");
+    assert_eq!(version.llvm_version, None);
+}
+
+#[test]
+fn parse_nightly() {
+    let version = version_meta_for(
+        "rustc 1.5.0-nightly (65d5c0833 2015-09-29)
+binary: rustc
+commit-hash: 65d5c083377645a115c4ac23a620d3581b9562b6
+commit-date: 2015-09-29
+host: x86_64-unknown-linux-gnu
+release: 1.5.0-nightly",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.5.0-nightly").unwrap());
+    assert_eq!(
+        version.commit_hash,
+        Some("65d5c083377645a115c4ac23a620d3581b9562b6".into())
+    );
+    assert_eq!(version.commit_date, Some("2015-09-29".into()));
+    assert_eq!(version.channel, Channel::Nightly);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(
+        version.short_version_string,
+        "rustc 1.5.0-nightly (65d5c0833 2015-09-29)"
+    );
+    assert_eq!(version.llvm_version, None);
+}
+
+#[test]
+fn parse_stable() {
+    let version = version_meta_for(
+        "rustc 1.3.0 (9a92aaf19 2015-09-15)
+binary: rustc
+commit-hash: 9a92aaf19a64603b02b4130fe52958cc12488900
+commit-date: 2015-09-15
+host: x86_64-unknown-linux-gnu
+release: 1.3.0",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.3.0").unwrap());
+    assert_eq!(
+        version.commit_hash,
+        Some("9a92aaf19a64603b02b4130fe52958cc12488900".into())
+    );
+    assert_eq!(version.commit_date, Some("2015-09-15".into()));
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(
+        version.short_version_string,
+        "rustc 1.3.0 (9a92aaf19 2015-09-15)"
+    );
+    assert_eq!(version.llvm_version, None);
+}
+
+#[test]
+fn parse_1_16_0_nightly() {
+    let version = version_meta_for(
+        "rustc 1.16.0-nightly (5d994d8b7 2017-01-05)
+binary: rustc
+commit-hash: 5d994d8b7e482e87467d4a521911477bd8284ce3
+commit-date: 2017-01-05
+host: x86_64-unknown-linux-gnu
+release: 1.16.0-nightly
+LLVM version: 3.9",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.16.0-nightly").unwrap());
+    assert_eq!(
+        version.commit_hash,
+        Some("5d994d8b7e482e87467d4a521911477bd8284ce3".into())
+    );
+    assert_eq!(version.commit_date, Some("2017-01-05".into()));
+    assert_eq!(version.channel, Channel::Nightly);
+    assert_eq!(version.host, "x86_64-unknown-linux-gnu");
+    assert_eq!(
+        version.short_version_string,
+        "rustc 1.16.0-nightly (5d994d8b7 2017-01-05)"
+    );
+    assert_eq!(
+        version.llvm_version,
+        Some(LlvmVersion { major: 3, minor: 9 })
+    );
+}
+
+#[test]
+fn parse_1_47_0_stable() {
+    let version = version_meta_for(
+        "rustc 1.47.0 (18bf6b4f0 2020-10-07)
+binary: rustc
+commit-hash: 18bf6b4f01a6feaf7259ba7cdae58031af1b7b39
+commit-date: 2020-10-07
+host: powerpc64le-unknown-linux-gnu
+release: 1.47.0
+LLVM version: 11.0",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.47.0").unwrap());
+    assert_eq!(
+        version.commit_hash,
+        Some("18bf6b4f01a6feaf7259ba7cdae58031af1b7b39".into())
+    );
+    assert_eq!(version.commit_date, Some("2020-10-07".into()));
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "powerpc64le-unknown-linux-gnu");
+    assert_eq!(
+        version.short_version_string,
+        "rustc 1.47.0 (18bf6b4f0 2020-10-07)"
+    );
+    assert_eq!(
+        version.llvm_version,
+        Some(LlvmVersion {
+            major: 11,
+            minor: 0,
+        })
+    );
+}
+
+#[test]
+fn parse_llvm_micro() {
+    let version = version_meta_for(
+        "rustc 1.51.0-nightly (4253153db 2021-01-17)
+binary: rustc
+commit-hash: 4253153db205251f72ea4493687a31e04a2a8ca0
+commit-date: 2021-01-17
+host: x86_64-pc-windows-msvc
+release: 1.51.0-nightly
+LLVM version: 11.0.1",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.51.0-nightly").unwrap());
+    assert_eq!(
+        version.commit_hash.unwrap(),
+        "4253153db205251f72ea4493687a31e04a2a8ca0"
+    );
+    assert_eq!(version.commit_date.unwrap(), "2021-01-17");
+    assert_eq!(version.host, "x86_64-pc-windows-msvc");
+    assert_eq!(
+        version.short_version_string,
+        "rustc 1.51.0-nightly (4253153db 2021-01-17)"
+    );
+    assert_eq!(
+        version.llvm_version,
+        Some(LlvmVersion {
+            major: 11,
+            minor: 0
+        })
+    );
+}
+
+#[test]
+fn parse_debian_buster() {
+    let version = version_meta_for(
+        "rustc 1.41.1
+binary: rustc
+commit-hash: unknown
+commit-date: unknown
+host: powerpc64le-unknown-linux-gnu
+release: 1.41.1
+LLVM version: 7.0",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.41.1").unwrap());
+    assert_eq!(version.commit_hash, None);
+    assert_eq!(version.commit_date, None);
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "powerpc64le-unknown-linux-gnu");
+    assert_eq!(version.short_version_string, "rustc 1.41.1");
+    assert_eq!(
+        version.llvm_version,
+        Some(LlvmVersion { major: 7, minor: 0 })
+    );
+}
+
+#[test]
+fn parse_termux() {
+    let version = version_meta_for(
+        "rustc 1.46.0
+binary: rustc
+commit-hash: unknown
+commit-date: unknown
+host: aarch64-linux-android
+release: 1.46.0
+LLVM version: 10.0",
+    )
+    .unwrap();
+
+    assert_eq!(version.semver, Version::parse("1.46.0").unwrap());
+    assert_eq!(version.commit_hash, None);
+    assert_eq!(version.commit_date, None);
+    assert_eq!(version.channel, Channel::Stable);
+    assert_eq!(version.host, "aarch64-linux-android");
+    assert_eq!(version.short_version_string, "rustc 1.46.0");
+    assert_eq!(
+        version.llvm_version,
+        Some(LlvmVersion {
+            major: 10,
+            minor: 0,
+        })
+    );
+}
+
+#[test]
+fn parse_llvm_version_empty() {
+    let res: Result<LlvmVersion, _> = "".parse();
+    assert!(match res {
+        Err(LlvmVersionParseError::ParseIntError(_)) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_invalid_char() {
+    let res: Result<LlvmVersion, _> = "A".parse();
+    assert!(match res {
+        Err(LlvmVersionParseError::ParseIntError(_)) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_overflow() {
+    let res: Result<LlvmVersion, _> = "9999999999999999999999999999999".parse();
+    assert!(match res {
+        Err(LlvmVersionParseError::ParseIntError(_)) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_leading_zero_on_zero() {
+    let res: Result<LlvmVersion, _> = "00".parse();
+    assert!(match res {
+        Err(LlvmVersionParseError::ComponentMustNotHaveLeadingZeros) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_leading_zero_on_nonzero() {
+    let res: Result<LlvmVersion, _> = "01".parse();
+    assert!(match res {
+        Err(LlvmVersionParseError::ComponentMustNotHaveLeadingZeros) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_4_components() {
+    let res: Result<LlvmVersion, _> = "4.0.0.0".parse();
+
+    assert!(match res {
+        Err(LlvmVersionParseError::TooManyComponents) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_component_sign_plus() {
+    let res: Result<LlvmVersion, _> = "1.+3".parse();
+
+    assert!(match res {
+        Err(LlvmVersionParseError::ComponentMustNotHaveSign) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_component_sign_minus() {
+    let res: Result<LlvmVersion, _> = "1.-3".parse();
+
+    assert!(match res {
+        Err(LlvmVersionParseError::ComponentMustNotHaveSign) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_3() {
+    let res: Result<LlvmVersion, _> = "3".parse();
+
+    assert!(match res {
+        Err(LlvmVersionParseError::MinorVersionRequiredBefore4) => true,
+        _ => false,
+    });
+}
+
+#[test]
+fn parse_llvm_version_5() {
+    let v: LlvmVersion = "5".parse().unwrap();
+    assert_eq!(v, LlvmVersion { major: 5, minor: 0 });
+}
+
+#[test]
+fn parse_llvm_version_5_0() {
+    let v: LlvmVersion = "5.0".parse().unwrap();
+    assert_eq!(v, LlvmVersion { major: 5, minor: 0 });
+}
+
+#[test]
+fn parse_llvm_version_4_0() {
+    let v: LlvmVersion = "4.0".parse().unwrap();
+    assert_eq!(v, LlvmVersion { major: 4, minor: 0 });
+}
+
+#[test]
+fn parse_llvm_version_3_0() {
+    let v: LlvmVersion = "3.0".parse().unwrap();
+    assert_eq!(v, LlvmVersion { major: 3, minor: 0 });
+}
+
+#[test]
+fn parse_llvm_version_3_9() {
+    let v: LlvmVersion = "3.9".parse().unwrap();
+    assert_eq!(v, LlvmVersion { major: 3, minor: 9 });
+}
+
+#[test]
+fn parse_llvm_version_11_0() {
+    let v: LlvmVersion = "11.0".parse().unwrap();
+    assert_eq!(
+        v,
+        LlvmVersion {
+            major: 11,
+            minor: 0
+        }
+    );
+}
+
+#[test]
+fn parse_llvm_version_11() {
+    let v: LlvmVersion = "11".parse().unwrap();
+    assert_eq!(
+        v,
+        LlvmVersion {
+            major: 11,
+            minor: 0
+        }
+    );
+}
+
+#[test]
+fn test_llvm_version_comparison() {
+    // check that field order is correct
+    assert!(LlvmVersion { major: 3, minor: 9 } < LlvmVersion { major: 4, minor: 0 });
+}
+
+/*
+#[test]
+fn version_matches_replacement() {
+    let f = |s1: &str, s2: &str| {
+        let a = Version::parse(s1).unwrap();
+        let b = Version::parse(s2).unwrap();
+        println!("{} <= {} : {}", s1, s2, a <= b);
+    };
+
+    println!();
+
+    f("1.5.0",         "1.5.0");
+    f("1.5.0-nightly", "1.5.0");
+    f("1.5.0",         "1.5.0-nightly");
+    f("1.5.0-nightly", "1.5.0-nightly");
+
+    f("1.5.0",         "1.6.0");
+    f("1.5.0-nightly", "1.6.0");
+    f("1.5.0",         "1.6.0-nightly");
+    f("1.5.0-nightly", "1.6.0-nightly");
+
+    panic!();
+
+}
+*/
diff --git a/third_party/rust/semver-0.9.0/.cargo-checksum.json b/third_party/rust/semver-0.9.0/.cargo-checksum.json
new file mode 100644
index 000000000000..2f9af6eca870
--- /dev/null
+++ b/third_party/rust/semver-0.9.0/.cargo-checksum.json
@@ -0,0 +1 @@
+{"files":{"Cargo.toml":"a5b995796b5559de8975a6fee7166c9fda6c21b449ec90bef5f9baaeddd479a5","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"6485b8ed310d3f0340bf1ad1f47645069ce4069dcc6bb46c7d5c6faf41de1fdb","README.md":"c780d8c3c802c5fe2c316127900385010c3e57f71c851eea9e8ed8495e2030dd","src/lib.rs":"cb1725a8bb90c1043f187c6ba504d0a9d07793e2f39f5205f926c58849311770","src/version.rs":"ffdf9c628597b889f149f3b2b1245b97c774eae1ce7030bd19235eabecaaede0","src/version_req.rs":"40d20720f5fdc0b3d9e398e64eb448a65987229bd322cab0fedf0cf1843f3bd8","tests/deprecation.rs":"b5ec79e19d61968d05b96b876c449e54d43cbd1762c6e63c23c3470f9db56292","tests/regression.rs":"180b699ad029b81e6135d42f0a8e6d782177bc29a41132f875ee6f8607a46b56","tests/serde.rs":"cdbbefc576ffcc814c30dad9598ab87a7fd9d14c5f42f1349e1db6afc72f8fed"},"package":"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403"}
\ No newline at end of file
diff --git a/third_party/rust/semver-0.9.0/Cargo.toml b/third_party/rust/semver-0.9.0/Cargo.toml
new file mode 100644
index 000000000000..7749f76c3778
--- /dev/null
+++ b/third_party/rust/semver-0.9.0/Cargo.toml
@@ -0,0 +1,45 @@
+# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
+#
+# When uploading crates to the registry Cargo will automatically
+# "normalize" Cargo.toml files for maximal compatibility
+# with all versions of Cargo and also rewrite `path` dependencies
+# to registry (e.g. crates.io) dependencies
+#
+# If you believe there's an error in this file please file an
+# issue against the rust-lang/cargo repository. If you're
+# editing this file be aware that the upstream Cargo.toml
+# will likely look very different (and much more reasonable)
+
+[package]
+name = "semver"
+version = "0.9.0"
+authors = ["Steve Klabnik <steve@steveklabnik.com>", "The Rust Project Developers"]
+description = "Semantic version parsing and comparison.\n"
+homepage = "https://docs.rs/crate/semver/"
+documentation = "https://docs.rs/crate/semver/"
+readme = "README.md"
+license = "MIT/Apache-2.0"
+repository = "https://github.com/steveklabnik/semver"
+[dependencies.semver-parser]
+version = "0.7.0"
+
+[dependencies.serde]
+version = "1.0"
+optional = true
+[dev-dependencies.crates-index]
+version = "0.5.0"
+
+[dev-dependencies.serde_json]
+version = "1.0"
+
+[dev-dependencies.serde_derive]
+version = "1.0"
+
+[dev-dependencies.tempdir]
+version = "0.3.4"
+
+[features]
+default = []
+ci = ["serde"]
+[badges.travis-ci]
+repository = "steveklabnik/semver"
diff --git a/third_party/rust/semver-0.9.0/LICENSE-APACHE b/third_party/rust/semver-0.9.0/LICENSE-APACHE
new file mode 100644
index 000000000000..16fe87b06e80
--- /dev/null
+++ b/third_party/rust/semver-0.9.0/LICENSE-APACHE
@@ -0,0 +1,201 @@
+                              Apache License
+                        Version 2.0, January 2004
+                     http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+   "License" shall mean the terms and conditions for use, reproduction,
+   and distribution as defined by Sections 1 through 9 of this document.
+
+   "Licensor" shall mean the copyright owner or entity authorized by
+   the copyright owner that is granting the License.
+
+   "Legal Entity" shall mean the union of the acting entity and all
+   other entities that control, are controlled by, or are under common
+   control with that entity. For the purposes of this definition,
+   "control" means (i) the power, direct or indirect, to cause the
+   direction or management of such entity, whether by contract or
+   otherwise, or (ii) ownership of fifty percent (50%) or more of the
+   outstanding shares, or (iii) beneficial ownership of such entity.
+
+   "You" (or "Your") shall mean an individual or Legal Entity
+   exercising permissions granted by this License.
+
+   "Source" form shall mean the preferred form for making modifications,
+   including but not limited to software source code, documentation
+   source, and configuration files.
+
+   "Object" form shall mean any form resulting from mechanical
+   transformation or translation of a Source form, including but
+   not limited to compiled object code, generated documentation,
+   and conversions to other media types.
+
+   "Work" shall mean the work of authorship, whether in Source or
+   Object form, made available under the License, as indicated by a
+   copyright notice that is included in or attached to the work
+   (an example is provided in the Appendix below).
+
+   "Derivative Works" shall mean any work, whether in Source or Object
+   form, that is based on (or derived from) the Work and for which the
+   editorial revisions, annotations, elaborations, or other modifications
+   represent, as a whole, an original work of authorship. For the purposes
+   of this License, Derivative Works shall not include works that remain
+   separable from, or merely link (or bind by name) to the interfaces of,
+   the Work and Derivative Works thereof.
+
+   "Contribution" shall mean any work of authorship, including
+   the original version of the Work and any modifications or additions
+   to that Work or Derivative Works thereof, that is intentionally
+   submitted to Licensor for inclusion in the Work by the copyright owner
+   or by an individual or Legal Entity authorized to submit on behalf of
+   the copyright owner. For the purposes of this definition, "submitted"
+   means any form of electronic, verbal, or written communication sent
+   to the Licensor or its representatives, including but not limited to
+   communication on electronic mailing lists, source code control systems,
+   and issue tracking systems that are managed by, or on behalf of, the
+   Licensor for the purpose of discussing and improving the Work, but
+   excluding communication that is conspicuously marked or otherwise
+   designated in writing by the copyright owner as "Not a Contribution."
+
+   "Contributor" shall mean Licensor and any individual or Legal Entity
+   on behalf of whom a Contribution has been received by Licensor and
+   subsequently incorporated within the Work.
+
+2. Grant of Copyright License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   copyright license to reproduce, prepare Derivative Works of,
+   publicly display, publicly perform, sublicense, and distribute the
+   Work and such Derivative Works in Source or Object form.
+
+3. Grant of Patent License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   (except as stated in this section) patent license to make, have made,
+   use, offer to sell, sell, import, and otherwise transfer the Work,
+   where such license applies only to those patent claims licensable
+   by such Contributor that are necessarily infringed by their
+   Contribution(s) alone or by combination of their Contribution(s)
+   with the Work to which such Contribution(s) was submitted. If You
+   institute patent litigation against any entity (including a
+   cross-claim or counterclaim in a lawsuit) alleging that the Work
+   or a Contribution incorporated within the Work constitutes direct
+   or contributory patent infringement, then any patent licenses
+   granted to You under this License for that Work shall terminate
+   as of the date such litigation is filed.
+
+4. Redistribution. You may reproduce and distribute copies of the
+   Work or Derivative Works thereof in any medium, with or without
+   modifications, and in Source or Object form, provided that You
+   meet the following conditions:
+
+   (a) You must give any other recipients of the Work or
+       Derivative Works a copy of this License; and
+
+   (b) You must cause any modified files to carry prominent notices
+       stating that You changed the files; and
+
+   (c) You must retain, in the Source form of any Derivative Works
+       that You distribute, all copyright, patent, trademark, and
+       attribution notices from the Source form of the Work,
+       excluding those notices that do not pertain to any part of
+       the Derivative Works; and
+
+   (d) If the Work includes a "NOTICE" text file as part of its
+       distribution, then any Derivative Works that You distribute must
+       include a readable copy of the attribution notices contained
+       within such NOTICE file, excluding those notices that do not
+       pertain to any part of the Derivative Works, in at least one
+       of the following places: within a NOTICE text file distributed
+       as part of the Derivative Works; within the Source form or
+       documentation, if provided along with the Derivative Works; or,
+       within a display generated by the Derivative Works, if and
+       wherever such third-party notices normally appear. The contents
+       of the NOTICE file are for informational purposes only and
+       do not modify the License. You may add Your own attribution
+       notices within Derivative Works that You distribute, alongside
+       or as an addendum to the NOTICE text from the Work, provided
+       that such additional attribution notices cannot be construed
+       as modifying the License.
+
+   You may add Your own copyright statement to Your modifications and
+   may provide additional or different license terms and conditions
+   for use, reproduction, or distribution of Your modifications, or
+   for any such Derivative Works as a whole, provided Your use,
+   reproduction, and distribution of the Work otherwise complies with
+   the conditions stated in this License.
+
+5. Submission of Contributions. Unless You explicitly state otherwise,
+   any Contribution intentionally submitted for inclusion in the Work
+   by You to the Licensor shall be under the terms and conditions of
+   this License, without any additional terms or conditions.
+   Notwithstanding the above, nothing herein shall supersede or modify
+   the terms of any separate license agreement you may have executed
+   with Licensor regarding such Contributions.
+
+6. Trademarks. This License does not grant permission to use the trade
+   names, trademarks, service marks, or product names of the Licensor,
+   except as required for reasonable and customary use in describing the
+   origin of the Work and reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty. Unless required by applicable law or
+   agreed to in writing, Licensor provides the Work (and each
+   Contributor provides its Contributions) on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+   implied, including, without limitation, any warranties or conditions
+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+   PARTICULAR PURPOSE. You are solely responsible for determining the
+   appropriateness of using or redistributing the Work and assume any
+   risks associated with Your exercise of permissions under this License.
+
+8. Limitation of Liability. In no event and under no legal theory,
+   whether in tort (including negligence), contract, or otherwise,
+   unless required by applicable law (such as deliberate and grossly
+   negligent acts) or agreed to in writing, shall any Contributor be
+   liable to You for damages, including any direct, indirect, special,
+   incidental, or consequential damages of any character arising as a
+   result of this License or out of the use or inability to use the
+   Work (including but not limited to damages for loss of goodwill,
+   work stoppage, computer failure or malfunction, or any and all
+   other commercial damages or losses), even if such Contributor
+   has been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability. While redistributing
+   the Work or Derivative Works thereof, You may choose to offer,
+   and charge a fee for, acceptance of support, warranty, indemnity,
+   or other liability obligations and/or rights consistent with this
+   License. However, in accepting such obligations, You may act only
+   on Your own behalf and on Your sole responsibility, not on behalf
+   of any other Contributor, and only if You agree to indemnify,
+   defend, and hold each Contributor harmless for any liability
+   incurred by, or claims asserted against, such Contributor by reason
+   of your accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
+
+APPENDIX: How to apply the Apache License to your work.
+
+   To apply the Apache License to your work, attach the following
+   boilerplate notice, with the fields enclosed by brackets "[]"
+   replaced with your own identifying information. (Don't include
+   the brackets!)  The text should be enclosed in the appropriate
+   comment syntax for the file format. We also recommend that a
+   file or class name and description of purpose be included on the
+   same "printed page" as the copyright notice for easier
+   identification within third-party archives.
+
+Copyright [yyyy] [name of copyright owner]
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+	http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/third_party/rust/semver-0.9.0/LICENSE-MIT b/third_party/rust/semver-0.9.0/LICENSE-MIT
new file mode 100644
index 000000000000..39d4bdb5acd3
--- /dev/null
+++ b/third_party/rust/semver-0.9.0/LICENSE-MIT
@@ -0,0 +1,25 @@
+Copyright (c) 2014 The Rust Project Developers
+
+Permission is hereby granted, free of charge, to any
+person obtaining a copy of this software and associated
+documentation files (the "Software"), to deal in the
+Software without restriction, including without
+limitation the rights to use, copy, modify, merge,
+publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software
+is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice
+shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
diff --git a/third_party/rust/semver-0.9.0/README.md b/third_party/rust/semver-0.9.0/README.md
new file mode 100644
index 000000000000..2a5306d4ccd2
--- /dev/null
+++ b/third_party/rust/semver-0.9.0/README.md
@@ -0,0 +1,103 @@
+semver
+======
+
+Semantic version parsing and comparison.
+
+[![Build Status](https://api.travis-ci.org/steveklabnik/semver.svg?branch=master)](https://travis-ci.org/steveklabnik/semver)
+
+[Documentation](https://steveklabnik.github.io/semver)
+
+Semantic versioning (see http://semver.org/) is a set of rules for
+assigning version numbers.
+
+## SemVer and the Rust ecosystem
+
+Rust itself follows the SemVer specification, as does its standard libraries. The two are
+not tied together.
+
+[Cargo](https://crates.io), Rust's package manager, uses SemVer to determine which versions of
+packages you need installed.
+
+## Installation
+
+To use `semver`, add this to your `[dependencies]` section:
+
+```toml
+semver = "0.7.0"
+```
+
+And this to your crate root:
+
+```rust
+extern crate semver;
+```
+
+## Versions
+
+At its simplest, the `semver` crate allows you to construct `Version` objects using the `parse`
+method:
+
+```rust
+use semver::Version;
+
+assert!(Version::parse("1.2.3") == Ok(Version {
+   major: 1,
+   minor: 2,
+   patch: 3,
+   pre: vec!(),
+   build: vec!(),
+}));
+```
+
+If you have multiple `Version`s, you can use the usual comparison operators to compare them:
+
+```rust
+use semver::Version;
+
+assert!(Version::parse("1.2.3-alpha")  != Version::parse("1.2.3-beta"));
+assert!(Version::parse("1.2.3-alpha2") >  Version::parse("1.2.0"));
+```
+
+## Requirements
+
+The `semver` crate also provides the ability to compare requirements, which are more complex
+comparisons.
+
+For example, creating a requirement that only matches versions greater than or
+equal to 1.0.0:
+
+```rust
+use semver::Version;
+use semver::VersionReq;
+
+let r = VersionReq::parse(">= 1.0.0").unwrap();
+let v = Version::parse("1.0.0").unwrap();
+
+assert!(r.to_string() == ">= 1.0.0".to_string());
+assert!(r.matches(&v))
+```
+
+It also allows parsing of `~x.y.z` and `^x.y.z` requirements as defined at
+https://www.npmjs.org/doc/misc/semver.html
+
+**Tilde requirements** specify a minimal version with some updates:
+
+```notrust
+~1.2.3 := >=1.2.3 <1.3.0
+~1.2   := >=1.2.0 <1.3.0
+~1     := >=1.0.0 <2.0.0
+```
+
+**Caret requirements** allow SemVer compatible updates to a specified version,
+`0.x` and `0.x+1` are not considered compatible, but `1.x` and `1.x+1` are.
+
+`0.0.x` is not considered compatible with any other version.
+Missing minor and patch versions are desugared to `0` but allow flexibility for that value.
+
+```notrust
+^1.2.3 := >=1.2.3 <2.0.0
+^0.2.3 := >=0.2.3 <0.3.0
+^0.0.3 := >=0.0.3 <0.0.4
+^0.0   := >=0.0.0 <0.1.0
+^0     := >=0.0.0 <1.0.0
+```
diff --git a/third_party/rust/semver-0.9.0/src/lib.rs b/third_party/rust/semver-0.9.0/src/lib.rs
new file mode 100644
index 000000000000..a38aae0e163d
--- /dev/null
+++ b/third_party/rust/semver-0.9.0/src/lib.rs
@@ -0,0 +1,182 @@
+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT
+// file at the top-level directory of this distribution and at
+// http://rust-lang.org/COPYRIGHT.
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+//! Semantic version parsing and comparison.
+//!
+//! Semantic versioning (see http://semver.org/) is a set of rules for
+//! assigning version numbers.
+//!
+//! ## SemVer overview
+//!
+//! Given a version number MAJOR.MINOR.PATCH, increment the:
+//!
+//! 1. MAJOR version when you make incompatible API changes,
+//! 2. MINOR version when you add functionality in a backwards-compatible
+//!    manner, and
+//! 3. PATCH version when you make backwards-compatible bug fixes.
+//!
+//! Additional labels for pre-release and build metadata are available as
+//! extensions to the MAJOR.MINOR.PATCH format.
+//!
+//! Any references to 'the spec' in this documentation refer to [version 2.0 of
+//! the SemVer spec](http://semver.org/spec/v2.0.0.html).
+//!
+//! ## SemVer and the Rust ecosystem
+//!
+//! Rust itself follows the SemVer specification, as does its standard
+//! libraries. The two are not tied together.
+//!
+//! [Cargo](http://crates.io), Rust's package manager, uses SemVer to determine
+//! which versions of packages you need installed.
+//!
+//! ## Versions
+//!
+//! At its simplest, the `semver` crate allows you to construct `Version`
+//! objects using the `parse` method:
+//!
+//! ```{rust}
+//! use semver::Version;
+//!
+//! assert!(Version::parse("1.2.3") == Ok(Version {
+//!    major: 1,
+//!    minor: 2,
+//!    patch: 3,
+//!    pre: vec!(),
+//!    build: vec!(),
+//! }));
+//! ```
+//!
+//! If you have multiple `Version`s, you can use the usual comparison operators
+//! to compare them:
+//!
+//! ```{rust}
+//! use semver::Version;
+//!
+//! assert!(Version::parse("1.2.3-alpha") != Version::parse("1.2.3-beta"));
+//! assert!(Version::parse("1.2.3-alpha2") >  Version::parse("1.2.0"));
+//! ```
+//!
+//! If you explicitly need to modify a Version, SemVer also allows you to
+//! increment the major, minor, and patch numbers in accordance with the spec.
+//!
+//! Please note that in order to do this, you must use a mutable Version:
+//!
+//! ```{rust}
+//! use semver::Version;
+//!
+//! let mut bugfix_release = Version::parse("1.0.0").unwrap();
+//! bugfix_release.increment_patch();
+//!
+//! assert_eq!(Ok(bugfix_release), Version::parse("1.0.1"));
+//! ```
+//!
+//! When incrementing the minor version number, the patch number resets to zero
+//! (in accordance with section 7 of the spec)
+//!
+//! ```{rust}
+//! use semver::Version;
+//!
+//! let mut feature_release = Version::parse("1.4.6").unwrap();
+//! feature_release.increment_minor();
+//!
+//! assert_eq!(Ok(feature_release), Version::parse("1.5.0"));
+//! ```
+//!
+//! Similarly, when incrementing the major version number, the patch and minor
+//! numbers reset to zero (in accordance with section 8 of the spec)
+//!
+//! ```{rust}
+//! use semver::Version;
+//!
+//! let mut chrome_release = Version::parse("41.5.5377").unwrap();
+//! chrome_release.increment_major();
+//!
+//! assert_eq!(Ok(chrome_release), Version::parse("42.0.0"));
+//! ```
+//!
+//! ## Requirements
+//!
+//! The `semver` crate also provides the ability to compare requirements, which
+//! are more complex comparisons.
+//!
+//! For example, creating a requirement that only matches versions greater than
+//! or equal to 1.0.0:
+//!
+//! ```{rust}
+//! # #![allow(unstable)]
+//! use semver::Version;
+//! use semver::VersionReq;
+//!
+//! let r = VersionReq::parse(">= 1.0.0").unwrap();
+//! let v = Version::parse("1.0.0").unwrap();
+//!
+//! assert!(r.to_string() == ">= 1.0.0".to_string());
+//! assert!(r.matches(&v))
+//! ```
+//!
+//! It also allows parsing of `~x.y.z` and `^x.y.z` requirements as defined at
+//! https://www.npmjs.org/doc/misc/semver.html
+//!
+//! **Tilde requirements** specify a minimal version with some updates:
+//!
+//! ```notrust
+//! ~1.2.3 := >=1.2.3 <1.3.0
+//! ~1.2   := >=1.2.0 <1.3.0
+//! ~1     := >=1.0.0 <2.0.0
+//! ```
+//!
+//! **Caret requirements** allow SemVer compatible updates to a specified
+//! verion, `0.x` and `0.x+1` are not considered compatible, but `1.x` and
+//! `1.x+1` are.
+//!
+//! `0.0.x` is not considered compatible with any other version.
+//! Missing minor and patch versions are desugared to `0` but allow flexibility
+//! for that value.
+//!
+//! ```notrust
+//! ^1.2.3 := >=1.2.3 <2.0.0
+//! ^0.2.3 := >=0.2.3 <0.3.0
+//! ^0.0.3 := >=0.0.3 <0.0.4
+//! ^0.0   := >=0.0.0 <0.1.0
+//! ^0     := >=0.0.0 <1.0.0
+//! ```
+//!
+//! **Wildcard requirements** allows parsing of version requirements of the
+//! formats `*`, `x.*` and `x.y.*`.
+//!
+//! ```notrust
+//! *     := >=0.0.0
+//! 1.*   := >=1.0.0 <2.0.0
+//! 1.2.* := >=1.2.0 <1.3.0
+//! ```
+
+#![doc(html_logo_url = "https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png",
+       html_favicon_url = "https://www.rust-lang.org/favicon.ico")]
+#![deny(missing_docs)]
+#![cfg_attr(test, deny(warnings))]
+
+extern crate semver_parser;
+
+// Serialization and deserialization support for version numbers
+#[cfg(feature = "serde")]
+extern crate serde;
+
+// We take the common approach of keeping our own module system private, and
+// just re-exporting the interface that we want.
+
+pub use version::{Version, Identifier, SemVerError};
+pub use version::Identifier::{Numeric, AlphaNumeric};
+pub use version_req::{VersionReq, ReqParseError};
+
+// SemVer-compliant versions.
+mod version;
+
+// advanced version comparisons
+mod version_req;
diff --git a/third_party/rust/semver/src/version.rs b/third_party/rust/semver-0.9.0/src/version.rs
similarity index 100%
rename from third_party/rust/semver/src/version.rs
rename to third_party/rust/semver-0.9.0/src/version.rs
diff --git a/third_party/rust/semver/src/version_req.rs b/third_party/rust/semver-0.9.0/src/version_req.rs
similarity index 100%
rename from third_party/rust/semver/src/version_req.rs
rename to third_party/rust/semver-0.9.0/src/version_req.rs
diff --git a/third_party/rust/semver/tests/deprecation.rs b/third_party/rust/semver-0.9.0/tests/deprecation.rs
similarity index 100%
rename from third_party/rust/semver/tests/deprecation.rs
rename to third_party/rust/semver-0.9.0/tests/deprecation.rs
diff --git a/third_party/rust/semver/tests/regression.rs b/third_party/rust/semver-0.9.0/tests/regression.rs
similarity index 100%
rename from third_party/rust/semver/tests/regression.rs
rename to third_party/rust/semver-0.9.0/tests/regression.rs
diff --git a/third_party/rust/semver/tests/serde.rs b/third_party/rust/semver-0.9.0/tests/serde.rs
similarity index 100%
rename from third_party/rust/semver/tests/serde.rs
rename to third_party/rust/semver-0.9.0/tests/serde.rs
diff --git a/third_party/rust/semver/.cargo-checksum.json b/third_party/rust/semver/.cargo-checksum.json
index 2f9af6eca870..f9b5c853b449 100644
--- a/third_party/rust/semver/.cargo-checksum.json
+++ b/third_party/rust/semver/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"Cargo.toml":"a5b995796b5559de8975a6fee7166c9fda6c21b449ec90bef5f9baaeddd479a5","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"6485b8ed310d3f0340bf1ad1f47645069ce4069dcc6bb46c7d5c6faf41de1fdb","README.md":"c780d8c3c802c5fe2c316127900385010c3e57f71c851eea9e8ed8495e2030dd","src/lib.rs":"cb1725a8bb90c1043f187c6ba504d0a9d07793e2f39f5205f926c58849311770","src/version.rs":"ffdf9c628597b889f149f3b2b1245b97c774eae1ce7030bd19235eabecaaede0","src/version_req.rs":"40d20720f5fdc0b3d9e398e64eb448a65987229bd322cab0fedf0cf1843f3bd8","tests/deprecation.rs":"b5ec79e19d61968d05b96b876c449e54d43cbd1762c6e63c23c3470f9db56292","tests/regression.rs":"180b699ad029b81e6135d42f0a8e6d782177bc29a41132f875ee6f8607a46b56","tests/serde.rs":"cdbbefc576ffcc814c30dad9598ab87a7fd9d14c5f42f1349e1db6afc72f8fed"},"package":"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403"}
\ No newline at end of file
+{"files":{"Cargo.toml":"2841cf520fc7e71e16036c48021789cdf36182786556b2a97eb8371193e0c69c","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"23f18e03dc49df91622fe2a76176497404e46ced8a715d9d2b67a7446571cca3","README.md":"83e92a83348171f60d768651091803e69e4cb7ea3190cdfc45918d4637f38e1e","benches/parse.rs":"6531f66f80ce2fc83878f9bf84f94c42e96f1e709466f2b88be8d95a3cec1511","build.rs":"eedfc19afa205955347175916974cdad121b55cb940e40c61931e5e7629f0e65","src/backport.rs":"f8866548840434c8974f135528693f25aacc4ad03639c4e3aea3be351e13fdf8","src/display.rs":"9ba42f7a6579aa9c7dd72f2380036f5c9664592f3eacd09ea25cef291a3e64e5","src/error.rs":"3bb489f4a29f38d93370e64ae8d6e4e9b451a055cd7d392b6aeacab7eb3e1953","src/eval.rs":"b7e7ec976051b9f87ddf5cfdbaad64654d98d86ae0763f7d88b14eeaeac6013c","src/identifier.rs":"601231351ac58602b7d193cb0951b5146bd868b62aba938d5cbe52cf2b93414b","src/impls.rs":"79b5a2ac6ca3d4cb46adfb1494756079f53bef780dd81c3a8d3adf86f91395c8","src/lib.rs":"f59b217cd6d3e26389562710c540f0f0e1af7184ac5cbf75b2200f7ed7538f1d","src/parse.rs":"ffbb84081f0f66ec47b752a1e32f1bea5f206ca84f464b99d0497451305a92f8","src/serde.rs":"e2a9b9dc3cd2cccc250eaffad049de418ef791bf8c4a34111a48f068353e0a37","tests/node/mod.rs":"2710d9b8daace2038b66db0f8f4cc522dee938e7cbc42d7739c31995343c32f4","tests/test_autotrait.rs":"070500c32ceee14a8a0110c04a01f98278b24614a0aec8c382dcea3da0343f58","tests/test_identifier.rs":"6c3da46c73df210527b60f1069131b15e2c65eb7b5d11793940d00cf66812f4d","tests/test_version.rs":"09e37c3df162205acf3683d1c760a6001e34e1c709fd4a1a265d82450e340003","tests/test_version_req.rs":"b6eea0258cc3b6d567a9f6c42693a97316345083495236c47e85374fd45f7cf0","tests/util/mod.rs":"db61c2cd86af864d8be4f2a3d5f25c86d7712201cc6ab47b715facf5f7f275b7"},"package":"93f6841e709003d68bb2deee8c343572bf446003ec20a583e76f7b15cebf3711"}
\ No newline at end of file
diff --git a/third_party/rust/semver/Cargo.toml b/third_party/rust/semver/Cargo.toml
index 7749f76c3778..e8ad37c7ad64 100644
--- a/third_party/rust/semver/Cargo.toml
+++ b/third_party/rust/semver/Cargo.toml
@@ -3,43 +3,43 @@
 # When uploading crates to the registry Cargo will automatically
 # "normalize" Cargo.toml files for maximal compatibility
 # with all versions of Cargo and also rewrite `path` dependencies
-# to registry (e.g. crates.io) dependencies
+# to registry (e.g., crates.io) dependencies.
 #
-# If you believe there's an error in this file please file an
-# issue against the rust-lang/cargo repository. If you're
-# editing this file be aware that the upstream Cargo.toml
-# will likely look very different (and much more reasonable)
+# If you are reading this file be aware that the original Cargo.toml
+# will likely look very different (and much more reasonable).
+# See Cargo.toml.orig for the original contents.
 
 [package]
+edition = "2018"
+rust-version = "1.31"
 name = "semver"
-version = "0.9.0"
-authors = ["Steve Klabnik <steve@steveklabnik.com>", "The Rust Project Developers"]
-description = "Semantic version parsing and comparison.\n"
-homepage = "https://docs.rs/crate/semver/"
-documentation = "https://docs.rs/crate/semver/"
+version = "1.0.13"
+authors = ["David Tolnay <dtolnay@gmail.com>"]
+description = "Parser and evaluator for Cargo's flavor of Semantic Versioning"
+documentation = "https://docs.rs/semver"
 readme = "README.md"
-license = "MIT/Apache-2.0"
-repository = "https://github.com/steveklabnik/semver"
-[dependencies.semver-parser]
-version = "0.7.0"
+keywords = ["cargo"]
+categories = [
+    "data-structures",
+    "no-std",
+]
+license = "MIT OR Apache-2.0"
+repository = "https://github.com/dtolnay/semver"
+
+[package.metadata.docs.rs]
+targets = ["x86_64-unknown-linux-gnu"]
+rustdoc-args = [
+    "--cfg",
+    "doc_cfg",
+    "--cfg",
+    "semver_rustdoc_workaround",
+]
 
 [dependencies.serde]
 version = "1.0"
 optional = true
-[dev-dependencies.crates-index]
-version = "0.5.0"
-
-[dev-dependencies.serde_json]
-version = "1.0"
-
-[dev-dependencies.serde_derive]
-version = "1.0"
-
-[dev-dependencies.tempdir]
-version = "0.3.4"
+default-features = false
 
 [features]
-default = []
-ci = ["serde"]
-[badges.travis-ci]
-repository = "steveklabnik/semver"
+default = ["std"]
+std = []
diff --git a/third_party/rust/semver/LICENSE-MIT b/third_party/rust/semver/LICENSE-MIT
index 39d4bdb5acd3..31aa79387f27 100644
--- a/third_party/rust/semver/LICENSE-MIT
+++ b/third_party/rust/semver/LICENSE-MIT
@@ -1,5 +1,3 @@
-Copyright (c) 2014 The Rust Project Developers
-
 Permission is hereby granted, free of charge, to any
 person obtaining a copy of this software and associated
 documentation files (the "Software"), to deal in the
diff --git a/third_party/rust/semver/README.md b/third_party/rust/semver/README.md
index 2a5306d4ccd2..84d227ea8601 100644
--- a/third_party/rust/semver/README.md
+++ b/third_party/rust/semver/README.md
@@ -1,103 +1,84 @@
 semver
 ======
 
-Semantic version parsing and comparison.
+[<img alt="github" src="https://img.shields.io/badge/github-dtolnay/semver-8da0cb?style=for-the-badge&labelColor=555555&logo=github" height="20">](https://github.com/dtolnay/semver)
+[<img alt="crates.io" src="https://img.shields.io/crates/v/semver.svg?style=for-the-badge&color=fc8d62&logo=rust" height="20">](https://crates.io/crates/semver)
+[<img alt="docs.rs" src="https://img.shields.io/badge/docs.rs-semver-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs" height="20">](https://docs.rs/semver)
+[<img alt="build status" src="https://img.shields.io/github/workflow/status/dtolnay/semver/CI/master?style=for-the-badge" height="20">](https://github.com/dtolnay/semver/actions?query=branch%3Amaster)
 
-[![Build Status](https://api.travis-ci.org/steveklabnik/semver.svg?branch=master)](https://travis-ci.org/steveklabnik/semver)
+A parser and evaluator for Cargo's flavor of Semantic Versioning.
 
-[Documentation](https://steveklabnik.github.io/semver)
-
-Semantic versioning (see http://semver.org/) is a set of rules for
-assigning version numbers.
-
-## SemVer and the Rust ecosystem
-
-Rust itself follows the SemVer specification, as does its standard libraries. The two are
-not tied together.
-
-[Cargo](https://crates.io), Rust's package manager, uses SemVer to determine which versions of
-packages you need installed.
-
-## Installation
-
-To use `semver`, add this to your `[dependencies]` section:
+Semantic Versioning (see <https://semver.org>) is a guideline for how version
+numbers are assigned and incremented. It is widely followed within the
+Cargo/crates.io ecosystem for Rust.
 
 ```toml
-semver = "0.7.0"
-```
-
-And this to your crate root:
-
-```rust
-extern crate semver;
+[dependencies]
+semver = "1.0"
 ```
 
-## Versions
+*Compiler support: requires rustc 1.31+*
 
-At its simplest, the `semver` crate allows you to construct `Version` objects using the `parse`
-method:
+<br>
 
-```rust
-use semver::Version;
-
-assert!(Version::parse("1.2.3") == Ok(Version {
-   major: 1,
-   minor: 2,
-   patch: 3,
-   pre: vec!(),
-   build: vec!(),
-}));
-```
-
-If you have multiple `Version`s, you can use the usual comparison operators to compare them:
+## Example
 
 ```rust
-use semver::Version;
-
-assert!(Version::parse("1.2.3-alpha")  != Version::parse("1.2.3-beta"));
-assert!(Version::parse("1.2.3-alpha2") >  Version::parse("1.2.0"));
+use semver::{BuildMetadata, Prerelease, Version, VersionReq};
+
+fn main() {
+    let req = VersionReq::parse(">=1.2.3, <1.8.0").unwrap();
+
+    // Check whether this requirement matches version 1.2.3-alpha.1 (no)
+    let version = Version {
+        major: 1,
+        minor: 2,
+        patch: 3,
+        pre: Prerelease::new("alpha.1").unwrap(),
+        build: BuildMetadata::EMPTY,
+    };
+    assert!(!req.matches(&version));
+
+    // Check whether it matches 1.3.0 (yes it does)
+    let version = Version::parse("1.3.0").unwrap();
+    assert!(req.matches(&version));
+}
 ```
 
-## Requirements
+<br>
 
-The `semver` crate also provides the ability to compare requirements, which are more complex
-comparisons.
+## Scope of this crate
 
-For example, creating a requirement that only matches versions greater than or
-equal to 1.0.0:
+Besides Cargo, several other package ecosystems and package managers for other
+languages also use SemVer:&ensp;RubyGems/Bundler for Ruby, npm for JavaScript,
+Composer for PHP, CocoaPods for Objective-C...
 
-```rust
-use semver::Version;
-use semver::VersionReq;
+The `semver` crate is specifically intended to implement Cargo's interpretation
+of Semantic Versioning.
 
-let r = VersionReq::parse(">= 1.0.0").unwrap();
-let v = Version::parse("1.0.0").unwrap();
+Where the various tools differ in their interpretation or implementation of the
+spec, this crate follows the implementation choices made by Cargo. If you are
+operating on version numbers from some other package ecosystem, you will want to
+use a different semver library which is appropriate to that ecosystem.
 
-assert!(r.to_string() == ">= 1.0.0".to_string());
-assert!(r.matches(&v))
-```
+The extent of Cargo's SemVer support is documented in the *[Specifying
+Dependencies]* chapter of the Cargo reference.
 
-It also allows parsing of `~x.y.z` and `^x.y.z` requirements as defined at
-https://www.npmjs.org/doc/misc/semver.html
+[Specifying Dependencies]: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html
 
-**Tilde requirements** specify a minimal version with some updates:
+<br>
 
-```notrust
-~1.2.3 := >=1.2.3 <1.3.0
-~1.2   := >=1.2.0 <1.3.0
-~1     := >=1.0.0 <2.0.0
-```
+#### License
 
-**Caret requirements** allow SemVer compatible updates to a specified version,
-`0.x` and `0.x+1` are not considered compatible, but `1.x` and `1.x+1` are.
+<sup>
+Licensed under either of <a href="LICENSE-APACHE">Apache License, Version
+2.0</a> or <a href="LICENSE-MIT">MIT license</a> at your option.
+</sup>
 
-`0.0.x` is not considered compatible with any other version.
-Missing minor and patch versions are desugared to `0` but allow flexibility for that value.
+<br>
 
-```notrust
-^1.2.3 := >=1.2.3 <2.0.0
-^0.2.3 := >=0.2.3 <0.3.0
-^0.0.3 := >=0.0.3 <0.0.4
-^0.0   := >=0.0.0 <0.1.0
-^0     := >=0.0.0 <1.0.0
-```
+<sub>
+Unless you explicitly state otherwise, any contribution intentionally submitted
+for inclusion in this crate by you, as defined in the Apache-2.0 license, shall
+be dual licensed as above, without any additional terms or conditions.
+</sub>
diff --git a/third_party/rust/semver/benches/parse.rs b/third_party/rust/semver/benches/parse.rs
new file mode 100644
index 000000000000..d6aded7802f0
--- /dev/null
+++ b/third_party/rust/semver/benches/parse.rs
@@ -0,0 +1,24 @@
+#![feature(test)]
+
+extern crate test;
+
+use semver::{Prerelease, Version, VersionReq};
+use test::{black_box, Bencher};
+
+#[bench]
+fn parse_prerelease(b: &mut Bencher) {
+    let text = "x.7.z.92";
+    b.iter(|| black_box(text).parse::<Prerelease>().unwrap());
+}
+
+#[bench]
+fn parse_version(b: &mut Bencher) {
+    let text = "1.0.2021-beta+exp.sha.5114f85";
+    b.iter(|| black_box(text).parse::<Version>().unwrap());
+}
+
+#[bench]
+fn parse_version_req(b: &mut Bencher) {
+    let text = ">=1.2.3, <2.0.0";
+    b.iter(|| black_box(text).parse::<VersionReq>().unwrap());
+}
diff --git a/third_party/rust/semver/build.rs b/third_party/rust/semver/build.rs
new file mode 100644
index 000000000000..2bf4418c1220
--- /dev/null
+++ b/third_party/rust/semver/build.rs
@@ -0,0 +1,73 @@
+use std::env;
+use std::process::Command;
+use std::str;
+
+fn main() {
+    let compiler = match rustc_minor_version() {
+        Some(compiler) => compiler,
+        None => return,
+    };
+
+    if compiler < 33 {
+        // Exhaustive integer patterns. On older compilers, a final `_` arm is
+        // required even if every possible integer value is otherwise covered.
+        // https://github.com/rust-lang/rust/issues/50907
+        println!("cargo:rustc-cfg=no_exhaustive_int_match");
+    }
+
+    if compiler < 36 {
+        // extern crate alloc.
+        // https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html#the-alloc-crate-is-stable
+        println!("cargo:rustc-cfg=no_alloc_crate");
+    }
+
+    if compiler < 39 {
+        // const Vec::new.
+        // https://doc.rust-lang.org/std/vec/struct.Vec.html#method.new
+        println!("cargo:rustc-cfg=no_const_vec_new");
+    }
+
+    if compiler < 40 {
+        // #[non_exhaustive].
+        // https://blog.rust-lang.org/2019/12/19/Rust-1.40.0.html#non_exhaustive-structs-enums-and-variants
+        println!("cargo:rustc-cfg=no_non_exhaustive");
+    }
+
+    if compiler < 45 {
+        // String::strip_prefix.
+        // https://doc.rust-lang.org/std/primitive.str.html#method.strip_prefix
+        println!("cargo:rustc-cfg=no_str_strip_prefix");
+    }
+
+    if compiler < 46 {
+        // #[track_caller].
+        // https://blog.rust-lang.org/2020/08/27/Rust-1.46.0.html#track_caller
+        println!("cargo:rustc-cfg=no_track_caller");
+    }
+
+    if compiler < 52 {
+        // #![deny(unsafe_op_in_unsafe_fn)].
+        // https://github.com/rust-lang/rust/issues/71668
+        println!("cargo:rustc-cfg=no_unsafe_op_in_unsafe_fn_lint");
+    }
+
+    if compiler < 53 {
+        // Efficient intrinsics for count-leading-zeros and count-trailing-zeros
+        // on NonZero integers stabilized in 1.53.0. On many architectures these
+        // are more efficient than counting zeros on ordinary zeroable integers.
+        // https://doc.rust-lang.org/std/num/struct.NonZeroU64.html#method.leading_zeros
+        // https://doc.rust-lang.org/std/num/struct.NonZeroU64.html#method.trailing_zeros
+        println!("cargo:rustc-cfg=no_nonzero_bitscan");
+    }
+}
+
+fn rustc_minor_version() -> Option<u32> {
+    let rustc = env::var_os("RUSTC")?;
+    let output = Command::new(rustc).arg("--version").output().ok()?;
+    let version = str::from_utf8(&output.stdout).ok()?;
+    let mut pieces = version.split('.');
+    if pieces.next() != Some("rustc 1") {
+        return None;
+    }
+    pieces.next()?.parse().ok()
+}
diff --git a/third_party/rust/semver/src/backport.rs b/third_party/rust/semver/src/backport.rs
new file mode 100644
index 000000000000..c7751b29f3b4
--- /dev/null
+++ b/third_party/rust/semver/src/backport.rs
@@ -0,0 +1,51 @@
+#[cfg(no_str_strip_prefix)] // rustc <1.45
+pub(crate) trait StripPrefixExt {
+    fn strip_prefix(&self, ch: char) -> Option<&str>;
+}
+
+#[cfg(no_str_strip_prefix)]
+impl StripPrefixExt for str {
+    fn strip_prefix(&self, ch: char) -> Option<&str> {
+        if self.starts_with(ch) {
+            Some(&self[ch.len_utf8()..])
+        } else {
+            None
+        }
+    }
+}
+
+pub(crate) use crate::alloc::vec::Vec;
+
+#[cfg(no_alloc_crate)] // rustc <1.36
+pub(crate) mod alloc {
+    pub use std::vec;
+
+    pub mod alloc {
+        use std::mem;
+
+        pub struct Layout {
+            size: usize,
+        }
+
+        impl Layout {
+            pub unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {
+                assert_eq!(align, 2);
+                Layout { size }
+            }
+        }
+
+        pub unsafe fn alloc(layout: Layout) -> *mut u8 {
+            let len_u16 = (layout.size + 1) / 2;
+            let mut vec = Vec::new();
+            vec.reserve_exact(len_u16);
+            let ptr: *mut u16 = vec.as_mut_ptr();
+            mem::forget(vec);
+            ptr as *mut u8
+        }
+
+        pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {
+            let len_u16 = (layout.size + 1) / 2;
+            unsafe { Vec::from_raw_parts(ptr as *mut u16, 0, len_u16) };
+        }
+    }
+}
diff --git a/third_party/rust/semver/src/display.rs b/third_party/rust/semver/src/display.rs
new file mode 100644
index 000000000000..3c2871bb9783
--- /dev/null
+++ b/third_party/rust/semver/src/display.rs
@@ -0,0 +1,165 @@
+use crate::{BuildMetadata, Comparator, Op, Prerelease, Version, VersionReq};
+use core::fmt::{self, Alignment, Debug, Display, Write};
+
+impl Display for Version {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        let do_display = |formatter: &mut fmt::Formatter| -> fmt::Result {
+            write!(formatter, "{}.{}.{}", self.major, self.minor, self.patch)?;
+            if !self.pre.is_empty() {
+                write!(formatter, "-{}", self.pre)?;
+            }
+            if !self.build.is_empty() {
+                write!(formatter, "+{}", self.build)?;
+            }
+            Ok(())
+        };
+
+        let do_len = || -> usize {
+            digits(self.major)
+                + 1
+                + digits(self.minor)
+                + 1
+                + digits(self.patch)
+                + !self.pre.is_empty() as usize
+                + self.pre.len()
+                + !self.build.is_empty() as usize
+                + self.build.len()
+        };
+
+        pad(formatter, do_display, do_len)
+    }
+}
+
+impl Display for VersionReq {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        if self.comparators.is_empty() {
+            return formatter.write_str("*");
+        }
+        for (i, comparator) in self.comparators.iter().enumerate() {
+            if i > 0 {
+                formatter.write_str(", ")?;
+            }
+            write!(formatter, "{}", comparator)?;
+        }
+        Ok(())
+    }
+}
+
+impl Display for Comparator {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        let op = match self.op {
+            Op::Exact => "=",
+            Op::Greater => ">",
+            Op::GreaterEq => ">=",
+            Op::Less => "<",
+            Op::LessEq => "<=",
+            Op::Tilde => "~",
+            Op::Caret => "^",
+            Op::Wildcard => "",
+            #[cfg(no_non_exhaustive)]
+            Op::__NonExhaustive => unreachable!(),
+        };
+        formatter.write_str(op)?;
+        write!(formatter, "{}", self.major)?;
+        if let Some(minor) = &self.minor {
+            write!(formatter, ".{}", minor)?;
+            if let Some(patch) = &self.patch {
+                write!(formatter, ".{}", patch)?;
+                if !self.pre.is_empty() {
+                    write!(formatter, "-{}", self.pre)?;
+                }
+            } else if self.op == Op::Wildcard {
+                formatter.write_str(".*")?;
+            }
+        } else if self.op == Op::Wildcard {
+            formatter.write_str(".*")?;
+        }
+        Ok(())
+    }
+}
+
+impl Display for Prerelease {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        formatter.write_str(self.as_str())
+    }
+}
+
+impl Display for BuildMetadata {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        formatter.write_str(self.as_str())
+    }
+}
+
+impl Debug for Version {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        let mut debug = formatter.debug_struct("Version");
+        debug
+            .field("major", &self.major)
+            .field("minor", &self.minor)
+            .field("patch", &self.patch);
+        if !self.pre.is_empty() {
+            debug.field("pre", &self.pre);
+        }
+        if !self.build.is_empty() {
+            debug.field("build", &self.build);
+        }
+        debug.finish()
+    }
+}
+
+impl Debug for Prerelease {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        write!(formatter, "Prerelease(\"{}\")", self)
+    }
+}
+
+impl Debug for BuildMetadata {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        write!(formatter, "BuildMetadata(\"{}\")", self)
+    }
+}
+
+fn pad(
+    formatter: &mut fmt::Formatter,
+    do_display: impl FnOnce(&mut fmt::Formatter) -> fmt::Result,
+    do_len: impl FnOnce() -> usize,
+) -> fmt::Result {
+    let min_width = match formatter.width() {
+        Some(min_width) => min_width,
+        None => return do_display(formatter),
+    };
+
+    let len = do_len();
+    if len >= min_width {
+        return do_display(formatter);
+    }
+
+    let default_align = Alignment::Left;
+    let align = formatter.align().unwrap_or(default_align);
+    let padding = min_width - len;
+    let (pre_pad, post_pad) = match align {
+        Alignment::Left => (0, padding),
+        Alignment::Right => (padding, 0),
+        Alignment::Center => (padding / 2, (padding + 1) / 2),
+    };
+
+    let fill = formatter.fill();
+    for _ in 0..pre_pad {
+        formatter.write_char(fill)?;
+    }
+
+    do_display(formatter)?;
+
+    for _ in 0..post_pad {
+        formatter.write_char(fill)?;
+    }
+    Ok(())
+}
+
+fn digits(val: u64) -> usize {
+    if val < 10 {
+        1
+    } else {
+        1 + digits(val / 10)
+    }
+}
diff --git a/third_party/rust/semver/src/error.rs b/third_party/rust/semver/src/error.rs
new file mode 100644
index 000000000000..a514e3f11e8f
--- /dev/null
+++ b/third_party/rust/semver/src/error.rs
@@ -0,0 +1,124 @@
+use crate::parse::Error;
+use core::fmt::{self, Debug, Display};
+
+pub(crate) enum ErrorKind {
+    UnexpectedEnd(Position),
+    UnexpectedChar(Position, char),
+    UnexpectedCharAfter(Position, char),
+    ExpectedCommaFound(Position, char),
+    LeadingZero(Position),
+    Overflow(Position),
+    EmptySegment(Position),
+    IllegalCharacter(Position),
+    WildcardNotTheOnlyComparator(char),
+    UnexpectedAfterWildcard,
+    ExcessiveComparators,
+}
+
+#[derive(Copy, Clone, Eq, PartialEq)]
+pub(crate) enum Position {
+    Major,
+    Minor,
+    Patch,
+    Pre,
+    Build,
+}
+
+#[cfg(feature = "std")]
+#[cfg_attr(doc_cfg, doc(cfg(feature = "std")))]
+impl std::error::Error for Error {}
+
+impl Display for Error {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        match &self.kind {
+            ErrorKind::UnexpectedEnd(pos) => {
+                write!(formatter, "unexpected end of input while parsing {}", pos)
+            }
+            ErrorKind::UnexpectedChar(pos, ch) => {
+                write!(
+                    formatter,
+                    "unexpected character {} while parsing {}",
+                    QuotedChar(*ch),
+                    pos,
+                )
+            }
+            ErrorKind::UnexpectedCharAfter(pos, ch) => {
+                write!(
+                    formatter,
+                    "unexpected character {} after {}",
+                    QuotedChar(*ch),
+                    pos,
+                )
+            }
+            ErrorKind::ExpectedCommaFound(pos, ch) => {
+                write!(
+                    formatter,
+                    "expected comma after {}, found {}",
+                    pos,
+                    QuotedChar(*ch),
+                )
+            }
+            ErrorKind::LeadingZero(pos) => {
+                write!(formatter, "invalid leading zero in {}", pos)
+            }
+            ErrorKind::Overflow(pos) => {
+                write!(formatter, "value of {} exceeds u64::MAX", pos)
+            }
+            ErrorKind::EmptySegment(pos) => {
+                write!(formatter, "empty identifier segment in {}", pos)
+            }
+            ErrorKind::IllegalCharacter(pos) => {
+                write!(formatter, "unexpected character in {}", pos)
+            }
+            ErrorKind::WildcardNotTheOnlyComparator(ch) => {
+                write!(
+                    formatter,
+                    "wildcard req ({}) must be the only comparator in the version req",
+                    ch,
+                )
+            }
+            ErrorKind::UnexpectedAfterWildcard => {
+                formatter.write_str("unexpected character after wildcard in version req")
+            }
+            ErrorKind::ExcessiveComparators => {
+                formatter.write_str("excessive number of version comparators")
+            }
+        }
+    }
+}
+
+impl Display for Position {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        formatter.write_str(match self {
+            Position::Major => "major version number",
+            Position::Minor => "minor version number",
+            Position::Patch => "patch version number",
+            Position::Pre => "pre-release identifier",
+            Position::Build => "build metadata",
+        })
+    }
+}
+
+impl Debug for Error {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        formatter.write_str("Error(\"")?;
+        Display::fmt(self, formatter)?;
+        formatter.write_str("\")")?;
+        Ok(())
+    }
+}
+
+struct QuotedChar(char);
+
+impl Display for QuotedChar {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        // Standard library versions prior to https://github.com/rust-lang/rust/pull/95345
+        // print character 0 as '\u{0}'. We prefer '\0' to keep error messages
+        // the same across all supported Rust versions.
+        if self.0 == '\0' {
+            formatter.write_str("'\\0'")
+        } else {
+            write!(formatter, "{:?}", self.0)
+        }
+    }
+}
diff --git a/third_party/rust/semver/src/eval.rs b/third_party/rust/semver/src/eval.rs
new file mode 100644
index 000000000000..e6e38949a93f
--- /dev/null
+++ b/third_party/rust/semver/src/eval.rs
@@ -0,0 +1,181 @@
+use crate::{Comparator, Op, Version, VersionReq};
+
+pub(crate) fn matches_req(req: &VersionReq, ver: &Version) -> bool {
+    for cmp in &req.comparators {
+        if !matches_impl(cmp, ver) {
+            return false;
+        }
+    }
+
+    if ver.pre.is_empty() {
+        return true;
+    }
+
+    // If a version has a prerelease tag (for example, 1.2.3-alpha.3) then it
+    // will only be allowed to satisfy req if at least one comparator with the
+    // same major.minor.patch also has a prerelease tag.
+    for cmp in &req.comparators {
+        if pre_is_compatible(cmp, ver) {
+            return true;
+        }
+    }
+
+    false
+}
+
+pub(crate) fn matches_comparator(cmp: &Comparator, ver: &Version) -> bool {
+    matches_impl(cmp, ver) && (ver.pre.is_empty() || pre_is_compatible(cmp, ver))
+}
+
+fn matches_impl(cmp: &Comparator, ver: &Version) -> bool {
+    match cmp.op {
+        Op::Exact | Op::Wildcard => matches_exact(cmp, ver),
+        Op::Greater => matches_greater(cmp, ver),
+        Op::GreaterEq => matches_exact(cmp, ver) || matches_greater(cmp, ver),
+        Op::Less => matches_less(cmp, ver),
+        Op::LessEq => matches_exact(cmp, ver) || matches_less(cmp, ver),
+        Op::Tilde => matches_tilde(cmp, ver),
+        Op::Caret => matches_caret(cmp, ver),
+        #[cfg(no_non_exhaustive)]
+        Op::__NonExhaustive => unreachable!(),
+    }
+}
+
+fn matches_exact(cmp: &Comparator, ver: &Version) -> bool {
+    if ver.major != cmp.major {
+        return false;
+    }
+
+    if let Some(minor) = cmp.minor {
+        if ver.minor != minor {
+            return false;
+        }
+    }
+
+    if let Some(patch) = cmp.patch {
+        if ver.patch != patch {
+            return false;
+        }
+    }
+
+    ver.pre == cmp.pre
+}
+
+fn matches_greater(cmp: &Comparator, ver: &Version) -> bool {
+    if ver.major != cmp.major {
+        return ver.major > cmp.major;
+    }
+
+    match cmp.minor {
+        None => return false,
+        Some(minor) => {
+            if ver.minor != minor {
+                return ver.minor > minor;
+            }
+        }
+    }
+
+    match cmp.patch {
+        None => return false,
+        Some(patch) => {
+            if ver.patch != patch {
+                return ver.patch > patch;
+            }
+        }
+    }
+
+    ver.pre > cmp.pre
+}
+
+fn matches_less(cmp: &Comparator, ver: &Version) -> bool {
+    if ver.major != cmp.major {
+        return ver.major < cmp.major;
+    }
+
+    match cmp.minor {
+        None => return false,
+        Some(minor) => {
+            if ver.minor != minor {
+                return ver.minor < minor;
+            }
+        }
+    }
+
+    match cmp.patch {
+        None => return false,
+        Some(patch) => {
+            if ver.patch != patch {
+                return ver.patch < patch;
+            }
+        }
+    }
+
+    ver.pre < cmp.pre
+}
+
+fn matches_tilde(cmp: &Comparator, ver: &Version) -> bool {
+    if ver.major != cmp.major {
+        return false;
+    }
+
+    if let Some(minor) = cmp.minor {
+        if ver.minor != minor {
+            return false;
+        }
+    }
+
+    if let Some(patch) = cmp.patch {
+        if ver.patch != patch {
+            return ver.patch > patch;
+        }
+    }
+
+    ver.pre >= cmp.pre
+}
+
+fn matches_caret(cmp: &Comparator, ver: &Version) -> bool {
+    if ver.major != cmp.major {
+        return false;
+    }
+
+    let minor = match cmp.minor {
+        None => return true,
+        Some(minor) => minor,
+    };
+
+    let patch = match cmp.patch {
+        None => {
+            if cmp.major > 0 {
+                return ver.minor >= minor;
+            } else {
+                return ver.minor == minor;
+            }
+        }
+        Some(patch) => patch,
+    };
+
+    if cmp.major > 0 {
+        if ver.minor != minor {
+            return ver.minor > minor;
+        } else if ver.patch != patch {
+            return ver.patch > patch;
+        }
+    } else if minor > 0 {
+        if ver.minor != minor {
+            return false;
+        } else if ver.patch != patch {
+            return ver.patch > patch;
+        }
+    } else if ver.minor != minor || ver.patch != patch {
+        return false;
+    }
+
+    ver.pre >= cmp.pre
+}
+
+fn pre_is_compatible(cmp: &Comparator, ver: &Version) -> bool {
+    cmp.major == ver.major
+        && cmp.minor == Some(ver.minor)
+        && cmp.patch == Some(ver.patch)
+        && !cmp.pre.is_empty()
+}
diff --git a/third_party/rust/semver/src/identifier.rs b/third_party/rust/semver/src/identifier.rs
new file mode 100644
index 000000000000..170a4e05e118
--- /dev/null
+++ b/third_party/rust/semver/src/identifier.rs
@@ -0,0 +1,400 @@
+// This module implements Identifier, a short-optimized string allowed to
+// contain only the ASCII characters hyphen, dot, 0-9, A-Z, a-z.
+//
+// As of mid-2021, the distribution of pre-release lengths on crates.io is:
+//
+//     length  count         length  count         length  count
+//        0  355929            11      81            24       2
+//        1     208            12      48            25       6
+//        2     236            13      55            26      10
+//        3    1909            14      25            27       4
+//        4    1284            15      15            28       1
+//        5    1742            16      35            30       1
+//        6    3440            17       9            31       5
+//        7    5624            18       6            32       1
+//        8    1321            19      12            36       2
+//        9     179            20       2            37     379
+//       10      65            23      11
+//
+// and the distribution of build metadata lengths is:
+//
+//     length  count         length  count         length  count
+//        0  364445             8    7725            18       1
+//        1      72             9      16            19       1
+//        2       7            10      85            20       1
+//        3      28            11      17            22       4
+//        4       9            12      10            26       1
+//        5      68            13       9            27       1
+//        6      73            14      10            40       5
+//        7      53            15       6
+//
+// Therefore it really behooves us to be able to use the entire 8 bytes of a
+// pointer for inline storage. For both pre-release and build metadata there are
+// vastly more strings with length exactly 8 bytes than the sum over all lengths
+// longer than 8 bytes.
+//
+// To differentiate the inline representation from the heap allocated long
+// representation, we'll allocate heap pointers with 2-byte alignment so that
+// they are guaranteed to have an unset least significant bit. Then in the repr
+// we store for pointers, we rotate a 1 into the most significant bit of the
+// most significant byte, which is never set for an ASCII byte.
+//
+// Inline repr:
+//
+//     0xxxxxxx 0xxxxxxx 0xxxxxxx 0xxxxxxx 0xxxxxxx 0xxxxxxx 0xxxxxxx 0xxxxxxx
+//
+// Heap allocated repr:
+//
+//     1ppppppp pppppppp pppppppp pppppppp pppppppp pppppppp pppppppp pppppppp 0
+//     ^ most significant bit   least significant bit of orig ptr, rotated out ^
+//
+// Since the most significant bit doubles as a sign bit for the similarly sized
+// signed integer type, the CPU has an efficient instruction for inspecting it,
+// meaning we can differentiate between an inline repr and a heap allocated repr
+// in one instruction. Effectively an inline repr always looks like a positive
+// i64 while a heap allocated repr always looks like a negative i64.
+//
+// For the inline repr, we store \0 padding on the end of the stored characters,
+// and thus the string length is readily determined efficiently by a cttz (count
+// trailing zeros) or bsf (bit scan forward) instruction.
+//
+// For the heap allocated repr, the length is encoded as a base-128 varint at
+// the head of the allocation.
+//
+// Empty strings are stored as an all-1 bit pattern, corresponding to -1i64.
+// Consequently the all-0 bit pattern is never a legal representation in any
+// repr, leaving it available as a niche for downstream code. For example this
+// allows size_of::<Version>() == size_of::<Option<Version>>().
+
+use crate::alloc::alloc::{alloc, dealloc, Layout};
+use core::mem;
+use core::num::{NonZeroU64, NonZeroUsize};
+use core::ptr::{self, NonNull};
+use core::slice;
+use core::str;
+
+const PTR_BYTES: usize = mem::size_of::<NonNull<u8>>();
+
+// If pointers are already 8 bytes or bigger, then 0. If pointers are smaller
+// than 8 bytes, then Identifier will contain a byte array to raise its size up
+// to 8 bytes total.
+const TAIL_BYTES: usize = 8 * (PTR_BYTES < 8) as usize - PTR_BYTES * (PTR_BYTES < 8) as usize;
+
+#[repr(C, align(8))]
+pub(crate) struct Identifier {
+    head: NonNull<u8>,
+    tail: [u8; TAIL_BYTES],
+}
+
+impl Identifier {
+    pub(crate) const fn empty() -> Self {
+        // This is a separate constant because unsafe function calls are not
+        // allowed in a const fn body, only in a const, until later rustc than
+        // what we support.
+        const HEAD: NonNull<u8> = unsafe { NonNull::new_unchecked(!0 as *mut u8) };
+
+        // `mov rax, -1`
+        Identifier {
+            head: HEAD,
+            tail: [!0; TAIL_BYTES],
+        }
+    }
+
+    // SAFETY: string must be ASCII and not contain \0 bytes.
+    pub(crate) unsafe fn new_unchecked(string: &str) -> Self {
+        let len = string.len();
+        match len as u64 {
+            0 => Self::empty(),
+            1..=8 => {
+                let mut bytes = [0u8; mem::size_of::<Identifier>()];
+                // SAFETY: string is big enough to read len bytes, bytes is big
+                // enough to write len bytes, and they do not overlap.
+                unsafe { ptr::copy_nonoverlapping(string.as_ptr(), bytes.as_mut_ptr(), len) };
+                // SAFETY: the head field is nonzero because the input string
+                // was at least 1 byte of ASCII and did not contain \0.
+                unsafe { mem::transmute::<[u8; mem::size_of::<Identifier>()], Identifier>(bytes) }
+            }
+            9..=0xff_ffff_ffff_ffff => {
+                // SAFETY: len is in a range that does not contain 0.
+                let size = bytes_for_varint(unsafe { NonZeroUsize::new_unchecked(len) }) + len;
+                let align = 2;
+                // SAFETY: align is not zero, align is a power of two, and
+                // rounding size up to align does not overflow usize::MAX.
+                let layout = unsafe { Layout::from_size_align_unchecked(size, align) };
+                // SAFETY: layout's size is nonzero.
+                let ptr = unsafe { alloc(layout) };
+                let mut write = ptr;
+                let mut varint_remaining = len;
+                while varint_remaining > 0 {
+                    // SAFETY: size is bytes_for_varint(len) bytes + len bytes.
+                    // This is writing the first bytes_for_varint(len) bytes.
+                    unsafe { ptr::write(write, varint_remaining as u8 | 0x80) };
+                    varint_remaining >>= 7;
+                    // SAFETY: still in bounds of the same allocation.
+                    write = unsafe { write.add(1) };
+                }
+                // SAFETY: size is bytes_for_varint(len) bytes + len bytes. This
+                // is writing to the last len bytes.
+                unsafe { ptr::copy_nonoverlapping(string.as_ptr(), write, len) };
+                Identifier {
+                    head: ptr_to_repr(ptr),
+                    tail: [0; TAIL_BYTES],
+                }
+            }
+            0x100_0000_0000_0000..=0xffff_ffff_ffff_ffff => {
+                unreachable!("please refrain from storing >64 petabytes of text in semver version");
+            }
+            #[cfg(no_exhaustive_int_match)] // rustc <1.33
+            _ => unreachable!(),
+        }
+    }
+
+    pub(crate) fn is_empty(&self) -> bool {
+        // `cmp rdi, -1` -- basically: `repr as i64 == -1`
+        let empty = Self::empty();
+        let is_empty = self.head == empty.head && self.tail == empty.tail;
+        // The empty representation does nothing on Drop. We can't let this one
+        // drop normally because `impl Drop for Identifier` calls is_empty; that
+        // would be an infinite recursion.
+        mem::forget(empty);
+        is_empty
+    }
+
+    fn is_inline(&self) -> bool {
+        // `test rdi, rdi` -- basically: `repr as i64 >= 0`
+        self.head.as_ptr() as usize >> (PTR_BYTES * 8 - 1) == 0
+    }
+
+    fn is_empty_or_inline(&self) -> bool {
+        // `cmp rdi, -2` -- basically: `repr as i64 > -2`
+        self.is_empty() || self.is_inline()
+    }
+
+    pub(crate) fn as_str(&self) -> &str {
+        if self.is_empty() {
+            ""
+        } else if self.is_inline() {
+            // SAFETY: repr is in the inline representation.
+            unsafe { inline_as_str(self) }
+        } else {
+            // SAFETY: repr is in the heap allocated representation.
+            unsafe { ptr_as_str(&self.head) }
+        }
+    }
+}
+
+impl Clone for Identifier {
+    fn clone(&self) -> Self {
+        if self.is_empty_or_inline() {
+            Identifier {
+                head: self.head,
+                tail: self.tail,
+            }
+        } else {
+            let ptr = repr_to_ptr(self.head);
+            // SAFETY: ptr is one of our own heap allocations.
+            let len = unsafe { decode_len(ptr) };
+            let size = bytes_for_varint(len) + len.get();
+            let align = 2;
+            // SAFETY: align is not zero, align is a power of two, and rounding
+            // size up to align does not overflow usize::MAX. This is just
+            // duplicating a previous allocation where all of these guarantees
+            // were already made.
+            let layout = unsafe { Layout::from_size_align_unchecked(size, align) };
+            // SAFETY: layout's size is nonzero.
+            let clone = unsafe { alloc(layout) };
+            // SAFETY: new allocation cannot overlap the previous one (this was
+            // not a realloc). The argument ptrs are readable/writeable
+            // respectively for size bytes.
+            unsafe { ptr::copy_nonoverlapping(ptr, clone, size) }
+            Identifier {
+                head: ptr_to_repr(clone),
+                tail: [0; TAIL_BYTES],
+            }
+        }
+    }
+}
+
+impl Drop for Identifier {
+    fn drop(&mut self) {
+        if self.is_empty_or_inline() {
+            return;
+        }
+        let ptr = repr_to_ptr_mut(self.head);
+        // SAFETY: ptr is one of our own heap allocations.
+        let len = unsafe { decode_len(ptr) };
+        let size = bytes_for_varint(len) + len.get();
+        let align = 2;
+        // SAFETY: align is not zero, align is a power of two, and rounding
+        // size up to align does not overflow usize::MAX. These guarantees were
+        // made when originally allocating this memory.
+        let layout = unsafe { Layout::from_size_align_unchecked(size, align) };
+        // SAFETY: ptr was previously allocated by the same allocator with the
+        // same layout.
+        unsafe { dealloc(ptr, layout) }
+    }
+}
+
+impl PartialEq for Identifier {
+    fn eq(&self, rhs: &Self) -> bool {
+        if self.is_empty_or_inline() {
+            // Fast path (most common)
+            self.head == rhs.head && self.tail == rhs.tail
+        } else if rhs.is_empty_or_inline() {
+            false
+        } else {
+            // SAFETY: both reprs are in the heap allocated representation.
+            unsafe { ptr_as_str(&self.head) == ptr_as_str(&rhs.head) }
+        }
+    }
+}
+
+unsafe impl Send for Identifier {}
+unsafe impl Sync for Identifier {}
+
+// We use heap pointers that are 2-byte aligned, meaning they have an
+// insignificant 0 in the least significant bit. We take advantage of that
+// unneeded bit to rotate a 1 into the most significant bit to make the repr
+// distinguishable from ASCII bytes.
+fn ptr_to_repr(original: *mut u8) -> NonNull<u8> {
+    // `mov eax, 1`
+    // `shld rax, rdi, 63`
+    let modified = (original as usize | 1).rotate_right(1);
+
+    // `original + (modified - original)`, but being mindful of provenance.
+    let diff = modified.wrapping_sub(original as usize);
+    let modified = original.wrapping_add(diff);
+
+    // SAFETY: the most significant bit of repr is known to be set, so the value
+    // is not zero.
+    unsafe { NonNull::new_unchecked(modified) }
+}
+
+// Shift out the 1 previously placed into the most significant bit of the least
+// significant byte. Shift in a low 0 bit to reconstruct the original 2-byte
+// aligned pointer.
+fn repr_to_ptr(modified: NonNull<u8>) -> *const u8 {
+    // `lea rax, [rdi + rdi]`
+    let modified = modified.as_ptr();
+    let original = (modified as usize) << 1;
+
+    // `modified + (original - modified)`, but being mindful of provenance.
+    let diff = original.wrapping_sub(modified as usize);
+    modified.wrapping_add(diff)
+}
+
+fn repr_to_ptr_mut(repr: NonNull<u8>) -> *mut u8 {
+    repr_to_ptr(repr) as *mut u8
+}
+
+// Compute the length of the inline string, assuming the argument is in short
+// string representation. Short strings are stored as 1 to 8 nonzero ASCII
+// bytes, followed by \0 padding for the remaining bytes.
+//
+// SAFETY: the identifier must indeed be in the inline representation.
+unsafe fn inline_len(repr: &Identifier) -> NonZeroUsize {
+    // SAFETY: Identifier's layout is align(8) and at least size 8. We're doing
+    // an aligned read of the first 8 bytes from it. The bytes are not all zero
+    // because inline strings are at least 1 byte long and cannot contain \0.
+    let repr = unsafe { ptr::read(repr as *const Identifier as *const NonZeroU64) };
+
+    // Rustc >=1.53 has intrinsics for counting zeros on a non-zeroable integer.
+    // On many architectures these are more efficient than counting on ordinary
+    // zeroable integers (bsf vs cttz). On rustc <1.53 without those intrinsics,
+    // we count zeros in the u64 rather than the NonZeroU64.
+    #[cfg(no_nonzero_bitscan)]
+    let repr = repr.get();
+
+    #[cfg(target_endian = "little")]
+    let zero_bits_on_string_end = repr.leading_zeros();
+    #[cfg(target_endian = "big")]
+    let zero_bits_on_string_end = repr.trailing_zeros();
+
+    let nonzero_bytes = 8 - zero_bits_on_string_end as usize / 8;
+
+    // SAFETY: repr is nonzero, so it has at most 63 zero bits on either end,
+    // thus at least one nonzero byte.
+    unsafe { NonZeroUsize::new_unchecked(nonzero_bytes) }
+}
+
+// SAFETY: repr must be in the inline representation, i.e. at least 1 and at
+// most 8 nonzero ASCII bytes padded on the end with \0 bytes.
+unsafe fn inline_as_str(repr: &Identifier) -> &str {
+    let ptr = repr as *const Identifier as *const u8;
+    let len = unsafe { inline_len(repr) }.get();
+    // SAFETY: we are viewing the nonzero ASCII prefix of the inline repr's
+    // contents as a slice of bytes. Input/output lifetimes are correctly
+    // associated.
+    let slice = unsafe { slice::from_raw_parts(ptr, len) };
+    // SAFETY: the string contents are known to be only ASCII bytes, which are
+    // always valid UTF-8.
+    unsafe { str::from_utf8_unchecked(slice) }
+}
+
+// Decode varint. Varints consist of between one and eight base-128 digits, each
+// of which is stored in a byte with most significant bit set. Adjacent to the
+// varint in memory there is guaranteed to be at least 9 ASCII bytes, each of
+// which has an unset most significant bit.
+//
+// SAFETY: ptr must be one of our own heap allocations, with the varint header
+// already written.
+unsafe fn decode_len(ptr: *const u8) -> NonZeroUsize {
+    // SAFETY: There is at least one byte of varint followed by at least 9 bytes
+    // of string content, which is at least 10 bytes total for the allocation,
+    // so reading the first two is no problem.
+    let [first, second] = unsafe { ptr::read(ptr as *const [u8; 2]) };
+    if second < 0x80 {
+        // SAFETY: the length of this heap allocated string has been encoded as
+        // one base-128 digit, so the length is at least 9 and at most 127. It
+        // cannot be zero.
+        unsafe { NonZeroUsize::new_unchecked((first & 0x7f) as usize) }
+    } else {
+        return unsafe { decode_len_cold(ptr) };
+
+        // Identifiers 128 bytes or longer. This is not exercised by any crate
+        // version currently published to crates.io.
+        #[cold]
+        #[inline(never)]
+        unsafe fn decode_len_cold(mut ptr: *const u8) -> NonZeroUsize {
+            let mut len = 0;
+            let mut shift = 0;
+            loop {
+                // SAFETY: varint continues while there are bytes having the
+                // most significant bit set, i.e. until we start hitting the
+                // ASCII string content with msb unset.
+                let byte = unsafe { *ptr };
+                if byte < 0x80 {
+                    // SAFETY: the string length is known to be 128 bytes or
+                    // longer.
+                    return unsafe { NonZeroUsize::new_unchecked(len) };
+                }
+                // SAFETY: still in bounds of the same allocation.
+                ptr = unsafe { ptr.add(1) };
+                len += ((byte & 0x7f) as usize) << shift;
+                shift += 7;
+            }
+        }
+    }
+}
+
+// SAFETY: repr must be in the heap allocated representation, with varint header
+// and string contents already written.
+unsafe fn ptr_as_str(repr: &NonNull<u8>) -> &str {
+    let ptr = repr_to_ptr(*repr);
+    let len = unsafe { decode_len(ptr) };
+    let header = bytes_for_varint(len);
+    let slice = unsafe { slice::from_raw_parts(ptr.add(header), len.get()) };
+    // SAFETY: all identifier contents are ASCII bytes, which are always valid
+    // UTF-8.
+    unsafe { str::from_utf8_unchecked(slice) }
+}
+
+// Number of base-128 digits required for the varint representation of a length.
+fn bytes_for_varint(len: NonZeroUsize) -> usize {
+    #[cfg(no_nonzero_bitscan)] // rustc <1.53
+    let len = len.get();
+
+    let usize_bits = mem::size_of::<usize>() * 8;
+    let len_bits = usize_bits - len.leading_zeros() as usize;
+    (len_bits + 6) / 7
+}
diff --git a/third_party/rust/semver/src/impls.rs b/third_party/rust/semver/src/impls.rs
new file mode 100644
index 000000000000..c3b6c6013377
--- /dev/null
+++ b/third_party/rust/semver/src/impls.rs
@@ -0,0 +1,156 @@
+use crate::backport::*;
+use crate::identifier::Identifier;
+use crate::{BuildMetadata, Comparator, Prerelease, VersionReq};
+use core::cmp::Ordering;
+use core::hash::{Hash, Hasher};
+use core::iter::FromIterator;
+use core::ops::Deref;
+
+impl Default for Identifier {
+    fn default() -> Self {
+        Identifier::empty()
+    }
+}
+
+impl Eq for Identifier {}
+
+impl Hash for Identifier {
+    fn hash<H: Hasher>(&self, hasher: &mut H) {
+        self.as_str().hash(hasher);
+    }
+}
+
+impl Deref for Prerelease {
+    type Target = str;
+
+    fn deref(&self) -> &Self::Target {
+        self.identifier.as_str()
+    }
+}
+
+impl Deref for BuildMetadata {
+    type Target = str;
+
+    fn deref(&self) -> &Self::Target {
+        self.identifier.as_str()
+    }
+}
+
+impl PartialOrd for Prerelease {
+    fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {
+        Some(Ord::cmp(self, rhs))
+    }
+}
+
+impl PartialOrd for BuildMetadata {
+    fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {
+        Some(Ord::cmp(self, rhs))
+    }
+}
+
+impl Ord for Prerelease {
+    fn cmp(&self, rhs: &Self) -> Ordering {
+        match self.is_empty() {
+            true if rhs.is_empty() => return Ordering::Equal,
+            // A real release compares greater than prerelease.
+            true => return Ordering::Greater,
+            // Prerelease compares less than the real release.
+            false if rhs.is_empty() => return Ordering::Less,
+            false => {}
+        }
+
+        let lhs = self.as_str().split('.');
+        let mut rhs = rhs.as_str().split('.');
+
+        for lhs in lhs {
+            let rhs = match rhs.next() {
+                // Spec: "A larger set of pre-release fields has a higher
+                // precedence than a smaller set, if all of the preceding
+                // identifiers are equal."
+                None => return Ordering::Greater,
+                Some(rhs) => rhs,
+            };
+
+            let string_cmp = || Ord::cmp(lhs, rhs);
+            let is_ascii_digit = |b: u8| b.is_ascii_digit();
+            let ordering = match (
+                lhs.bytes().all(is_ascii_digit),
+                rhs.bytes().all(is_ascii_digit),
+            ) {
+                // Respect numeric ordering, for example 99 < 100. Spec says:
+                // "Identifiers consisting of only digits are compared
+                // numerically."
+                (true, true) => Ord::cmp(&lhs.len(), &rhs.len()).then_with(string_cmp),
+                // Spec: "Numeric identifiers always have lower precedence than
+                // non-numeric identifiers."
+                (true, false) => return Ordering::Less,
+                (false, true) => return Ordering::Greater,
+                // Spec: "Identifiers with letters or hyphens are compared
+                // lexically in ASCII sort order."
+                (false, false) => string_cmp(),
+            };
+
+            if ordering != Ordering::Equal {
+                return ordering;
+            }
+        }
+
+        if rhs.next().is_none() {
+            Ordering::Equal
+        } else {
+            Ordering::Less
+        }
+    }
+}
+
+impl Ord for BuildMetadata {
+    fn cmp(&self, rhs: &Self) -> Ordering {
+        let lhs = self.as_str().split('.');
+        let mut rhs = rhs.as_str().split('.');
+
+        for lhs in lhs {
+            let rhs = match rhs.next() {
+                None => return Ordering::Greater,
+                Some(rhs) => rhs,
+            };
+
+            let is_ascii_digit = |b: u8| b.is_ascii_digit();
+            let ordering = match (
+                lhs.bytes().all(is_ascii_digit),
+                rhs.bytes().all(is_ascii_digit),
+            ) {
+                (true, true) => {
+                    // 0 < 00 < 1 < 01 < 001 < 2 < 02 < 002 < 10
+                    let lhval = lhs.trim_start_matches('0');
+                    let rhval = rhs.trim_start_matches('0');
+                    Ord::cmp(&lhval.len(), &rhval.len())
+                        .then_with(|| Ord::cmp(lhval, rhval))
+                        .then_with(|| Ord::cmp(&lhs.len(), &rhs.len()))
+                }
+                (true, false) => return Ordering::Less,
+                (false, true) => return Ordering::Greater,
+                (false, false) => Ord::cmp(lhs, rhs),
+            };
+
+            if ordering != Ordering::Equal {
+                return ordering;
+            }
+        }
+
+        if rhs.next().is_none() {
+            Ordering::Equal
+        } else {
+            Ordering::Less
+        }
+    }
+}
+
+impl FromIterator<Comparator> for VersionReq {
+    fn from_iter<I>(iter: I) -> Self
+    where
+        I: IntoIterator<Item = Comparator>,
+    {
+        let comparators = Vec::from_iter(iter);
+        VersionReq { comparators }
+    }
+}
diff --git a/third_party/rust/semver/src/lib.rs b/third_party/rust/semver/src/lib.rs
index a38aae0e163d..b3c3ea2867e3 100644
--- a/third_party/rust/semver/src/lib.rs
+++ b/third_party/rust/semver/src/lib.rs
@@ -1,182 +1,543 @@
-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT
-// file at the top-level directory of this distribution and at
-// http://rust-lang.org/COPYRIGHT.
-//
-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
-// option. This file may not be copied, modified, or distributed
-// except according to those terms.
-
-//! Semantic version parsing and comparison.
-//!
-//! Semantic versioning (see http://semver.org/) is a set of rules for
-//! assigning version numbers.
-//!
-//! ## SemVer overview
-//!
-//! Given a version number MAJOR.MINOR.PATCH, increment the:
-//!
-//! 1. MAJOR version when you make incompatible API changes,
-//! 2. MINOR version when you add functionality in a backwards-compatible
-//!    manner, and
-//! 3. PATCH version when you make backwards-compatible bug fixes.
-//!
-//! Additional labels for pre-release and build metadata are available as
-//! extensions to the MAJOR.MINOR.PATCH format.
-//!
-//! Any references to 'the spec' in this documentation refer to [version 2.0 of
-//! the SemVer spec](http://semver.org/spec/v2.0.0.html).
-//!
-//! ## SemVer and the Rust ecosystem
+//! [![github]](https://github.com/dtolnay/semver)&ensp;[![crates-io]](https://crates.io/crates/semver)&ensp;[![docs-rs]](https://docs.rs/semver)
 //!
-//! Rust itself follows the SemVer specification, as does its standard
-//! libraries. The two are not tied together.
+//! [github]: https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github
+//! [crates-io]: https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust
+//! [docs-rs]: https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs
 //!
-//! [Cargo](http://crates.io), Rust's package manager, uses SemVer to determine
-//! which versions of packages you need installed.
+//! <br>
 //!
-//! ## Versions
+//! A parser and evaluator for Cargo's flavor of Semantic Versioning.
 //!
-//! At its simplest, the `semver` crate allows you to construct `Version`
-//! objects using the `parse` method:
+//! Semantic Versioning (see <https://semver.org>) is a guideline for how
+//! version numbers are assigned and incremented. It is widely followed within
+//! the Cargo/crates.io ecosystem for Rust.
 //!
-//! ```{rust}
-//! use semver::Version;
+//! <br>
 //!
-//! assert!(Version::parse("1.2.3") == Ok(Version {
-//!    major: 1,
-//!    minor: 2,
-//!    patch: 3,
-//!    pre: vec!(),
-//!    build: vec!(),
-//! }));
-//! ```
-//!
-//! If you have multiple `Version`s, you can use the usual comparison operators
-//! to compare them:
+//! # Example
 //!
-//! ```{rust}
-//! use semver::Version;
-//!
-//! assert!(Version::parse("1.2.3-alpha") != Version::parse("1.2.3-beta"));
-//! assert!(Version::parse("1.2.3-alpha2") >  Version::parse("1.2.0"));
 //! ```
-//!
-//! If you explicitly need to modify a Version, SemVer also allows you to
-//! increment the major, minor, and patch numbers in accordance with the spec.
-//!
-//! Please note that in order to do this, you must use a mutable Version:
-//!
-//! ```{rust}
-//! use semver::Version;
-//!
-//! let mut bugfix_release = Version::parse("1.0.0").unwrap();
-//! bugfix_release.increment_patch();
-//!
-//! assert_eq!(Ok(bugfix_release), Version::parse("1.0.1"));
-//! ```
-//!
-//! When incrementing the minor version number, the patch number resets to zero
-//! (in accordance with section 7 of the spec)
-//!
-//! ```{rust}
-//! use semver::Version;
-//!
-//! let mut feature_release = Version::parse("1.4.6").unwrap();
-//! feature_release.increment_minor();
-//!
-//! assert_eq!(Ok(feature_release), Version::parse("1.5.0"));
-//! ```
-//!
-//! Similarly, when incrementing the major version number, the patch and minor
-//! numbers reset to zero (in accordance with section 8 of the spec)
-//!
-//! ```{rust}
-//! use semver::Version;
-//!
-//! let mut chrome_release = Version::parse("41.5.5377").unwrap();
-//! chrome_release.increment_major();
-//!
-//! assert_eq!(Ok(chrome_release), Version::parse("42.0.0"));
-//! ```
-//!
-//! ## Requirements
-//!
-//! The `semver` crate also provides the ability to compare requirements, which
-//! are more complex comparisons.
-//!
-//! For example, creating a requirement that only matches versions greater than
-//! or equal to 1.0.0:
-//!
-//! ```{rust}
-//! # #![allow(unstable)]
-//! use semver::Version;
-//! use semver::VersionReq;
-//!
-//! let r = VersionReq::parse(">= 1.0.0").unwrap();
-//! let v = Version::parse("1.0.0").unwrap();
-//!
-//! assert!(r.to_string() == ">= 1.0.0".to_string());
-//! assert!(r.matches(&v))
+//! use semver::{BuildMetadata, Prerelease, Version, VersionReq};
+//!
+//! fn main() {
+//!     let req = VersionReq::parse(">=1.2.3, <1.8.0").unwrap();
+//!
+//!     // Check whether this requirement matches version 1.2.3-alpha.1 (no)
+//!     let version = Version {
+//!         major: 1,
+//!         minor: 2,
+//!         patch: 3,
+//!         pre: Prerelease::new("alpha.1").unwrap(),
+//!         build: BuildMetadata::EMPTY,
+//!     };
+//!     assert!(!req.matches(&version));
+//!
+//!     // Check whether it matches 1.3.0 (yes it does)
+//!     let version = Version::parse("1.3.0").unwrap();
+//!     assert!(req.matches(&version));
+//! }
 //! ```
 //!
-//! It also allows parsing of `~x.y.z` and `^x.y.z` requirements as defined at
-//! https://www.npmjs.org/doc/misc/semver.html
+//! <br><br>
 //!
-//! **Tilde requirements** specify a minimal version with some updates:
-//!
-//! ```notrust
-//! ~1.2.3 := >=1.2.3 <1.3.0
-//! ~1.2   := >=1.2.0 <1.3.0
-//! ~1     := >=1.0.0 <2.0.0
-//! ```
+//! # Scope of this crate
 //!
-//! **Caret requirements** allow SemVer compatible updates to a specified
-//! verion, `0.x` and `0.x+1` are not considered compatible, but `1.x` and
-//! `1.x+1` are.
+//! Besides Cargo, several other package ecosystems and package managers for
+//! other languages also use SemVer:&ensp;RubyGems/Bundler for Ruby, npm for
+//! JavaScript, Composer for PHP, CocoaPods for Objective-C...
 //!
-//! `0.0.x` is not considered compatible with any other version.
-//! Missing minor and patch versions are desugared to `0` but allow flexibility
-//! for that value.
+//! The `semver` crate is specifically intended to implement Cargo's
+//! interpretation of Semantic Versioning.
 //!
-//! ```notrust
-//! ^1.2.3 := >=1.2.3 <2.0.0
-//! ^0.2.3 := >=0.2.3 <0.3.0
-//! ^0.0.3 := >=0.0.3 <0.0.4
-//! ^0.0   := >=0.0.0 <0.1.0
-//! ^0     := >=0.0.0 <1.0.0
-//! ```
+//! Where the various tools differ in their interpretation or implementation of
+//! the spec, this crate follows the implementation choices made by Cargo. If
+//! you are operating on version numbers from some other package ecosystem, you
+//! will want to use a different semver library which is appropriate to that
+//! ecosystem.
 //!
-//! **Wildcard requirements** allows parsing of version requirements of the
-//! formats `*`, `x.*` and `x.y.*`.
+//! The extent of Cargo's SemVer support is documented in the *[Specifying
+//! Dependencies]* chapter of the Cargo reference.
 //!
-//! ```notrust
-//! *     := >=0.0.0
-//! 1.*   := >=1.0.0 <2.0.0
-//! 1.2.* := >=1.2.0 <1.3.0
-//! ```
+//! [Specifying Dependencies]: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html
 
-#![doc(html_logo_url = "https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png",
-       html_favicon_url = "https://www.rust-lang.org/favicon.ico")]
-#![deny(missing_docs)]
-#![cfg_attr(test, deny(warnings))]
+#![doc(html_root_url = "https://docs.rs/semver/1.0.13")]
+#![cfg_attr(doc_cfg, feature(doc_cfg))]
+#![cfg_attr(all(not(feature = "std"), not(no_alloc_crate)), no_std)]
+#![cfg_attr(not(no_unsafe_op_in_unsafe_fn_lint), deny(unsafe_op_in_unsafe_fn))]
+#![cfg_attr(no_unsafe_op_in_unsafe_fn_lint, allow(unused_unsafe))]
+#![cfg_attr(no_str_strip_prefix, allow(unstable_name_collisions))]
+#![allow(
+    clippy::cast_lossless,
+    clippy::cast_possible_truncation,
+    clippy::doc_markdown,
+    clippy::items_after_statements,
+    clippy::manual_map,
+    clippy::match_bool,
+    clippy::missing_errors_doc,
+    clippy::must_use_candidate,
+    clippy::needless_doctest_main,
+    clippy::option_if_let_else,
+    clippy::ptr_as_ptr,
+    clippy::redundant_else,
+    clippy::semicolon_if_nothing_returned, // https://github.com/rust-lang/rust-clippy/issues/7324
+    clippy::similar_names,
+    clippy::unnested_or_patterns,
+    clippy::unseparated_literal_suffix,
+    clippy::wildcard_imports
+)]
 
-extern crate semver_parser;
+#[cfg(not(no_alloc_crate))]
+extern crate alloc;
+
+mod backport;
+mod display;
+mod error;
+mod eval;
+mod identifier;
+mod impls;
+mod parse;
 
-// Serialization and deserialization support for version numbers
 #[cfg(feature = "serde")]
-extern crate serde;
+mod serde;
+
+use crate::alloc::vec::Vec;
+use crate::identifier::Identifier;
+use core::str::FromStr;
+
+#[allow(unused_imports)]
+use crate::backport::*;
+
+pub use crate::parse::Error;
+
+/// **SemVer version** as defined by <https://semver.org>.
+///
+/// # Syntax
+///
+/// - The major, minor, and patch numbers may be any integer 0 through u64::MAX.
+///   When representing a SemVer version as a string, each number is written as
+///   a base 10 integer. For example, `1.0.119`.
+///
+/// - Leading zeros are forbidden in those positions. For example `1.01.00` is
+///   invalid as a SemVer version.
+///
+/// - The pre-release identifier, if present, must conform to the syntax
+///   documented for [`Prerelease`].
+///
+/// - The build metadata, if present, must conform to the syntax documented for
+///   [`BuildMetadata`].
+///
+/// - Whitespace is not allowed anywhere in the version.
+///
+/// # Total ordering
+///
+/// Given any two SemVer versions, one is less than, greater than, or equal to
+/// the other. Versions may be compared against one another using Rust's usual
+/// comparison operators.
+///
+/// - The major, minor, and patch number are compared numerically from left to
+/// right, lexicographically ordered as a 3-tuple of integers. So for example
+/// version `1.5.0` is less than version `1.19.0`, despite the fact that
+/// "1.19.0" &lt; "1.5.0" as ASCIIbetically compared strings and 1.19 &lt; 1.5
+/// as real numbers.
+///
+/// - When major, minor, and patch are equal, a pre-release version is
+///   considered less than the ordinary release:&ensp;version `1.0.0-alpha.1` is
+///   less than version `1.0.0`.
+///
+/// - Two pre-releases of the same major, minor, patch are compared by
+///   lexicographic ordering of dot-separated components of the pre-release
+///   string.
+///
+///   - Identifiers consisting of only digits are compared
+///     numerically:&ensp;`1.0.0-pre.8` is less than `1.0.0-pre.12`.
+///
+///   - Identifiers that contain a letter or hyphen are compared in ASCII sort
+///     order:&ensp;`1.0.0-pre12` is less than `1.0.0-pre8`.
+///
+///   - Any numeric identifier is always less than any non-numeric
+///     identifier:&ensp;`1.0.0-pre.1` is less than `1.0.0-pre.x`.
+///
+/// Example:&ensp;`1.0.0-alpha`&ensp;&lt;&ensp;`1.0.0-alpha.1`&ensp;&lt;&ensp;`1.0.0-alpha.beta`&ensp;&lt;&ensp;`1.0.0-beta`&ensp;&lt;&ensp;`1.0.0-beta.2`&ensp;&lt;&ensp;`1.0.0-beta.11`&ensp;&lt;&ensp;`1.0.0-rc.1`&ensp;&lt;&ensp;`1.0.0`
+#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
+pub struct Version {
+    pub major: u64,
+    pub minor: u64,
+    pub patch: u64,
+    pub pre: Prerelease,
+    pub build: BuildMetadata,
+}
+
+/// **SemVer version requirement** describing the intersection of some version
+/// comparators, such as `>=1.2.3, <1.8`.
+///
+/// # Syntax
+///
+/// - Either `*` (meaning "any"), or one or more comma-separated comparators.
+///
+/// - A [`Comparator`] is an operator ([`Op`]) and a partial version, separated
+///   by optional whitespace. For example `>=1.0.0` or `>=1.0`.
+///
+/// - Build metadata is syntactically permitted on the partial versions, but is
+///   completely ignored, as it's never relevant to whether any comparator
+///   matches a particular version.
+///
+/// - Whitespace is permitted around commas and around operators. Whitespace is
+///   not permitted within a partial version, i.e. anywhere between the major
+///   version number and its minor, patch, pre-release, or build metadata.
+#[derive(Clone, Eq, PartialEq, Hash, Debug)]
+#[cfg_attr(no_const_vec_new, derive(Default))]
+pub struct VersionReq {
+    pub comparators: Vec<Comparator>,
+}
+
+/// A pair of comparison operator and partial version, such as `>=1.2`. Forms
+/// one piece of a VersionReq.
+#[derive(Clone, Eq, PartialEq, Hash, Debug)]
+pub struct Comparator {
+    pub op: Op,
+    pub major: u64,
+    pub minor: Option<u64>,
+    /// Patch is only allowed if minor is Some.
+    pub patch: Option<u64>,
+    /// Non-empty pre-release is only allowed if patch is Some.
+    pub pre: Prerelease,
+}
+
+/// SemVer comparison operator: `=`, `>`, `>=`, `<`, `<=`, `~`, `^`, `*`.
+///
+/// # Op::Exact
+/// - &ensp;**`=I.J.K`**&emsp;&mdash;&emsp;exactly the version I.J.K
+/// - &ensp;**`=I.J`**&emsp;&mdash;&emsp;equivalent to `>=I.J.0, <I.(J+1).0`
+/// - &ensp;**`=I`**&emsp;&mdash;&emsp;equivalent to `>=I.0.0, <(I+1).0.0`
+///
+/// # Op::Greater
+/// - &ensp;**`>I.J.K`**
+/// - &ensp;**`>I.J`**&emsp;&mdash;&emsp;equivalent to `>=I.(J+1).0`
+/// - &ensp;**`>I`**&emsp;&mdash;&emsp;equivalent to `>=(I+1).0.0`
+///
+/// # Op::GreaterEq
+/// - &ensp;**`>=I.J.K`**
+/// - &ensp;**`>=I.J`**&emsp;&mdash;&emsp;equivalent to `>=I.J.0`
+/// - &ensp;**`>=I`**&emsp;&mdash;&emsp;equivalent to `>=I.0.0`
+///
+/// # Op::Less
+/// - &ensp;**`<I.J.K`**
+/// - &ensp;**`<I.J`**&emsp;&mdash;&emsp;equivalent to `<I.J.0`
+/// - &ensp;**`<I`**&emsp;&mdash;&emsp;equivalent to `<I.0.0`
+///
+/// # Op::LessEq
+/// - &ensp;**`<=I.J.K`**
+/// - &ensp;**`<=I.J`**&emsp;&mdash;&emsp;equivalent to `<I.(J+1).0`
+/// - &ensp;**`<=I`**&emsp;&mdash;&emsp;equivalent to `<(I+1).0.0`
+///
+/// # Op::Tilde&emsp;("patch" updates)
+/// *Tilde requirements allow the **patch** part of the semver version (the third number) to increase.*
+/// - &ensp;**`~I.J.K`**&emsp;&mdash;&emsp;equivalent to `>=I.J.K, <I.(J+1).0`
+/// - &ensp;**`~I.J`**&emsp;&mdash;&emsp;equivalent to `=I.J`
+/// - &ensp;**`~I`**&emsp;&mdash;&emsp;equivalent to `=I`
+///
+/// # Op::Caret&emsp;("compatible" updates)
+/// *Caret requirements allow parts that are **right of the first nonzero** part of the semver version to increase.*
+/// - &ensp;**`^I.J.K`**&ensp;(for I\>0)&emsp;&mdash;&emsp;equivalent to `>=I.J.K, <(I+1).0.0`
+/// - &ensp;**`^0.J.K`**&ensp;(for J\>0)&emsp;&mdash;&emsp;equivalent to `>=0.J.K, <0.(J+1).0`
+/// - &ensp;**`^0.0.K`**&emsp;&mdash;&emsp;equivalent to `=0.0.K`
+/// - &ensp;**`^I.J`**&ensp;(for I\>0 or J\>0)&emsp;&mdash;&emsp;equivalent to `^I.J.0`
+/// - &ensp;**`^0.0`**&emsp;&mdash;&emsp;equivalent to `=0.0`
+/// - &ensp;**`^I`**&emsp;&mdash;&emsp;equivalent to `=I`
+///
+/// # Op::Wildcard
+/// - &ensp;**`I.J.*`**&emsp;&mdash;&emsp;equivalent to `=I.J`
+/// - &ensp;**`I.*`**&ensp;or&ensp;**`I.*.*`**&emsp;&mdash;&emsp;equivalent to `=I`
+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
+#[cfg_attr(not(no_non_exhaustive), non_exhaustive)]
+pub enum Op {
+    Exact,
+    Greater,
+    GreaterEq,
+    Less,
+    LessEq,
+    Tilde,
+    Caret,
+    Wildcard,
+
+    #[cfg(no_non_exhaustive)] // rustc <1.40
+    #[doc(hidden)]
+    __NonExhaustive,
+}
+
+/// Optional pre-release identifier on a version string. This comes after `-` in
+/// a SemVer version, like `1.0.0-alpha.1`
+///
+/// # Examples
+///
+/// Some real world pre-release idioms drawn from crates.io:
+///
+/// - **[mio]** <code>0.7.0-<b>alpha.1</b></code> &mdash; the most common style
+///   for numbering pre-releases.
+///
+/// - **[pest]** <code>1.0.0-<b>beta.8</b></code>,&ensp;<code>1.0.0-<b>rc.0</b></code>
+///   &mdash; this crate makes a distinction between betas and release
+///   candidates.
+///
+/// - **[sassers]** <code>0.11.0-<b>shitshow</b></code> &mdash; ???.
+///
+/// - **[atomic-utils]** <code>0.0.0-<b>reserved</b></code> &mdash; a squatted
+///   crate name.
+///
+/// [mio]: https://crates.io/crates/mio
+/// [pest]: https://crates.io/crates/pest
+/// [atomic-utils]: https://crates.io/crates/atomic-utils
+/// [sassers]: https://crates.io/crates/sassers
+///
+/// *Tip:* Be aware that if you are planning to number your own pre-releases,
+/// you should prefer to separate the numeric part from any non-numeric
+/// identifiers by using a dot in between. That is, prefer pre-releases
+/// `alpha.1`, `alpha.2`, etc rather than `alpha1`, `alpha2` etc. The SemVer
+/// spec's rule for pre-release precedence has special treatment of numeric
+/// components in the pre-release string, but only if there are no non-digit
+/// characters in the same dot-separated component. So you'd have `alpha.2` &lt;
+/// `alpha.11` as intended, but `alpha11` &lt; `alpha2`.
+///
+/// # Syntax
+///
+/// Pre-release strings are a series of dot separated identifiers immediately
+/// following the patch version. Identifiers must comprise only ASCII
+/// alphanumerics and hyphens: `0-9`, `A-Z`, `a-z`, `-`. Identifiers must not be
+/// empty. Numeric identifiers must not include leading zeros.
+///
+/// # Total ordering
+///
+/// Pre-releases have a total order defined by the SemVer spec. It uses
+/// lexicographic ordering of dot-separated components. Identifiers consisting
+/// of only digits are compared numerically. Otherwise, identifiers are compared
+/// in ASCII sort order. Any numeric identifier is always less than any
+/// non-numeric identifier.
+///
+/// Example:&ensp;`alpha`&ensp;&lt;&ensp;`alpha.85`&ensp;&lt;&ensp;`alpha.90`&ensp;&lt;&ensp;`alpha.200`&ensp;&lt;&ensp;`alpha.0a`&ensp;&lt;&ensp;`alpha.1a0`&ensp;&lt;&ensp;`alpha.a`&ensp;&lt;&ensp;`beta`
+#[derive(Default, Clone, Eq, PartialEq, Hash)]
+pub struct Prerelease {
+    identifier: Identifier,
+}
+
+/// Optional build metadata identifier. This comes after `+` in a SemVer
+/// version, as in `0.8.1+zstd.1.5.0`.
+///
+/// # Examples
+///
+/// Some real world build metadata idioms drawn from crates.io:
+///
+/// - **[libgit2-sys]** <code>0.12.20+<b>1.1.0</b></code> &mdash; for this
+///   crate, the build metadata indicates the version of the C libgit2 library
+///   that the Rust crate is built against.
+///
+/// - **[mashup]** <code>0.1.13+<b>deprecated</b></code> &mdash; just the word
+///   "deprecated" for a crate that has been superseded by another. Eventually
+///   people will take notice of this in Cargo's build output where it lists the
+///   crates being compiled.
+///
+/// - **[google-bigquery2]** <code>2.0.4+<b>20210327</b></code> &mdash; this
+///   library is automatically generated from an official API schema, and the
+///   build metadata indicates the date on which that schema was last captured.
+///
+/// - **[fbthrift-git]** <code>0.0.6+<b>c7fcc0e</b></code> &mdash; this crate is
+///   published from snapshots of a big company monorepo. In monorepo
+///   development, there is no concept of versions, and all downstream code is
+///   just updated atomically in the same commit that breaking changes to a
+///   library are landed. Therefore for crates.io purposes, every published
+///   version must be assumed to be incompatible with the previous. The build
+///   metadata provides the source control hash of the snapshotted code.
+///
+/// [libgit2-sys]: https://crates.io/crates/libgit2-sys
+/// [mashup]: https://crates.io/crates/mashup
+/// [google-bigquery2]: https://crates.io/crates/google-bigquery2
+/// [fbthrift-git]: https://crates.io/crates/fbthrift-git
+///
+/// # Syntax
+///
+/// Build metadata is a series of dot separated identifiers immediately
+/// following the patch or pre-release version. Identifiers must comprise only
+/// ASCII alphanumerics and hyphens: `0-9`, `A-Z`, `a-z`, `-`. Identifiers must
+/// not be empty. Leading zeros *are* allowed, unlike any other place in the
+/// SemVer grammar.
+///
+/// # Total ordering
+///
+/// Build metadata is ignored in evaluating `VersionReq`; it plays no role in
+/// whether a `Version` matches any one of the comparison operators.
+///
+/// However for comparing build metadatas among one another, they do have a
+/// total order which is determined by lexicographic ordering of dot-separated
+/// components. Identifiers consisting of only digits are compared numerically.
+/// Otherwise, identifiers are compared in ASCII sort order. Any numeric
+/// identifier is always less than any non-numeric identifier.
+///
+/// Example:&ensp;`demo`&ensp;&lt;&ensp;`demo.85`&ensp;&lt;&ensp;`demo.90`&ensp;&lt;&ensp;`demo.090`&ensp;&lt;&ensp;`demo.200`&ensp;&lt;&ensp;`demo.1a0`&ensp;&lt;&ensp;`demo.a`&ensp;&lt;&ensp;`memo`
+#[derive(Default, Clone, Eq, PartialEq, Hash)]
+pub struct BuildMetadata {
+    identifier: Identifier,
+}
+
+impl Version {
+    /// Create `Version` with an empty pre-release and build metadata.
+    ///
+    /// Equivalent to:
+    ///
+    /// ```
+    /// # use semver::{BuildMetadata, Prerelease, Version};
+    /// #
+    /// # const fn new(major: u64, minor: u64, patch: u64) -> Version {
+    /// Version {
+    ///     major,
+    ///     minor,
+    ///     patch,
+    ///     pre: Prerelease::EMPTY,
+    ///     build: BuildMetadata::EMPTY,
+    /// }
+    /// # }
+    /// ```
+    pub const fn new(major: u64, minor: u64, patch: u64) -> Self {
+        Version {
+            major,
+            minor,
+            patch,
+            pre: Prerelease::EMPTY,
+            build: BuildMetadata::EMPTY,
+        }
+    }
+
+    /// Create `Version` by parsing from string representation.
+    ///
+    /// # Errors
+    ///
+    /// Possible reasons for the parse to fail include:
+    ///
+    /// - `1.0` &mdash; too few numeric components. A SemVer version must have
+    ///   exactly three. If you are looking at something that has fewer than
+    ///   three numbers in it, it's possible it is a `VersionReq` instead (with
+    ///   an implicit default `^` comparison operator).
+    ///
+    /// - `1.0.01` &mdash; a numeric component has a leading zero.
+    ///
+    /// - `1.0.unknown` &mdash; unexpected character in one of the components.
+    ///
+    /// - `1.0.0-` or `1.0.0+` &mdash; the pre-release or build metadata are
+    ///   indicated present but empty.
+    ///
+    /// - `1.0.0-alpha_123` &mdash; pre-release or build metadata have something
+    ///   outside the allowed characters, which are `0-9`, `A-Z`, `a-z`, `-`,
+    ///   and `.` (dot).
+    ///
+    /// - `23456789999999999999.0.0` &mdash; overflow of a u64.
+    pub fn parse(text: &str) -> Result<Self, Error> {
+        Version::from_str(text)
+    }
+}
+
+impl VersionReq {
+    /// A `VersionReq` with no constraint on the version numbers it matches.
+    /// Equivalent to `VersionReq::parse("*").unwrap()`.
+    ///
+    /// In terms of comparators this is equivalent to `>=0.0.0`.
+    ///
+    /// Counterintuitively a `*` VersionReq does not match every possible
+    /// version number. In particular, in order for *any* `VersionReq` to match
+    /// a pre-release version, the `VersionReq` must contain at least one
+    /// `Comparator` that has an explicit major, minor, and patch version
+    /// identical to the pre-release being matched, and that has a nonempty
+    /// pre-release component. Since `*` is not written with an explicit major,
+    /// minor, and patch version, and does not contain a nonempty pre-release
+    /// component, it does not match any pre-release versions.
+    #[cfg(not(no_const_vec_new))] // rustc <1.39
+    pub const STAR: Self = VersionReq {
+        comparators: Vec::new(),
+    };
+
+    /// Create `VersionReq` by parsing from string representation.
+    ///
+    /// # Errors
+    ///
+    /// Possible reasons for the parse to fail include:
+    ///
+    /// - `>a.b` &mdash; unexpected characters in the partial version.
+    ///
+    /// - `@1.0.0` &mdash; unrecognized comparison operator.
+    ///
+    /// - `^1.0.0, ` &mdash; unexpected end of input.
+    ///
+    /// - `>=1.0 <2.0` &mdash; missing comma between comparators.
+    ///
+    /// - `*.*` &mdash; unsupported wildcard syntax.
+    pub fn parse(text: &str) -> Result<Self, Error> {
+        VersionReq::from_str(text)
+    }
+
+    /// Evaluate whether the given `Version` satisfies the version requirement
+    /// described by `self`.
+    pub fn matches(&self, version: &Version) -> bool {
+        eval::matches_req(self, version)
+    }
+}
+
+/// The default VersionReq is the same as [`VersionReq::STAR`].
+#[cfg(not(no_const_vec_new))]
+impl Default for VersionReq {
+    fn default() -> Self {
+        VersionReq::STAR
+    }
+}
+
+impl Comparator {
+    pub fn parse(text: &str) -> Result<Self, Error> {
+        Comparator::from_str(text)
+    }
+
+    pub fn matches(&self, version: &Version) -> bool {
+        eval::matches_comparator(self, version)
+    }
+}
+
+impl Prerelease {
+    // Work around https://github.com/rust-lang/rust/issues/97933
+    #[cfg(all(doc, semver_rustdoc_workaround))]
+    pub const EMPTY: Self = "";
+
+    #[cfg(not(all(doc, semver_rustdoc_workaround)))]
+    pub const EMPTY: Self = Prerelease {
+        identifier: Identifier::empty(),
+    };
+
+    pub fn new(text: &str) -> Result<Self, Error> {
+        Prerelease::from_str(text)
+    }
+
+    pub fn as_str(&self) -> &str {
+        self.identifier.as_str()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.identifier.is_empty()
+    }
+}
+
+impl BuildMetadata {
+    // Work around https://github.com/rust-lang/rust/issues/97933
+    #[cfg(all(doc, semver_rustdoc_workaround))]
+    pub const EMPTY: Self = "";
 
-// We take the common approach of keeping our own module system private, and
-// just re-exporting the interface that we want.
+    #[cfg(not(all(doc, semver_rustdoc_workaround)))]
+    pub const EMPTY: Self = BuildMetadata {
+        identifier: Identifier::empty(),
+    };
 
-pub use version::{Version, Identifier, SemVerError};
-pub use version::Identifier::{Numeric, AlphaNumeric};
-pub use version_req::{VersionReq, ReqParseError};
+    pub fn new(text: &str) -> Result<Self, Error> {
+        BuildMetadata::from_str(text)
+    }
 
-// SemVer-compliant versions.
-mod version;
+    pub fn as_str(&self) -> &str {
+        self.identifier.as_str()
+    }
 
-// advanced version comparisons
-mod version_req;
+    pub fn is_empty(&self) -> bool {
+        self.identifier.is_empty()
+    }
+}
diff --git a/third_party/rust/semver/src/parse.rs b/third_party/rust/semver/src/parse.rs
new file mode 100644
index 000000000000..6a8f6ffba4fd
--- /dev/null
+++ b/third_party/rust/semver/src/parse.rs
@@ -0,0 +1,405 @@
+use crate::backport::*;
+use crate::error::{ErrorKind, Position};
+use crate::identifier::Identifier;
+use crate::{BuildMetadata, Comparator, Op, Prerelease, Version, VersionReq};
+use core::str::FromStr;
+
+/// Error parsing a SemVer version or version requirement.
+///
+/// # Example
+///
+/// ```
+/// use semver::Version;
+///
+/// fn main() {
+///     let err = Version::parse("1.q.r").unwrap_err();
+///
+///     // "unexpected character 'q' while parsing minor version number"
+///     eprintln!("{}", err);
+/// }
+/// ```
+pub struct Error {
+    pub(crate) kind: ErrorKind,
+}
+
+impl FromStr for Version {
+    type Err = Error;
+
+    fn from_str(text: &str) -> Result<Self, Self::Err> {
+        let mut pos = Position::Major;
+        let (major, text) = numeric_identifier(text, pos)?;
+        let text = dot(text, pos)?;
+
+        pos = Position::Minor;
+        let (minor, text) = numeric_identifier(text, pos)?;
+        let text = dot(text, pos)?;
+
+        pos = Position::Patch;
+        let (patch, text) = numeric_identifier(text, pos)?;
+
+        if text.is_empty() {
+            return Ok(Version::new(major, minor, patch));
+        }
+
+        let (pre, text) = if let Some(text) = text.strip_prefix('-') {
+            pos = Position::Pre;
+            let (pre, text) = prerelease_identifier(text)?;
+            if pre.is_empty() {
+                return Err(Error::new(ErrorKind::EmptySegment(pos)));
+            }
+            (pre, text)
+        } else {
+            (Prerelease::EMPTY, text)
+        };
+
+        let (build, text) = if let Some(text) = text.strip_prefix('+') {
+            pos = Position::Build;
+            let (build, text) = build_identifier(text)?;
+            if build.is_empty() {
+                return Err(Error::new(ErrorKind::EmptySegment(pos)));
+            }
+            (build, text)
+        } else {
+            (BuildMetadata::EMPTY, text)
+        };
+
+        if let Some(unexpected) = text.chars().next() {
+            return Err(Error::new(ErrorKind::UnexpectedCharAfter(pos, unexpected)));
+        }
+
+        Ok(Version {
+            major,
+            minor,
+            patch,
+            pre,
+            build,
+        })
+    }
+}
+
+impl FromStr for VersionReq {
+    type Err = Error;
+
+    fn from_str(text: &str) -> Result<Self, Self::Err> {
+        let text = text.trim_start_matches(' ');
+        if let Some((ch, text)) = wildcard(text) {
+            let rest = text.trim_start_matches(' ');
+            if rest.is_empty() {
+                #[cfg(not(no_const_vec_new))]
+                return Ok(VersionReq::STAR);
+                #[cfg(no_const_vec_new)] // rustc <1.39
+                return Ok(VersionReq {
+                    comparators: Vec::new(),
+                });
+            } else if rest.starts_with(',') {
+                return Err(Error::new(ErrorKind::WildcardNotTheOnlyComparator(ch)));
+            } else {
+                return Err(Error::new(ErrorKind::UnexpectedAfterWildcard));
+            }
+        }
+
+        let depth = 0;
+        let mut comparators = Vec::new();
+        let len = version_req(text, &mut comparators, depth)?;
+        unsafe { comparators.set_len(len) }
+        Ok(VersionReq { comparators })
+    }
+}
+
+impl FromStr for Comparator {
+    type Err = Error;
+
+    fn from_str(text: &str) -> Result<Self, Self::Err> {
+        let text = text.trim_start_matches(' ');
+        let (comparator, pos, rest) = comparator(text)?;
+        if !rest.is_empty() {
+            let unexpected = rest.chars().next().unwrap();
+            return Err(Error::new(ErrorKind::UnexpectedCharAfter(pos, unexpected)));
+        }
+        Ok(comparator)
+    }
+}
+
+impl FromStr for Prerelease {
+    type Err = Error;
+
+    fn from_str(text: &str) -> Result<Self, Self::Err> {
+        let (pre, rest) = prerelease_identifier(text)?;
+        if !rest.is_empty() {
+            return Err(Error::new(ErrorKind::IllegalCharacter(Position::Pre)));
+        }
+        Ok(pre)
+    }
+}
+
+impl FromStr for BuildMetadata {
+    type Err = Error;
+
+    fn from_str(text: &str) -> Result<Self, Self::Err> {
+        let (build, rest) = build_identifier(text)?;
+        if !rest.is_empty() {
+            return Err(Error::new(ErrorKind::IllegalCharacter(Position::Build)));
+        }
+        Ok(build)
+    }
+}
+
+impl Error {
+    fn new(kind: ErrorKind) -> Self {
+        Error { kind }
+    }
+}
+
+impl Op {
+    const DEFAULT: Self = Op::Caret;
+}
+
+fn numeric_identifier(input: &str, pos: Position) -> Result<(u64, &str), Error> {
+    let mut len = 0;
+    let mut value = 0u64;
+
+    while let Some(&digit) = input.as_bytes().get(len) {
+        if digit < b'0' || digit > b'9' {
+            break;
+        }
+        if value == 0 && len > 0 {
+            return Err(Error::new(ErrorKind::LeadingZero(pos)));
+        }
+        match value
+            .checked_mul(10)
+            .and_then(|value| value.checked_add((digit - b'0') as u64))
+        {
+            Some(sum) => value = sum,
+            None => return Err(Error::new(ErrorKind::Overflow(pos))),
+        }
+        len += 1;
+    }
+
+    if len > 0 {
+        Ok((value, &input[len..]))
+    } else if let Some(unexpected) = input[len..].chars().next() {
+        Err(Error::new(ErrorKind::UnexpectedChar(pos, unexpected)))
+    } else {
+        Err(Error::new(ErrorKind::UnexpectedEnd(pos)))
+    }
+}
+
+fn wildcard(input: &str) -> Option<(char, &str)> {
+    if let Some(rest) = input.strip_prefix('*') {
+        Some(('*', rest))
+    } else if let Some(rest) = input.strip_prefix('x') {
+        Some(('x', rest))
+    } else if let Some(rest) = input.strip_prefix('X') {
+        Some(('X', rest))
+    } else {
+        None
+    }
+}
+
+fn dot(input: &str, pos: Position) -> Result<&str, Error> {
+    if let Some(rest) = input.strip_prefix('.') {
+        Ok(rest)
+    } else if let Some(unexpected) = input.chars().next() {
+        Err(Error::new(ErrorKind::UnexpectedCharAfter(pos, unexpected)))
+    } else {
+        Err(Error::new(ErrorKind::UnexpectedEnd(pos)))
+    }
+}
+
+fn prerelease_identifier(input: &str) -> Result<(Prerelease, &str), Error> {
+    let (string, rest) = identifier(input, Position::Pre)?;
+    let identifier = unsafe { Identifier::new_unchecked(string) };
+    Ok((Prerelease { identifier }, rest))
+}
+
+fn build_identifier(input: &str) -> Result<(BuildMetadata, &str), Error> {
+    let (string, rest) = identifier(input, Position::Build)?;
+    let identifier = unsafe { Identifier::new_unchecked(string) };
+    Ok((BuildMetadata { identifier }, rest))
+}
+
+fn identifier(input: &str, pos: Position) -> Result<(&str, &str), Error> {
+    let mut accumulated_len = 0;
+    let mut segment_len = 0;
+    let mut segment_has_nondigit = false;
+
+    loop {
+        match input.as_bytes().get(accumulated_len + segment_len) {
+            Some(b'A'..=b'Z') | Some(b'a'..=b'z') | Some(b'-') => {
+                segment_len += 1;
+                segment_has_nondigit = true;
+            }
+            Some(b'0'..=b'9') => {
+                segment_len += 1;
+            }
+            boundary => {
+                if segment_len == 0 {
+                    if accumulated_len == 0 && boundary != Some(&b'.') {
+                        return Ok(("", input));
+                    } else {
+                        return Err(Error::new(ErrorKind::EmptySegment(pos)));
+                    }
+                }
+                if pos == Position::Pre
+                    && segment_len > 1
+                    && !segment_has_nondigit
+                    && input[accumulated_len..].starts_with('0')
+                {
+                    return Err(Error::new(ErrorKind::LeadingZero(pos)));
+                }
+                accumulated_len += segment_len;
+                if boundary == Some(&b'.') {
+                    accumulated_len += 1;
+                    segment_len = 0;
+                    segment_has_nondigit = false;
+                } else {
+                    return Ok(input.split_at(accumulated_len));
+                }
+            }
+        }
+    }
+}
+
+fn op(input: &str) -> (Op, &str) {
+    let bytes = input.as_bytes();
+    if bytes.first() == Some(&b'=') {
+        (Op::Exact, &input[1..])
+    } else if bytes.first() == Some(&b'>') {
+        if bytes.get(1) == Some(&b'=') {
+            (Op::GreaterEq, &input[2..])
+        } else {
+            (Op::Greater, &input[1..])
+        }
+    } else if bytes.first() == Some(&b'<') {
+        if bytes.get(1) == Some(&b'=') {
+            (Op::LessEq, &input[2..])
+        } else {
+            (Op::Less, &input[1..])
+        }
+    } else if bytes.first() == Some(&b'~') {
+        (Op::Tilde, &input[1..])
+    } else if bytes.first() == Some(&b'^') {
+        (Op::Caret, &input[1..])
+    } else {
+        (Op::DEFAULT, input)
+    }
+}
+
+fn comparator(input: &str) -> Result<(Comparator, Position, &str), Error> {
+    let (mut op, text) = op(input);
+    let default_op = input.len() == text.len();
+    let text = text.trim_start_matches(' ');
+
+    let mut pos = Position::Major;
+    let (major, text) = numeric_identifier(text, pos)?;
+    let mut has_wildcard = false;
+
+    let (minor, text) = if let Some(text) = text.strip_prefix('.') {
+        pos = Position::Minor;
+        if let Some((_, text)) = wildcard(text) {
+            has_wildcard = true;
+            if default_op {
+                op = Op::Wildcard;
+            }
+            (None, text)
+        } else {
+            let (minor, text) = numeric_identifier(text, pos)?;
+            (Some(minor), text)
+        }
+    } else {
+        (None, text)
+    };
+
+    let (patch, text) = if let Some(text) = text.strip_prefix('.') {
+        pos = Position::Patch;
+        if let Some((_, text)) = wildcard(text) {
+            if default_op {
+                op = Op::Wildcard;
+            }
+            (None, text)
+        } else if has_wildcard {
+            return Err(Error::new(ErrorKind::UnexpectedAfterWildcard));
+        } else {
+            let (patch, text) = numeric_identifier(text, pos)?;
+            (Some(patch), text)
+        }
+    } else {
+        (None, text)
+    };
+
+    let (pre, text) = if patch.is_some() && text.starts_with('-') {
+        pos = Position::Pre;
+        let text = &text[1..];
+        let (pre, text) = prerelease_identifier(text)?;
+        if pre.is_empty() {
+            return Err(Error::new(ErrorKind::EmptySegment(pos)));
+        }
+        (pre, text)
+    } else {
+        (Prerelease::EMPTY, text)
+    };
+
+    let text = if patch.is_some() && text.starts_with('+') {
+        pos = Position::Build;
+        let text = &text[1..];
+        let (build, text) = build_identifier(text)?;
+        if build.is_empty() {
+            return Err(Error::new(ErrorKind::EmptySegment(pos)));
+        }
+        text
+    } else {
+        text
+    };
+
+    let text = text.trim_start_matches(' ');
+
+    let comparator = Comparator {
+        op,
+        major,
+        minor,
+        patch,
+        pre,
+    };
+
+    Ok((comparator, pos, text))
+}
+
+fn version_req(input: &str, out: &mut Vec<Comparator>, depth: usize) -> Result<usize, Error> {
+    let (comparator, pos, text) = match comparator(input) {
+        Ok(success) => success,
+        Err(mut error) => {
+            if let Some((ch, mut rest)) = wildcard(input) {
+                rest = rest.trim_start_matches(' ');
+                if rest.is_empty() || rest.starts_with(',') {
+                    error.kind = ErrorKind::WildcardNotTheOnlyComparator(ch);
+                }
+            }
+            return Err(error);
+        }
+    };
+
+    if text.is_empty() {
+        out.reserve_exact(depth + 1);
+        unsafe { out.as_mut_ptr().add(depth).write(comparator) }
+        return Ok(depth + 1);
+    }
+
+    let text = if let Some(text) = text.strip_prefix(',') {
+        text.trim_start_matches(' ')
+    } else {
+        let unexpected = text.chars().next().unwrap();
+        return Err(Error::new(ErrorKind::ExpectedCommaFound(pos, unexpected)));
+    };
+
+    const MAX_COMPARATORS: usize = 32;
+    if depth + 1 == MAX_COMPARATORS {
+        return Err(Error::new(ErrorKind::ExcessiveComparators));
+    }
+
+    // Recurse to collect parsed Comparator objects on the stack. We perform a
+    // single allocation to allocate exactly the right sized Vec only once the
+    // total number of comparators is known.
+    let len = version_req(text, out, depth + 1)?;
+    unsafe { out.as_mut_ptr().add(depth).write(comparator) }
+    Ok(len)
+}
diff --git a/third_party/rust/semver/src/serde.rs b/third_party/rust/semver/src/serde.rs
new file mode 100644
index 000000000000..1fcc7d87f624
--- /dev/null
+++ b/third_party/rust/semver/src/serde.rs
@@ -0,0 +1,109 @@
+use crate::{Comparator, Version, VersionReq};
+use core::fmt;
+use serde::de::{Deserialize, Deserializer, Error, Visitor};
+use serde::ser::{Serialize, Serializer};
+
+impl Serialize for Version {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        serializer.collect_str(self)
+    }
+}
+
+impl Serialize for VersionReq {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        serializer.collect_str(self)
+    }
+}
+
+impl Serialize for Comparator {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        serializer.collect_str(self)
+    }
+}
+
+impl<'de> Deserialize<'de> for Version {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        struct VersionVisitor;
+
+        impl<'de> Visitor<'de> for VersionVisitor {
+            type Value = Version;
+
+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+                formatter.write_str("semver version")
+            }
+
+            fn visit_str<E>(self, string: &str) -> Result<Self::Value, E>
+            where
+                E: Error,
+            {
+                string.parse().map_err(Error::custom)
+            }
+        }
+
+        deserializer.deserialize_str(VersionVisitor)
+    }
+}
+
+impl<'de> Deserialize<'de> for VersionReq {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        struct VersionReqVisitor;
+
+        impl<'de> Visitor<'de> for VersionReqVisitor {
+            type Value = VersionReq;
+
+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+                formatter.write_str("semver version")
+            }
+
+            fn visit_str<E>(self, string: &str) -> Result<Self::Value, E>
+            where
+                E: Error,
+            {
+                string.parse().map_err(Error::custom)
+            }
+        }
+
+        deserializer.deserialize_str(VersionReqVisitor)
+    }
+}
+
+impl<'de> Deserialize<'de> for Comparator {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        struct ComparatorVisitor;
+
+        impl<'de> Visitor<'de> for ComparatorVisitor {
+            type Value = Comparator;
+
+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+                formatter.write_str("semver comparator")
+            }
+
+            fn visit_str<E>(self, string: &str) -> Result<Self::Value, E>
+            where
+                E: Error,
+            {
+                string.parse().map_err(Error::custom)
+            }
+        }
+
+        deserializer.deserialize_str(ComparatorVisitor)
+    }
+}
diff --git a/third_party/rust/semver/tests/node/mod.rs b/third_party/rust/semver/tests/node/mod.rs
new file mode 100644
index 000000000000..eb50673d5ff1
--- /dev/null
+++ b/third_party/rust/semver/tests/node/mod.rs
@@ -0,0 +1,43 @@
+#![cfg(test_node_semver)]
+
+use semver::Version;
+use std::fmt::{self, Display};
+use std::process::Command;
+
+#[derive(Default, Eq, PartialEq, Hash, Debug)]
+pub(super) struct VersionReq(semver::VersionReq);
+
+impl VersionReq {
+    pub(super) const STAR: Self = VersionReq(semver::VersionReq::STAR);
+
+    pub(super) fn matches(&self, version: &Version) -> bool {
+        let out = Command::new("node")
+            .arg("-e")
+            .arg(format!(
+                "console.log(require('semver').satisfies('{}', '{}'))",
+                version,
+                self.to_string().replace(',', ""),
+            ))
+            .output()
+            .unwrap();
+        if out.stdout == b"true\n" {
+            true
+        } else if out.stdout == b"false\n" {
+            false
+        } else {
+            let s = String::from_utf8_lossy(&out.stdout) + String::from_utf8_lossy(&out.stderr);
+            panic!("unexpected output: {}", s);
+        }
+    }
+}
+
+impl Display for VersionReq {
+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+        Display::fmt(&self.0, formatter)
+    }
+}
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+pub(super) fn req(text: &str) -> VersionReq {
+    VersionReq(crate::util::req(text))
+}
diff --git a/third_party/rust/semver/tests/test_autotrait.rs b/third_party/rust/semver/tests/test_autotrait.rs
new file mode 100644
index 000000000000..af8534bd73ce
--- /dev/null
+++ b/third_party/rust/semver/tests/test_autotrait.rs
@@ -0,0 +1,12 @@
+fn assert_send_sync<T: Send + Sync>() {}
+
+#[test]
+fn test() {
+    assert_send_sync::<semver::BuildMetadata>();
+    assert_send_sync::<semver::Comparator>();
+    assert_send_sync::<semver::Error>();
+    assert_send_sync::<semver::Prerelease>();
+    assert_send_sync::<semver::Version>();
+    assert_send_sync::<semver::VersionReq>();
+    assert_send_sync::<semver::Op>();
+}
diff --git a/third_party/rust/semver/tests/test_identifier.rs b/third_party/rust/semver/tests/test_identifier.rs
new file mode 100644
index 000000000000..dc888c9c1019
--- /dev/null
+++ b/third_party/rust/semver/tests/test_identifier.rs
@@ -0,0 +1,45 @@
+#![allow(
+    clippy::eq_op,
+    clippy::needless_pass_by_value,
+    clippy::toplevel_ref_arg,
+    clippy::wildcard_imports
+)]
+
+mod util;
+
+use crate::util::*;
+use semver::Prerelease;
+
+#[test]
+fn test_new() {
+    fn test(identifier: Prerelease, expected: &str) {
+        assert_eq!(identifier.is_empty(), expected.is_empty());
+        assert_eq!(identifier.len(), expected.len());
+        assert_eq!(identifier.as_str(), expected);
+        assert_eq!(identifier, identifier);
+        assert_eq!(identifier, identifier.clone());
+    }
+
+    let ref mut string = String::new();
+    let limit = if cfg!(miri) { 40 } else { 280 }; // miri is slow
+    for _ in 0..limit {
+        test(prerelease(string), string);
+        string.push('1');
+    }
+
+    if !cfg!(miri) {
+        let ref string = string.repeat(20000);
+        test(prerelease(string), string);
+    }
+}
+
+#[test]
+fn test_eq() {
+    assert_eq!(prerelease("-"), prerelease("-"));
+    assert_ne!(prerelease("a"), prerelease("aa"));
+    assert_ne!(prerelease("aa"), prerelease("a"));
+    assert_ne!(prerelease("aaaaaaaaa"), prerelease("a"));
+    assert_ne!(prerelease("a"), prerelease("aaaaaaaaa"));
+    assert_ne!(prerelease("aaaaaaaaa"), prerelease("bbbbbbbbb"));
+    assert_ne!(build_metadata("1"), build_metadata("001"));
+}
diff --git a/third_party/rust/semver/tests/test_version.rs b/third_party/rust/semver/tests/test_version.rs
new file mode 100644
index 000000000000..93a528c1933f
--- /dev/null
+++ b/third_party/rust/semver/tests/test_version.rs
@@ -0,0 +1,241 @@
+#![allow(
+    clippy::nonminimal_bool,
+    clippy::too_many_lines,
+    clippy::wildcard_imports
+)]
+
+mod util;
+
+use crate::util::*;
+use semver::{BuildMetadata, Prerelease, Version};
+
+#[test]
+fn test_parse() {
+    let err = version_err("");
+    assert_to_string(
+        err,
+        "unexpected end of input while parsing major version number",
+    );
+
+    let err = version_err("  ");
+    assert_to_string(
+        err,
+        "unexpected character ' ' while parsing major version number",
+    );
+
+    let err = version_err("1");
+    assert_to_string(
+        err,
+        "unexpected end of input while parsing major version number",
+    );
+
+    let err = version_err("1.2");
+    assert_to_string(
+        err,
+        "unexpected end of input while parsing minor version number",
+    );
+
+    let err = version_err("1.2.3-");
+    assert_to_string(err, "empty identifier segment in pre-release identifier");
+
+    let err = version_err("a.b.c");
+    assert_to_string(
+        err,
+        "unexpected character 'a' while parsing major version number",
+    );
+
+    let err = version_err("1.2.3 abc");
+    assert_to_string(err, "unexpected character ' ' after patch version number");
+
+    let err = version_err("1.2.3-01");
+    assert_to_string(err, "invalid leading zero in pre-release identifier");
+
+    let parsed = version("1.2.3");
+    let expected = Version::new(1, 2, 3);
+    assert_eq!(parsed, expected);
+    let expected = Version {
+        major: 1,
+        minor: 2,
+        patch: 3,
+        pre: Prerelease::EMPTY,
+        build: BuildMetadata::EMPTY,
+    };
+    assert_eq!(parsed, expected);
+
+    let parsed = version("1.2.3-alpha1");
+    let expected = Version {
+        major: 1,
+        minor: 2,
+        patch: 3,
+        pre: prerelease("alpha1"),
+        build: BuildMetadata::EMPTY,
+    };
+    assert_eq!(parsed, expected);
+
+    let parsed = version("1.2.3+build5");
+    let expected = Version {
+        major: 1,
+        minor: 2,
+        patch: 3,
+        pre: Prerelease::EMPTY,
+        build: build_metadata("build5"),
+    };
+    assert_eq!(parsed, expected);
+
+    let parsed = version("1.2.3+5build");
+    let expected = Version {
+        major: 1,
+        minor: 2,
+        patch: 3,
+        pre: Prerelease::EMPTY,
+        build: build_metadata("5build"),
+    };
+    assert_eq!(parsed, expected);
+
+    let parsed = version("1.2.3-alpha1+build5");
+    let expected = Version {
+        major: 1,
+        minor: 2,
+        patch: 3,
+        pre: prerelease("alpha1"),
+        build: build_metadata("build5"),
+    };
+    assert_eq!(parsed, expected);
+
+    let parsed = version("1.2.3-1.alpha1.9+build5.7.3aedf");
+    let expected = Version {
+        major: 1,
+        minor: 2,
+        patch: 3,
+        pre: prerelease("1.alpha1.9"),
+        build: build_metadata("build5.7.3aedf"),
+    };
+    assert_eq!(parsed, expected);
+
+    let parsed = version("1.2.3-0a.alpha1.9+05build.7.3aedf");
+    let expected = Version {
+        major: 1,
+        minor: 2,
+        patch: 3,
+        pre: prerelease("0a.alpha1.9"),
+        build: build_metadata("05build.7.3aedf"),
+    };
+    assert_eq!(parsed, expected);
+
+    let parsed = version("0.4.0-beta.1+0851523");
+    let expected = Version {
+        major: 0,
+        minor: 4,
+        patch: 0,
+        pre: prerelease("beta.1"),
+        build: build_metadata("0851523"),
+    };
+    assert_eq!(parsed, expected);
+
+    // for https://nodejs.org/dist/index.json, where some older npm versions are "1.1.0-beta-10"
+    let parsed = version("1.1.0-beta-10");
+    let expected = Version {
+        major: 1,
+        minor: 1,
+        patch: 0,
+        pre: prerelease("beta-10"),
+        build: BuildMetadata::EMPTY,
+    };
+    assert_eq!(parsed, expected);
+}
+
+#[test]
+fn test_eq() {
+    assert_eq!(version("1.2.3"), version("1.2.3"));
+    assert_eq!(version("1.2.3-alpha1"), version("1.2.3-alpha1"));
+    assert_eq!(version("1.2.3+build.42"), version("1.2.3+build.42"));
+    assert_eq!(version("1.2.3-alpha1+42"), version("1.2.3-alpha1+42"));
+}
+
+#[test]
+fn test_ne() {
+    assert_ne!(version("0.0.0"), version("0.0.1"));
+    assert_ne!(version("0.0.0"), version("0.1.0"));
+    assert_ne!(version("0.0.0"), version("1.0.0"));
+    assert_ne!(version("1.2.3-alpha"), version("1.2.3-beta"));
+    assert_ne!(version("1.2.3+23"), version("1.2.3+42"));
+}
+
+#[test]
+fn test_display() {
+    assert_to_string(version("1.2.3"), "1.2.3");
+    assert_to_string(version("1.2.3-alpha1"), "1.2.3-alpha1");
+    assert_to_string(version("1.2.3+build.42"), "1.2.3+build.42");
+    assert_to_string(version("1.2.3-alpha1+42"), "1.2.3-alpha1+42");
+}
+
+#[test]
+fn test_lt() {
+    assert!(version("0.0.0") < version("1.2.3-alpha2"));
+    assert!(version("1.0.0") < version("1.2.3-alpha2"));
+    assert!(version("1.2.0") < version("1.2.3-alpha2"));
+    assert!(version("1.2.3-alpha1") < version("1.2.3"));
+    assert!(version("1.2.3-alpha1") < version("1.2.3-alpha2"));
+    assert!(!(version("1.2.3-alpha2") < version("1.2.3-alpha2")));
+    assert!(version("1.2.3+23") < version("1.2.3+42"));
+}
+
+#[test]
+fn test_le() {
+    assert!(version("0.0.0") <= version("1.2.3-alpha2"));
+    assert!(version("1.0.0") <= version("1.2.3-alpha2"));
+    assert!(version("1.2.0") <= version("1.2.3-alpha2"));
+    assert!(version("1.2.3-alpha1") <= version("1.2.3-alpha2"));
+    assert!(version("1.2.3-alpha2") <= version("1.2.3-alpha2"));
+    assert!(version("1.2.3+23") <= version("1.2.3+42"));
+}
+
+#[test]
+fn test_gt() {
+    assert!(version("1.2.3-alpha2") > version("0.0.0"));
+    assert!(version("1.2.3-alpha2") > version("1.0.0"));
+    assert!(version("1.2.3-alpha2") > version("1.2.0"));
+    assert!(version("1.2.3-alpha2") > version("1.2.3-alpha1"));
+    assert!(version("1.2.3") > version("1.2.3-alpha2"));
+    assert!(!(version("1.2.3-alpha2") > version("1.2.3-alpha2")));
+    assert!(!(version("1.2.3+23") > version("1.2.3+42")));
+}
+
+#[test]
+fn test_ge() {
+    assert!(version("1.2.3-alpha2") >= version("0.0.0"));
+    assert!(version("1.2.3-alpha2") >= version("1.0.0"));
+    assert!(version("1.2.3-alpha2") >= version("1.2.0"));
+    assert!(version("1.2.3-alpha2") >= version("1.2.3-alpha1"));
+    assert!(version("1.2.3-alpha2") >= version("1.2.3-alpha2"));
+    assert!(!(version("1.2.3+23") >= version("1.2.3+42")));
+}
+
+#[test]
+fn test_spec_order() {
+    let vs = [
+        "1.0.0-alpha",
+        "1.0.0-alpha.1",
+        "1.0.0-alpha.beta",
+        "1.0.0-beta",
+        "1.0.0-beta.2",
+        "1.0.0-beta.11",
+        "1.0.0-rc.1",
+        "1.0.0",
+    ];
+    let mut i = 1;
+    while i < vs.len() {
+        let a = version(vs[i - 1]);
+        let b = version(vs[i]);
+        assert!(a < b, "nope {:?} < {:?}", a, b);
+        i += 1;
+    }
+}
+
+#[test]
+fn test_align() {
+    let version = version("1.2.3-rc1");
+    assert_eq!("1.2.3-rc1           ", format!("{:20}", version));
+    assert_eq!("*****1.2.3-rc1******", format!("{:*^20}", version));
+    assert_eq!("           1.2.3-rc1", format!("{:>20}", version));
+}
diff --git a/third_party/rust/semver/tests/test_version_req.rs b/third_party/rust/semver/tests/test_version_req.rs
new file mode 100644
index 000000000000..98a03ac896ea
--- /dev/null
+++ b/third_party/rust/semver/tests/test_version_req.rs
@@ -0,0 +1,443 @@
+#![allow(
+    clippy::missing_panics_doc,
+    clippy::shadow_unrelated,
+    clippy::toplevel_ref_arg,
+    clippy::wildcard_imports
+)]
+
+mod node;
+mod util;
+
+use crate::util::*;
+use std::collections::hash_map::DefaultHasher;
+use std::hash::{Hash, Hasher};
+
+#[cfg(test_node_semver)]
+use node::{req, VersionReq};
+#[cfg(not(test_node_semver))]
+use semver::VersionReq;
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+fn assert_match_all(req: &VersionReq, versions: &[&str]) {
+    for string in versions {
+        let parsed = version(string);
+        assert!(req.matches(&parsed), "did not match {}", string);
+    }
+}
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+fn assert_match_none(req: &VersionReq, versions: &[&str]) {
+    for string in versions {
+        let parsed = version(string);
+        assert!(!req.matches(&parsed), "matched {}", string);
+    }
+}
+
+#[test]
+fn test_basic() {
+    let ref r = req("1.0.0");
+    assert_to_string(r, "^1.0.0");
+    assert_match_all(r, &["1.0.0", "1.1.0", "1.0.1"]);
+    assert_match_none(r, &["0.9.9", "0.10.0", "0.1.0", "1.0.0-pre", "1.0.1-pre"]);
+}
+
+#[test]
+#[cfg(not(no_const_vec_new))]
+fn test_default() {
+    let ref r = VersionReq::default();
+    assert_eq!(r, &VersionReq::STAR);
+}
+
+#[test]
+fn test_exact() {
+    let ref r = req("=1.0.0");
+    assert_to_string(r, "=1.0.0");
+    assert_match_all(r, &["1.0.0"]);
+    assert_match_none(r, &["1.0.1", "0.9.9", "0.10.0", "0.1.0", "1.0.0-pre"]);
+
+    let ref r = req("=0.9.0");
+    assert_to_string(r, "=0.9.0");
+    assert_match_all(r, &["0.9.0"]);
+    assert_match_none(r, &["0.9.1", "1.9.0", "0.0.9", "0.9.0-pre"]);
+
+    let ref r = req("=0.0.2");
+    assert_to_string(r, "=0.0.2");
+    assert_match_all(r, &["0.0.2"]);
+    assert_match_none(r, &["0.0.1", "0.0.3", "0.0.2-pre"]);
+
+    let ref r = req("=0.1.0-beta2.a");
+    assert_to_string(r, "=0.1.0-beta2.a");
+    assert_match_all(r, &["0.1.0-beta2.a"]);
+    assert_match_none(r, &["0.9.1", "0.1.0", "0.1.1-beta2.a", "0.1.0-beta2"]);
+
+    let ref r = req("=0.1.0+meta");
+    assert_to_string(r, "=0.1.0");
+    assert_match_all(r, &["0.1.0", "0.1.0+meta", "0.1.0+any"]);
+}
+
+#[test]
+pub fn test_greater_than() {
+    let ref r = req(">= 1.0.0");
+    assert_to_string(r, ">=1.0.0");
+    assert_match_all(r, &["1.0.0", "2.0.0"]);
+    assert_match_none(r, &["0.1.0", "0.0.1", "1.0.0-pre", "2.0.0-pre"]);
+
+    let ref r = req(">= 2.1.0-alpha2");
+    assert_to_string(r, ">=2.1.0-alpha2");
+    assert_match_all(r, &["2.1.0-alpha2", "2.1.0-alpha3", "2.1.0", "3.0.0"]);
+    assert_match_none(
+        r,
+        &["2.0.0", "2.1.0-alpha1", "2.0.0-alpha2", "3.0.0-alpha2"],
+    );
+}
+
+#[test]
+pub fn test_less_than() {
+    let ref r = req("< 1.0.0");
+    assert_to_string(r, "<1.0.0");
+    assert_match_all(r, &["0.1.0", "0.0.1"]);
+    assert_match_none(r, &["1.0.0", "1.0.0-beta", "1.0.1", "0.9.9-alpha"]);
+
+    let ref r = req("<= 2.1.0-alpha2");
+    assert_match_all(r, &["2.1.0-alpha2", "2.1.0-alpha1", "2.0.0", "1.0.0"]);
+    assert_match_none(
+        r,
+        &["2.1.0", "2.2.0-alpha1", "2.0.0-alpha2", "1.0.0-alpha2"],
+    );
+
+    let ref r = req(">1.0.0-alpha, <1.0.0");
+    assert_match_all(r, &["1.0.0-beta"]);
+
+    let ref r = req(">1.0.0-alpha, <1.0");
+    assert_match_none(r, &["1.0.0-beta"]);
+
+    let ref r = req(">1.0.0-alpha, <1");
+    assert_match_none(r, &["1.0.0-beta"]);
+}
+
+#[test]
+pub fn test_multiple() {
+    let ref r = req("> 0.0.9, <= 2.5.3");
+    assert_to_string(r, ">0.0.9, <=2.5.3");
+    assert_match_all(r, &["0.0.10", "1.0.0", "2.5.3"]);
+    assert_match_none(r, &["0.0.8", "2.5.4"]);
+
+    let ref r = req("0.3.0, 0.4.0");
+    assert_to_string(r, "^0.3.0, ^0.4.0");
+    assert_match_none(r, &["0.0.8", "0.3.0", "0.4.0"]);
+
+    let ref r = req("<= 0.2.0, >= 0.5.0");
+    assert_to_string(r, "<=0.2.0, >=0.5.0");
+    assert_match_none(r, &["0.0.8", "0.3.0", "0.5.1"]);
+
+    let ref r = req("0.1.0, 0.1.4, 0.1.6");
+    assert_to_string(r, "^0.1.0, ^0.1.4, ^0.1.6");
+    assert_match_all(r, &["0.1.6", "0.1.9"]);
+    assert_match_none(r, &["0.1.0", "0.1.4", "0.2.0"]);
+
+    let err = req_err("> 0.1.0,");
+    assert_to_string(
+        err,
+        "unexpected end of input while parsing major version number",
+    );
+
+    let err = req_err("> 0.3.0, ,");
+    assert_to_string(
+        err,
+        "unexpected character ',' while parsing major version number",
+    );
+
+    let ref r = req(">=0.5.1-alpha3, <0.6");
+    assert_to_string(r, ">=0.5.1-alpha3, <0.6");
+    assert_match_all(
+        r,
+        &[
+            "0.5.1-alpha3",
+            "0.5.1-alpha4",
+            "0.5.1-beta",
+            "0.5.1",
+            "0.5.5",
+        ],
+    );
+    assert_match_none(
+        r,
+        &["0.5.1-alpha1", "0.5.2-alpha3", "0.5.5-pre", "0.5.0-pre"],
+    );
+    assert_match_none(r, &["0.6.0", "0.6.0-pre"]);
+
+    // https://github.com/steveklabnik/semver/issues/56
+    let err = req_err("1.2.3 - 2.3.4");
+    assert_to_string(err, "expected comma after patch version number, found '-'");
+}
+
+#[test]
+pub fn test_whitespace_delimited_comparator_sets() {
+    // https://github.com/steveklabnik/semver/issues/55
+    let err = req_err("> 0.0.9 <= 2.5.3");
+    assert_to_string(err, "expected comma after patch version number, found '<'");
+}
+
+#[test]
+pub fn test_tilde() {
+    let ref r = req("~1");
+    assert_match_all(r, &["1.0.0", "1.0.1", "1.1.1"]);
+    assert_match_none(r, &["0.9.1", "2.9.0", "0.0.9"]);
+
+    let ref r = req("~1.2");
+    assert_match_all(r, &["1.2.0", "1.2.1"]);
+    assert_match_none(r, &["1.1.1", "1.3.0", "0.0.9"]);
+
+    let ref r = req("~1.2.2");
+    assert_match_all(r, &["1.2.2", "1.2.4"]);
+    assert_match_none(r, &["1.2.1", "1.9.0", "1.0.9", "2.0.1", "0.1.3"]);
+
+    let ref r = req("~1.2.3-beta.2");
+    assert_match_all(r, &["1.2.3", "1.2.4", "1.2.3-beta.2", "1.2.3-beta.4"]);
+    assert_match_none(r, &["1.3.3", "1.1.4", "1.2.3-beta.1", "1.2.4-beta.2"]);
+}
+
+#[test]
+pub fn test_caret() {
+    let ref r = req("^1");
+    assert_match_all(r, &["1.1.2", "1.1.0", "1.2.1", "1.0.1"]);
+    assert_match_none(r, &["0.9.1", "2.9.0", "0.1.4"]);
+    assert_match_none(r, &["1.0.0-beta1", "0.1.0-alpha", "1.0.1-pre"]);
+
+    let ref r = req("^1.1");
+    assert_match_all(r, &["1.1.2", "1.1.0", "1.2.1"]);
+    assert_match_none(r, &["0.9.1", "2.9.0", "1.0.1", "0.1.4"]);
+
+    let ref r = req("^1.1.2");
+    assert_match_all(r, &["1.1.2", "1.1.4", "1.2.1"]);
+    assert_match_none(r, &["0.9.1", "2.9.0", "1.1.1", "0.0.1"]);
+    assert_match_none(r, &["1.1.2-alpha1", "1.1.3-alpha1", "2.9.0-alpha1"]);
+
+    let ref r = req("^0.1.2");
+    assert_match_all(r, &["0.1.2", "0.1.4"]);
+    assert_match_none(r, &["0.9.1", "2.9.0", "1.1.1", "0.0.1"]);
+    assert_match_none(r, &["0.1.2-beta", "0.1.3-alpha", "0.2.0-pre"]);
+
+    let ref r = req("^0.5.1-alpha3");
+    assert_match_all(
+        r,
+        &[
+            "0.5.1-alpha3",
+            "0.5.1-alpha4",
+            "0.5.1-beta",
+            "0.5.1",
+            "0.5.5",
+        ],
+    );
+    assert_match_none(
+        r,
+        &[
+            "0.5.1-alpha1",
+            "0.5.2-alpha3",
+            "0.5.5-pre",
+            "0.5.0-pre",
+            "0.6.0",
+        ],
+    );
+
+    let ref r = req("^0.0.2");
+    assert_match_all(r, &["0.0.2"]);
+    assert_match_none(r, &["0.9.1", "2.9.0", "1.1.1", "0.0.1", "0.1.4"]);
+
+    let ref r = req("^0.0");
+    assert_match_all(r, &["0.0.2", "0.0.0"]);
+    assert_match_none(r, &["0.9.1", "2.9.0", "1.1.1", "0.1.4"]);
+
+    let ref r = req("^0");
+    assert_match_all(r, &["0.9.1", "0.0.2", "0.0.0"]);
+    assert_match_none(r, &["2.9.0", "1.1.1"]);
+
+    let ref r = req("^1.4.2-beta.5");
+    assert_match_all(
+        r,
+        &["1.4.2", "1.4.3", "1.4.2-beta.5", "1.4.2-beta.6", "1.4.2-c"],
+    );
+    assert_match_none(
+        r,
+        &[
+            "0.9.9",
+            "2.0.0",
+            "1.4.2-alpha",
+            "1.4.2-beta.4",
+            "1.4.3-beta.5",
+        ],
+    );
+}
+
+#[test]
+pub fn test_wildcard() {
+    let err = req_err("");
+    assert_to_string(
+        err,
+        "unexpected end of input while parsing major version number",
+    );
+
+    let ref r = req("*");
+    assert_match_all(r, &["0.9.1", "2.9.0", "0.0.9", "1.0.1", "1.1.1"]);
+    assert_match_none(r, &["1.0.0-pre"]);
+
+    for s in &["x", "X"] {
+        assert_eq!(*r, req(s));
+    }
+
+    let ref r = req("1.*");
+    assert_match_all(r, &["1.2.0", "1.2.1", "1.1.1", "1.3.0"]);
+    assert_match_none(r, &["0.0.9", "1.2.0-pre"]);
+
+    for s in &["1.x", "1.X", "1.*.*"] {
+        assert_eq!(*r, req(s));
+    }
+
+    let ref r = req("1.2.*");
+    assert_match_all(r, &["1.2.0", "1.2.2", "1.2.4"]);
+    assert_match_none(r, &["1.9.0", "1.0.9", "2.0.1", "0.1.3", "1.2.2-pre"]);
+
+    for s in &["1.2.x", "1.2.X"] {
+        assert_eq!(*r, req(s));
+    }
+}
+
+#[test]
+pub fn test_logical_or() {
+    // https://github.com/steveklabnik/semver/issues/57
+    let err = req_err("=1.2.3 || =2.3.4");
+    assert_to_string(err, "expected comma after patch version number, found '|'");
+
+    let err = req_err("1.1 || =1.2.3");
+    assert_to_string(err, "expected comma after minor version number, found '|'");
+
+    let err = req_err("6.* || 8.* || >= 10.*");
+    assert_to_string(err, "expected comma after minor version number, found '|'");
+}
+
+#[test]
+pub fn test_any() {
+    #[cfg(not(no_const_vec_new))]
+    let ref r = VersionReq::STAR;
+    #[cfg(no_const_vec_new)]
+    let ref r = VersionReq {
+        comparators: Vec::new(),
+    };
+    assert_match_all(r, &["0.0.1", "0.1.0", "1.0.0"]);
+}
+
+#[test]
+pub fn test_pre() {
+    let ref r = req("=2.1.1-really.0");
+    assert_match_all(r, &["2.1.1-really.0"]);
+}
+
+#[test]
+pub fn test_parse_errors() {
+    let err = req_err("\0");
+    assert_to_string(
+        err,
+        "unexpected character '\\0' while parsing major version number",
+    );
+
+    let err = req_err(">= >= 0.0.2");
+    assert_to_string(
+        err,
+        "unexpected character '>' while parsing major version number",
+    );
+
+    let err = req_err(">== 0.0.2");
+    assert_to_string(
+        err,
+        "unexpected character '=' while parsing major version number",
+    );
+
+    let err = req_err("a.0.0");
+    assert_to_string(
+        err,
+        "unexpected character 'a' while parsing major version number",
+    );
+
+    let err = req_err("1.0.0-");
+    assert_to_string(err, "empty identifier segment in pre-release identifier");
+
+    let err = req_err(">=");
+    assert_to_string(
+        err,
+        "unexpected end of input while parsing major version number",
+    );
+}
+
+#[test]
+fn test_cargo3202() {
+    let ref r = req("0.*.*");
+    assert_to_string(r, "0.*");
+    assert_match_all(r, &["0.5.0"]);
+
+    let ref r = req("0.0.*");
+    assert_to_string(r, "0.0.*");
+}
+
+#[test]
+fn test_digit_after_wildcard() {
+    let err = req_err("*.1");
+    assert_to_string(err, "unexpected character after wildcard in version req");
+
+    let err = req_err("1.*.1");
+    assert_to_string(err, "unexpected character after wildcard in version req");
+
+    let err = req_err(">=1.*.1");
+    assert_to_string(err, "unexpected character after wildcard in version req");
+}
+
+#[test]
+fn test_eq_hash() {
+    fn calculate_hash(value: impl Hash) -> u64 {
+        let mut hasher = DefaultHasher::new();
+        value.hash(&mut hasher);
+        hasher.finish()
+    }
+
+    assert!(req("^1") == req("^1"));
+    assert!(calculate_hash(req("^1")) == calculate_hash(req("^1")));
+    assert!(req("^1") != req("^2"));
+}
+
+#[test]
+fn test_leading_digit_in_pre_and_build() {
+    for op in &["=", ">", ">=", "<", "<=", "~", "^"] {
+        // digit then alpha
+        req(&format!("{} 1.2.3-1a", op));
+        req(&format!("{} 1.2.3+1a", op));
+
+        // digit then alpha (leading zero)
+        req(&format!("{} 1.2.3-01a", op));
+        req(&format!("{} 1.2.3+01", op));
+
+        // multiple
+        req(&format!("{} 1.2.3-1+1", op));
+        req(&format!("{} 1.2.3-1-1+1-1-1", op));
+        req(&format!("{} 1.2.3-1a+1a", op));
+        req(&format!("{} 1.2.3-1a-1a+1a-1a-1a", op));
+    }
+}
+
+#[test]
+fn test_wildcard_and_another() {
+    let err = req_err("*, 0.20.0-any");
+    assert_to_string(
+        err,
+        "wildcard req (*) must be the only comparator in the version req",
+    );
+
+    let err = req_err("0.20.0-any, *");
+    assert_to_string(
+        err,
+        "wildcard req (*) must be the only comparator in the version req",
+    );
+
+    let err = req_err("0.20.0-any, *, 1.0");
+    assert_to_string(
+        err,
+        "wildcard req (*) must be the only comparator in the version req",
+    );
+}
diff --git a/third_party/rust/semver/tests/util/mod.rs b/third_party/rust/semver/tests/util/mod.rs
new file mode 100644
index 000000000000..5cc142c484e5
--- /dev/null
+++ b/third_party/rust/semver/tests/util/mod.rs
@@ -0,0 +1,39 @@
+#![allow(dead_code)]
+
+use semver::{BuildMetadata, Error, Prerelease, Version, VersionReq};
+use std::fmt::Display;
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+pub(super) fn version(text: &str) -> Version {
+    Version::parse(text).unwrap()
+}
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+pub(super) fn version_err(text: &str) -> Error {
+    Version::parse(text).unwrap_err()
+}
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+pub(super) fn req(text: &str) -> VersionReq {
+    VersionReq::parse(text).unwrap()
+}
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+pub(super) fn req_err(text: &str) -> Error {
+    VersionReq::parse(text).unwrap_err()
+}
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+pub(super) fn prerelease(text: &str) -> Prerelease {
+    Prerelease::new(text).unwrap()
+}
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+pub(super) fn build_metadata(text: &str) -> BuildMetadata {
+    BuildMetadata::new(text).unwrap()
+}
+
+#[cfg_attr(not(no_track_caller), track_caller)]
+pub(super) fn assert_to_string(value: impl Display, expected: &str) {
+    assert_eq!(value.to_string(), expected);
+}
-- 
2.37.1

