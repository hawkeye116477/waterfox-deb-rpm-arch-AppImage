From c6311073527d13af0bc793a02c62ef42900ae510 Mon Sep 17 00:00:00 2001
Date: Tue, 23 Aug 2022 18:13:08 +0200
Subject: [PATCH 1/2] Bug 1660745 - Update encoding_rs to 0.8.31 and
 packed_simd to 0.3.7. r=hsivonen

---
 .cargo/config.in                              |   2 +-
 Cargo.lock                                    |  17 +-
 Cargo.toml                                    |   2 +-
 config/makefiles/rust.mk                      |   2 +-
 .../mozbuild/mozbuild/vendor/vendor_rust.py   |   7 +
 .../encoding/textdecoder-labels.any.js.ini    |  57 ----
 .../rust/encoding_rs/.cargo-checksum.json     |   2 +-
 third_party/rust/encoding_rs/CONTRIBUTING.md  |   5 +-
 third_party/rust/encoding_rs/COPYRIGHT        |   7 +-
 third_party/rust/encoding_rs/Cargo.toml       |  52 ++-
 third_party/rust/encoding_rs/LICENSE-MIT      |   2 +-
 third_party/rust/encoding_rs/LICENSE-WHATWG   |  26 ++
 third_party/rust/encoding_rs/README.md        | 109 +++++--
 third_party/rust/encoding_rs/ci/miri.sh       |  14 +
 .../encoding_rs/generate-encoding-data.py     |  23 +-
 third_party/rust/encoding_rs/src/ascii.rs     |  41 ++-
 third_party/rust/encoding_rs/src/big5.rs      |  40 ++-
 third_party/rust/encoding_rs/src/data.rs      |   2 +-
 third_party/rust/encoding_rs/src/euc_jp.rs    |  13 +-
 third_party/rust/encoding_rs/src/euc_kr.rs    |  12 +-
 third_party/rust/encoding_rs/src/gb18030.rs   |  60 ++--
 third_party/rust/encoding_rs/src/handles.rs   |  50 +--
 .../rust/encoding_rs/src/iso_2022_jp.rs       |  62 ++--
 third_party/rust/encoding_rs/src/lib.rs       | 197 ++++++++----
 third_party/rust/encoding_rs/src/macros.rs    |   6 +-
 third_party/rust/encoding_rs/src/mem.rs       | 115 ++++---
 .../rust/encoding_rs/src/replacement.rs       |   6 +-
 third_party/rust/encoding_rs/src/shift_jis.rs |  12 +-
 .../rust/encoding_rs/src/simd_funcs.rs        |  37 +--
 .../rust/encoding_rs/src/single_byte.rs       |  22 +-
 .../rust/encoding_rs/src/test_labels_names.rs |   9 +
 third_party/rust/encoding_rs/src/testing.rs   |  16 +-
 third_party/rust/encoding_rs/src/utf_16.rs    |   8 +-
 third_party/rust/encoding_rs/src/utf_8.rs     |  22 +-
 third_party/rust/encoding_rs/src/variant.rs   |   2 +-
 .../rust/encoding_rs/src/x_user_defined.rs    |   8 +-
 third_party/rust/packed_simd/Cargo.toml       |  45 ---
 third_party/rust/packed_simd/build.rs         |  34 --
 third_party/rust/packed_simd/rustfmt.toml     |   7 -
 .../rust/packed_simd/src/api/cast/v128.rs     |  79 -----
 .../rust/packed_simd/src/api/cast/v16.rs      |  17 -
 .../rust/packed_simd/src/api/cast/v256.rs     |  81 -----
 .../rust/packed_simd/src/api/cast/v32.rs      |  30 --
 .../rust/packed_simd/src/api/cast/v512.rs     |  68 ----
 .../rust/packed_simd/src/api/cast/v64.rs      |  47 ---
 .../packed_simd/src/api/into_bits/v128.rs     |  28 --
 .../packed_simd/src/api/into_bits/v256.rs     |  27 --
 .../packed_simd/src/api/into_bits/v512.rs     |  27 --
 .../rust/packed_simd/src/testing/macros.rs    |  44 ---
 .../.appveyor.yml                             |   0
 .../.cargo-checksum.json                      |   2 +-
 .../.travis.yml                               |  31 +-
 third_party/rust/packed_simd_2/Cargo.toml     |  42 +++
 .../LICENSE-APACHE                            |   0
 .../LICENSE-MIT                               |   0
 .../{packed_simd => packed_simd_2}/README.md  |  31 +-
 .../{packed_simd => packed_simd_2}/bors.toml  |   0
 third_party/rust/packed_simd_2/build.rs       |   6 +
 .../{packed_simd => packed_simd_2}/ci/all.sh  |   0
 .../ci/android-install-ndk.sh                 |   0
 .../ci/android-install-sdk.sh                 |   0
 .../ci/android-sysimage.sh                    |   0
 .../ci/benchmark.sh                           |   0
 .../ci/deploy_and_run_on_ios_simulator.rs     |   0
 .../docker/aarch64-linux-android/Dockerfile   |   0
 .../aarch64-unknown-linux-gnu/Dockerfile      |   0
 .../docker/arm-linux-androideabi/Dockerfile   |   0
 .../arm-unknown-linux-gnueabi/Dockerfile      |   0
 .../arm-unknown-linux-gnueabihf/Dockerfile    |   0
 .../armv7-unknown-linux-gnueabihf/Dockerfile  |   0
 .../docker/i586-unknown-linux-gnu/Dockerfile  |   0
 .../docker/i686-unknown-linux-gnu/Dockerfile  |   0
 .../docker/mips-unknown-linux-gnu/Dockerfile  |   0
 .../mips64-unknown-linux-gnuabi64/Dockerfile  |   0
 .../Dockerfile                                |   0
 .../mipsel-unknown-linux-musl/Dockerfile      |   0
 .../powerpc-unknown-linux-gnu/Dockerfile      |   0
 .../powerpc64-unknown-linux-gnu/Dockerfile    |   0
 .../powerpc64le-unknown-linux-gnu/Dockerfile  |   0
 .../docker/s390x-unknown-linux-gnu/Dockerfile |   0
 .../sparc64-unknown-linux-gnu/Dockerfile      |   0
 .../thumbv7neon-linux-androideabi/Dockerfile  |   0
 .../Dockerfile                                |   0
 .../docker/wasm32-unknown-unknown/Dockerfile  |   9 +-
 .../ci/docker/x86_64-linux-android/Dockerfile |   0
 .../Dockerfile                                |   0
 .../x86_64-unknown-linux-gnu/Dockerfile       |   0
 .../{packed_simd => packed_simd_2}/ci/dox.sh  |   0
 .../ci/linux-s390x.sh                         |   0
 .../ci/linux-sparc64.sh                       |   0
 .../ci/lld-shim.rs                            |   0
 .../ci/max_line_width.sh                      |   0
 .../ci/run-docker.sh                          |   0
 .../{packed_simd => packed_simd_2}/ci/run.sh  |   0
 .../ci/run_examples.sh                        |   0
 .../ci/runtest-android.rs                     |   0
 .../ci/setup_benchmarks.sh                    |   0
 .../ci/test-runner-linux                      |   0
 .../contributing.md                           |   2 +-
 .../perf-guide/.gitignore                     |   0
 .../perf-guide/book.toml                      |   0
 .../perf-guide/src/SUMMARY.md                 |   0
 .../perf-guide/src/ascii.css                  |   0
 .../perf-guide/src/bound_checks.md            |   0
 .../perf-guide/src/float-math/approx.md       |   0
 .../perf-guide/src/float-math/fma.md          |   0
 .../perf-guide/src/float-math/fp.md           |   0
 .../perf-guide/src/float-math/svml.md         |   0
 .../perf-guide/src/introduction.md            |   0
 .../perf-guide/src/prof/linux.md              |   0
 .../perf-guide/src/prof/mca.md                |   0
 .../perf-guide/src/prof/profiling.md          |   0
 .../src/target-feature/attribute.md           |   0
 .../perf-guide/src/target-feature/features.md |   0
 .../perf-guide/src/target-feature/inlining.md |   0
 .../perf-guide/src/target-feature/practice.md |   0
 .../perf-guide/src/target-feature/runtime.md  |   0
 .../src/target-feature/rustflags.md           |   6 +-
 .../perf-guide/src/vert-hor-ops.md            |   0
 third_party/rust/packed_simd_2/rustfmt.toml   |   5 +
 .../{packed_simd => packed_simd_2}/src/api.rs |   0
 .../src/api/bit_manip.rs                      |   0
 .../src/api/bitmask.rs                        |   0
 .../src/api/cast.rs                           |   0
 .../src/api/cast/macros.rs                    |   0
 .../rust/packed_simd_2/src/api/cast/v128.rs   | 302 ++++++++++++++++++
 .../rust/packed_simd_2/src/api/cast/v16.rs    |  68 ++++
 .../rust/packed_simd_2/src/api/cast/v256.rs   | 298 +++++++++++++++++
 .../rust/packed_simd_2/src/api/cast/v32.rs    | 132 ++++++++
 .../rust/packed_simd_2/src/api/cast/v512.rs   | 209 ++++++++++++
 .../rust/packed_simd_2/src/api/cast/v64.rs    | 208 ++++++++++++
 .../src/api/cmp.rs                            |   0
 .../src/api/cmp/eq.rs                         |   0
 .../src/api/cmp/ord.rs                        |   0
 .../src/api/cmp/partial_eq.rs                 |   4 +-
 .../src/api/cmp/partial_ord.rs                |   8 +-
 .../src/api/cmp/vertical.rs                   |   0
 .../src/api/default.rs                        |   0
 .../src/api/fmt.rs                            |   0
 .../src/api/fmt/binary.rs                     |   4 +-
 .../src/api/fmt/debug.rs                      |   4 +-
 .../src/api/fmt/lower_hex.rs                  |   4 +-
 .../src/api/fmt/octal.rs                      |   4 +-
 .../src/api/fmt/upper_hex.rs                  |   4 +-
 .../src/api/from.rs                           |   0
 .../src/api/from/from_array.rs                |   0
 .../src/api/from/from_vector.rs               |   0
 .../src/api/hash.rs                           |   0
 .../src/api/into_bits.rs                      |   4 +-
 .../src/api/into_bits/arch_specific.rs        | 272 ++++++++++++----
 .../src/api/into_bits/macros.rs               |   2 +-
 .../packed_simd_2/src/api/into_bits/v128.rs   | 232 ++++++++++++++
 .../src/api/into_bits/v16.rs                  |   0
 .../packed_simd_2/src/api/into_bits/v256.rs   | 232 ++++++++++++++
 .../src/api/into_bits/v32.rs                  |   0
 .../packed_simd_2/src/api/into_bits/v512.rs   | 232 ++++++++++++++
 .../src/api/into_bits/v64.rs                  |   0
 .../src/api/math.rs                           |   0
 .../src/api/math/float.rs                     |   0
 .../src/api/math/float/abs.rs                 |   0
 .../src/api/math/float/consts.rs              |  36 +--
 .../src/api/math/float/cos.rs                 |   0
 .../src/api/math/float/exp.rs                 |   0
 .../src/api/math/float/ln.rs                  |   0
 .../src/api/math/float/mul_add.rs             |   0
 .../src/api/math/float/mul_adde.rs            |   0
 .../src/api/math/float/powf.rs                |   0
 .../src/api/math/float/recpre.rs              |   0
 .../src/api/math/float/rsqrte.rs              |   0
 .../src/api/math/float/sin.rs                 |   0
 .../src/api/math/float/sqrt.rs                |   0
 .../src/api/math/float/sqrte.rs               |   0
 .../src/api/minimal.rs                        |   0
 .../src/api/minimal/iuf.rs                    |   0
 .../src/api/minimal/mask.rs                   |   0
 .../src/api/minimal/ptr.rs                    |   0
 .../src/api/ops.rs                            |   0
 .../src/api/ops/scalar_arithmetic.rs          |   0
 .../src/api/ops/scalar_bitwise.rs             |   0
 .../src/api/ops/scalar_mask_bitwise.rs        |   0
 .../src/api/ops/scalar_shifts.rs              |   7 +-
 .../src/api/ops/vector_arithmetic.rs          |   0
 .../src/api/ops/vector_bitwise.rs             |   0
 .../src/api/ops/vector_float_min_max.rs       |   0
 .../src/api/ops/vector_int_min_max.rs         |   0
 .../src/api/ops/vector_mask_bitwise.rs        |   0
 .../src/api/ops/vector_neg.rs                 |   0
 .../src/api/ops/vector_rotates.rs             |   2 +
 .../src/api/ops/vector_shifts.rs              |   7 +-
 .../src/api/ptr.rs                            |   0
 .../src/api/ptr/gather_scatter.rs             |  21 +-
 .../src/api/reductions.rs                     |   0
 .../src/api/reductions/bitwise.rs             |   0
 .../src/api/reductions/float_arithmetic.rs    |   8 +-
 .../src/api/reductions/integer_arithmetic.rs  |   8 +-
 .../src/api/reductions/mask.rs                |   0
 .../src/api/reductions/min_max.rs             |  65 ++--
 .../src/api/select.rs                         |   4 +-
 .../src/api/shuffle.rs                        |   8 +-
 .../src/api/shuffle1_dyn.rs                   |   0
 .../src/api/slice.rs                          |   0
 .../src/api/slice/from_slice.rs               |  28 +-
 .../src/api/slice/write_to_slice.rs           |  35 +-
 .../src/api/swap_bytes.rs                     |   0
 .../src/codegen.rs                            |   0
 .../src/codegen/bit_manip.rs                  |  13 +-
 .../src/codegen/llvm.rs                       |   0
 .../src/codegen/math.rs                       |   0
 .../src/codegen/math/float.rs                 |   0
 .../src/codegen/math/float/abs.rs             |   0
 .../src/codegen/math/float/cos.rs             |   0
 .../src/codegen/math/float/cos_pi.rs          |   0
 .../src/codegen/math/float/exp.rs             |   0
 .../src/codegen/math/float/ln.rs              |   0
 .../src/codegen/math/float/macros.rs          | 133 ++------
 .../src/codegen/math/float/mul_add.rs         |   0
 .../src/codegen/math/float/mul_adde.rs        |   8 +-
 .../src/codegen/math/float/powf.rs            |   0
 .../src/codegen/math/float/sin.rs             |   0
 .../src/codegen/math/float/sin_cos_pi.rs      |  21 +-
 .../src/codegen/math/float/sin_pi.rs          |   0
 .../src/codegen/math/float/sqrt.rs            |   0
 .../src/codegen/math/float/sqrte.rs           |   0
 .../src/codegen/pointer_sized_int.rs          |   0
 .../src/codegen/reductions.rs                 |   0
 .../src/codegen/reductions/mask.rs            |   2 +-
 .../src/codegen/reductions/mask/aarch64.rs    |  38 ++-
 .../src/codegen/reductions/mask/arm.rs        |  26 +-
 .../src/codegen/reductions/mask/fallback.rs   |   4 +-
 .../codegen/reductions/mask/fallback_impl.rs  |   0
 .../src/codegen/reductions/mask/x86.rs        |  70 ++--
 .../src/codegen/reductions/mask/x86/avx.rs    |  10 +-
 .../src/codegen/reductions/mask/x86/avx2.rs   |   0
 .../src/codegen/reductions/mask/x86/sse.rs    |   3 +-
 .../src/codegen/reductions/mask/x86/sse2.rs   |   6 +-
 .../src/codegen/shuffle.rs                    |   4 +-
 .../src/codegen/shuffle1_dyn.rs               |  19 +-
 .../src/codegen/swap_bytes.rs                 |  48 +--
 .../src/codegen/v128.rs                       |   0
 .../src/codegen/v16.rs                        |   0
 .../src/codegen/v256.rs                       |   0
 .../src/codegen/v32.rs                        |   0
 .../src/codegen/v512.rs                       |   0
 .../src/codegen/v64.rs                        |   0
 .../src/codegen/vPtr.rs                       |   0
 .../src/codegen/vSize.rs                      |  33 +-
 .../{packed_simd => packed_simd_2}/src/lib.rs |  54 ++--
 .../src/masks.rs                              |   8 +-
 .../src/sealed.rs                             |   0
 .../src/testing.rs                            |   0
 .../rust/packed_simd_2/src/testing/macros.rs  |  44 +++
 .../src/testing/utils.rs                      |  34 +-
 .../src/v128.rs                               |   0
 .../{packed_simd => packed_simd_2}/src/v16.rs |   0
 .../src/v256.rs                               |   0
 .../{packed_simd => packed_simd_2}/src/v32.rs |   0
 .../src/v512.rs                               |   0
 .../{packed_simd => packed_simd_2}/src/v64.rs |   0
 .../src/vPtr.rs                               |   0
 .../src/vSize.rs                              |   0
 .../tests/endianness.rs                       |  10 +-
 261 files changed, 3219 insertions(+), 1556 deletions(-)
 delete mode 100644 testing/web-platform/meta/encoding/textdecoder-labels.any.js.ini
 create mode 100644 third_party/rust/encoding_rs/LICENSE-WHATWG
 create mode 100644 third_party/rust/encoding_rs/ci/miri.sh
 delete mode 100644 third_party/rust/packed_simd/Cargo.toml
 delete mode 100644 third_party/rust/packed_simd/build.rs
 delete mode 100644 third_party/rust/packed_simd/rustfmt.toml
 delete mode 100644 third_party/rust/packed_simd/src/api/cast/v128.rs
 delete mode 100644 third_party/rust/packed_simd/src/api/cast/v16.rs
 delete mode 100644 third_party/rust/packed_simd/src/api/cast/v256.rs
 delete mode 100644 third_party/rust/packed_simd/src/api/cast/v32.rs
 delete mode 100644 third_party/rust/packed_simd/src/api/cast/v512.rs
 delete mode 100644 third_party/rust/packed_simd/src/api/cast/v64.rs
 delete mode 100644 third_party/rust/packed_simd/src/api/into_bits/v128.rs
 delete mode 100644 third_party/rust/packed_simd/src/api/into_bits/v256.rs
 delete mode 100644 third_party/rust/packed_simd/src/api/into_bits/v512.rs
 delete mode 100644 third_party/rust/packed_simd/src/testing/macros.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/.appveyor.yml (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/.cargo-checksum.json (66%)
 rename third_party/rust/{packed_simd => packed_simd_2}/.travis.yml (86%)
 create mode 100644 third_party/rust/packed_simd_2/Cargo.toml
 rename third_party/rust/{packed_simd => packed_simd_2}/LICENSE-APACHE (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/LICENSE-MIT (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/README.md (85%)
 rename third_party/rust/{packed_simd => packed_simd_2}/bors.toml (100%)
 create mode 100644 third_party/rust/packed_simd_2/build.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/all.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/android-install-ndk.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/android-install-sdk.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/android-sysimage.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/benchmark.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/deploy_and_run_on_ios_simulator.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/aarch64-linux-android/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/aarch64-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/arm-linux-androideabi/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/arm-unknown-linux-gnueabi/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/i586-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/i686-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/mips-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/mipsel-unknown-linux-musl/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/powerpc-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/s390x-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/sparc64-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/thumbv7neon-linux-androideabi/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/wasm32-unknown-unknown/Dockerfile (77%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/x86_64-linux-android/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/docker/x86_64-unknown-linux-gnu/Dockerfile (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/dox.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/linux-s390x.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/linux-sparc64.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/lld-shim.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/max_line_width.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/run-docker.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/run.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/run_examples.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/runtest-android.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/setup_benchmarks.sh (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/ci/test-runner-linux (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/contributing.md (99%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/.gitignore (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/book.toml (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/SUMMARY.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/ascii.css (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/bound_checks.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/float-math/approx.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/float-math/fma.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/float-math/fp.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/float-math/svml.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/introduction.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/prof/linux.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/prof/mca.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/prof/profiling.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/target-feature/attribute.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/target-feature/features.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/target-feature/inlining.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/target-feature/practice.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/target-feature/runtime.md (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/target-feature/rustflags.md (92%)
 rename third_party/rust/{packed_simd => packed_simd_2}/perf-guide/src/vert-hor-ops.md (100%)
 create mode 100644 third_party/rust/packed_simd_2/rustfmt.toml
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/bit_manip.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/bitmask.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/cast.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/cast/macros.rs (100%)
 create mode 100644 third_party/rust/packed_simd_2/src/api/cast/v128.rs
 create mode 100644 third_party/rust/packed_simd_2/src/api/cast/v16.rs
 create mode 100644 third_party/rust/packed_simd_2/src/api/cast/v256.rs
 create mode 100644 third_party/rust/packed_simd_2/src/api/cast/v32.rs
 create mode 100644 third_party/rust/packed_simd_2/src/api/cast/v512.rs
 create mode 100644 third_party/rust/packed_simd_2/src/api/cast/v64.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/cmp.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/cmp/eq.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/cmp/ord.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/cmp/partial_eq.rs (97%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/cmp/partial_ord.rs (98%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/cmp/vertical.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/default.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/fmt.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/fmt/binary.rs (94%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/fmt/debug.rs (95%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/fmt/lower_hex.rs (94%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/fmt/octal.rs (94%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/fmt/upper_hex.rs (94%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/from.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/from/from_array.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/from/from_vector.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/hash.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/into_bits.rs (90%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/into_bits/arch_specific.rs (54%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/into_bits/macros.rs (97%)
 create mode 100644 third_party/rust/packed_simd_2/src/api/into_bits/v128.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/into_bits/v16.rs (100%)
 create mode 100644 third_party/rust/packed_simd_2/src/api/into_bits/v256.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/into_bits/v32.rs (100%)
 create mode 100644 third_party/rust/packed_simd_2/src/api/into_bits/v512.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/into_bits/v64.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/abs.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/consts.rs (57%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/cos.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/exp.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/ln.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/mul_add.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/mul_adde.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/powf.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/recpre.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/rsqrte.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/sin.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/sqrt.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/math/float/sqrte.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/minimal.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/minimal/iuf.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/minimal/mask.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/minimal/ptr.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/scalar_arithmetic.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/scalar_bitwise.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/scalar_mask_bitwise.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/scalar_shifts.rs (94%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/vector_arithmetic.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/vector_bitwise.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/vector_float_min_max.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/vector_int_min_max.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/vector_mask_bitwise.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/vector_neg.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/vector_rotates.rs (96%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ops/vector_shifts.rs (94%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ptr.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/ptr/gather_scatter.rs (94%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/reductions.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/reductions/bitwise.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/reductions/float_arithmetic.rs (97%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/reductions/integer_arithmetic.rs (96%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/reductions/mask.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/reductions/min_max.rs (86%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/select.rs (94%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/shuffle.rs (97%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/shuffle1_dyn.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/slice.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/slice/from_slice.rs (90%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/slice/write_to_slice.rs (88%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/api/swap_bytes.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/bit_manip.rs (96%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/llvm.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/abs.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/cos.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/cos_pi.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/exp.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/ln.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/macros.rs (80%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/mul_add.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/mul_adde.rs (89%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/powf.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/sin.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/sin_cos_pi.rs (87%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/sin_pi.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/sqrt.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/math/float/sqrte.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/pointer_sized_int.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask.rs (97%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/aarch64.rs (72%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/arm.rs (69%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/fallback.rs (68%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/fallback_impl.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/x86.rs (80%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/x86/avx.rs (91%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/x86/avx2.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/x86/sse.rs (92%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/reductions/mask/x86/sse2.rs (92%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/shuffle.rs (99%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/shuffle1_dyn.rs (96%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/swap_bytes.rs (90%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/v128.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/v16.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/v256.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/v32.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/v512.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/v64.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/vPtr.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/codegen/vSize.rs (55%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/lib.rs (86%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/masks.rs (92%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/sealed.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/testing.rs (100%)
 create mode 100644 third_party/rust/packed_simd_2/src/testing/macros.rs
 rename third_party/rust/{packed_simd => packed_simd_2}/src/testing/utils.rs (83%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/v128.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/v16.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/v256.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/v32.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/v512.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/v64.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/vPtr.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/src/vSize.rs (100%)
 rename third_party/rust/{packed_simd => packed_simd_2}/tests/endianness.rs (96%)

diff --git a/.cargo/config.in b/.cargo/config.in
index 5560f944e386..dc8837051460 100644
--- a/.cargo/config.in
+++ b/.cargo/config.in
@@ -65,7 +65,7 @@ rev = "746743227485a83123784df0c53227ab466612ed"
 [source."https://github.com/hsivonen/packed_simd"]
 git = "https://github.com/hsivonen/packed_simd"
 replace-with = "vendored-sources"
-rev = "8b4bd7d8229660a749dbe419a57ea01df9de5453"
+rev = "c149d0a519bf878567c7630096737669ec2ff15f"
 
 [source."https://github.com/hsivonen/chardetng_c"]
 git = "https://github.com/hsivonen/chardetng_c"
diff --git a/Cargo.lock b/Cargo.lock
index b2e20f5501ff..f22d010be310 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -1270,12 +1270,12 @@ dependencies = [
 
 [[package]]
 name = "encoding_rs"
-version = "0.8.22"
+version = "0.8.31"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cd8d03faa7fe0c1431609dfad7bbe827af30f82e1e2ae6f7ee4fca6bd764bc28"
+checksum = "9852635589dc9f9ea1b6fe9f05b50ef208c85c834a562f0c6abb1c475736ec2b"
 dependencies = [
- "cfg-if 0.1.10",
- "packed_simd",
+ "cfg-if 1.0.0",
+ "packed_simd_2",
 ]
 
 [[package]]
@@ -3540,12 +3540,11 @@ dependencies = [
 ]
 
 [[package]]
-name = "packed_simd"
-version = "0.3.4"
-source = "git+https://github.com/hsivonen/packed_simd?rev=8b4bd7d8229660a749dbe419a57ea01df9de5453#8b4bd7d8229660a749dbe419a57ea01df9de5453"
+name = "packed_simd_2"
+version = "0.3.7"
+source = "git+https://github.com/hsivonen/packed_simd?rev=c149d0a519bf878567c7630096737669ec2ff15f#c149d0a519bf878567c7630096737669ec2ff15f"
 dependencies = [
- "cfg-if 0.1.10",
- "rustc_version",
+ "cfg-if 1.0.0",
 ]
 
 [[package]]
diff --git a/Cargo.toml b/Cargo.toml
index 74658ce02ad8..cb7555a6b4ef 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -78,7 +78,7 @@ opt-level = 2
 chardetng = { git = "https://github.com/hsivonen/chardetng", rev="302c995f91f44cf26e77dc4758ad56c3ff0153ad" }
 chardetng_c = { git = "https://github.com/hsivonen/chardetng_c", rev="ed8a4c6f900a90d4dbc1d64b856e61490a1c3570" }
 libudev-sys = { path = "dom/webauthn/libudev-sys" }
-packed_simd = { git = "https://github.com/hsivonen/packed_simd", rev="8b4bd7d8229660a749dbe419a57ea01df9de5453" }
+packed_simd = { package = "packed_simd_2", git = "https://github.com/hsivonen/packed_simd", rev="c149d0a519bf878567c7630096737669ec2ff15f" }
 rlbox_lucet_sandbox = { git = "https://github.com/PLSysSec/rlbox_lucet_sandbox/", rev="5c8e79048d3ff6f434109e19d4aee4ff8624d3d7" }
 nix = { git = "https://github.com/shravanrn/nix/", rev="4af6c367603869a30fddb5ffb0aba2b9477ba92e" }
 spirv_cross = { git = "https://github.com/kvark/spirv_cross", branch = "wgpu5" }
diff --git a/config/makefiles/rust.mk b/config/makefiles/rust.mk
index 401c2933bb63..489db449b7e5 100644
--- a/config/makefiles/rust.mk
+++ b/config/makefiles/rust.mk
@@ -238,7 +238,7 @@ endif
 ifndef RUSTC_BOOTSTRAP
 RUSTC_BOOTSTRAP := gkrust_shared,qcms
 ifdef MOZ_RUST_SIMD
-RUSTC_BOOTSTRAP := $(RUSTC_BOOTSTRAP),encoding_rs,packed_simd
+RUSTC_BOOTSTRAP := $(RUSTC_BOOTSTRAP),encoding_rs,packed_simd_2
 endif
 export RUSTC_BOOTSTRAP
 endif
diff --git a/python/mozbuild/mozbuild/vendor/vendor_rust.py b/python/mozbuild/mozbuild/vendor/vendor_rust.py
index 2c38aa2e3731..39805228d927 100644
--- a/python/mozbuild/mozbuild/vendor/vendor_rust.py
+++ b/python/mozbuild/mozbuild/vendor/vendor_rust.py
@@ -292,6 +292,13 @@ Please commit or stash these changes before vendoring, or re-run with `--ignore-
         we will abort if that is detected. We'll handle `/` and OR as
         equivalent and approve is any is in our approved list."""
 
+        # This specific AND combination has been reviewed for encoding_rs.
+        if (
+            license_string == "(Apache-2.0 OR MIT) AND BSD-3-Clause"
+            and package == "encoding_rs"
+        ):
+            return True
+
         if re.search(r"\s+AND", license_string):
             return False
 
diff --git a/testing/web-platform/meta/encoding/textdecoder-labels.any.js.ini b/testing/web-platform/meta/encoding/textdecoder-labels.any.js.ini
deleted file mode 100644
index 271605647343..000000000000
--- a/testing/web-platform/meta/encoding/textdecoder-labels.any.js.ini
+++ /dev/null
@@ -1,57 +0,0 @@
-[textdecoder-labels.any.html]
-  [unicode11utf8 => UTF-8]
-    expected: FAIL
-
-  [ucs-2 => UTF-16LE]
-    expected: FAIL
-
-  [unicodefffe => UTF-16BE]
-    expected: FAIL
-
-  [unicode => UTF-16LE]
-    expected: FAIL
-
-  [csunicode => UTF-16LE]
-    expected: FAIL
-
-  [x-unicode20utf8 => UTF-8]
-    expected: FAIL
-
-  [iso-10646-ucs-2 => UTF-16LE]
-    expected: FAIL
-
-  [unicodefeff => UTF-16LE]
-    expected: FAIL
-
-  [unicode20utf8 => UTF-8]
-    expected: FAIL
-
-
-[textdecoder-labels.any.worker.html]
-  [unicode11utf8 => UTF-8]
-    expected: FAIL
-
-  [ucs-2 => UTF-16LE]
-    expected: FAIL
-
-  [unicodefffe => UTF-16BE]
-    expected: FAIL
-
-  [unicode => UTF-16LE]
-    expected: FAIL
-
-  [csunicode => UTF-16LE]
-    expected: FAIL
-
-  [x-unicode20utf8 => UTF-8]
-    expected: FAIL
-
-  [iso-10646-ucs-2 => UTF-16LE]
-    expected: FAIL
-
-  [unicodefeff => UTF-16LE]
-    expected: FAIL
-
-  [unicode20utf8 => UTF-8]
-    expected: FAIL
-
diff --git a/third_party/rust/encoding_rs/.cargo-checksum.json b/third_party/rust/encoding_rs/.cargo-checksum.json
index d009a2c7e818..925adb692537 100644
--- a/third_party/rust/encoding_rs/.cargo-checksum.json
+++ b/third_party/rust/encoding_rs/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"CONTRIBUTING.md":"06c26277e8dbd3f57be2eb51b5e3285dc1cbbf8c11326df413868ae702e6a61c","COPYRIGHT":"8b98376eb373dcf81950474efe34b5576a8171460dff500cc58a1ed8d160cd57","Cargo.toml":"99e8b29ff66a85a2961d2d70064c3a83dede337cdc18e149cfa59d4d59eb2991","Ideas.md":"b7452893f500163868d8de52c09addaf91e1632454ed02e892c467ed7ec39dbd","LICENSE-APACHE":"cfc7749b96f63bd31c3c42b5c471bf756814053e847c10f3eb003417bc523d30","LICENSE-MIT":"f2ad48641d9c997d9ae3b95d93d1cd6e1ab12ab4c44de89937c7bfabbd076a4a","README.md":"9351c79bd13e297091f745f6fb276a1f5113b5f644dc79eccb8ef09eb6cfa032","build.rs":"9276ee24ef71433d46323c15296b3fbbb29c0b37c4b1ca45416587f14ba8e777","doc/Big5.txt":"f73a2edc5cb6c2d140ba6e07f4542e1c4a234950378acde1df93480f0ca0be0b","doc/EUC-JP.txt":"ee2818b907d0137f40a9ab9fd525fc700a44dbdddb6cf0c157a656566bae4bf1","doc/EUC-KR.txt":"71d9e2ccf3b124e8bdfb433c8cf2773fd878077038d0cec3c7237a50f4a78a30","doc/GBK.txt":"c1b522b5a799884e5001da661f42c5a8f4d0acb9ef1d74b206f22b5f65365606","doc/IBM866.txt":"a5a433e804d0f83af785015179fbc1d9b0eaf1f7960efcd04093e136b51fbd0e","doc/ISO-2022-JP.txt":"af86684f5a8f0e2868d7b2c292860140c3d2e5527530ca091f1b28198e8e2fe6","doc/ISO-8859-10.txt":"6d3949ad7c81ca176895101ed81a1db7df1060d64e262880b94bd31bb344ab4d","doc/ISO-8859-13.txt":"3951dd89cf93f7729148091683cf8511f4529388b7dc8dcd0d62eaed55be93fa","doc/ISO-8859-14.txt":"3d330784a0374fd255a38b47949675cc7168c800530534b0a01cac6edc623adc","doc/ISO-8859-15.txt":"24b1084aab5127a85aab99153f86e24694d0a3615f53b5ce23683f97cf66c47a","doc/ISO-8859-16.txt":"ce0272559b92ba76d7a7e476f6424ae4a5cc72e75b183611b08392e44add4d25","doc/ISO-8859-2.txt":"18ceff88c13d1b5ba455a3919b1e3de489045c4c3d2dd7e8527c125c75d54aad","doc/ISO-8859-3.txt":"21798404c68f4f5db59223362f24999da96968c0628427321fccce7d2849a130","doc/ISO-8859-4.txt":"d27f6520c6c5bfbcc19176b71d081cdb3bccde1622bb3e420d5680e812632d53","doc/ISO-8859-5.txt":"a10ec8d6ea7a78ad15da7275f6cb1a3365118527e28f9af6d0d5830501303f3a","doc/ISO-8859-6.txt":"ccda8a2efc96115336bdd77776637b9712425e44fbcf745353b9057fbef144e7","doc/ISO-8859-7.txt":"17900fa1f27a445958f0a77d7d9056be375a6bd7ee4492aa680c7c1500bab85e","doc/ISO-8859-8-I.txt":"8357555646d54265a9b9ffa3e68b08d132312f1561c60108ff9b8b1167b6ecf2","doc/ISO-8859-8.txt":"72cd6f3afb7b4a9c16a66a362473315770b7755d72c86c870e52fc3eba86c8af","doc/KOI8-R.txt":"839cf19a38da994488004ed7814b1f6151640156a9a2af02bf2efca745fb5966","doc/KOI8-U.txt":"0cc76624ed1f024183e2298b7e019957da2c70c8ca06e0fc4e6f353f50a5054f","doc/Shift_JIS.txt":"34c49141818cb9ddbcf59cc858f78a79be8ad148d563f26415108ae1f148443f","doc/UTF-16BE.txt":"e2e280d8acbaa6d2a6b3569d60e17500a285f2baa0df3363dd85537cd5a1ef8f","doc/UTF-16LE.txt":"70bdc170e3fc5298ba68f10125fb5eeb8b077036cc96bb4416c4de396f6d76c1","doc/UTF-8.txt":"ea7bae742e613010ced002cf4b601a737d2203fad65e115611451bc4428f548a","doc/gb18030.txt":"dc71378a8f07a2d8659f69ee81fb8791fef56ba86f124b429978285237bb4a7b","doc/macintosh.txt":"57491e53866711b4672d9b9ff35380b9dac9e0d8e3d6c20bdd6140603687c023","doc/replacement.txt":"4b6c3bbd7999d9d4108a281594bd02d13607e334a95465afff8c2c08d395f0e4","doc/windows-1250.txt":"61296bb6a21cdab602300d32ecfba434cb82de5ac3bc88d58710d2f125e28d39","doc/windows-1251.txt":"7deea1c61dea1485c8ff02db2c7d578db7a9aab63ab1cfd02ec04b515864689e","doc/windows-1252.txt":"933ef3bdddfce5ee132b9f1a1aa8b47423d2587bbe475b19028d0a6d38e180b6","doc/windows-1253.txt":"1a38748b88e99071a5c7b3d5456ead4caedeabab50d50d658be105bc113714de","doc/windows-1254.txt":"f8372f86c6f8d642563cd6ddc025260553292a39423df1683a98670bd7bf2b47","doc/windows-1255.txt":"4e5852494730054e2da258a74e1b9d780abbcdd8ce22ebc218ca2efe9e90493d","doc/windows-1256.txt":"c0879c5172abedead302a406e8f60d9cd9598694a0ffa4fd288ffe4fef7b8ea1","doc/windows-1257.txt":"c28a0c9f964fcb2b46d21f537c402446501a2800670481d6abf9fd9e9018d523","doc/windows-1258.txt":"5019ae4d61805c79aacbf17c93793342dbb098d65a1837783bc3e2c6d6a23602","doc/windows-874.txt":"4ef0e4501c5feba8b17aee1818602ed44b36ca8475db771ce2fc16d392cabecc","doc/x-mac-cyrillic.txt":"58be154d8a888ca3d484b83b44f749823ef339ab27f14d90ca9a856f5050a8bd","doc/x-user-defined.txt":"f9cd07c4321bf5cfb0be4bdddd251072999b04a6cf7a6f5bc63709a84e2c1ffc","generate-encoding-data.py":"b523b9f00711976357db0b735d15863b9d0559c90946136e874bda0b68fd5479","rustfmt.toml":"85c1a3b4382fd89e991cbb81b70fb52780472edc064c963943cdaaa56e0a2030","src/ascii.rs":"800cfbe3036d0c97ce27e07a4fd05edbcb7354ebec20903d81c76136d734931c","src/big5.rs":"ae801a92f7b8218eb488ac030958c7b0e54b01bef1645a0f56f1c1172288fbd5","src/data.rs":"9544c019c7360a669bd3adaa90b70331124abd1df59841db66e74912bcdb96a5","src/euc_jp.rs":"881f670679362372ecb744f75533ca2c7020372abaf22ce1d8a57b5b3ecc4d81","src/euc_kr.rs":"f14f520134d2969361d7fe721cc1b4118660afe91d1972f9ee5518605084edbe","src/gb18030.rs":"15466e6f3d9a27d0f6ee41057977f6bc43d624c3267de56d8aefcbb8cbb883ad","src/handles.rs":"0646bd091892ff7a76f34efccda4e5ddabe1e624e890baa9fdc9d48011d2d38b","src/iso_2022_jp.rs":"4a9e0c9702e00d4df08cf4a090f23b314fe3548ca5634a21faa0e641fdda387e","src/lib.rs":"1df141d90ce5a7c8021dc56f3d19d936df38e3e7057d85fc9056e8d3567e9190","src/macros.rs":"c7a019fd81d31de77569036ac36fd4e404b3f20144bbf79747faf4ea21538d09","src/mem.rs":"ae6792b9be8b2103541cc789dfc8796e7f3307716d0ce918b563d61b000188ad","src/replacement.rs":"182c2093a6edb162183ca5990554fd7b199d3011924a8d80d894ba98ee7c479e","src/shift_jis.rs":"98decc3cc76f224adbe24b8114ff966cb48ac92abeee5c0ef81d28cec033df55","src/simd_funcs.rs":"63df317a3a8edac708196546d02b2070ecfb8d1d0a2aa16db33d13803572b2fc","src/single_byte.rs":"ddd8162b8d0f1256fd5da1d8e203110265887f8a3f75ebe6af9310a06a8cd39f","src/test_data/big5_in.txt":"4c5a8691f8dc717311889c63894026d2fb62725a86c4208ca274a9cc8d42a503","src/test_data/big5_in_ref.txt":"99d399e17750cf9c7cf30bb253dbfe35b81c4fcbdead93cfa48b1429213473c7","src/test_data/big5_out.txt":"6193ca97c297aa20e09396038d18e938bb7ea331c26f0f2454097296723a0b13","src/test_data/big5_out_ref.txt":"36567691f557df144f6cc520015a87038dfa156f296fcf103b56ae9a718be1fc","src/test_data/euc_kr_in.txt":"c86a7224f3215fa0d04e685622a752fdc72763e8ae076230c7fd62de57ec4074","src/test_data/euc_kr_in_ref.txt":"1f419f4ca47d708b54c73c461545a022ae2e20498fdbf8005a483d752a204883","src/test_data/euc_kr_out.txt":"e7f32e026f70be1e1b58e0047baf7d3d2c520269c4f9b9992e158b4decb0a1a3","src/test_data/euc_kr_out_ref.txt":"c9907857980b20b8e9e3b584482ed6567a2be6185d72237b6322f0404944924e","src/test_data/gb18030_in.txt":"ab7231b2d3e9afacdbd7d7f3b9e5361a7ff9f7e1cfdb4f3bd905b9362b309e53","src/test_data/gb18030_in_ref.txt":"dc5069421adca2043c55f5012b55a76fdff651d22e6e699fd0978f8d5706815c","src/test_data/gb18030_out.txt":"f0208d527f5ca63de7d9a0323be8d5cf12d8a104b2943d92c2701f0c3364dac1","src/test_data/gb18030_out_ref.txt":"6819fe47627e4ea01027003fc514b9f21a1322e732d7f1fb92cc6c5455bc6c07","src/test_data/iso_2022_jp_in.txt":"cd24bbdcb1834e25db54646fbf4c41560a13dc7540f6be3dba4f5d97d44513af","src/test_data/iso_2022_jp_in_ref.txt":"3dc4e6a5e06471942d086b16c9440945e78415f6f3f47e43717e4bc2eac2cdf5","src/test_data/iso_2022_jp_out.txt":"9b6f015329dda6c3f9ee5ce6dbd6fa9c89acc21283e886836c78b8d833480c21","src/test_data/iso_2022_jp_out_ref.txt":"78cb260093a20116ad9a42f43b05d1848c5ab100b6b9a850749809e943884b35","src/test_data/jis0208_in.txt":"6df3030553ffb0a6615bb33dc8ea9dca6d9623a9028e2ffec754ce3c3da824cc","src/test_data/jis0208_in_ref.txt":"3dc4e6a5e06471942d086b16c9440945e78415f6f3f47e43717e4bc2eac2cdf5","src/test_data/jis0208_out.txt":"4ec24477e1675ce750733bdc3c5add1cd27b6bd4ce1f09289564646e9654e857","src/test_data/jis0208_out_ref.txt":"c3e1cef5032b2b1d93a406f31ff940c4e2dfe8859b8b17ca2761fee7a75a0e48","src/test_data/jis0212_in.txt":"c011f0dd72bd7c8cd922df9374ef8d2769a77190514c77f6c62b415852eeb9fe","src/test_data/jis0212_in_ref.txt":"7d9458b3d2f73e7092a7f505c08ce1d233dde18aa679fbcf9889256239cc9e06","src/test_data/shift_jis_in.txt":"02e389ccef0dd2122e63f503899402cb7f797912c2444cc80ab93131116c5524","src/test_data/shift_jis_in_ref.txt":"512f985950ca902e643c88682dba9708b7c38d3c5ec2925168ab00ac94ab19f9","src/test_data/shift_jis_out.txt":"5fbc44da7bf639bf6cfe0fa1fd3eba7102b88f81919c9ea991302712f69426fb","src/test_data/shift_jis_out_ref.txt":"466322c6fed8286c64582731755290c2296508efdd258826e6279686649b481f","src/test_labels_names.rs":"c962c7aeac3d9ef2aca70c9e21983b231d4cf998cb06879374b0401e5149d1da","src/testing.rs":"b299d27055f3b068de66cc10a75c024b881c48bc093627c01e0b1f8bd7d94666","src/utf_16.rs":"08c1f5fbd968b04b1d6f61b3b21202a9a3a18ec4da2723914907429f4f6a09fc","src/utf_8.rs":"c3baecaf74cf005313f8029f621a5a93456bd19252aa668e522d44bee88bbe45","src/variant.rs":"3d81a104eb07a87efc9daf295a53bbe66b85b0df478c14d5aad216f0df5f5a28","src/x_user_defined.rs":"da51def859b870ced29cb87987f02d27b220eac0f222876cb72a1dc616f9d8ec"},"package":"cd8d03faa7fe0c1431609dfad7bbe827af30f82e1e2ae6f7ee4fca6bd764bc28"}
\ No newline at end of file
+{"files":{"CONTRIBUTING.md":"ca1901f3e8532fb4cec894fd3664f0eaa898c0c4b961d1b992d1ed54eacf362a","COPYRIGHT":"11789f45bb180841cd362a5eee6789c68ddb573a11105e30768c308a6add0190","Cargo.toml":"abf2c7d17500cfa1148b76b9a8a8574873a6f6de90d6110d0d8f6b519c8c99f6","Ideas.md":"b7452893f500163868d8de52c09addaf91e1632454ed02e892c467ed7ec39dbd","LICENSE-APACHE":"cfc7749b96f63bd31c3c42b5c471bf756814053e847c10f3eb003417bc523d30","LICENSE-MIT":"3fa4ca83dcc9237839b1bdeb2e6d16bdfb5ec0c5ce42b24694d8bbf0dcbef72c","LICENSE-WHATWG":"838118388fe5c2e7f1dbbaeed13e1c7f3ebf88be91319c7c1d77c18e987d1a50","README.md":"bcb4b59cfc5f48fbaba954b8ae4daa9eaecf9044afc89208a78a7e995c321b81","build.rs":"9276ee24ef71433d46323c15296b3fbbb29c0b37c4b1ca45416587f14ba8e777","ci/miri.sh":"43cb8d82f49e3bfe2d2274b6ccd6f0714a4188ccef0cecc040829883cfdbee25","doc/Big5.txt":"f73a2edc5cb6c2d140ba6e07f4542e1c4a234950378acde1df93480f0ca0be0b","doc/EUC-JP.txt":"ee2818b907d0137f40a9ab9fd525fc700a44dbdddb6cf0c157a656566bae4bf1","doc/EUC-KR.txt":"71d9e2ccf3b124e8bdfb433c8cf2773fd878077038d0cec3c7237a50f4a78a30","doc/GBK.txt":"c1b522b5a799884e5001da661f42c5a8f4d0acb9ef1d74b206f22b5f65365606","doc/IBM866.txt":"a5a433e804d0f83af785015179fbc1d9b0eaf1f7960efcd04093e136b51fbd0e","doc/ISO-2022-JP.txt":"af86684f5a8f0e2868d7b2c292860140c3d2e5527530ca091f1b28198e8e2fe6","doc/ISO-8859-10.txt":"6d3949ad7c81ca176895101ed81a1db7df1060d64e262880b94bd31bb344ab4d","doc/ISO-8859-13.txt":"3951dd89cf93f7729148091683cf8511f4529388b7dc8dcd0d62eaed55be93fa","doc/ISO-8859-14.txt":"3d330784a0374fd255a38b47949675cc7168c800530534b0a01cac6edc623adc","doc/ISO-8859-15.txt":"24b1084aab5127a85aab99153f86e24694d0a3615f53b5ce23683f97cf66c47a","doc/ISO-8859-16.txt":"ce0272559b92ba76d7a7e476f6424ae4a5cc72e75b183611b08392e44add4d25","doc/ISO-8859-2.txt":"18ceff88c13d1b5ba455a3919b1e3de489045c4c3d2dd7e8527c125c75d54aad","doc/ISO-8859-3.txt":"21798404c68f4f5db59223362f24999da96968c0628427321fccce7d2849a130","doc/ISO-8859-4.txt":"d27f6520c6c5bfbcc19176b71d081cdb3bccde1622bb3e420d5680e812632d53","doc/ISO-8859-5.txt":"a10ec8d6ea7a78ad15da7275f6cb1a3365118527e28f9af6d0d5830501303f3a","doc/ISO-8859-6.txt":"ccda8a2efc96115336bdd77776637b9712425e44fbcf745353b9057fbef144e7","doc/ISO-8859-7.txt":"17900fa1f27a445958f0a77d7d9056be375a6bd7ee4492aa680c7c1500bab85e","doc/ISO-8859-8-I.txt":"8357555646d54265a9b9ffa3e68b08d132312f1561c60108ff9b8b1167b6ecf2","doc/ISO-8859-8.txt":"72cd6f3afb7b4a9c16a66a362473315770b7755d72c86c870e52fc3eba86c8af","doc/KOI8-R.txt":"839cf19a38da994488004ed7814b1f6151640156a9a2af02bf2efca745fb5966","doc/KOI8-U.txt":"0cc76624ed1f024183e2298b7e019957da2c70c8ca06e0fc4e6f353f50a5054f","doc/Shift_JIS.txt":"34c49141818cb9ddbcf59cc858f78a79be8ad148d563f26415108ae1f148443f","doc/UTF-16BE.txt":"e2e280d8acbaa6d2a6b3569d60e17500a285f2baa0df3363dd85537cd5a1ef8f","doc/UTF-16LE.txt":"70bdc170e3fc5298ba68f10125fb5eeb8b077036cc96bb4416c4de396f6d76c1","doc/UTF-8.txt":"ea7bae742e613010ced002cf4b601a737d2203fad65e115611451bc4428f548a","doc/gb18030.txt":"dc71378a8f07a2d8659f69ee81fb8791fef56ba86f124b429978285237bb4a7b","doc/macintosh.txt":"57491e53866711b4672d9b9ff35380b9dac9e0d8e3d6c20bdd6140603687c023","doc/replacement.txt":"4b6c3bbd7999d9d4108a281594bd02d13607e334a95465afff8c2c08d395f0e4","doc/windows-1250.txt":"61296bb6a21cdab602300d32ecfba434cb82de5ac3bc88d58710d2f125e28d39","doc/windows-1251.txt":"7deea1c61dea1485c8ff02db2c7d578db7a9aab63ab1cfd02ec04b515864689e","doc/windows-1252.txt":"933ef3bdddfce5ee132b9f1a1aa8b47423d2587bbe475b19028d0a6d38e180b6","doc/windows-1253.txt":"1a38748b88e99071a5c7b3d5456ead4caedeabab50d50d658be105bc113714de","doc/windows-1254.txt":"f8372f86c6f8d642563cd6ddc025260553292a39423df1683a98670bd7bf2b47","doc/windows-1255.txt":"4e5852494730054e2da258a74e1b9d780abbcdd8ce22ebc218ca2efe9e90493d","doc/windows-1256.txt":"c0879c5172abedead302a406e8f60d9cd9598694a0ffa4fd288ffe4fef7b8ea1","doc/windows-1257.txt":"c28a0c9f964fcb2b46d21f537c402446501a2800670481d6abf9fd9e9018d523","doc/windows-1258.txt":"5019ae4d61805c79aacbf17c93793342dbb098d65a1837783bc3e2c6d6a23602","doc/windows-874.txt":"4ef0e4501c5feba8b17aee1818602ed44b36ca8475db771ce2fc16d392cabecc","doc/x-mac-cyrillic.txt":"58be154d8a888ca3d484b83b44f749823ef339ab27f14d90ca9a856f5050a8bd","doc/x-user-defined.txt":"f9cd07c4321bf5cfb0be4bdddd251072999b04a6cf7a6f5bc63709a84e2c1ffc","generate-encoding-data.py":"be989dd25c6b946e3e8745fdc8e8a80fcf24b3be99ad0b4b78153ba3f6ab6310","rustfmt.toml":"85c1a3b4382fd89e991cbb81b70fb52780472edc064c963943cdaaa56e0a2030","src/ascii.rs":"5c94c74e9b3f48706a4a6dc2d860702a991687a2ac314319cf38cb6d8fb1eabe","src/big5.rs":"ec6e2913011a38e9a3e825a1731f139a7ca1d5b264fefae51a3cc1a68a57cef9","src/data.rs":"8a617cc57032092d65850eb27e00de687c80aea3299e839a1f58b42d0b35abf3","src/euc_jp.rs":"32047f5b540188c4cb19c07165f846b9786a09f18e315ed3e9bda1293dae52aa","src/euc_kr.rs":"9b25afc72d9378700eecfac58d55ad1c5946d6cd0ccde2c29c08200ef2de6bb9","src/gb18030.rs":"808587168d73f0c80f8520f0ca9b161866ed2efeb17a05e85fdf3b8efe7ba28a","src/handles.rs":"cc83dc0754751d67f5688a65c5e0191cba02f6bacce81a0813a243cba55eef7a","src/iso_2022_jp.rs":"9bb485e82574f4b7d4b2364f0ff276acb6a0bc111758420a3b0ec5e04c196652","src/lib.rs":"a64116a6d46ab30ce91deabdb4c5388f03be632326e8a00110bfb0c598474a0a","src/macros.rs":"200997f8870de8bfd8cdc475e92115df42108c0df661e49d3d1cbc32056e1d99","src/mem.rs":"e33f94f18a9dc53f0425c14de238dca22ff028baff4e9bca89d780ac6d581d71","src/replacement.rs":"7660b34a53f8c1ca2bdfa0e51e843ec28326950952ad8bc96569feb93ac62308","src/shift_jis.rs":"6951ae67e36b1a12fa3a30734957f444d8b1b4ae0e2bde52060b29bd0f16d9d9","src/simd_funcs.rs":"103ab4f21229270f97f5ca639ad4f8d82e0d5099974b63db4b3faa486012064b","src/single_byte.rs":"3c9e9c1f946ae622c725ba9421240c1faa9a05e95fa10dd4642a25cb276a1edc","src/test_data/big5_in.txt":"4c5a8691f8dc717311889c63894026d2fb62725a86c4208ca274a9cc8d42a503","src/test_data/big5_in_ref.txt":"99d399e17750cf9c7cf30bb253dbfe35b81c4fcbdead93cfa48b1429213473c7","src/test_data/big5_out.txt":"6193ca97c297aa20e09396038d18e938bb7ea331c26f0f2454097296723a0b13","src/test_data/big5_out_ref.txt":"36567691f557df144f6cc520015a87038dfa156f296fcf103b56ae9a718be1fc","src/test_data/euc_kr_in.txt":"c86a7224f3215fa0d04e685622a752fdc72763e8ae076230c7fd62de57ec4074","src/test_data/euc_kr_in_ref.txt":"1f419f4ca47d708b54c73c461545a022ae2e20498fdbf8005a483d752a204883","src/test_data/euc_kr_out.txt":"e7f32e026f70be1e1b58e0047baf7d3d2c520269c4f9b9992e158b4decb0a1a3","src/test_data/euc_kr_out_ref.txt":"c9907857980b20b8e9e3b584482ed6567a2be6185d72237b6322f0404944924e","src/test_data/gb18030_in.txt":"ab7231b2d3e9afacdbd7d7f3b9e5361a7ff9f7e1cfdb4f3bd905b9362b309e53","src/test_data/gb18030_in_ref.txt":"dc5069421adca2043c55f5012b55a76fdff651d22e6e699fd0978f8d5706815c","src/test_data/gb18030_out.txt":"f0208d527f5ca63de7d9a0323be8d5cf12d8a104b2943d92c2701f0c3364dac1","src/test_data/gb18030_out_ref.txt":"6819fe47627e4ea01027003fc514b9f21a1322e732d7f1fb92cc6c5455bc6c07","src/test_data/iso_2022_jp_in.txt":"cd24bbdcb1834e25db54646fbf4c41560a13dc7540f6be3dba4f5d97d44513af","src/test_data/iso_2022_jp_in_ref.txt":"3dc4e6a5e06471942d086b16c9440945e78415f6f3f47e43717e4bc2eac2cdf5","src/test_data/iso_2022_jp_out.txt":"9b6f015329dda6c3f9ee5ce6dbd6fa9c89acc21283e886836c78b8d833480c21","src/test_data/iso_2022_jp_out_ref.txt":"78cb260093a20116ad9a42f43b05d1848c5ab100b6b9a850749809e943884b35","src/test_data/jis0208_in.txt":"6df3030553ffb0a6615bb33dc8ea9dca6d9623a9028e2ffec754ce3c3da824cc","src/test_data/jis0208_in_ref.txt":"3dc4e6a5e06471942d086b16c9440945e78415f6f3f47e43717e4bc2eac2cdf5","src/test_data/jis0208_out.txt":"4ec24477e1675ce750733bdc3c5add1cd27b6bd4ce1f09289564646e9654e857","src/test_data/jis0208_out_ref.txt":"c3e1cef5032b2b1d93a406f31ff940c4e2dfe8859b8b17ca2761fee7a75a0e48","src/test_data/jis0212_in.txt":"c011f0dd72bd7c8cd922df9374ef8d2769a77190514c77f6c62b415852eeb9fe","src/test_data/jis0212_in_ref.txt":"7d9458b3d2f73e7092a7f505c08ce1d233dde18aa679fbcf9889256239cc9e06","src/test_data/shift_jis_in.txt":"02e389ccef0dd2122e63f503899402cb7f797912c2444cc80ab93131116c5524","src/test_data/shift_jis_in_ref.txt":"512f985950ca902e643c88682dba9708b7c38d3c5ec2925168ab00ac94ab19f9","src/test_data/shift_jis_out.txt":"5fbc44da7bf639bf6cfe0fa1fd3eba7102b88f81919c9ea991302712f69426fb","src/test_data/shift_jis_out_ref.txt":"466322c6fed8286c64582731755290c2296508efdd258826e6279686649b481f","src/test_labels_names.rs":"23a2e11b02b3b8d15fb5613a625e3edb2c61e70e3c581abfd638719a4088200d","src/testing.rs":"f59e671e95a98a56f6b573e8c6be4d71e670bf52f7e20eb1605d990aafa1894e","src/utf_16.rs":"c071a147fad38d750c2c247e141b76b929a48007b99f26b2922b9caecdaf2f25","src/utf_8.rs":"4bbda750d4cfcc1031d42b358955a5ef94381dbaf9c8820cfa7354fad2ede4a7","src/variant.rs":"1fab5363588a1554a7169de8731ea9cded7ac63ea35caabdd1c27a8dde68c27b","src/x_user_defined.rs":"c9c010730dfb9f141d4fed19350c08a21af240913a54bb64f5ca89ff93b6b7d1"},"package":"9852635589dc9f9ea1b6fe9f05b50ef208c85c834a562f0c6abb1c475736ec2b"}
\ No newline at end of file
diff --git a/third_party/rust/encoding_rs/CONTRIBUTING.md b/third_party/rust/encoding_rs/CONTRIBUTING.md
index ef268e308fca..e05207ed6626 100644
--- a/third_party/rust/encoding_rs/CONTRIBUTING.md
+++ b/third_party/rust/encoding_rs/CONTRIBUTING.md
@@ -29,8 +29,9 @@ Please do not contribute implementations of encodings that are not specified
 in the [Encoding Standard](https://encoding.spec.whatwg.org/).
 
 For example, an implementation of UTF-7 is explicitly out of scope for this
-crate and is, therefore, provided by the [charset](https://crates.io/crates/charset)
-crate instead.
+crate and is, therefore, provided by the [`charset`](https://crates.io/crates/charset)
+crate instead. For single-byte DOS encodings, please see the
+[`oem_cp`](https://crates.io/crates/oem_cp) crate.
 
 ## Compatibility with Stable Rust
 
diff --git a/third_party/rust/encoding_rs/COPYRIGHT b/third_party/rust/encoding_rs/COPYRIGHT
index 607467e3aab3..83d3ece14099 100644
--- a/third_party/rust/encoding_rs/COPYRIGHT
+++ b/third_party/rust/encoding_rs/COPYRIGHT
@@ -1,4 +1,4 @@
-encoding_rs is copyright 2013-2016 Mozilla Foundation.
+encoding_rs is copyright Mozilla Foundation.
 
 Licensed under the Apache License, Version 2.0
 <LICENSE-APACHE or
@@ -8,5 +8,10 @@ at your option. All files in the project carrying such
 notice may not be copied, modified, or distributed except
 according to those terms.
 
+This crate includes data derived from the data files supplied
+with the WHATWG Encoding Standard, which, when incorporated into
+source code, are licensed under the BSD 3-Clause License
+<LICENSE-WHATWG>.
+
 Test code within encoding_rs is dedicated to the Public Domain when so
 designated (see the individual files for PD/CC0-dedicated sections).
diff --git a/third_party/rust/encoding_rs/Cargo.toml b/third_party/rust/encoding_rs/Cargo.toml
index 9497c8c07e18..5fafdfa9aea5 100644
--- a/third_party/rust/encoding_rs/Cargo.toml
+++ b/third_party/rust/encoding_rs/Cargo.toml
@@ -3,37 +3,51 @@
 # When uploading crates to the registry Cargo will automatically
 # "normalize" Cargo.toml files for maximal compatibility
 # with all versions of Cargo and also rewrite `path` dependencies
-# to registry (e.g., crates.io) dependencies
+# to registry (e.g., crates.io) dependencies.
 #
-# If you believe there's an error in this file please file an
-# issue against the rust-lang/cargo repository. If you're
-# editing this file be aware that the upstream Cargo.toml
-# will likely look very different (and much more reasonable)
+# If you are reading this file be aware that the original Cargo.toml
+# will likely look very different (and much more reasonable).
+# See Cargo.toml.orig for the original contents.
 
 [package]
+edition = "2018"
 name = "encoding_rs"
-version = "0.8.22"
+version = "0.8.31"
 authors = ["Henri Sivonen <hsivonen@hsivonen.fi>"]
 description = "A Gecko-oriented implementation of the Encoding Standard"
 homepage = "https://docs.rs/encoding_rs/"
 documentation = "https://docs.rs/encoding_rs/"
 readme = "README.md"
-keywords = ["encoding", "web", "unicode", "charset"]
-categories = ["text-processing", "encoding", "web-programming", "internationalization"]
-license = "MIT/Apache-2.0"
+keywords = [
+    "encoding",
+    "web",
+    "unicode",
+    "charset",
+]
+categories = [
+    "text-processing",
+    "encoding",
+    "web-programming",
+    "internationalization",
+]
+license = "(Apache-2.0 OR MIT) AND BSD-3-Clause"
 repository = "https://github.com/hsivonen/encoding_rs"
+
 [profile.release]
 lto = true
+
 [dependencies.cfg-if]
-version = "0.1.0"
+version = "1.0"
 
 [dependencies.packed_simd]
-version = "0.3.3"
+version = "0.3.4"
 optional = true
+package = "packed_simd_2"
 
 [dependencies.serde]
 version = "1.0"
 optional = true
+
 [dev-dependencies.bincode]
 version = "1.0"
 
@@ -44,15 +58,27 @@ version = "1.0"
 version = "1.0"
 
 [features]
+alloc = []
+default = ["alloc"]
 fast-big5-hanzi-encode = []
 fast-gb-hanzi-encode = []
 fast-hangul-encode = []
 fast-hanja-encode = []
 fast-kanji-encode = []
-fast-legacy-encode = ["fast-hangul-encode", "fast-hanja-encode", "fast-kanji-encode", "fast-gb-hanzi-encode", "fast-big5-hanzi-encode"]
+fast-legacy-encode = [
+    "fast-hangul-encode",
+    "fast-hanja-encode",
+    "fast-kanji-encode",
+    "fast-gb-hanzi-encode",
+    "fast-big5-hanzi-encode",
+]
 less-slow-big5-hanzi-encode = []
 less-slow-gb-hanzi-encode = []
 less-slow-kanji-encode = []
-simd-accel = ["packed_simd", "packed_simd/into_bits"]
+simd-accel = [
+    "packed_simd",
+    "packed_simd/into_bits",
+]
+
 [badges.travis-ci]
 repository = "hsivonen/encoding_rs"
diff --git a/third_party/rust/encoding_rs/LICENSE-MIT b/third_party/rust/encoding_rs/LICENSE-MIT
index ede86d4596eb..3317c82e2f67 100644
--- a/third_party/rust/encoding_rs/LICENSE-MIT
+++ b/third_party/rust/encoding_rs/LICENSE-MIT
@@ -1,4 +1,4 @@
-Copyright (c) 2013-2016 Mozilla Foundation
+Copyright Mozilla Foundation
 
 Permission is hereby granted, free of charge, to any
 person obtaining a copy of this software and associated
diff --git a/third_party/rust/encoding_rs/LICENSE-WHATWG b/third_party/rust/encoding_rs/LICENSE-WHATWG
new file mode 100644
index 000000000000..f690e7196590
--- /dev/null
+++ b/third_party/rust/encoding_rs/LICENSE-WHATWG
@@ -0,0 +1,26 @@
+Copyright  WHATWG (Apple, Google, Mozilla, Microsoft).
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, this
+   list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice,
+   this list of conditions and the following disclaimer in the documentation
+   and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its
+   contributors may be used to endorse or promote products derived from
+   this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/third_party/rust/encoding_rs/README.md b/third_party/rust/encoding_rs/README.md
index 0f4d2e695ad5..d75d77d9a161 100644
--- a/third_party/rust/encoding_rs/README.md
+++ b/third_party/rust/encoding_rs/README.md
@@ -1,13 +1,18 @@
 # encoding_rs
 
 [![Build Status](https://travis-ci.org/hsivonen/encoding_rs.svg?branch=master)](https://travis-ci.org/hsivonen/encoding_rs)
-[![crates.io](https://meritbadge.herokuapp.com/encoding_rs)](https://crates.io/crates/encoding_rs)
+[![crates.io](https://img.shields.io/crates/v/encoding_rs.svg)](https://crates.io/crates/encoding_rs)
 [![docs.rs](https://docs.rs/encoding_rs/badge.svg)](https://docs.rs/encoding_rs/)
-[![Apache 2 / MIT dual-licensed](https://img.shields.io/badge/license-Apache%202%20%2F%20MIT-blue.svg)](https://github.com/hsivonen/encoding_rs/blob/master/COPYRIGHT)
 
 encoding_rs an implementation of the (non-JavaScript parts of) the
-[Encoding Standard](https://encoding.spec.whatwg.org/) written in Rust and
-used in Gecko (starting with Firefox 56).
+[Encoding Standard](https://encoding.spec.whatwg.org/) written in Rust.
+
+The Encoding Standard defines the Web-compatible set of character encodings,
+which means this crate can be used to decode Web content. encoding_rs is
+used in Gecko starting with Firefox 56. Due to the notable overlap between
+the legacy encodings on the Web and the legacy encodings used on Windows,
+this crate may be of use for non-Web-related situations as well; see below
+for links to adjacent crates.
 
 Additionally, the `mem` module provides various operations for dealing with
 in-RAM text (as opposed to data that's coming from or going to an IO boundary).
@@ -75,6 +80,13 @@ a `std::io::Read`, decode it into UTF-8 and presenting the result via
 `std::io::Read`. The [`encoding_rs_io`](https://crates.io/crates/encoding_rs_io)
 crate provides that capability.
 
+## `no_std` Environment
+
+The crate works in a `no_std` environment. By default, the `alloc` feature,
+which assumes that an allocator is present is enabled. For a no-allocator
+environment, the default features (i.e. `alloc`) can be turned off. This
+makes the part of the API that returns `Vec`/`String`/`Cow` unavailable.
+
 ## Decoding Email
 
 For decoding character encodings that occur in email, use the
@@ -86,6 +98,11 @@ one directly. (It wraps this crate and adds UTF-7 decoding.)
 For mappings to and from Windows code page identifiers, use the
 [`codepage`](https://crates.io/crates/codepage) crate.
 
+## DOS Encodings
+
+This crate does not support single-byte DOS encodings that aren't required by
+the Web Platform, but the [`oem_cp`](https://crates.io/crates/oem_cp) crate does.
+
 ## Preparing Text for the Encoders
 
 Normalizing text into Unicode Normalization Form C prior to encoding text into
@@ -100,9 +117,20 @@ characters. Vietnamese tone marks can be decomposed using the
 
 ## Licensing
 
+TL;DR: `(Apache-2.0 OR MIT) AND BSD-3-Clause` for the code and data combination.
+
 Please see the file named
 [COPYRIGHT](https://github.com/hsivonen/encoding_rs/blob/master/COPYRIGHT).
 
+The non-test code that isn't generated from the WHATWG data in this crate is
+under Apache-2.0 OR MIT. Test code is under CC0.
+
+This crate contains code/data generated from WHATWG-supplied data. The WHATWG
+upstream changed its license for portions of specs incorporated into source code
+from CC0 to BSD-3-Clause between the initial release of this crate and the present
+version of this crate. The in-source licensing legends have been updated for the
+parts of the generated code that have changed since the upstream license change.
+
 ## Documentation
 
 Generated [API documentation](https://docs.rs/encoding_rs/) is available
@@ -139,7 +167,7 @@ There are currently these optional cargo features:
 
 ### `simd-accel`
 
-Enables SIMD acceleration using the nightly-dependent `packed_simd` crate.
+Enables SIMD acceleration using the nightly-dependent `packed_simd_2` crate.
 
 This is an opt-in feature, because enabling this feature _opts out_ of Rust's
 guarantees of future compilers compiling old code (aka. "stability story").
@@ -160,7 +188,7 @@ feature.
 _Note!_ If you are compiling for a target that does not have 128-bit SIMD
 enabled as part of the target definition and you are enabling 128-bit SIMD
 using `-C target_feature`, you need to enable the `core_arch` Cargo feature
-for `packed_simd` to compile a crates.io snapshot of `core_arch` instead of
+for `packed_simd_2` to compile a crates.io snapshot of `core_arch` instead of
 using the standard-library copy of `core::arch`, because the `core::arch`
 module of the pre-compiled standard library has been compiled with the
 assumption that the CPU doesn't have 128-bit SIMD. At present this applies
@@ -345,16 +373,16 @@ A framework for measuring performance is [available separately][2].
 ## Rust Version Compatibility
 
 It is a goal to support the latest stable Rust, the latest nightly Rust and
-the version of Rust that's used for Firefox Nightly (currently 1.29.0).
-These are tested on Travis.
+the version of Rust that's used for Firefox Nightly.
+
+At this time, there is no firm commitment to support a version older than
+what's required by Firefox, and there is no commitment to treat MSRV changes
+as semver-breaking, because this crate depends on `cfg-if`, which doesn't
+appear to treat MSRV changes as semver-breaking, so it would be useless for
+this crate to treat MSRV changes as semver-breaking.
 
-Additionally, beta and the oldest known to work Rust version (currently
-1.29.0) are tested on Travis. The oldest Rust known to work is tested as
-a canary so that when the oldest known to work no longer works, the change
-can be documented here. At this time, there is no firm commitment to support
-a version older than what's required by Firefox. The oldest supported Rust
-is expected to move forward rapidly when `packed_simd` can replace the `simd`
-crate without performance regression.
+As of 2021-02-04, MSRV appears to be Rust 1.36.0 for using the crate and
+1.42.0 for doc tests to pass without errors about the global allocator.
 
 ## Compatibility with rust-encoding
 
@@ -376,7 +404,10 @@ To regenerate the generated code:
    next to the `encoding_rs` directory.
  * Clone [`https://github.com/whatwg/encoding`](https://github.com/whatwg/encoding)
    next to the `encoding_rs` directory.
- * Checkout revision `f381389` of the `encoding` repo.
+ * Checkout revision `be3337450e7df1c49dca7872153c4c4670dd8256` of the `encoding` repo.
+   (Note: `f381389` was the revision of `encoding` used from before the `encoding` repo
+   license change. So far, only output changed since then has been updated to
+   the new license legend.)
  * With the `encoding_rs` directory as the working directory, run
    `python generate-encoding-data.py`.
 
@@ -414,14 +445,56 @@ To regenerate the generated code:
       adapted to Rust in rust-encoding.~
 - [x] Add actually fast CJK encode options.
 - [ ] ~Investigate [Bob Steagall's lookup table acceleration for UTF-8](https://github.com/BobSteagall/CppNow2018/blob/master/FastConversionFromUTF-8/Fast%20Conversion%20From%20UTF-8%20with%20C%2B%2B%2C%20DFAs%2C%20and%20SSE%20Intrinsics%20-%20Bob%20Steagall%20-%20C%2B%2BNow%202018.pdf).~
+- [ ] Provide a build mode that works without `alloc` (with lesser API surface).
+- [ ] Migrate to `std::simd` once it is stable and declare 1.0.
 
 ## Release Notes
 
-## 0.8.22
+### 0.8.31
+
+* Use SPDX with parentheses now that crates.io supports parentheses.
+
+### 0.8.30
+
+* Update the licensing information to take into account the WHATWG data license change.
+
+### 0.8.29
+
+* Make the parts that use an allocator optional.
+
+### 0.8.28
+
+* Fix error in Serde support introduced as part of `no_std` support.
+
+### 0.8.27
+
+* Make the crate works in a `no_std` environment (with `alloc`).
+
+### 0.8.26
+
+* Fix oversights in edition 2018 migration that broke the `simd-accel` feature.
+
+### 0.8.25
+
+* Do pointer alignment checks in a way where intermediate steps aren't defined to be Undefined Behavior.
+* Update the `packed_simd` dependency to `packed_simd_2`.
+* Update the `cfg-if` dependency to 1.0.
+* Address warnings that have been introduced by newer Rust versions along the way.
+* Update to edition 2018, since even prior to 1.0 `cfg-if` updated to edition 2018 without a semver break.
+
+### 0.8.24
+
+* Avoid computing an intermediate (not dereferenced) pointer value in a manner designated as Undefined Behavior when computing pointer alignment.
+
+### 0.8.23
+
+* Remove year from copyright notices. (No features or bug fixes.)
+
+### 0.8.22
 
 * Formatting fix and new unit test. (No features or bug fixes.)
 
-## 0.8.21
+### 0.8.21
 
 * Fixed a panic with invalid UTF-16[BE|LE] input at the end of the stream.
 
diff --git a/third_party/rust/encoding_rs/ci/miri.sh b/third_party/rust/encoding_rs/ci/miri.sh
new file mode 100644
index 000000000000..8bf217fecd8d
--- /dev/null
+++ b/third_party/rust/encoding_rs/ci/miri.sh
@@ -0,0 +1,14 @@
+set -ex
+
+# Install Miri.
+MIRI_NIGHTLY=nightly-$(curl -s https://rust-lang.github.io/rustup-components-history/x86_64-unknown-linux-gnu/miri)
+echo "Installing latest nightly with Miri: $MIRI_NIGHTLY"
+rustup default "$MIRI_NIGHTLY"
+rustup component add miri
+
+# Run tests.
+# Stacked Borrows is disabled as it costs too much RAM (due to our large tables).
+MIRIFLAGS="-Zmiri-disable-stacked-borrows" cargo miri test
+
+# Restore old state in case Travis uses this cache for other jobs.
+rustup default nightly
diff --git a/third_party/rust/encoding_rs/generate-encoding-data.py b/third_party/rust/encoding_rs/generate-encoding-data.py
index cecb88e684de..99cec1adc5af 100644
--- a/third_party/rust/encoding_rs/generate-encoding-data.py
+++ b/third_party/rust/encoding_rs/generate-encoding-data.py
@@ -1,6 +1,6 @@
 #!/usr/bin/python
 
-# Copyright 2013-2016 Mozilla Foundation. See the COPYRIGHT
+# Copyright Mozilla Foundation. See the COPYRIGHT
 # file at the top-level directory of this distribution.
 #
 # Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -1171,7 +1171,7 @@ data_file.close()
 # Variant
 
 variant_file = open("src/variant.rs", "w")
-variant_file.write('''// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+variant_file.write('''// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -1446,12 +1446,20 @@ single_byte_file.write("""
     #[test]
     fn test_single_byte_decode() {""")
 
+idx = 0 # for Miri, return after 2nd test
 for name in preferred:
   if name == u"ISO-8859-8-I":
     continue;
   if is_single_byte(name):
     single_byte_file.write("""
         decode_single_byte(%s, &data::SINGLE_BYTE_DATA.%s);""" % (to_constant_name(name), to_snake_name(name)))
+    idx += 1
+    if idx == 2:
+      single_byte_file.write("""
+        if cfg!(miri) {
+            // Miri is too slow
+            return;
+        }""")
 
 single_byte_file.write("""
     }
@@ -1459,12 +1467,21 @@ single_byte_file.write("""
     #[test]
     fn test_single_byte_encode() {""")
 
+
+idx = 0 # for Miri, return after 2nd test
 for name in preferred:
   if name == u"ISO-8859-8-I":
     continue;
   if is_single_byte(name):
     single_byte_file.write("""
         encode_single_byte(%s, &data::SINGLE_BYTE_DATA.%s);""" % (to_constant_name(name), to_snake_name(name)))
+    idx += 1
+    if idx == 2:
+      single_byte_file.write("""
+        if cfg!(miri) {
+            // Miri is too slow
+            return;
+        }""")
 
 
 single_byte_file.write("""
@@ -1476,7 +1493,7 @@ single_byte_file.close()
 
 static_file = open("../encoding_c/include/encoding_rs_statics.h", "w")
 
-static_file.write("""// Copyright 2016 Mozilla Foundation. See the COPYRIGHT
+static_file.write("""// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
diff --git a/third_party/rust/encoding_rs/src/ascii.rs b/third_party/rust/encoding_rs/src/ascii.rs
index 96ee179b67cb..b8fb250ca241 100644
--- a/third_party/rust/encoding_rs/src/ascii.rs
+++ b/third_party/rust/encoding_rs/src/ascii.rs
@@ -1,4 +1,4 @@
-// Copyright 2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -29,14 +29,14 @@
         all(target_endian = "little", target_feature = "neon")
     )
 ))]
-use simd_funcs::*;
+use crate::simd_funcs::*;
 
 cfg_if! {
     if #[cfg(feature = "simd-accel")] {
         #[allow(unused_imports)]
-        use ::std::intrinsics::unlikely;
+        use ::core::intrinsics::unlikely;
         #[allow(unused_imports)]
-        use ::std::intrinsics::likely;
+        use ::core::intrinsics::likely;
     } else {
         #[allow(dead_code)]
         #[inline(always)]
@@ -103,7 +103,7 @@ macro_rules! ascii_alu {
                 let mut until_alignment = {
                     // Check if the other unit aligns if we move the narrower unit
                     // to alignment.
-                    //               if ::std::mem::size_of::<$src_unit>() == ::std::mem::size_of::<$dst_unit>() {
+                    //               if ::core::mem::size_of::<$src_unit>() == ::core::mem::size_of::<$dst_unit>() {
                     // ascii_to_ascii
                     let src_alignment = (src as usize) & ALU_ALIGNMENT_MASK;
                     let dst_alignment = (dst as usize) & ALU_ALIGNMENT_MASK;
@@ -111,7 +111,7 @@ macro_rules! ascii_alu {
                         break;
                     }
                     (ALU_ALIGNMENT - src_alignment) & ALU_ALIGNMENT_MASK
-                    //               } else if ::std::mem::size_of::<$src_unit>() < ::std::mem::size_of::<$dst_unit>() {
+                    //               } else if ::core::mem::size_of::<$src_unit>() < ::core::mem::size_of::<$dst_unit>() {
                     // ascii_to_basic_latin
                     //                   let src_until_alignment = (ALIGNMENT - ((src as usize) & ALIGNMENT_MASK)) & ALIGNMENT_MASK;
                     //                   if (dst.add(src_until_alignment) as usize) & ALIGNMENT_MASK != 0 {
@@ -197,7 +197,7 @@ macro_rules! basic_latin_alu {
                 let mut until_alignment = {
                     // Check if the other unit aligns if we move the narrower unit
                     // to alignment.
-                    //               if ::std::mem::size_of::<$src_unit>() == ::std::mem::size_of::<$dst_unit>() {
+                    //               if ::core::mem::size_of::<$src_unit>() == ::core::mem::size_of::<$dst_unit>() {
                     // ascii_to_ascii
                     //                   let src_alignment = (src as usize) & ALIGNMENT_MASK;
                     //                   let dst_alignment = (dst as usize) & ALIGNMENT_MASK;
@@ -206,12 +206,14 @@ macro_rules! basic_latin_alu {
                     //                   }
                     //                   (ALIGNMENT - src_alignment) & ALIGNMENT_MASK
                     //               } else
-                    if ::std::mem::size_of::<$src_unit>() < ::std::mem::size_of::<$dst_unit>() {
+                    if ::core::mem::size_of::<$src_unit>() < ::core::mem::size_of::<$dst_unit>() {
                         // ascii_to_basic_latin
                         let src_until_alignment = (ALU_ALIGNMENT
                             - ((src as usize) & ALU_ALIGNMENT_MASK))
                             & ALU_ALIGNMENT_MASK;
-                        if (dst.add(src_until_alignment) as usize) & ALU_ALIGNMENT_MASK != 0 {
+                        if (dst.wrapping_add(src_until_alignment) as usize) & ALU_ALIGNMENT_MASK
+                            != 0
+                        {
                             break;
                         }
                         src_until_alignment
@@ -220,7 +222,9 @@ macro_rules! basic_latin_alu {
                         let dst_until_alignment = (ALU_ALIGNMENT
                             - ((dst as usize) & ALU_ALIGNMENT_MASK))
                             & ALU_ALIGNMENT_MASK;
-                        if (src.add(dst_until_alignment) as usize) & ALU_ALIGNMENT_MASK != 0 {
+                        if (src.wrapping_add(dst_until_alignment) as usize) & ALU_ALIGNMENT_MASK
+                            != 0
+                        {
                             break;
                         }
                         dst_until_alignment
@@ -286,12 +290,14 @@ macro_rules! latin1_alu {
             // This loop is only broken out of as a `goto` forward
             loop {
                 let mut until_alignment = {
-                    if ::std::mem::size_of::<$src_unit>() < ::std::mem::size_of::<$dst_unit>() {
+                    if ::core::mem::size_of::<$src_unit>() < ::core::mem::size_of::<$dst_unit>() {
                         // unpack
                         let src_until_alignment = (ALU_ALIGNMENT
                             - ((src as usize) & ALU_ALIGNMENT_MASK))
                             & ALU_ALIGNMENT_MASK;
-                        if (dst.add(src_until_alignment) as usize) & ALU_ALIGNMENT_MASK != 0 {
+                        if (dst.wrapping_add(src_until_alignment) as usize) & ALU_ALIGNMENT_MASK
+                            != 0
+                        {
                             break;
                         }
                         src_until_alignment
@@ -300,7 +306,9 @@ macro_rules! latin1_alu {
                         let dst_until_alignment = (ALU_ALIGNMENT
                             - ((dst as usize) & ALU_ALIGNMENT_MASK))
                             & ALU_ALIGNMENT_MASK;
-                        if (src.add(dst_until_alignment) as usize) & ALU_ALIGNMENT_MASK != 0 {
+                        if (src.wrapping_add(dst_until_alignment) as usize) & ALU_ALIGNMENT_MASK
+                            != 0
+                        {
                             break;
                         }
                         dst_until_alignment
@@ -439,7 +447,7 @@ macro_rules! ascii_simd_check_align_unrolled {
             dst: *mut $dst_unit,
             len: usize,
         ) -> Option<($src_unit, usize)> {
-            let unit_size = ::std::mem::size_of::<$src_unit>();
+            let unit_size = ::core::mem::size_of::<$src_unit>();
             let mut offset = 0usize;
             // This loop is only broken out of as a goto forward without
             // actually looping
@@ -621,7 +629,7 @@ macro_rules! latin1_simd_check_align_unrolled {
     ) => {
         #[inline(always)]
         pub unsafe fn $name(src: *const $src_unit, dst: *mut $dst_unit, len: usize) {
-            let unit_size = ::std::mem::size_of::<$src_unit>();
+            let unit_size = ::core::mem::size_of::<$src_unit>();
             let mut offset = 0usize;
             if SIMD_STRIDE_SIZE <= len {
                 let mut until_alignment = ((SIMD_STRIDE_SIZE
@@ -1500,9 +1508,10 @@ pub fn iso_2022_jp_ascii_valid_up_to(bytes: &[u8]) -> usize {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::*;
+    use alloc::vec::Vec;
 
     macro_rules! test_ascii {
         ($test_name:ident, $fn_tested:ident, $src_unit:ty, $dst_unit:ty) => {
diff --git a/third_party/rust/encoding_rs/src/big5.rs b/third_party/rust/encoding_rs/src/big5.rs
index ff4e13055c12..5c72c5ef9c81 100644
--- a/third_party/rust/encoding_rs/src/big5.rs
+++ b/third_party/rust/encoding_rs/src/big5.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,9 +8,9 @@
 // except according to those terms.
 
 use super::*;
-use data::*;
-use handles::*;
-use variant::*;
+use crate::data::*;
+use crate::handles::*;
+use crate::variant::*;
 // Rust 1.14.0 requires the following despite the asterisk above.
 use super::in_inclusive_range32;
 
@@ -263,7 +263,7 @@ impl Big5Encoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
@@ -365,18 +365,21 @@ mod tests {
         // ASCII
         encode_big5("\u{0061}\u{0062}", b"\x61\x62");
 
-        // Edge cases
-        encode_big5("\u{9EA6}\u{0061}", b"&#40614;\x61");
-        encode_big5("\u{2626B}\u{0061}", b"&#156267;\x61");
-        encode_big5("\u{3000}", b"\xA1\x40");
-        encode_big5("\u{20AC}", b"\xA3\xE1");
-        encode_big5("\u{4E00}", b"\xA4\x40");
-        encode_big5("\u{27607}", b"\xC8\xA4");
-        encode_big5("\u{FFE2}", b"\xC8\xCD");
-        encode_big5("\u{79D4}", b"\xFE\xFE");
-
-        // Not in index
-        encode_big5("\u{2603}\u{0061}", b"&#9731;\x61");
+        if !cfg!(miri) {
+            // Miri is too slow
+            // Edge cases
+            encode_big5("\u{9EA6}\u{0061}", b"&#40614;\x61");
+            encode_big5("\u{2626B}\u{0061}", b"&#156267;\x61");
+            encode_big5("\u{3000}", b"\xA1\x40");
+            encode_big5("\u{20AC}", b"\xA3\xE1");
+            encode_big5("\u{4E00}", b"\xA4\x40");
+            encode_big5("\u{27607}", b"\xC8\xA4");
+            encode_big5("\u{FFE2}", b"\xC8\xCD");
+            encode_big5("\u{79D4}", b"\xFE\xFE");
+
+            // Not in index
+            encode_big5("\u{2603}\u{0061}", b"&#9731;\x61");
+        }
 
         // duplicate low bits
         encode_big5("\u{203B5}", b"\xFD\x6A");
@@ -387,6 +390,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_big5_decode_all() {
         let input = include_bytes!("test_data/big5_in.txt");
         let expectation = include_str!("test_data/big5_in_ref.txt");
@@ -396,6 +400,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_big5_encode_all() {
         let input = include_str!("test_data/big5_out.txt");
         let expectation = include_bytes!("test_data/big5_out_ref.txt");
@@ -406,6 +411,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_big5_encode_from_two_low_surrogates() {
         let expectation = b"&#65533;&#65533;";
         let mut output = [0u8; 40];
diff --git a/third_party/rust/encoding_rs/src/data.rs b/third_party/rust/encoding_rs/src/data.rs
index 32e700bb8c08..c1ae89e15bfc 100644
--- a/third_party/rust/encoding_rs/src/data.rs
+++ b/third_party/rust/encoding_rs/src/data.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
diff --git a/third_party/rust/encoding_rs/src/euc_jp.rs b/third_party/rust/encoding_rs/src/euc_jp.rs
index c2f3ad307e50..18d1e11ad939 100644
--- a/third_party/rust/encoding_rs/src/euc_jp.rs
+++ b/third_party/rust/encoding_rs/src/euc_jp.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,9 +8,9 @@
 // except according to those terms.
 
 use super::*;
-use data::*;
-use handles::*;
-use variant::*;
+use crate::data::*;
+use crate::handles::*;
+use crate::variant::*;
 // Rust 1.14.0 requires the following despite the asterisk above.
 use super::in_inclusive_range16;
 
@@ -346,7 +346,7 @@ impl EucJpEncoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
@@ -437,6 +437,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_jis0208_decode_all() {
         let input = include_bytes!("test_data/jis0208_in.txt");
         let expectation = include_str!("test_data/jis0208_in_ref.txt");
@@ -446,6 +447,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_jis0208_encode_all() {
         let input = include_str!("test_data/jis0208_out.txt");
         let expectation = include_bytes!("test_data/jis0208_out_ref.txt");
@@ -456,6 +458,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_jis0212_decode_all() {
         let input = include_bytes!("test_data/jis0212_in.txt");
         let expectation = include_str!("test_data/jis0212_in_ref.txt");
diff --git a/third_party/rust/encoding_rs/src/euc_kr.rs b/third_party/rust/encoding_rs/src/euc_kr.rs
index e9a8398f59ef..6487d45993b6 100644
--- a/third_party/rust/encoding_rs/src/euc_kr.rs
+++ b/third_party/rust/encoding_rs/src/euc_kr.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,9 +8,9 @@
 // except according to those terms.
 
 use super::*;
-use data::*;
-use handles::*;
-use variant::*;
+use crate::data::*;
+use crate::handles::*;
+use crate::variant::*;
 // Rust 1.14.0 requires the following despite the asterisk above.
 use super::in_inclusive_range16;
 use super::in_range16;
@@ -362,7 +362,7 @@ impl EucKrEncoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
@@ -406,6 +406,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_euc_kr_decode_all() {
         let input = include_bytes!("test_data/euc_kr_in.txt");
         let expectation = include_str!("test_data/euc_kr_in_ref.txt");
@@ -415,6 +416,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_euc_kr_encode_all() {
         let input = include_str!("test_data/euc_kr_out.txt");
         let expectation = include_bytes!("test_data/euc_kr_out_ref.txt");
diff --git a/third_party/rust/encoding_rs/src/gb18030.rs b/third_party/rust/encoding_rs/src/gb18030.rs
index b2184516a53d..a0b3bd7f03de 100644
--- a/third_party/rust/encoding_rs/src/gb18030.rs
+++ b/third_party/rust/encoding_rs/src/gb18030.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,9 +8,9 @@
 // except according to those terms.
 
 use super::*;
-use data::*;
-use handles::*;
-use variant::*;
+use crate::data::*;
+use crate::handles::*;
+use crate::variant::*;
 // Rust 1.14.0 requires the following despite the asterisk above.
 use super::in_inclusive_range16;
 use super::in_range16;
@@ -571,7 +571,7 @@ impl Gb18030Encoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
@@ -653,12 +653,15 @@ mod tests {
         // two bytes
         encode_gb18030("\u{4E02}", b"\x81\x40");
         encode_gb18030("\u{4E8A}", b"\x81\x7E");
-        encode_gb18030("\u{4E90}", b"\x81\x80");
-        encode_gb18030("\u{4FA2}", b"\x81\xFE");
-        encode_gb18030("\u{FA0C}", b"\xFE\x40");
-        encode_gb18030("\u{E843}", b"\xFE\x7E");
-        encode_gb18030("\u{4723}", b"\xFE\x80");
-        encode_gb18030("\u{E4C5}", b"\xFE\xFE");
+        if !cfg!(miri) {
+            // Miri is too slow
+            encode_gb18030("\u{4E90}", b"\x81\x80");
+            encode_gb18030("\u{4FA2}", b"\x81\xFE");
+            encode_gb18030("\u{FA0C}", b"\xFE\x40");
+            encode_gb18030("\u{E843}", b"\xFE\x7E");
+            encode_gb18030("\u{4723}", b"\xFE\x80");
+            encode_gb18030("\u{E4C5}", b"\xFE\xFE");
+        }
 
         // The difference from the original GB18030
         encode_gb18030("\u{E5E5}", b"&#58853;");
@@ -667,9 +670,12 @@ mod tests {
         // Four bytes
         encode_gb18030("\u{0080}", b"\x81\x30\x81\x30");
         encode_gb18030("\u{E7C7}", b"\x81\x35\xF4\x37");
-        encode_gb18030("\u{2603}", b"\x81\x37\xA3\x30");
-        encode_gb18030("\u{1F4A9}", b"\x94\x39\xDA\x33");
-        encode_gb18030("\u{10FFFF}", b"\xE3\x32\x9A\x35");
+        if !cfg!(miri) {
+            // Miri is too slow
+            encode_gb18030("\u{2603}", b"\x81\x37\xA3\x30");
+            encode_gb18030("\u{1F4A9}", b"\x94\x39\xDA\x33");
+            encode_gb18030("\u{10FFFF}", b"\xE3\x32\x9A\x35");
+        }
 
         // Edge cases
         encode_gb18030("\u{00F7}", b"\xA1\xC2");
@@ -689,12 +695,15 @@ mod tests {
         // two bytes
         encode_gbk("\u{4E02}", b"\x81\x40");
         encode_gbk("\u{4E8A}", b"\x81\x7E");
-        encode_gbk("\u{4E90}", b"\x81\x80");
-        encode_gbk("\u{4FA2}", b"\x81\xFE");
-        encode_gbk("\u{FA0C}", b"\xFE\x40");
-        encode_gbk("\u{E843}", b"\xFE\x7E");
-        encode_gbk("\u{4723}", b"\xFE\x80");
-        encode_gbk("\u{E4C5}", b"\xFE\xFE");
+        if !cfg!(miri) {
+            // Miri is too slow
+            encode_gbk("\u{4E90}", b"\x81\x80");
+            encode_gbk("\u{4FA2}", b"\x81\xFE");
+            encode_gbk("\u{FA0C}", b"\xFE\x40");
+            encode_gbk("\u{E843}", b"\xFE\x7E");
+            encode_gbk("\u{4723}", b"\xFE\x80");
+            encode_gbk("\u{E4C5}", b"\xFE\xFE");
+        }
 
         // The difference from the original gb18030
         encode_gbk("\u{E5E5}", b"&#58853;");
@@ -703,15 +712,19 @@ mod tests {
         // Four bytes
         encode_gbk("\u{0080}", b"&#128;");
         encode_gbk("\u{E7C7}", b"&#59335;");
-        encode_gbk("\u{2603}", b"&#9731;");
-        encode_gbk("\u{1F4A9}", b"&#128169;");
-        encode_gbk("\u{10FFFF}", b"&#1114111;");
+        if !cfg!(miri) {
+            // Miri is too slow
+            encode_gbk("\u{2603}", b"&#9731;");
+            encode_gbk("\u{1F4A9}", b"&#128169;");
+            encode_gbk("\u{10FFFF}", b"&#1114111;");
+        }
 
         // Edge cases
         encode_gbk("\u{00F7}", b"\xA1\xC2");
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_gb18030_decode_all() {
         let input = include_bytes!("test_data/gb18030_in.txt");
         let expectation = include_str!("test_data/gb18030_in_ref.txt");
@@ -721,6 +734,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_gb18030_encode_all() {
         let input = include_str!("test_data/gb18030_out.txt");
         let expectation = include_bytes!("test_data/gb18030_out_ref.txt");
diff --git a/third_party/rust/encoding_rs/src/handles.rs b/third_party/rust/encoding_rs/src/handles.rs
index 08da62d20051..b5404c01d9bd 100644
--- a/third_party/rust/encoding_rs/src/handles.rs
+++ b/third_party/rust/encoding_rs/src/handles.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -24,7 +24,7 @@
         all(target_endian = "little", target_feature = "neon")
     )
 ))]
-use simd_funcs::*;
+use crate::simd_funcs::*;
 
 #[cfg(all(
     feature = "simd-accel",
@@ -38,9 +38,9 @@ use packed_simd::u16x8;
 
 use super::DecoderResult;
 use super::EncoderResult;
-use ascii::*;
-use utf_8::convert_utf8_to_utf16_up_to_invalid;
-use utf_8::utf8_valid_up_to;
+use crate::ascii::*;
+use crate::utf_8::convert_utf8_to_utf16_up_to_invalid;
+use crate::utf_8::utf8_valid_up_to;
 
 pub enum Space<T> {
     Available(T),
@@ -108,11 +108,13 @@ impl UnalignedU16Slice {
 
     #[inline(always)]
     pub fn at(&self, i: usize) -> u16 {
+        use core::mem::MaybeUninit;
+
         assert!(i < self.len);
         unsafe {
-            let mut u: u16 = ::std::mem::uninitialized();
-            ::std::ptr::copy_nonoverlapping(self.ptr.add(i * 2), &mut u as *mut u16 as *mut u8, 2);
-            u
+            let mut u: MaybeUninit<u16> = MaybeUninit::uninit();
+            ::core::ptr::copy_nonoverlapping(self.ptr.add(i * 2), u.as_mut_ptr() as *mut u8, 2);
+            u.assume_init()
         }
     }
 
@@ -193,7 +195,7 @@ fn copy_unaligned_basic_latin_to_ascii_alu<E: Endian>(
     dst: &mut [u8],
     offset: usize,
 ) -> CopyAsciiResult<usize, (u16, usize)> {
-    let len = ::std::cmp::min(src.len(), dst.len());
+    let len = ::core::cmp::min(src.len(), dst.len());
     let mut i = 0usize;
     loop {
         if i == len {
@@ -232,7 +234,7 @@ fn copy_unaligned_basic_latin_to_ascii<E: Endian>(
     src: UnalignedU16Slice,
     dst: &mut [u8],
 ) -> CopyAsciiResult<usize, (u16, usize)> {
-    let len = ::std::cmp::min(src.len(), dst.len());
+    let len = ::core::cmp::min(src.len(), dst.len());
     let mut offset = 0;
     if SIMD_STRIDE_SIZE <= len {
         let len_minus_stride = len - SIMD_STRIDE_SIZE;
@@ -734,7 +736,7 @@ impl<'a> Utf16Destination<'a> {
         let mut src_unaligned = unsafe {
             UnalignedU16Slice::new(
                 src_remaining.as_ptr(),
-                ::std::cmp::min(src_remaining.len() / 2, dst_remaining.len()),
+                ::core::cmp::min(src_remaining.len() / 2, dst_remaining.len()),
             )
         };
         if src_unaligned.len() == 0 {
@@ -1078,7 +1080,7 @@ impl<'a> Utf8Destination<'a> {
     pub fn copy_utf8_up_to_invalid_from(&mut self, source: &mut ByteSource) {
         let src_remaining = &source.slice[source.pos..];
         let dst_remaining = &mut self.slice[self.pos..];
-        let min_len = ::std::cmp::min(src_remaining.len(), dst_remaining.len());
+        let min_len = ::core::cmp::min(src_remaining.len(), dst_remaining.len());
         // Validate first, then memcpy to let memcpy do its thing even for
         // non-ASCII. (And potentially do something better than SSE2 for ASCII.)
         let valid_len = utf8_valid_up_to(&src_remaining[..min_len]);
@@ -1154,7 +1156,7 @@ impl<'a> Utf16Source<'a> {
         self.pos += 1;
         let unit_minus_surrogate_start = unit.wrapping_sub(0xD800);
         if unit_minus_surrogate_start > (0xDFFF - 0xD800) {
-            return unsafe { ::std::char::from_u32_unchecked(u32::from(unit)) };
+            return unsafe { ::core::char::from_u32_unchecked(u32::from(unit)) };
         }
         if unit_minus_surrogate_start <= (0xDBFF - 0xD800) {
             // high surrogate
@@ -1165,7 +1167,7 @@ impl<'a> Utf16Source<'a> {
                     // The next code unit is a low surrogate. Advance position.
                     self.pos += 1;
                     return unsafe {
-                        ::std::char::from_u32_unchecked(
+                        ::core::char::from_u32_unchecked(
                             (u32::from(unit) << 10) + u32::from(second)
                                 - (((0xD800u32 << 10) - 0x10000u32) + 0xDC00u32),
                         )
@@ -1202,7 +1204,7 @@ impl<'a> Utf16Source<'a> {
                     // The next code unit is a low surrogate. Advance position.
                     self.pos += 1;
                     return Unicode::NonAscii(NonAscii::Astral(unsafe {
-                        ::std::char::from_u32_unchecked(
+                        ::core::char::from_u32_unchecked(
                             (u32::from(unit) << 10) + u32::from(second)
                                 - (((0xD800u32 << 10) - 0x10000u32) + 0xDC00u32),
                         )
@@ -1266,7 +1268,7 @@ impl<'a> Utf16Source<'a> {
                                     // The next code unit is a low surrogate. Advance position.
                                     self.pos += 1;
                                     NonAscii::Astral(unsafe {
-                                        ::std::char::from_u32_unchecked(
+                                        ::core::char::from_u32_unchecked(
                                             (u32::from(unit) << 10) + u32::from(second)
                                                 - (((0xD800u32 << 10) - 0x10000u32) + 0xDC00u32),
                                         )
@@ -1339,7 +1341,7 @@ impl<'a> Utf16Source<'a> {
                                     // The next code unit is a low surrogate. Advance position.
                                     self.pos += 1;
                                     NonAscii::Astral(unsafe {
-                                        ::std::char::from_u32_unchecked(
+                                        ::core::char::from_u32_unchecked(
                                             (u32::from(unit) << 10) + u32::from(second)
                                                 - (((0xD800u32 << 10) - 0x1_0000u32) + 0xDC00u32),
                                         )
@@ -1467,21 +1469,21 @@ impl<'a> Utf8Source<'a> {
             let point =
                 ((u32::from(unit) & 0x1F) << 6) | (u32::from(self.slice[self.pos + 1]) & 0x3F);
             self.pos += 2;
-            return unsafe { ::std::char::from_u32_unchecked(point) };
+            return unsafe { ::core::char::from_u32_unchecked(point) };
         }
         if unit < 0xF0 {
             let point = ((u32::from(unit) & 0xF) << 12)
                 | ((u32::from(self.slice[self.pos + 1]) & 0x3F) << 6)
                 | (u32::from(self.slice[self.pos + 2]) & 0x3F);
             self.pos += 3;
-            return unsafe { ::std::char::from_u32_unchecked(point) };
+            return unsafe { ::core::char::from_u32_unchecked(point) };
         }
         let point = ((u32::from(unit) & 0x7) << 18)
             | ((u32::from(self.slice[self.pos + 1]) & 0x3F) << 12)
             | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)
             | (u32::from(self.slice[self.pos + 3]) & 0x3F);
         self.pos += 4;
-        unsafe { ::std::char::from_u32_unchecked(point) }
+        unsafe { ::core::char::from_u32_unchecked(point) }
     }
     #[inline(always)]
     fn read_enum(&mut self) -> Unicode {
@@ -1510,7 +1512,7 @@ impl<'a> Utf8Source<'a> {
             | (u32::from(self.slice[self.pos + 3]) & 0x3F);
         self.pos += 4;
         Unicode::NonAscii(NonAscii::Astral(unsafe {
-            ::std::char::from_u32_unchecked(point)
+            ::core::char::from_u32_unchecked(point)
         }))
     }
     #[inline(always)]
@@ -1565,7 +1567,7 @@ impl<'a> Utf8Source<'a> {
                             | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)
                             | (u32::from(self.slice[self.pos + 3]) & 0x3F);
                         self.pos += 4;
-                        NonAscii::Astral(unsafe { ::std::char::from_u32_unchecked(point) })
+                        NonAscii::Astral(unsafe { ::core::char::from_u32_unchecked(point) })
                     }
                 }
             }
@@ -1615,7 +1617,7 @@ impl<'a> Utf8Source<'a> {
                                 | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)
                                 | (u32::from(self.slice[self.pos + 3]) & 0x3F);
                             self.pos += 4;
-                            NonAscii::Astral(unsafe { ::std::char::from_u32_unchecked(point) })
+                            NonAscii::Astral(unsafe { ::core::char::from_u32_unchecked(point) })
                         }
                     } else {
                         return CopyAsciiResult::Stop((
@@ -1672,7 +1674,7 @@ impl<'a> Utf8Source<'a> {
                                 | ((u32::from(self.slice[self.pos + 2]) & 0x3F) << 6)
                                 | (u32::from(self.slice[self.pos + 3]) & 0x3F);
                             self.pos += 4;
-                            NonAscii::Astral(unsafe { ::std::char::from_u32_unchecked(point) })
+                            NonAscii::Astral(unsafe { ::core::char::from_u32_unchecked(point) })
                         }
                     } else {
                         return CopyAsciiResult::Stop((
diff --git a/third_party/rust/encoding_rs/src/iso_2022_jp.rs b/third_party/rust/encoding_rs/src/iso_2022_jp.rs
index ab364951549e..d71111a6cece 100644
--- a/third_party/rust/encoding_rs/src/iso_2022_jp.rs
+++ b/third_party/rust/encoding_rs/src/iso_2022_jp.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,9 +8,9 @@
 // except according to those terms.
 
 use super::*;
-use data::*;
-use handles::*;
-use variant::*;
+use crate::data::*;
+use crate::handles::*;
+use crate::variant::*;
 // Rust 1.14.0 requires the following despite the asterisk above.
 use super::in_inclusive_range16;
 
@@ -754,7 +754,7 @@ impl Iso2022JpEncoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
@@ -863,6 +863,11 @@ mod tests {
         decode_iso_2022_jp(b"\x1B$@\x80\x54\x64", "\u{FFFD}\u{58FA}");
         decode_iso_2022_jp(b"\x1B$B\x28\x80", "\u{FFFD}");
 
+        if cfg!(miri) {
+            // Miri is too slow
+            return;
+        }
+
         // Transitions
         decode_iso_2022_jp(b"\x1B(B\x5C\x1B(J\x5C", "\u{005C}\u{00A5}");
         decode_iso_2022_jp(b"\x1B(B\x5C\x1B(I\x21", "\u{005C}\u{FF61}");
@@ -938,35 +943,45 @@ mod tests {
         // Roman
         encode_iso_2022_jp("a\u{00A5}b", b"a\x1B(J\x5Cb\x1B(B");
         encode_iso_2022_jp("a\u{203E}b", b"a\x1B(J\x7Eb\x1B(B");
-        encode_iso_2022_jp("a\u{00A5}b\x5C", b"a\x1B(J\x5Cb\x1B(B\x5C");
-        encode_iso_2022_jp("a\u{203E}b\x7E", b"a\x1B(J\x7Eb\x1B(B\x7E");
-        encode_iso_2022_jp("\u{00A5}\u{1F4A9}", b"\x1B(J\x5C&#128169;\x1B(B");
-        encode_iso_2022_jp("\u{00A5}\x1B", b"\x1B(J\x5C&#65533;\x1B(B");
-        encode_iso_2022_jp("\u{00A5}\x0E", b"\x1B(J\x5C&#65533;\x1B(B");
-        encode_iso_2022_jp("\u{00A5}\x0F", b"\x1B(J\x5C&#65533;\x1B(B");
-        encode_iso_2022_jp("\u{00A5}\u{58FA}", b"\x1B(J\x5C\x1B$B\x54\x64\x1B(B");
+        if !cfg!(miri) {
+            // Miri is too slow
+            encode_iso_2022_jp("a\u{00A5}b\x5C", b"a\x1B(J\x5Cb\x1B(B\x5C");
+            encode_iso_2022_jp("a\u{203E}b\x7E", b"a\x1B(J\x7Eb\x1B(B\x7E");
+            encode_iso_2022_jp("\u{00A5}\u{1F4A9}", b"\x1B(J\x5C&#128169;\x1B(B");
+            encode_iso_2022_jp("\u{00A5}\x1B", b"\x1B(J\x5C&#65533;\x1B(B");
+            encode_iso_2022_jp("\u{00A5}\x0E", b"\x1B(J\x5C&#65533;\x1B(B");
+            encode_iso_2022_jp("\u{00A5}\x0F", b"\x1B(J\x5C&#65533;\x1B(B");
+            encode_iso_2022_jp("\u{00A5}\u{58FA}", b"\x1B(J\x5C\x1B$B\x54\x64\x1B(B");
+        }
 
         // Half-width Katakana
         encode_iso_2022_jp("\u{FF61}", b"\x1B$B\x21\x23\x1B(B");
         encode_iso_2022_jp("\u{FF65}", b"\x1B$B\x21\x26\x1B(B");
-        encode_iso_2022_jp("\u{FF66}", b"\x1B$B\x25\x72\x1B(B");
-        encode_iso_2022_jp("\u{FF70}", b"\x1B$B\x21\x3C\x1B(B");
-        encode_iso_2022_jp("\u{FF9D}", b"\x1B$B\x25\x73\x1B(B");
-        encode_iso_2022_jp("\u{FF9E}", b"\x1B$B\x21\x2B\x1B(B");
-        encode_iso_2022_jp("\u{FF9F}", b"\x1B$B\x21\x2C\x1B(B");
+        if !cfg!(miri) {
+            // Miri is too slow
+            encode_iso_2022_jp("\u{FF66}", b"\x1B$B\x25\x72\x1B(B");
+            encode_iso_2022_jp("\u{FF70}", b"\x1B$B\x21\x3C\x1B(B");
+            encode_iso_2022_jp("\u{FF9D}", b"\x1B$B\x25\x73\x1B(B");
+            encode_iso_2022_jp("\u{FF9E}", b"\x1B$B\x21\x2B\x1B(B");
+            encode_iso_2022_jp("\u{FF9F}", b"\x1B$B\x21\x2C\x1B(B");
+        }
 
         // 0208
         encode_iso_2022_jp("\u{58FA}", b"\x1B$B\x54\x64\x1B(B");
         encode_iso_2022_jp("\u{58FA}\u{250F}", b"\x1B$B\x54\x64\x28\x2E\x1B(B");
-        encode_iso_2022_jp("\u{58FA}\u{1F4A9}", b"\x1B$B\x54\x64\x1B(B&#128169;");
-        encode_iso_2022_jp("\u{58FA}\x1B", b"\x1B$B\x54\x64\x1B(B&#65533;");
-        encode_iso_2022_jp("\u{58FA}\x0E", b"\x1B$B\x54\x64\x1B(B&#65533;");
-        encode_iso_2022_jp("\u{58FA}\x0F", b"\x1B$B\x54\x64\x1B(B&#65533;");
-        encode_iso_2022_jp("\u{58FA}\u{00A5}", b"\x1B$B\x54\x64\x1B(J\x5C\x1B(B");
-        encode_iso_2022_jp("\u{58FA}a", b"\x1B$B\x54\x64\x1B(Ba");
+        if !cfg!(miri) {
+            // Miri is too slow
+            encode_iso_2022_jp("\u{58FA}\u{1F4A9}", b"\x1B$B\x54\x64\x1B(B&#128169;");
+            encode_iso_2022_jp("\u{58FA}\x1B", b"\x1B$B\x54\x64\x1B(B&#65533;");
+            encode_iso_2022_jp("\u{58FA}\x0E", b"\x1B$B\x54\x64\x1B(B&#65533;");
+            encode_iso_2022_jp("\u{58FA}\x0F", b"\x1B$B\x54\x64\x1B(B&#65533;");
+            encode_iso_2022_jp("\u{58FA}\u{00A5}", b"\x1B$B\x54\x64\x1B(J\x5C\x1B(B");
+            encode_iso_2022_jp("\u{58FA}a", b"\x1B$B\x54\x64\x1B(Ba");
+        }
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_iso_2022_jp_decode_all() {
         let input = include_bytes!("test_data/iso_2022_jp_in.txt");
         let expectation = include_str!("test_data/iso_2022_jp_in_ref.txt");
@@ -976,6 +991,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_iso_2022_jp_encode_all() {
         let input = include_str!("test_data/iso_2022_jp_out.txt");
         let expectation = include_bytes!("test_data/iso_2022_jp_out_ref.txt");
diff --git a/third_party/rust/encoding_rs/src/lib.rs b/third_party/rust/encoding_rs/src/lib.rs
index 73f5ec2cca09..bce2738ae152 100644
--- a/third_party/rust/encoding_rs/src/lib.rs
+++ b/third_party/rust/encoding_rs/src/lib.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -11,7 +11,6 @@
     feature = "cargo-clippy",
     allow(doc_markdown, inline_always, new_ret_no_self)
 )]
-#![doc(html_root_url = "https://docs.rs/encoding_rs/0.8.22")]
 
 //! encoding_rs is a Gecko-oriented Free Software / Open Source implementation
 //! of the [Encoding Standard](https://encoding.spec.whatwg.org/) in Rust.
@@ -60,6 +59,7 @@
 //! Decode using the non-streaming API:
 //!
 //! ```
+//! #[cfg(feature = "alloc")] {
 //! use encoding_rs::*;
 //!
 //! let expectation = "\u{30CF}\u{30ED}\u{30FC}\u{30FB}\u{30EF}\u{30FC}\u{30EB}\u{30C9}";
@@ -69,6 +69,7 @@
 //! assert_eq!(&cow[..], expectation);
 //! assert_eq!(encoding_used, SHIFT_JIS);
 //! assert!(!had_errors);
+//! }
 //! ```
 //!
 //! Decode using the streaming API with minimal `unsafe`:
@@ -248,6 +249,9 @@
 //! [charset](https://crates.io/crates/charset) wraps encoding_rs and adds
 //! UTF-7 decoding for email purposes.
 //!
+//! For single-byte DOS encodings beyond the ones supported by the Encoding
+//! Standard, there is the [`oem_cp`](https://crates.io/crates/oem_cp) crate.
+//!
 //! # Preparing Text for the Encoders
 //!
 //! Normalizing text into Unicode Normalization Form C prior to encoding text
@@ -677,8 +681,14 @@
 //! See the section [_UTF-16LE, UTF-16BE and Unicode Encoding Schemes_](#utf-16le-utf-16be-and-unicode-encoding-schemes)
 //! for discussion about the UTF-16 family.
 
+#![no_std]
 #![cfg_attr(feature = "simd-accel", feature(stdsimd, core_intrinsics))]
 
+#[cfg(feature = "alloc")]
+#[cfg_attr(test, macro_use)]
+extern crate alloc;
+
+extern crate core;
 #[macro_use]
 extern crate cfg_if;
 
@@ -717,7 +727,7 @@ mod macros;
 ))]
 mod simd_funcs;
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod testing;
 
 mod big5;
@@ -739,15 +749,20 @@ mod variant;
 
 pub mod mem;
 
-use ascii::ascii_valid_up_to;
-use ascii::iso_2022_jp_ascii_valid_up_to;
-use utf_8::utf8_valid_up_to;
-use variant::*;
-
-use std::borrow::Cow;
-use std::cmp::Ordering;
-use std::hash::Hash;
-use std::hash::Hasher;
+use crate::ascii::ascii_valid_up_to;
+use crate::ascii::iso_2022_jp_ascii_valid_up_to;
+use crate::utf_8::utf8_valid_up_to;
+use crate::variant::*;
+
+#[cfg(feature = "alloc")]
+use alloc::borrow::Cow;
+#[cfg(feature = "alloc")]
+use alloc::string::String;
+#[cfg(feature = "alloc")]
+use alloc::vec::Vec;
+use core::cmp::Ordering;
+use core::hash::Hash;
+use core::hash::Hasher;
 
 #[cfg(feature = "serde")]
 use serde::de::Visitor;
@@ -2129,7 +2144,7 @@ pub static X_USER_DEFINED_INIT: Encoding = Encoding {
 /// `static`.
 pub static X_USER_DEFINED: &'static Encoding = &X_USER_DEFINED_INIT;
 
-static LABELS_SORTED: [&'static str; 219] = [
+static LABELS_SORTED: [&'static str; 228] = [
     "l1",
     "l2",
     "l3",
@@ -2145,6 +2160,7 @@ static LABELS_SORTED: [&'static str; 219] = [
     "utf8",
     "koi8",
     "sjis",
+    "ucs-2",
     "ms932",
     "cp866",
     "utf-8",
@@ -2189,6 +2205,7 @@ static LABELS_SORTED: [&'static str; 219] = [
     "gb_2312",
     "dos-874",
     "cn-big5",
+    "unicode",
     "chinese",
     "logical",
     "cskoi8r",
@@ -2241,6 +2258,7 @@ static LABELS_SORTED: [&'static str; 219] = [
     "iso8859-8",
     "iso-ir-58",
     "iso8859-9",
+    "csunicode",
     "macintosh",
     "shift-jis",
     "shift_jis",
@@ -2300,6 +2318,8 @@ static LABELS_SORTED: [&'static str; 219] = [
     "csisolatin9",
     "csiso88596e",
     "csiso88598e",
+    "unicodefffe",
+    "unicodefeff",
     "csmacintosh",
     "csiso88596i",
     "csiso88598i",
@@ -2326,12 +2346,15 @@ static LABELS_SORTED: [&'static str; 219] = [
     "iso-8859-8-i",
     "sun_eu_greek",
     "csksc56011987",
+    "unicode20utf8",
+    "unicode11utf8",
     "ks_c_5601-1987",
     "ansi_x3.4-1968",
     "ks_c_5601-1989",
     "x-mac-cyrillic",
     "x-user-defined",
     "csiso58gb231280",
+    "iso-10646-ucs-2",
     "iso_8859-1:1987",
     "iso_8859-2:1987",
     "iso_8859-6:1987",
@@ -2340,6 +2363,7 @@ static LABELS_SORTED: [&'static str; 219] = [
     "iso_8859-4:1988",
     "iso_8859-5:1988",
     "iso_8859-8:1988",
+    "x-unicode20utf8",
     "iso_8859-9:1989",
     "csisolatingreek",
     "x-mac-ukrainian",
@@ -2351,7 +2375,7 @@ static LABELS_SORTED: [&'static str; 219] = [
     "cseucpkdfmtjapanese",
 ];
 
-static ENCODINGS_IN_LABEL_SORT: [&'static Encoding; 219] = [
+static ENCODINGS_IN_LABEL_SORT: [&'static Encoding; 228] = [
     &WINDOWS_1252_INIT,
     &ISO_8859_2_INIT,
     &ISO_8859_3_INIT,
@@ -2367,6 +2391,7 @@ static ENCODINGS_IN_LABEL_SORT: [&'static Encoding; 219] = [
     &UTF_8_INIT,
     &KOI8_R_INIT,
     &SHIFT_JIS_INIT,
+    &UTF_16LE_INIT,
     &SHIFT_JIS_INIT,
     &IBM866_INIT,
     &UTF_8_INIT,
@@ -2411,6 +2436,7 @@ static ENCODINGS_IN_LABEL_SORT: [&'static Encoding; 219] = [
     &GBK_INIT,
     &WINDOWS_874_INIT,
     &BIG5_INIT,
+    &UTF_16LE_INIT,
     &GBK_INIT,
     &ISO_8859_8_I_INIT,
     &KOI8_R_INIT,
@@ -2463,6 +2489,7 @@ static ENCODINGS_IN_LABEL_SORT: [&'static Encoding; 219] = [
     &ISO_8859_8_INIT,
     &GBK_INIT,
     &WINDOWS_1254_INIT,
+    &UTF_16LE_INIT,
     &MACINTOSH_INIT,
     &SHIFT_JIS_INIT,
     &SHIFT_JIS_INIT,
@@ -2522,6 +2549,8 @@ static ENCODINGS_IN_LABEL_SORT: [&'static Encoding; 219] = [
     &ISO_8859_15_INIT,
     &ISO_8859_6_INIT,
     &ISO_8859_8_INIT,
+    &UTF_16BE_INIT,
+    &UTF_16LE_INIT,
     &MACINTOSH_INIT,
     &ISO_8859_6_INIT,
     &ISO_8859_8_I_INIT,
@@ -2548,12 +2577,15 @@ static ENCODINGS_IN_LABEL_SORT: [&'static Encoding; 219] = [
     &ISO_8859_8_I_INIT,
     &ISO_8859_7_INIT,
     &EUC_KR_INIT,
+    &UTF_8_INIT,
+    &UTF_8_INIT,
     &EUC_KR_INIT,
     &WINDOWS_1252_INIT,
     &EUC_KR_INIT,
     &X_MAC_CYRILLIC_INIT,
     &X_USER_DEFINED_INIT,
     &GBK_INIT,
+    &UTF_16LE_INIT,
     &WINDOWS_1252_INIT,
     &ISO_8859_2_INIT,
     &ISO_8859_6_INIT,
@@ -2562,6 +2594,7 @@ static ENCODINGS_IN_LABEL_SORT: [&'static Encoding; 219] = [
     &ISO_8859_4_INIT,
     &ISO_8859_5_INIT,
     &ISO_8859_8_INIT,
+    &UTF_8_INIT,
     &WINDOWS_1254_INIT,
     &ISO_8859_7_INIT,
     &X_MAC_CYRILLIC_INIT,
@@ -2664,6 +2697,20 @@ impl Encoding {
     /// on it.)
     ///
     /// Available via the C wrapper.
+    ///
+    /// # Example
+    /// ```
+    /// use encoding_rs::Encoding;
+    ///
+    /// assert_eq!(Some(encoding_rs::UTF_8), Encoding::for_label(b"utf-8"));
+    /// assert_eq!(Some(encoding_rs::UTF_8), Encoding::for_label(b"unicode11utf8"));
+    ///
+    /// assert_eq!(Some(encoding_rs::ISO_8859_2), Encoding::for_label(b"latin2"));
+    ///
+    /// assert_eq!(Some(encoding_rs::UTF_16BE), Encoding::for_label(b"utf-16be"));
+    ///
+    /// assert_eq!(None, Encoding::for_label(b"unrecognized label"));
+    /// ```
     pub fn for_label(label: &[u8]) -> Option<&'static Encoding> {
         let mut trimmed = [0u8; LONGEST_LABEL_LENGTH];
         let mut trimmed_pos = 0usize;
@@ -2683,12 +2730,12 @@ impl Encoding {
                         0x09u8 | 0x0Au8 | 0x0Cu8 | 0x0Du8 | 0x20u8 => {
                             continue;
                         }
-                        b'A'...b'Z' => {
+                        b'A'..=b'Z' => {
                             trimmed[trimmed_pos] = *byte + 0x20u8;
                             trimmed_pos = 1usize;
                             break;
                         }
-                        b'a'...b'z' | b'0'...b'9' | b'-' | b'_' | b':' | b'.' => {
+                        b'a'..=b'z' | b'0'..=b'9' | b'-' | b'_' | b':' | b'.' => {
                             trimmed[trimmed_pos] = *byte;
                             trimmed_pos = 1usize;
                             break;
@@ -2711,7 +2758,7 @@ impl Encoding {
                         0x09u8 | 0x0Au8 | 0x0Cu8 | 0x0Du8 | 0x20u8 => {
                             break;
                         }
-                        b'A'...b'Z' => {
+                        b'A'..=b'Z' => {
                             if trimmed_pos == LONGEST_LABEL_LENGTH {
                                 // There's no encoding with a label this long
                                 return None;
@@ -2720,7 +2767,7 @@ impl Encoding {
                             trimmed_pos += 1usize;
                             continue;
                         }
-                        b'a'...b'z' | b'0'...b'9' | b'-' | b'_' | b':' | b'.' => {
+                        b'a'..=b'z' | b'0'..=b'9' | b'-' | b'_' | b':' | b'.' => {
                             if trimmed_pos == LONGEST_LABEL_LENGTH {
                                 // There's no encoding with a label this long
                                 return None;
@@ -2868,6 +2915,7 @@ impl Encoding {
 
     /// Checks whether the bytes 0x00...0x7F map mostly to the characters
     /// U+0000...U+007F and vice versa.
+    #[cfg(feature = "alloc")]
     #[inline]
     fn is_potentially_borrowable(&'static self) -> bool {
         !(self == REPLACEMENT || self == UTF_16BE || self == UTF_16LE)
@@ -2919,7 +2967,9 @@ impl Encoding {
     /// If the size calculation for a heap-allocated backing buffer overflows
     /// `usize`.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     #[inline]
     pub fn decode<'a>(&'static self, bytes: &'a [u8]) -> (Cow<'a, str>, &'static Encoding, bool) {
         let (encoding, without_bom) = match Encoding::for_bom(bytes) {
@@ -2962,7 +3012,9 @@ impl Encoding {
     /// If the size calculation for a heap-allocated backing buffer overflows
     /// `usize`.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     #[inline]
     pub fn decode_with_bom_removal<'a>(&'static self, bytes: &'a [u8]) -> (Cow<'a, str>, bool) {
         let without_bom = if self == UTF_8 && bytes.starts_with(b"\xEF\xBB\xBF") {
@@ -3009,7 +3061,9 @@ impl Encoding {
     /// If the size calculation for a heap-allocated backing buffer overflows
     /// `usize`.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     pub fn decode_without_bom_handling<'a>(&'static self, bytes: &'a [u8]) -> (Cow<'a, str>, bool) {
         let (mut decoder, mut string, mut total_read) = if self.is_potentially_borrowable() {
             let valid_up_to = if self == UTF_8 {
@@ -3020,7 +3074,7 @@ impl Encoding {
                 ascii_valid_up_to(bytes)
             };
             if valid_up_to == bytes.len() {
-                let str: &str = unsafe { std::str::from_utf8_unchecked(bytes) };
+                let str: &str = unsafe { core::str::from_utf8_unchecked(bytes) };
                 return (Cow::Borrowed(str), false);
             }
             let decoder = self.new_decoder_without_bom_handling();
@@ -3039,7 +3093,7 @@ impl Encoding {
             unsafe {
                 let vec = string.as_mut_vec();
                 vec.set_len(valid_up_to);
-                std::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);
+                core::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);
             }
             (decoder, string, valid_up_to)
         } else {
@@ -3104,7 +3158,9 @@ impl Encoding {
     /// If the size calculation for a heap-allocated backing buffer overflows
     /// `usize`.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     pub fn decode_without_bom_handling_and_without_replacement<'a>(
         &'static self,
         bytes: &'a [u8],
@@ -3112,7 +3168,7 @@ impl Encoding {
         if self == UTF_8 {
             let valid_up_to = utf8_valid_up_to(bytes);
             if valid_up_to == bytes.len() {
-                let str: &str = unsafe { std::str::from_utf8_unchecked(bytes) };
+                let str: &str = unsafe { core::str::from_utf8_unchecked(bytes) };
                 return Some(Cow::Borrowed(str));
             }
             return None;
@@ -3124,7 +3180,7 @@ impl Encoding {
                 ascii_valid_up_to(bytes)
             };
             if valid_up_to == bytes.len() {
-                let str: &str = unsafe { std::str::from_utf8_unchecked(bytes) };
+                let str: &str = unsafe { core::str::from_utf8_unchecked(bytes) };
                 return Some(Cow::Borrowed(str));
             }
             let decoder = self.new_decoder_without_bom_handling();
@@ -3138,7 +3194,7 @@ impl Encoding {
             unsafe {
                 let vec = string.as_mut_vec();
                 vec.set_len(valid_up_to);
-                std::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);
+                core::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);
             }
             (decoder, string, &bytes[valid_up_to..])
         } else {
@@ -3199,7 +3255,9 @@ impl Encoding {
     /// If the size calculation for a heap-allocated backing buffer overflows
     /// `usize`.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     pub fn encode<'a>(&'static self, string: &'a str) -> (Cow<'a, [u8]>, &'static Encoding, bool) {
         let output_encoding = self.output_encoding();
         if output_encoding == UTF_8 {
@@ -3226,7 +3284,7 @@ impl Encoding {
         );
         unsafe {
             vec.set_len(valid_up_to);
-            std::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);
+            core::ptr::copy_nonoverlapping(bytes.as_ptr(), vec.as_mut_ptr(), valid_up_to);
         }
         let mut total_read = valid_up_to;
         let mut total_had_errors = false;
@@ -3355,6 +3413,20 @@ impl PartialEq for Encoding {
 
 impl Eq for Encoding {}
 
+#[cfg(test)]
+impl PartialOrd for Encoding {
+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
+        (self as *const Encoding as usize).partial_cmp(&(other as *const Encoding as usize))
+    }
+}
+
+#[cfg(test)]
+impl Ord for Encoding {
+    fn cmp(&self, other: &Self) -> Ordering {
+        (self as *const Encoding as usize).cmp(&(other as *const Encoding as usize))
+    }
+}
+
 impl Hash for Encoding {
     #[inline]
     fn hash<H: Hasher>(&self, state: &mut H) {
@@ -3362,9 +3434,9 @@ impl Hash for Encoding {
     }
 }
 
-impl std::fmt::Debug for Encoding {
+impl core::fmt::Debug for Encoding {
     #[inline]
-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
         write!(f, "Encoding {{ {} }}", self.name)
     }
 }
@@ -3387,7 +3459,7 @@ struct EncodingVisitor;
 impl<'de> Visitor<'de> for EncodingVisitor {
     type Value = &'static Encoding;
 
-    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
+    fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
         formatter.write_str("a valid encoding label")
     }
 
@@ -3398,7 +3470,10 @@ impl<'de> Visitor<'de> for EncodingVisitor {
         if let Some(enc) = Encoding::for_label(value.as_bytes()) {
             Ok(enc)
         } else {
-            Err(E::custom(format!("invalid encoding label: {}", value)))
+            Err(E::custom(alloc::format!(
+                "invalid encoding label: {}",
+                value
+            )))
         }
     }
 }
@@ -3672,7 +3747,7 @@ impl Decoder {
                         1,
                         checked_mul(3, checked_div(byte_length.checked_add(1), 2)),
                     ) {
-                        let utf_bom = std::cmp::max(utf8_bom, utf16_bom);
+                        let utf_bom = core::cmp::max(utf8_bom, utf16_bom);
                         let encoding = self.encoding();
                         if encoding == UTF_8 || encoding == UTF_16LE || encoding == UTF_16BE {
                             // No need to consider the internal state of the underlying decoder,
@@ -3681,7 +3756,7 @@ impl Decoder {
                         } else if let Some(non_bom) =
                             self.variant.max_utf8_buffer_length(byte_length)
                         {
-                            return Some(std::cmp::max(utf_bom, non_bom));
+                            return Some(core::cmp::max(utf_bom, non_bom));
                         }
                     }
                 }
@@ -3699,7 +3774,7 @@ impl Decoder {
                             // because it is at start, because no data has reached it yet.
                             return Some(utf8_bom);
                         } else if let Some(non_bom) = self.variant.max_utf8_buffer_length(sum) {
-                            return Some(std::cmp::max(utf8_bom, non_bom));
+                            return Some(core::cmp::max(utf8_bom, non_bom));
                         }
                     }
                 }
@@ -3725,7 +3800,7 @@ impl Decoder {
                             // because it is at start, because no data has reached it yet.
                             return Some(utf16_bom);
                         } else if let Some(non_bom) = self.variant.max_utf8_buffer_length(sum) {
-                            return Some(std::cmp::max(utf16_bom, non_bom));
+                            return Some(core::cmp::max(utf16_bom, non_bom));
                         }
                     }
                 }
@@ -3764,7 +3839,7 @@ impl Decoder {
                         1,
                         checked_mul(3, checked_div(byte_length.checked_add(1), 2)),
                     ) {
-                        let utf_bom = std::cmp::max(utf8_bom, utf16_bom);
+                        let utf_bom = core::cmp::max(utf8_bom, utf16_bom);
                         let encoding = self.encoding();
                         if encoding == UTF_8 || encoding == UTF_16LE || encoding == UTF_16BE {
                             // No need to consider the internal state of the underlying decoder,
@@ -3774,7 +3849,7 @@ impl Decoder {
                             .variant
                             .max_utf8_buffer_length_without_replacement(byte_length)
                         {
-                            return Some(std::cmp::max(utf_bom, non_bom));
+                            return Some(core::cmp::max(utf_bom, non_bom));
                         }
                     }
                 }
@@ -3794,7 +3869,7 @@ impl Decoder {
                         } else if let Some(non_bom) =
                             self.variant.max_utf8_buffer_length_without_replacement(sum)
                         {
-                            return Some(std::cmp::max(utf8_bom, non_bom));
+                            return Some(core::cmp::max(utf8_bom, non_bom));
                         }
                     }
                 }
@@ -3822,7 +3897,7 @@ impl Decoder {
                         } else if let Some(non_bom) =
                             self.variant.max_utf8_buffer_length_without_replacement(sum)
                         {
-                            return Some(std::cmp::max(utf16_bom, non_bom));
+                            return Some(core::cmp::max(utf16_bom, non_bom));
                         }
                     }
                 }
@@ -3916,7 +3991,7 @@ impl Decoder {
         // bytes of trailing garbage. No need to optimize non-ASCII-compatible
         // encodings to avoid overwriting here.
         if self.encoding != UTF_8 {
-            let max = std::cmp::min(len, trail + ascii::MAX_STRIDE_SIZE);
+            let max = core::cmp::min(len, trail + ascii::MAX_STRIDE_SIZE);
             while trail < max {
                 bytes[trail] = 0;
                 trail += 1;
@@ -3945,7 +4020,9 @@ impl Decoder {
     /// See the documentation of the struct for documentation for `decode_*`
     /// methods collectively.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     pub fn decode_to_string(
         &mut self,
         src: &[u8],
@@ -4006,7 +4083,7 @@ impl Decoder {
         // bytes of trailing garbage. No need to optimize non-ASCII-compatible
         // encodings to avoid overwriting here.
         if self.encoding != UTF_8 {
-            let max = std::cmp::min(len, trail + ascii::MAX_STRIDE_SIZE);
+            let max = core::cmp::min(len, trail + ascii::MAX_STRIDE_SIZE);
             while trail < max {
                 bytes[trail] = 0;
                 trail += 1;
@@ -4033,7 +4110,9 @@ impl Decoder {
     /// See the documentation of the struct for documentation for `decode_*`
     /// methods collectively.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     pub fn decode_to_string_without_replacement(
         &mut self,
         src: &[u8],
@@ -4079,7 +4158,7 @@ impl Decoder {
                     if let Some(utf16_bom) =
                         checked_add(1, checked_div(byte_length.checked_add(1), 2))
                     {
-                        let utf_bom = std::cmp::max(utf8_bom, utf16_bom);
+                        let utf_bom = core::cmp::max(utf8_bom, utf16_bom);
                         let encoding = self.encoding();
                         if encoding == UTF_8 || encoding == UTF_16LE || encoding == UTF_16BE {
                             // No need to consider the internal state of the underlying decoder,
@@ -4088,7 +4167,7 @@ impl Decoder {
                         } else if let Some(non_bom) =
                             self.variant.max_utf16_buffer_length(byte_length)
                         {
-                            return Some(std::cmp::max(utf_bom, non_bom));
+                            return Some(core::cmp::max(utf_bom, non_bom));
                         }
                     }
                 }
@@ -4106,7 +4185,7 @@ impl Decoder {
                             // because it is at start, because no data has reached it yet.
                             return Some(utf8_bom);
                         } else if let Some(non_bom) = self.variant.max_utf16_buffer_length(sum) {
-                            return Some(std::cmp::max(utf8_bom, non_bom));
+                            return Some(core::cmp::max(utf8_bom, non_bom));
                         }
                     }
                 }
@@ -4130,7 +4209,7 @@ impl Decoder {
                             // because it is at start, because no data has reached it yet.
                             return Some(utf16_bom);
                         } else if let Some(non_bom) = self.variant.max_utf16_buffer_length(sum) {
-                            return Some(std::cmp::max(utf16_bom, non_bom));
+                            return Some(core::cmp::max(utf16_bom, non_bom));
                         }
                     }
                 }
@@ -4265,7 +4344,7 @@ pub enum EncoderResult {
 
 impl EncoderResult {
     fn unmappable_from_bmp(bmp: u16) -> EncoderResult {
-        EncoderResult::Unmappable(::std::char::from_u32(u32::from(bmp)).unwrap())
+        EncoderResult::Unmappable(::core::char::from_u32(u32::from(bmp)).unwrap())
     }
 }
 
@@ -4532,7 +4611,9 @@ impl Encoder {
     /// See the documentation of the struct for documentation for `encode_*`
     /// methods collectively.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     pub fn encode_from_utf8_to_vec(
         &mut self,
         src: &str,
@@ -4570,7 +4651,9 @@ impl Encoder {
     /// See the documentation of the struct for documentation for `encode_*`
     /// methods collectively.
     ///
-    /// Available to Rust only.
+    /// Available to Rust only and only with the `alloc` feature enabled (enabled
+    /// by default).
+    #[cfg(feature = "alloc")]
     pub fn encode_from_utf8_to_vec_without_replacement(
         &mut self,
         src: &str,
@@ -4836,16 +4919,18 @@ fn checked_div(opt: Option<usize>, num: usize) -> Option<usize> {
     }
 }
 
+#[cfg(feature = "alloc")]
 #[inline(always)]
 fn checked_next_power_of_two(opt: Option<usize>) -> Option<usize> {
     opt.map(|n| n.next_power_of_two())
 }
 
+#[cfg(feature = "alloc")]
 #[inline(always)]
 fn checked_min(one: Option<usize>, other: Option<usize>) -> Option<usize> {
     if let Some(a) = one {
         if let Some(b) = other {
-            Some(::std::cmp::min(a, b))
+            Some(::core::cmp::min(a, b))
         } else {
             Some(a)
         }
@@ -4867,10 +4952,10 @@ struct Demo {
 #[cfg(test)]
 mod test_labels_names;
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::*;
-    use std::borrow::Cow;
+    use alloc::borrow::Cow;
 
     fn sniff_to_utf16(
         initial_encoding: &'static Encoding,
@@ -5623,7 +5708,7 @@ mod tests {
 
     #[test]
     fn test_hash() {
-        let mut encodings = ::std::collections::HashSet::new();
+        let mut encodings = ::alloc::collections::btree_set::BTreeSet::new();
         encodings.insert(UTF_8);
         encodings.insert(ISO_2022_JP);
         assert!(encodings.contains(UTF_8));
diff --git a/third_party/rust/encoding_rs/src/macros.rs b/third_party/rust/encoding_rs/src/macros.rs
index 135ddd664866..d3bb5e9ed018 100644
--- a/third_party/rust/encoding_rs/src/macros.rs
+++ b/third_party/rust/encoding_rs/src/macros.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -571,7 +571,7 @@ macro_rules! gb18030_decoder_function {
                                     }
                                     Space::Available(destination_handle) => {
                                         let (b, _) = source_handle.read();
-                                        'innermost: loop {
+                                        loop {
                                             if b > 127 {
                                                 $non_ascii = b;
                                                 $handle = destination_handle;
@@ -875,7 +875,7 @@ macro_rules! euc_jp_decoder_function {
                                     }
                                     Space::Available(destination_handle) => {
                                         let (b, _) = source_handle.read();
-                                        'innermost: loop {
+                                        loop {
                                             if b > 127 {
                                                 $non_ascii = b;
                                                 $handle = destination_handle;
diff --git a/third_party/rust/encoding_rs/src/mem.rs b/third_party/rust/encoding_rs/src/mem.rs
index 8c82704d7e04..3330619310df 100644
--- a/third_party/rust/encoding_rs/src/mem.rs
+++ b/third_party/rust/encoding_rs/src/mem.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -24,7 +24,12 @@
 //! The FFI binding for this module are in the
 //! [encoding_c_mem crate](https://github.com/hsivonen/encoding_c_mem).
 
-use std::borrow::Cow;
+#[cfg(feature = "alloc")]
+use alloc::borrow::Cow;
+#[cfg(feature = "alloc")]
+use alloc::string::String;
+#[cfg(feature = "alloc")]
+use alloc::vec::Vec;
 
 use super::in_inclusive_range16;
 use super::in_inclusive_range32;
@@ -32,8 +37,8 @@ use super::in_inclusive_range8;
 use super::in_range16;
 use super::in_range32;
 use super::DecoderResult;
-use ascii::*;
-use utf_8::*;
+use crate::ascii::*;
+use crate::utf_8::*;
 
 macro_rules! non_fuzz_debug_assert {
     ($($arg:tt)*) => (if !cfg!(fuzzing) { debug_assert!($($arg)*); })
@@ -41,8 +46,8 @@ macro_rules! non_fuzz_debug_assert {
 
 cfg_if! {
     if #[cfg(feature = "simd-accel")] {
-        use ::std::intrinsics::likely;
-        use ::std::intrinsics::unlikely;
+        use ::core::intrinsics::likely;
+        use ::core::intrinsics::unlikely;
     } else {
         #[inline(always)]
         // Unsafe to match the intrinsic, which is needlessly unsafe.
@@ -85,7 +90,7 @@ macro_rules! by_unit_check_alu {
         fn $name(buffer: &[$unit]) -> bool {
             let mut offset = 0usize;
             let mut accu = 0usize;
-            let unit_size = ::std::mem::size_of::<$unit>();
+            let unit_size = ::core::mem::size_of::<$unit>();
             let len = buffer.len();
             if len >= ALU_ALIGNMENT / unit_size {
                 // The most common reason to return `false` is for the first code
@@ -157,7 +162,7 @@ macro_rules! by_unit_check_simd {
         fn $name(buffer: &[$unit]) -> bool {
             let mut offset = 0usize;
             let mut accu = 0usize;
-            let unit_size = ::std::mem::size_of::<$unit>();
+            let unit_size = ::core::mem::size_of::<$unit>();
             let len = buffer.len();
             if len >= SIMD_STRIDE_SIZE / unit_size {
                 // The most common reason to return `false` is for the first code
@@ -230,7 +235,7 @@ macro_rules! by_unit_check_simd {
 
 cfg_if! {
     if #[cfg(all(feature = "simd-accel", any(target_feature = "sse2", all(target_endian = "little", target_arch = "aarch64"), all(target_endian = "little", target_feature = "neon"))))] {
-        use simd_funcs::*;
+        use crate::simd_funcs::*;
         use packed_simd::u8x16;
         use packed_simd::u16x8;
 
@@ -248,7 +253,7 @@ cfg_if! {
             // only aligned SIMD (perhaps misguidedly) and needs to deal with
             // the last code unit in a SIMD stride being part of a valid
             // surrogate pair.
-            let unit_size = ::std::mem::size_of::<u16>();
+            let unit_size = ::core::mem::size_of::<u16>();
             let src = buffer.as_ptr();
             let len = buffer.len();
             let mut offset = 0usize;
@@ -276,7 +281,7 @@ cfg_if! {
                     offset = offset_plus_until_alignment;
                 }
                 let len_minus_stride = len - SIMD_STRIDE_SIZE / unit_size;
-                'inner: loop {
+                loop {
                     let offset_plus_stride = offset + SIMD_STRIDE_SIZE / unit_size;
                     if contains_surrogates(unsafe { *(src.add(offset) as *const u16x8) }) {
                         if offset_plus_stride == len {
@@ -740,13 +745,13 @@ pub fn is_utf8_bidi(buffer: &[u8]) -> bool {
                 'inner: loop {
                     // At this point, `byte` is not included in `read`.
                     match byte {
-                        0...0x7F => {
+                        0..=0x7F => {
                             // ASCII: go back to SIMD.
                             read += 1;
                             src = &src[read..];
                             continue 'outer;
                         }
-                        0xC2...0xD5 => {
+                        0xC2..=0xD5 => {
                             // Two-byte
                             let second = unsafe { *(src.get_unchecked(read + 1)) };
                             if !in_inclusive_range8(second, 0x80, 0xBF) {
@@ -767,7 +772,7 @@ pub fn is_utf8_bidi(buffer: &[u8]) -> bool {
                             read += 2;
                         }
                         // two-byte starting with 0xD7 and above is bidi
-                        0xE1 | 0xE3...0xEC | 0xEE => {
+                        0xE1 | 0xE3..=0xEC | 0xEE => {
                             // Three-byte normal
                             let second = unsafe { *(src.get_unchecked(read + 1)) };
                             let third = unsafe { *(src.get_unchecked(read + 2)) };
@@ -876,7 +881,7 @@ pub fn is_utf8_bidi(buffer: &[u8]) -> bool {
                             }
                             read += 3;
                         }
-                        0xF1...0xF4 => {
+                        0xF1..=0xF4 => {
                             // Four-byte normal
                             let second = unsafe { *(src.get_unchecked(read + 1)) };
                             let third = unsafe { *(src.get_unchecked(read + 2)) };
@@ -939,13 +944,13 @@ pub fn is_utf8_bidi(buffer: &[u8]) -> bool {
 
             // At this point, `byte` is not included in `read`.
             match byte {
-                0...0x7F => {
+                0..=0x7F => {
                     // ASCII: go back to SIMD.
                     read += 1;
                     src = &src[read..];
                     continue 'outer;
                 }
-                0xC2...0xD5 => {
+                0xC2..=0xD5 => {
                     // Two-byte
                     let new_read = read + 2;
                     if new_read > src.len() {
@@ -982,7 +987,7 @@ pub fn is_utf8_bidi(buffer: &[u8]) -> bool {
                     continue 'outer;
                 }
                 // two-byte starting with 0xD7 and above is bidi
-                0xE1 | 0xE3...0xEC | 0xEE => {
+                0xE1 | 0xE3..=0xEC | 0xEE => {
                     // Three-byte normal
                     let new_read = read + 3;
                     if new_read > src.len() {
@@ -1781,7 +1786,7 @@ pub fn convert_latin1_to_utf8_partial(src: &[u8], dst: &mut [u8]) -> (usize, usi
         // src can't advance more than dst
         let src_left = src_len - total_read;
         let dst_left = dst_len - total_written;
-        let min_left = ::std::cmp::min(src_left, dst_left);
+        let min_left = ::core::cmp::min(src_left, dst_left);
         if let Some((non_ascii, consumed)) = unsafe {
             ascii_to_ascii(
                 src_ptr.add(total_read),
@@ -1850,7 +1855,7 @@ pub fn convert_latin1_to_str_partial(src: &[u8], dst: &mut str) -> (usize, usize
     let (read, written) = convert_latin1_to_utf8_partial(src, bytes);
     let len = bytes.len();
     let mut trail = written;
-    let max = ::std::cmp::min(len, trail + MAX_STRIDE_SIZE);
+    let max = ::core::cmp::min(len, trail + MAX_STRIDE_SIZE);
     while trail < max {
         bytes[trail] = 0;
         trail += 1;
@@ -1986,12 +1991,15 @@ pub fn convert_utf16_to_latin1_lossy(src: &[u16], dst: &mut [u8]) {
 ///
 /// Borrows if input is ASCII-only. Performs a single heap allocation
 /// otherwise.
+///
+/// Only available if the `alloc` feature is enabled (enabled by default).
+#[cfg(feature = "alloc")]
 pub fn decode_latin1<'a>(bytes: &'a [u8]) -> Cow<'a, str> {
     let up_to = ascii_valid_up_to(bytes);
     // >= makes later things optimize better than ==
     if up_to >= bytes.len() {
         debug_assert_eq!(up_to, bytes.len());
-        let s: &str = unsafe { ::std::str::from_utf8_unchecked(bytes) };
+        let s: &str = unsafe { ::core::str::from_utf8_unchecked(bytes) };
         return Cow::Borrowed(s);
     }
     let (head, tail) = bytes.split_at(up_to);
@@ -2020,6 +2028,9 @@ pub fn decode_latin1<'a>(bytes: &'a [u8]) -> Cow<'a, str> {
 ///
 /// Borrows if input is ASCII-only. Performs a single heap allocation
 /// otherwise.
+///
+/// Only available if the `alloc` feature is enabled (enabled by default).
+#[cfg(feature = "alloc")]
 pub fn encode_latin1_lossy<'a>(string: &'a str) -> Cow<'a, [u8]> {
     let bytes = string.as_bytes();
     let up_to = ascii_valid_up_to(bytes);
@@ -2056,7 +2067,7 @@ pub fn utf8_latin1_up_to(buffer: &[u8]) -> usize {
 /// Returns the index of first byte that starts a non-Latin1 byte
 /// sequence, or the length of the string if there are none.
 pub fn str_latin1_up_to(buffer: &str) -> usize {
-    is_str_latin1_impl(buffer).unwrap_or(buffer.len())
+    is_str_latin1_impl(buffer).unwrap_or_else(|| buffer.len())
 }
 
 /// Replaces unpaired surrogates in the input with the REPLACEMENT CHARACTER.
@@ -2153,7 +2164,7 @@ pub fn copy_basic_latin_to_ascii(src: &[u16], dst: &mut [u8]) -> usize {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::*;
 
@@ -2231,8 +2242,9 @@ mod tests {
 
     #[test]
     fn test_is_utf16_latin1_fail() {
-        let mut src: Vec<u16> = Vec::with_capacity(256);
-        src.resize(256, 0);
+        let len = if cfg!(miri) { 64 } else { 256 }; // Miri is too slow
+        let mut src: Vec<u16> = Vec::with_capacity(len);
+        src.resize(len, 0);
         for i in 0..src.len() {
             src[i] = i as u16;
         }
@@ -2248,8 +2260,9 @@ mod tests {
 
     #[test]
     fn test_is_str_latin1_success() {
-        let mut src: Vec<u16> = Vec::with_capacity(256);
-        src.resize(256, 0);
+        let len = if cfg!(miri) { 64 } else { 256 }; // Miri is too slow
+        let mut src: Vec<u16> = Vec::with_capacity(len);
+        src.resize(len, 0);
         for i in 0..src.len() {
             src[i] = i as u16;
         }
@@ -2262,8 +2275,9 @@ mod tests {
 
     #[test]
     fn test_is_str_latin1_fail() {
-        let mut src: Vec<u16> = Vec::with_capacity(256);
-        src.resize(256, 0);
+        let len = if cfg!(miri) { 32 } else { 256 }; // Miri is too slow
+        let mut src: Vec<u16> = Vec::with_capacity(len);
+        src.resize(len, 0);
         for i in 0..src.len() {
             src[i] = i as u16;
         }
@@ -2280,8 +2294,9 @@ mod tests {
 
     #[test]
     fn test_is_utf8_latin1_success() {
-        let mut src: Vec<u16> = Vec::with_capacity(256);
-        src.resize(256, 0);
+        let len = if cfg!(miri) { 64 } else { 256 }; // Miri is too slow
+        let mut src: Vec<u16> = Vec::with_capacity(len);
+        src.resize(len, 0);
         for i in 0..src.len() {
             src[i] = i as u16;
         }
@@ -2297,8 +2312,9 @@ mod tests {
 
     #[test]
     fn test_is_utf8_latin1_fail() {
-        let mut src: Vec<u16> = Vec::with_capacity(256);
-        src.resize(256, 0);
+        let len = if cfg!(miri) { 32 } else { 256 }; // Miri is too slow
+        let mut src: Vec<u16> = Vec::with_capacity(len);
+        src.resize(len, 0);
         for i in 0..src.len() {
             src[i] = i as u16;
         }
@@ -3112,11 +3128,11 @@ mod tests {
     #[inline(always)]
     pub fn reference_is_char_bidi(c: char) -> bool {
         match c {
-            '\u{0590}'...'\u{08FF}'
-            | '\u{FB1D}'...'\u{FDFF}'
-            | '\u{FE70}'...'\u{FEFE}'
-            | '\u{10800}'...'\u{10FFF}'
-            | '\u{1E800}'...'\u{1EFFF}'
+            '\u{0590}'..='\u{08FF}'
+            | '\u{FB1D}'..='\u{FDFF}'
+            | '\u{FE70}'..='\u{FEFE}'
+            | '\u{10800}'..='\u{10FFF}'
+            | '\u{1E800}'..='\u{1EFFF}'
             | '\u{200F}'
             | '\u{202B}'
             | '\u{202E}'
@@ -3128,9 +3144,9 @@ mod tests {
     #[inline(always)]
     pub fn reference_is_utf16_code_unit_bidi(u: u16) -> bool {
         match u {
-            0x0590...0x08FF
-            | 0xFB1D...0xFDFF
-            | 0xFE70...0xFEFE
+            0x0590..=0x08FF
+            | 0xFB1D..=0xFDFF
+            | 0xFE70..=0xFEFE
             | 0xD802
             | 0xD803
             | 0xD83A
@@ -3144,18 +3160,20 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_is_char_bidi_thoroughly() {
         for i in 0..0xD800u32 {
-            let c: char = ::std::char::from_u32(i).unwrap();
+            let c: char = ::core::char::from_u32(i).unwrap();
             assert_eq!(is_char_bidi(c), reference_is_char_bidi(c));
         }
         for i in 0xE000..0x110000u32 {
-            let c: char = ::std::char::from_u32(i).unwrap();
+            let c: char = ::core::char::from_u32(i).unwrap();
             assert_eq!(is_char_bidi(c), reference_is_char_bidi(c));
         }
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_is_utf16_code_unit_bidi_thoroughly() {
         for i in 0..0x10000u32 {
             let u = i as u16;
@@ -3167,17 +3185,18 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_is_str_bidi_thoroughly() {
         let mut buf = [0; 4];
         for i in 0..0xD800u32 {
-            let c: char = ::std::char::from_u32(i).unwrap();
+            let c: char = ::core::char::from_u32(i).unwrap();
             assert_eq!(
                 is_str_bidi(c.encode_utf8(&mut buf[..])),
                 reference_is_char_bidi(c)
             );
         }
         for i in 0xE000..0x110000u32 {
-            let c: char = ::std::char::from_u32(i).unwrap();
+            let c: char = ::core::char::from_u32(i).unwrap();
             assert_eq!(
                 is_str_bidi(c.encode_utf8(&mut buf[..])),
                 reference_is_char_bidi(c)
@@ -3186,10 +3205,11 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_is_utf8_bidi_thoroughly() {
         let mut buf = [0; 8];
         for i in 0..0xD800u32 {
-            let c: char = ::std::char::from_u32(i).unwrap();
+            let c: char = ::core::char::from_u32(i).unwrap();
             let expect = reference_is_char_bidi(c);
             {
                 let len = {
@@ -3207,7 +3227,7 @@ mod tests {
             assert_eq!(is_utf8_bidi(&buf[..]), expect);
         }
         for i in 0xE000..0x110000u32 {
-            let c: char = ::std::char::from_u32(i).unwrap();
+            let c: char = ::core::char::from_u32(i).unwrap();
             let expect = reference_is_char_bidi(c);
             {
                 let len = {
@@ -3227,6 +3247,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_is_utf16_bidi_thoroughly() {
         let mut buf = [0; 32];
         for i in 0..0x10000u32 {
diff --git a/third_party/rust/encoding_rs/src/replacement.rs b/third_party/rust/encoding_rs/src/replacement.rs
index e3c8974312ae..3d1bcc1f57cc 100644
--- a/third_party/rust/encoding_rs/src/replacement.rs
+++ b/third_party/rust/encoding_rs/src/replacement.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,7 +8,7 @@
 // except according to those terms.
 
 use super::*;
-use variant::*;
+use crate::variant::*;
 
 pub struct ReplacementDecoder {
     emitted: bool,
@@ -73,7 +73,7 @@ impl ReplacementDecoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
diff --git a/third_party/rust/encoding_rs/src/shift_jis.rs b/third_party/rust/encoding_rs/src/shift_jis.rs
index 16a2a8eec277..eb1b0f0ca9ac 100644
--- a/third_party/rust/encoding_rs/src/shift_jis.rs
+++ b/third_party/rust/encoding_rs/src/shift_jis.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,9 +8,9 @@
 // except according to those terms.
 
 use super::*;
-use data::*;
-use handles::*;
-use variant::*;
+use crate::data::*;
+use crate::handles::*;
+use crate::variant::*;
 // Rust 1.14.0 requires the following despite the asterisk above.
 use super::in_inclusive_range;
 use super::in_inclusive_range16;
@@ -305,7 +305,7 @@ impl ShiftJisEncoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
@@ -385,6 +385,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_shift_jis_decode_all() {
         let input = include_bytes!("test_data/shift_jis_in.txt");
         let expectation = include_str!("test_data/shift_jis_in_ref.txt");
@@ -394,6 +395,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg_attr(miri, ignore)] // Miri is too slow
     fn test_shift_jis_encode_all() {
         let input = include_str!("test_data/shift_jis_out.txt");
         let expectation = include_bytes!("test_data/shift_jis_out_ref.txt");
diff --git a/third_party/rust/encoding_rs/src/simd_funcs.rs b/third_party/rust/encoding_rs/src/simd_funcs.rs
index 8f9746fe9caf..08e627b6309e 100644
--- a/third_party/rust/encoding_rs/src/simd_funcs.rs
+++ b/third_party/rust/encoding_rs/src/simd_funcs.rs
@@ -1,4 +1,4 @@
-// Copyright 2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -16,8 +16,8 @@ use packed_simd::FromBits;
 
 #[inline(always)]
 pub unsafe fn load16_unaligned(ptr: *const u8) -> u8x16 {
-    let mut simd = ::std::mem::uninitialized();
-    ::std::ptr::copy_nonoverlapping(ptr, &mut simd as *mut u8x16 as *mut u8, 16);
+    let mut simd = ::core::mem::uninitialized();
+    ::core::ptr::copy_nonoverlapping(ptr, &mut simd as *mut u8x16 as *mut u8, 16);
     simd
 }
 
@@ -29,7 +29,7 @@ pub unsafe fn load16_aligned(ptr: *const u8) -> u8x16 {
 
 #[inline(always)]
 pub unsafe fn store16_unaligned(ptr: *mut u8, s: u8x16) {
-    ::std::ptr::copy_nonoverlapping(&s as *const u8x16 as *const u8, ptr, 16);
+    ::core::ptr::copy_nonoverlapping(&s as *const u8x16 as *const u8, ptr, 16);
 }
 
 #[allow(dead_code)]
@@ -40,8 +40,8 @@ pub unsafe fn store16_aligned(ptr: *mut u8, s: u8x16) {
 
 #[inline(always)]
 pub unsafe fn load8_unaligned(ptr: *const u16) -> u16x8 {
-    let mut simd = ::std::mem::uninitialized();
-    ::std::ptr::copy_nonoverlapping(ptr as *const u8, &mut simd as *mut u16x8 as *mut u8, 16);
+    let mut simd = ::core::mem::uninitialized();
+    ::core::ptr::copy_nonoverlapping(ptr as *const u8, &mut simd as *mut u16x8 as *mut u8, 16);
     simd
 }
 
@@ -53,7 +53,7 @@ pub unsafe fn load8_aligned(ptr: *const u16) -> u16x8 {
 
 #[inline(always)]
 pub unsafe fn store8_unaligned(ptr: *mut u16, s: u16x8) {
-    ::std::ptr::copy_nonoverlapping(&s as *const u16x8 as *const u8, ptr as *mut u8, 16);
+    ::core::ptr::copy_nonoverlapping(&s as *const u16x8 as *const u8, ptr as *mut u8, 16);
 }
 
 #[allow(dead_code)]
@@ -64,18 +64,18 @@ pub unsafe fn store8_aligned(ptr: *mut u16, s: u16x8) {
 
 cfg_if! {
     if #[cfg(all(target_feature = "sse2", target_arch = "x86_64"))] {
-        use std::arch::x86_64::__m128i;
-        use std::arch::x86_64::_mm_movemask_epi8;
-        use std::arch::x86_64::_mm_packus_epi16;
+        use core::arch::x86_64::__m128i;
+        use core::arch::x86_64::_mm_movemask_epi8;
+        use core::arch::x86_64::_mm_packus_epi16;
     } else if #[cfg(all(target_feature = "sse2", target_arch = "x86"))] {
-        use std::arch::x86::__m128i;
-        use std::arch::x86::_mm_movemask_epi8;
-        use std::arch::x86::_mm_packus_epi16;
+        use core::arch::x86::__m128i;
+        use core::arch::x86::_mm_movemask_epi8;
+        use core::arch::x86::_mm_packus_epi16;
     } else if #[cfg(target_arch = "aarch64")]{
-        use std::arch::aarch64::uint8x16_t;
-        use std::arch::aarch64::uint16x8_t;
-        use std::arch::aarch64::vmaxvq_u8;
-        use std::arch::aarch64::vmaxvq_u16;
+        use core::arch::aarch64::uint8x16_t;
+        use core::arch::aarch64::uint16x8_t;
+        use core::arch::aarch64::vmaxvq_u8;
+        use core::arch::aarch64::vmaxvq_u16;
     } else {
 
     }
@@ -327,6 +327,7 @@ cfg_if! {
 #[cfg(test)]
 mod tests {
     use super::*;
+    use alloc::vec::Vec;
 
     #[test]
     fn test_unpack() {
@@ -446,7 +447,7 @@ mod tests {
         ];
         let mut alu = 0u64;
         unsafe {
-            ::std::ptr::copy_nonoverlapping(input.as_ptr(), &mut alu as *mut u64 as *mut u8, 8);
+            ::core::ptr::copy_nonoverlapping(input.as_ptr(), &mut alu as *mut u64 as *mut u8, 8);
         }
         let masked = alu & 0x8080808080808080;
         assert_eq!(masked.trailing_zeros(), 39);
diff --git a/third_party/rust/encoding_rs/src/single_byte.rs b/third_party/rust/encoding_rs/src/single_byte.rs
index a8a99cde78cf..b3b6089d318b 100644
--- a/third_party/rust/encoding_rs/src/single_byte.rs
+++ b/third_party/rust/encoding_rs/src/single_byte.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,10 +8,10 @@
 // except according to those terms.
 
 use super::*;
-use ascii::*;
-use data::position;
-use handles::*;
-use variant::*;
+use crate::ascii::*;
+use crate::data::position;
+use crate::handles::*;
+use crate::variant::*;
 
 pub struct SingleByteDecoder {
     table: &'static [u16; 128],
@@ -432,7 +432,7 @@ impl SingleByteEncoder {
                                     }
                                     // The next code unit is a low surrogate.
                                     let astral: char = unsafe {
-                                        ::std::char::from_u32_unchecked(
+                                        ::core::char::from_u32_unchecked(
                                             (u32::from(non_ascii) << 10) + second
                                                 - (((0xD800u32 << 10) - 0x1_0000u32) + 0xDC00u32),
                                         )
@@ -503,7 +503,7 @@ impl SingleByteEncoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
@@ -645,6 +645,10 @@ mod tests {
     fn test_single_byte_decode() {
         decode_single_byte(IBM866, &data::SINGLE_BYTE_DATA.ibm866);
         decode_single_byte(ISO_8859_10, &data::SINGLE_BYTE_DATA.iso_8859_10);
+        if cfg!(miri) {
+            // Miri is too slow
+            return;
+        }
         decode_single_byte(ISO_8859_13, &data::SINGLE_BYTE_DATA.iso_8859_13);
         decode_single_byte(ISO_8859_14, &data::SINGLE_BYTE_DATA.iso_8859_14);
         decode_single_byte(ISO_8859_15, &data::SINGLE_BYTE_DATA.iso_8859_15);
@@ -676,6 +680,10 @@ mod tests {
     fn test_single_byte_encode() {
         encode_single_byte(IBM866, &data::SINGLE_BYTE_DATA.ibm866);
         encode_single_byte(ISO_8859_10, &data::SINGLE_BYTE_DATA.iso_8859_10);
+        if cfg!(miri) {
+            // Miri is too slow
+            return;
+        }
         encode_single_byte(ISO_8859_13, &data::SINGLE_BYTE_DATA.iso_8859_13);
         encode_single_byte(ISO_8859_14, &data::SINGLE_BYTE_DATA.iso_8859_14);
         encode_single_byte(ISO_8859_15, &data::SINGLE_BYTE_DATA.iso_8859_15);
diff --git a/third_party/rust/encoding_rs/src/test_labels_names.rs b/third_party/rust/encoding_rs/src/test_labels_names.rs
index 5aeb5ab54d6d..ac3b3d9e836b 100644
--- a/third_party/rust/encoding_rs/src/test_labels_names.rs
+++ b/third_party/rust/encoding_rs/src/test_labels_names.rs
@@ -23,6 +23,7 @@ fn test_all_labels() {
     assert_eq!(Encoding::for_label(b"utf8"), Some(UTF_8));
     assert_eq!(Encoding::for_label(b"koi8"), Some(KOI8_R));
     assert_eq!(Encoding::for_label(b"sjis"), Some(SHIFT_JIS));
+    assert_eq!(Encoding::for_label(b"ucs-2"), Some(UTF_16LE));
     assert_eq!(Encoding::for_label(b"ms932"), Some(SHIFT_JIS));
     assert_eq!(Encoding::for_label(b"cp866"), Some(IBM866));
     assert_eq!(Encoding::for_label(b"utf-8"), Some(UTF_8));
@@ -67,6 +68,7 @@ fn test_all_labels() {
     assert_eq!(Encoding::for_label(b"gb_2312"), Some(GBK));
     assert_eq!(Encoding::for_label(b"dos-874"), Some(WINDOWS_874));
     assert_eq!(Encoding::for_label(b"cn-big5"), Some(BIG5));
+    assert_eq!(Encoding::for_label(b"unicode"), Some(UTF_16LE));
     assert_eq!(Encoding::for_label(b"chinese"), Some(GBK));
     assert_eq!(Encoding::for_label(b"logical"), Some(ISO_8859_8_I));
     assert_eq!(Encoding::for_label(b"cskoi8r"), Some(KOI8_R));
@@ -119,6 +121,7 @@ fn test_all_labels() {
     assert_eq!(Encoding::for_label(b"iso8859-8"), Some(ISO_8859_8));
     assert_eq!(Encoding::for_label(b"iso-ir-58"), Some(GBK));
     assert_eq!(Encoding::for_label(b"iso8859-9"), Some(WINDOWS_1254));
+    assert_eq!(Encoding::for_label(b"csunicode"), Some(UTF_16LE));
     assert_eq!(Encoding::for_label(b"macintosh"), Some(MACINTOSH));
     assert_eq!(Encoding::for_label(b"shift-jis"), Some(SHIFT_JIS));
     assert_eq!(Encoding::for_label(b"shift_jis"), Some(SHIFT_JIS));
@@ -178,6 +181,8 @@ fn test_all_labels() {
     assert_eq!(Encoding::for_label(b"csisolatin9"), Some(ISO_8859_15));
     assert_eq!(Encoding::for_label(b"csiso88596e"), Some(ISO_8859_6));
     assert_eq!(Encoding::for_label(b"csiso88598e"), Some(ISO_8859_8));
+    assert_eq!(Encoding::for_label(b"unicodefffe"), Some(UTF_16BE));
+    assert_eq!(Encoding::for_label(b"unicodefeff"), Some(UTF_16LE));
     assert_eq!(Encoding::for_label(b"csmacintosh"), Some(MACINTOSH));
     assert_eq!(Encoding::for_label(b"csiso88596i"), Some(ISO_8859_6));
     assert_eq!(Encoding::for_label(b"csiso88598i"), Some(ISO_8859_8_I));
@@ -204,12 +209,15 @@ fn test_all_labels() {
     assert_eq!(Encoding::for_label(b"iso-8859-8-i"), Some(ISO_8859_8_I));
     assert_eq!(Encoding::for_label(b"sun_eu_greek"), Some(ISO_8859_7));
     assert_eq!(Encoding::for_label(b"csksc56011987"), Some(EUC_KR));
+    assert_eq!(Encoding::for_label(b"unicode20utf8"), Some(UTF_8));
+    assert_eq!(Encoding::for_label(b"unicode11utf8"), Some(UTF_8));
     assert_eq!(Encoding::for_label(b"ks_c_5601-1987"), Some(EUC_KR));
     assert_eq!(Encoding::for_label(b"ansi_x3.4-1968"), Some(WINDOWS_1252));
     assert_eq!(Encoding::for_label(b"ks_c_5601-1989"), Some(EUC_KR));
     assert_eq!(Encoding::for_label(b"x-mac-cyrillic"), Some(X_MAC_CYRILLIC));
     assert_eq!(Encoding::for_label(b"x-user-defined"), Some(X_USER_DEFINED));
     assert_eq!(Encoding::for_label(b"csiso58gb231280"), Some(GBK));
+    assert_eq!(Encoding::for_label(b"iso-10646-ucs-2"), Some(UTF_16LE));
     assert_eq!(Encoding::for_label(b"iso_8859-1:1987"), Some(WINDOWS_1252));
     assert_eq!(Encoding::for_label(b"iso_8859-2:1987"), Some(ISO_8859_2));
     assert_eq!(Encoding::for_label(b"iso_8859-6:1987"), Some(ISO_8859_6));
@@ -218,6 +226,7 @@ fn test_all_labels() {
     assert_eq!(Encoding::for_label(b"iso_8859-4:1988"), Some(ISO_8859_4));
     assert_eq!(Encoding::for_label(b"iso_8859-5:1988"), Some(ISO_8859_5));
     assert_eq!(Encoding::for_label(b"iso_8859-8:1988"), Some(ISO_8859_8));
+    assert_eq!(Encoding::for_label(b"x-unicode20utf8"), Some(UTF_8));
     assert_eq!(Encoding::for_label(b"iso_8859-9:1989"), Some(WINDOWS_1254));
     assert_eq!(Encoding::for_label(b"csisolatingreek"), Some(ISO_8859_7));
     assert_eq!(
diff --git a/third_party/rust/encoding_rs/src/testing.rs b/third_party/rust/encoding_rs/src/testing.rs
index 5e00431d3bd2..e2ca55c90dad 100644
--- a/third_party/rust/encoding_rs/src/testing.rs
+++ b/third_party/rust/encoding_rs/src/testing.rs
@@ -1,4 +1,4 @@
-// Copyright 2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -12,7 +12,12 @@ use super::*;
 pub fn decode(encoding: &'static Encoding, bytes: &[u8], expect: &str) {
     let mut vec = Vec::with_capacity(bytes.len() + 32);
     let mut string = String::with_capacity(expect.len() + 32);
-    for i in 0usize..32usize {
+    let range = if cfg!(miri) {
+        0usize..4usize
+    } else {
+        0usize..32usize
+    };
+    for i in range {
         vec.clear();
         string.clear();
         for j in 0usize..i {
@@ -44,7 +49,12 @@ fn decode_without_padding_impl(
 pub fn encode(encoding: &'static Encoding, str: &str, expect: &[u8]) {
     let mut vec = Vec::with_capacity(expect.len() + 32);
     let mut string = String::with_capacity(str.len() + 32);
-    for i in 0usize..32usize {
+    let range = if cfg!(miri) {
+        0usize..4usize
+    } else {
+        0usize..32usize
+    };
+    for i in range {
         vec.clear();
         string.clear();
         for j in 0usize..i {
diff --git a/third_party/rust/encoding_rs/src/utf_16.rs b/third_party/rust/encoding_rs/src/utf_16.rs
index b95c284fe888..c4428b39ce0a 100644
--- a/third_party/rust/encoding_rs/src/utf_16.rs
+++ b/third_party/rust/encoding_rs/src/utf_16.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,8 +8,8 @@
 // except according to those terms.
 
 use super::*;
-use handles::*;
-use variant::*;
+use crate::handles::*;
+use crate::variant::*;
 
 pub struct Utf16Decoder {
     lead_surrogate: u16, // If non-zero and pending_bmp == false, a pending lead surrogate
@@ -200,7 +200,7 @@ impl Utf16Decoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
diff --git a/third_party/rust/encoding_rs/src/utf_8.rs b/third_party/rust/encoding_rs/src/utf_8.rs
index da8be91a5236..2f72cc091d5e 100644
--- a/third_party/rust/encoding_rs/src/utf_8.rs
+++ b/third_party/rust/encoding_rs/src/utf_8.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,17 +8,17 @@
 // except according to those terms.
 
 use super::*;
-use ascii::ascii_to_basic_latin;
-use ascii::basic_latin_to_ascii;
-use ascii::validate_ascii;
-use handles::*;
-use mem::convert_utf16_to_utf8_partial;
-use variant::*;
+use crate::ascii::ascii_to_basic_latin;
+use crate::ascii::basic_latin_to_ascii;
+use crate::ascii::validate_ascii;
+use crate::handles::*;
+use crate::mem::convert_utf16_to_utf8_partial;
+use crate::variant::*;
 
 cfg_if! {
     if #[cfg(feature = "simd-accel")] {
-        use ::std::intrinsics::unlikely;
-        use ::std::intrinsics::likely;
+        use ::core::intrinsics::unlikely;
+        use ::core::intrinsics::likely;
     } else {
         #[inline(always)]
         // Unsafe to match the intrinsic, which is needlessly unsafe.
@@ -236,7 +236,7 @@ pub fn convert_utf8_to_utf16_up_to_invalid(src: &[u8], dst: &mut [u16]) -> (usiz
         let mut byte = {
             let src_remaining = &src[read..];
             let dst_remaining = &mut dst[written..];
-            let length = ::std::cmp::min(src_remaining.len(), dst_remaining.len());
+            let length = ::core::cmp::min(src_remaining.len(), dst_remaining.len());
             match unsafe {
                 ascii_to_basic_latin(src_remaining.as_ptr(), dst_remaining.as_mut_ptr(), length)
             } {
@@ -886,7 +886,7 @@ impl Utf8Encoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
diff --git a/third_party/rust/encoding_rs/src/variant.rs b/third_party/rust/encoding_rs/src/variant.rs
index 6c1dfeb6333e..dffaf053e37d 100644
--- a/third_party/rust/encoding_rs/src/variant.rs
+++ b/third_party/rust/encoding_rs/src/variant.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
diff --git a/third_party/rust/encoding_rs/src/x_user_defined.rs b/third_party/rust/encoding_rs/src/x_user_defined.rs
index 2d2076987984..103c9afba9eb 100644
--- a/third_party/rust/encoding_rs/src/x_user_defined.rs
+++ b/third_party/rust/encoding_rs/src/x_user_defined.rs
@@ -1,4 +1,4 @@
-// Copyright 2015-2016 Mozilla Foundation. See the COPYRIGHT
+// Copyright Mozilla Foundation. See the COPYRIGHT
 // file at the top-level directory of this distribution.
 //
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
@@ -8,8 +8,8 @@
 // except according to those terms.
 
 use super::*;
-use handles::*;
-use variant::*;
+use crate::handles::*;
+use crate::variant::*;
 
 cfg_if! {
     if #[cfg(feature = "simd-accel")] {
@@ -196,7 +196,7 @@ impl UserDefinedEncoder {
 // Any copyright to the test code below this comment is dedicated to the
 // Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
 
-#[cfg(test)]
+#[cfg(all(test, feature = "alloc"))]
 mod tests {
     use super::super::testing::*;
     use super::super::*;
diff --git a/third_party/rust/packed_simd/Cargo.toml b/third_party/rust/packed_simd/Cargo.toml
deleted file mode 100644
index 1e52297b7ec8..000000000000
--- a/third_party/rust/packed_simd/Cargo.toml
+++ /dev/null
@@ -1,45 +0,0 @@
-[package]
-name = "packed_simd"
-version = "0.3.4"
-authors = ["Gonzalo Brito Gadeschi <gonzalobg88@gmail.com>"]
-description = "Portable Packed SIMD vectors"
-documentation = "https://docs.rs/crate/packed_simd/"
-homepage = "https://github.com/rust-lang-nursery/packed_simd"
-repository = "https://github.com/rust-lang-nursery/packed_simd"
-keywords = ["simd", "vector", "portability"]
-categories = ["hardware-support", "concurrency", "no-std", "data-structures"]
-license = "MIT/Apache-2.0"
-build = "build.rs"
-edition = "2018"
-
-[badges]
-appveyor = { repository = "rust-lang-nursery/packed_simd" }
-travis-ci = { repository = "rust-lang-nursery/packed_simd" }
-codecov = { repository = "rust-lang-nursery/packed_simd" }
-is-it-maintained-issue-resolution = { repository = "rust-lang-nursery/packed_simd" }
-is-it-maintained-open-issues = { repository = "rust-lang-nursery/packed_simd" }
-maintenance = { status = "experimental" }
-
-[dependencies]
-cfg-if = "0.1.10"
-core_arch = { version = "0.1.5", optional = true }
-
-[features]
-default = []
-into_bits = []
-libcore_neon = []
-
-[build-dependencies]
-rustc_version = "0.2"
-
-[dev-dependencies]
-paste = "^0.1.3"
-arrayvec = { version = "^0.5", default-features = false }
-
-[target.'cfg(target_arch = "x86_64")'.dependencies.sleef-sys]
-version = "0.1.2"
-optional = true
-
-[target.wasm32-unknown-unknown.dev-dependencies]
-wasm-bindgen = "=0.2.52"
-wasm-bindgen-test = "=0.3.2"
diff --git a/third_party/rust/packed_simd/build.rs b/third_party/rust/packed_simd/build.rs
deleted file mode 100644
index 571139204e8f..000000000000
--- a/third_party/rust/packed_simd/build.rs
+++ /dev/null
@@ -1,34 +0,0 @@
-use rustc_version::{version_meta, Channel, Version};
-
-fn main() {
-    println!("cargo:rustc-env=RUSTC_BOOTSTRAP=1");
-    let target = std::env::var("TARGET")
-        .expect("TARGET environment variable not defined");
-    if target.contains("neon") {
-        println!("cargo:rustc-cfg=libcore_neon");
-    }
-    let ver_meta = version_meta().unwrap();
-    let old_const_generics =
-        if ver_meta.semver < Version::parse("1.56.0-alpha").unwrap() {
-            true
-        } else if ver_meta.semver >= Version::parse("1.57.0-alpha").unwrap() {
-            false
-        } else {
-            match ver_meta.channel {
-                Channel::Stable | Channel::Beta => false,
-                Channel::Nightly | Channel::Dev
-                    if ver_meta
-                        .commit_date
-                        .as_deref()
-                        .map(|d| d < "2021-08-31")
-                        .unwrap_or(false) =>
-                {
-                    true
-                }
-                _ => false,
-            }
-        };
-    if old_const_generics {
-        println!("cargo:rustc-cfg=const_generics");
-    }
-}
diff --git a/third_party/rust/packed_simd/rustfmt.toml b/third_party/rust/packed_simd/rustfmt.toml
deleted file mode 100644
index 5b400a4ce440..000000000000
--- a/third_party/rust/packed_simd/rustfmt.toml
+++ /dev/null
@@ -1,7 +0,0 @@
-max_width = 79
-use_small_heuristics = "Max"
-wrap_comments = true
-comment_width = 79
-fn_args_density = "Compressed"
-edition = "2018"
-error_on_line_overflow = true
\ No newline at end of file
diff --git a/third_party/rust/packed_simd/src/api/cast/v128.rs b/third_party/rust/packed_simd/src/api/cast/v128.rs
deleted file mode 100644
index ab47ddc006d6..000000000000
--- a/third_party/rust/packed_simd/src/api/cast/v128.rs
+++ /dev/null
@@ -1,79 +0,0 @@
-//! `FromCast` and `IntoCast` implementations for portable 128-bit wide vectors
-#[rustfmt::skip]
-
-use crate::*;
-
-impl_from_cast!(
-    i8x16[test_v128]: u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16, m32x16
-);
-impl_from_cast!(
-    u8x16[test_v128]: i8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16, m32x16
-);
-impl_from_cast_mask!(
-    m8x16[test_v128]: i8x16, u8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16, m32x16
-);
-
-impl_from_cast!(
-    i16x8[test_v128]: i8x8, u8x8, m8x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast!(
-    u16x8[test_v128]: i8x8, u8x8, m8x8, i16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast_mask!(
-    m16x8[test_v128]: i8x8, u8x8, m8x8, i16x8, u16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-
-impl_from_cast!(
-    i32x4[test_v128]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast!(
-    u32x4[test_v128]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast!(
-    f32x4[test_v128]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast_mask!(
-    m32x4[test_v128]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-
-impl_from_cast!(
-    i64x2[test_v128]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast!(
-    u64x2[test_v128]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast!(
-    f64x2[test_v128]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast_mask!(
-    m64x2[test_v128]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-
-impl_from_cast!(
-    isizex2[test_v128]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, usizex2, msizex2
-);
-impl_from_cast!(
-    usizex2[test_v128]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, msizex2
-);
-impl_from_cast_mask!(
-    msizex2[test_v128]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2
-);
-
-// FIXME[test_v128]: 64-bit single element vectors into_cast impls
-impl_from_cast!(i128x1[test_v128]: u128x1, m128x1);
-impl_from_cast!(u128x1[test_v128]: i128x1, m128x1);
-impl_from_cast!(m128x1[test_v128]: i128x1, u128x1);
diff --git a/third_party/rust/packed_simd/src/api/cast/v16.rs b/third_party/rust/packed_simd/src/api/cast/v16.rs
deleted file mode 100644
index cf974bb08e70..000000000000
--- a/third_party/rust/packed_simd/src/api/cast/v16.rs
+++ /dev/null
@@ -1,17 +0,0 @@
-//! `FromCast` and `IntoCast` implementations for portable 16-bit wide vectors
-#[rustfmt::skip]
-
-use crate::*;
-
-impl_from_cast!(
-    i8x2[test_v16]: u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast!(
-    u8x2[test_v16]: i8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast_mask!(
-    m8x2[test_v16]: i8x2, u8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
diff --git a/third_party/rust/packed_simd/src/api/cast/v256.rs b/third_party/rust/packed_simd/src/api/cast/v256.rs
deleted file mode 100644
index 9389dcb4c7f7..000000000000
--- a/third_party/rust/packed_simd/src/api/cast/v256.rs
+++ /dev/null
@@ -1,81 +0,0 @@
-//! `FromCast` and `IntoCast` implementations for portable 256-bit wide vectors
-#[rustfmt::skip]
-
-use crate::*;
-
-impl_from_cast!(i8x32[test_v256]: u8x32, m8x32, i16x32, u16x32, m16x32);
-impl_from_cast!(u8x32[test_v256]: i8x32, m8x32, i16x32, u16x32, m16x32);
-impl_from_cast_mask!(m8x32[test_v256]: i8x32, u8x32, i16x32, u16x32, m16x32);
-
-impl_from_cast!(
-    i16x16[test_v256]: i8x16, u8x16, m8x16, u16x16, m16x16,
-    i32x16, u32x16, f32x16, m32x16
-);
-impl_from_cast!(
-    u16x16[test_v256]: i8x16, u8x16, m8x16, i16x16, m16x16,
-    i32x16, u32x16, f32x16, m32x16
-);
-impl_from_cast_mask!(
-    m16x16[test_v256]: i8x16, u8x16, m8x16, i16x16, u16x16,
-    i32x16, u32x16, f32x16, m32x16
-);
-
-impl_from_cast!(
-    i32x8[test_v256]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast!(
-    u32x8[test_v256]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast!(
-    f32x8[test_v256]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast_mask!(
-    m32x8[test_v256]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-
-impl_from_cast!(
-    i64x4[test_v256]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast!(
-    u64x4[test_v256]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast!(
-    f64x4[test_v256]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast_mask!(
-    m64x4[test_v256]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-
-impl_from_cast!(
-    i128x2[test_v256]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast!(
-    u128x2[test_v256]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast_mask!(
-    m128x2[test_v256]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, m64x2, f64x2, i128x2, u128x2, isizex2, usizex2, msizex2
-);
-
-impl_from_cast!(
-    isizex4[test_v256]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, usizex4, msizex4
-);
-impl_from_cast!(
-    usizex4[test_v256]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, msizex4
-);
-impl_from_cast_mask!(
-    msizex4[test_v256]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4
-);
diff --git a/third_party/rust/packed_simd/src/api/cast/v32.rs b/third_party/rust/packed_simd/src/api/cast/v32.rs
deleted file mode 100644
index 2b254ba0cf12..000000000000
--- a/third_party/rust/packed_simd/src/api/cast/v32.rs
+++ /dev/null
@@ -1,30 +0,0 @@
-//! `FromCast` and `IntoCast` implementations for portable 32-bit wide vectors
-#[rustfmt::skip]
-
-use crate::*;
-
-impl_from_cast!(
-    i8x4[test_v32]: u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast!(
-    u8x4[test_v32]: i8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast_mask!(
-    m8x4[test_v32]: i8x4, u8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-
-impl_from_cast!(
-    i16x2[test_v32]: i8x2, u8x2, m8x2, u16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast!(
-    u16x2[test_v32]: i8x2, u8x2, m8x2, i16x2, m16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast_mask!(
-    m16x2[test_v32]: i8x2, u8x2, m8x2, i16x2, u16x2, i32x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
diff --git a/third_party/rust/packed_simd/src/api/cast/v512.rs b/third_party/rust/packed_simd/src/api/cast/v512.rs
deleted file mode 100644
index 5a10ab066677..000000000000
--- a/third_party/rust/packed_simd/src/api/cast/v512.rs
+++ /dev/null
@@ -1,68 +0,0 @@
-//! `FromCast` and `IntoCast` implementations for portable 512-bit wide vectors
-#[rustfmt::skip]
-
-use crate::*;
-
-impl_from_cast!(i8x64[test_v512]: u8x64, m8x64);
-impl_from_cast!(u8x64[test_v512]: i8x64, m8x64);
-impl_from_cast_mask!(m8x64[test_v512]: i8x64, u8x64);
-
-impl_from_cast!(i16x32[test_v512]: i8x32, u8x32, m8x32, u16x32, m16x32);
-impl_from_cast!(u16x32[test_v512]: i8x32, u8x32, m8x32, i16x32, m16x32);
-impl_from_cast_mask!(m16x32[test_v512]: i8x32, u8x32, m8x32, i16x32, u16x32);
-
-impl_from_cast!(
-    i32x16[test_v512]: i8x16, u8x16, m8x16, i16x16, u16x16, m16x16, u32x16, f32x16, m32x16
-);
-impl_from_cast!(
-    u32x16[test_v512]: i8x16, u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, f32x16, m32x16
-);
-impl_from_cast!(
-    f32x16[test_v512]: i8x16, u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, m32x16
-);
-impl_from_cast_mask!(
-    m32x16[test_v512]: i8x16, u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16
-);
-
-impl_from_cast!(
-    i64x8[test_v512]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast!(
-    u64x8[test_v512]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast!(
-    f64x8[test_v512]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast_mask!(
-    m64x8[test_v512]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, isizex8, usizex8, msizex8
-);
-
-impl_from_cast!(
-    i128x4[test_v512]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast!(
-    u128x4[test_v512]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast_mask!(
-    m128x4[test_v512]: i8x4, u8x4, m8x4, i16x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, m64x4, f64x4, i128x4, u128x4, isizex4, usizex4, msizex4
-);
-
-impl_from_cast!(
-    isizex8[test_v512]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, usizex8, msizex8
-);
-impl_from_cast!(
-    usizex8[test_v512]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, msizex8
-);
-impl_from_cast_mask!(
-    msizex8[test_v512]: i8x8, u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8
-);
diff --git a/third_party/rust/packed_simd/src/api/cast/v64.rs b/third_party/rust/packed_simd/src/api/cast/v64.rs
deleted file mode 100644
index 192a4638a362..000000000000
--- a/third_party/rust/packed_simd/src/api/cast/v64.rs
+++ /dev/null
@@ -1,47 +0,0 @@
-//! `FromCast` and `IntoCast` implementations for portable 64-bit wide vectors
-#[rustfmt::skip]
-
-use crate::*;
-
-impl_from_cast!(
-    i8x8[test_v64]: u8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast!(
-    u8x8[test_v64]: i8x8, m8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-impl_from_cast_mask!(
-    m8x8[test_v64]: i8x8, u8x8, i16x8, u16x8, m16x8, i32x8, u32x8, f32x8, m32x8,
-    i64x8, u64x8, f64x8, m64x8, isizex8, usizex8, msizex8
-);
-
-impl_from_cast!(
-    i16x4[test_v64]: i8x4, u8x4, m8x4, u16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast!(
-    u16x4[test_v64]: i8x4, u8x4, m8x4, i16x4, m16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-impl_from_cast_mask!(
-    m16x4[test_v64]: i8x4, u8x4, m8x4, i16x4, u16x4, i32x4, u32x4, f32x4, m32x4,
-    i64x4, u64x4, f64x4, m64x4, i128x4, u128x4, m128x4, isizex4, usizex4, msizex4
-);
-
-impl_from_cast!(
-    i32x2[test_v64]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, u32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast!(
-    u32x2[test_v64]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, f32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast!(
-    f32x2[test_v64]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, m32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
-impl_from_cast_mask!(
-    m32x2[test_v64]: i8x2, u8x2, m8x2, i16x2, u16x2, m16x2, i32x2, u32x2, f32x2,
-    i64x2, u64x2, f64x2, m64x2, i128x2, u128x2, m128x2, isizex2, usizex2, msizex2
-);
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v128.rs b/third_party/rust/packed_simd/src/api/into_bits/v128.rs
deleted file mode 100644
index e32cd7f9f099..000000000000
--- a/third_party/rust/packed_simd/src/api/into_bits/v128.rs
+++ /dev/null
@@ -1,28 +0,0 @@
-//! `FromBits` and `IntoBits` implementations for portable 128-bit wide vectors
-#[rustfmt::skip]
-
-#[allow(unused)]  // wasm_bindgen_test
-use crate::*;
-
-impl_from_bits!(i8x16[test_v128]: u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(u8x16[test_v128]: i8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(m8x16[test_v128]: m16x8, m32x4, m64x2, m128x1);
-
-impl_from_bits!(i16x8[test_v128]: i8x16, u8x16, m8x16, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(u16x8[test_v128]: i8x16, u8x16, m8x16, i16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(m16x8[test_v128]: m32x4, m64x2, m128x1);
-
-impl_from_bits!(i32x4[test_v128]: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, u32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(u32x4[test_v128]: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(f32x4[test_v128]: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(m32x4[test_v128]: m64x2, m128x1);
-
-impl_from_bits!(i64x2[test_v128]: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(u64x2[test_v128]: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, f64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(f64x2[test_v128]: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, u64x2, m64x2, i128x1, u128x1, m128x1);
-impl_from_bits!(m64x2[test_v128]: m128x1);
-
-impl_from_bits!(i128x1[test_v128]: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, u128x1, m128x1);
-impl_from_bits!(u128x1[test_v128]: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4, i64x2, u64x2, f64x2, m64x2, i128x1, m128x1);
-// note: m128x1 cannot be constructed from all the other masks bit patterns in here
-
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v256.rs b/third_party/rust/packed_simd/src/api/into_bits/v256.rs
deleted file mode 100644
index c4c373e0d0b8..000000000000
--- a/third_party/rust/packed_simd/src/api/into_bits/v256.rs
+++ /dev/null
@@ -1,27 +0,0 @@
-//! `FromBits` and `IntoBits` implementations for portable 256-bit wide vectors
-#[rustfmt::skip]
-
-#[allow(unused)]  // wasm_bindgen_test
-use crate::*;
-
-impl_from_bits!(i8x32[test_v256]: u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(u8x32[test_v256]: i8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(m8x32[test_v256]: m16x16, m32x8, m64x4, m128x2);
-
-impl_from_bits!(i16x16[test_v256]: i8x32, u8x32, m8x32, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(u16x16[test_v256]: i8x32, u8x32, m8x32, i16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(m16x16[test_v256]: m32x8, m64x4, m128x2);
-
-impl_from_bits!(i32x8[test_v256]: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16, u32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(u32x8[test_v256]: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(f32x8[test_v256]: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(m32x8[test_v256]: m64x4, m128x2);
-
-impl_from_bits!(i64x4[test_v256]: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(u64x4[test_v256]: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, f64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(f64x4[test_v256]: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, u64x4, m64x4, i128x2, u128x2, m128x2);
-impl_from_bits!(m64x4[test_v256]: m128x2);
-
-impl_from_bits!(i128x2[test_v256]: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, u128x2, m128x2);
-impl_from_bits!(u128x2[test_v256]: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16, i32x8, u32x8, f32x8, m32x8, i64x4, u64x4, f64x4, m64x4, i128x2, m128x2);
-// note: m128x2 cannot be constructed from all the other masks bit patterns in here
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v512.rs b/third_party/rust/packed_simd/src/api/into_bits/v512.rs
deleted file mode 100644
index 4a771962c348..000000000000
--- a/third_party/rust/packed_simd/src/api/into_bits/v512.rs
+++ /dev/null
@@ -1,27 +0,0 @@
-//! `FromBits` and `IntoBits` implementations for portable 512-bit wide vectors
-#[rustfmt::skip]
-
-#[allow(unused)]  // wasm_bindgen_test
-use crate::*;
-
-impl_from_bits!(i8x64[test_v512]: u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(u8x64[test_v512]: i8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(m8x64[test_v512]: m16x32, m32x16, m64x8, m128x4);
-
-impl_from_bits!(i16x32[test_v512]: i8x64, u8x64, m8x64, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(u16x32[test_v512]: i8x64, u8x64, m8x64, i16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(m16x32[test_v512]: m32x16, m64x8, m128x4);
-
-impl_from_bits!(i32x16[test_v512]: i8x64, u8x64, m8x64, i16x32, u16x32, m16x32, u32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(u32x16[test_v512]: i8x64, u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(f32x16[test_v512]: i8x64, u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(m32x16[test_v512]: m64x8, m128x4);
-
-impl_from_bits!(i64x8[test_v512]: i8x64, u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, u64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(u64x8[test_v512]: i8x64, u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, f64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(f64x8[test_v512]: i8x64, u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, u64x8, m64x8, i128x4, u128x4, m128x4);
-impl_from_bits!(m64x8[test_v512]: m128x4);
-
-impl_from_bits!(i128x4[test_v512]: i8x64, u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, u128x4, m128x4);
-impl_from_bits!(u128x4[test_v512]: i8x64, u8x64, m8x64, i16x32, u16x32, m16x32, i32x16, u32x16, f32x16, m32x16, i64x8, u64x8, f64x8, m64x8, i128x4, m128x4);
-// note: m128x4 cannot be constructed from all the other masks bit patterns in here
diff --git a/third_party/rust/packed_simd/src/testing/macros.rs b/third_party/rust/packed_simd/src/testing/macros.rs
deleted file mode 100644
index 6008634c76ce..000000000000
--- a/third_party/rust/packed_simd/src/testing/macros.rs
+++ /dev/null
@@ -1,44 +0,0 @@
-//! Testing macros
-
-macro_rules! test_if {
-    ($cfg_tt:tt: $it:item) => {
-        #[cfg(any(
-                            // Test everything if:
-                            //
-                            // * tests are enabled,
-                            // * no features about exclusively testing
-                            //   specific vector classes are enabled
-                            all(test, not(any(
-                                test_v16,
-                                test_v32,
-                                test_v64,
-                                test_v128,
-                                test_v256,
-                                test_v512,
-                                test_none,  // disables all tests
-                            ))),
-                            // Test if:
-                            //
-                            // * tests are enabled
-                            // * a particular cfg token tree returns true
-                            all(test, $cfg_tt),
-                        ))]
-        $it
-    };
-}
-
-#[cfg(test)]
-#[allow(unused)]
-macro_rules! ref_ {
-    ($anything:tt) => {
-        &$anything
-    };
-}
-
-#[cfg(test)]
-#[allow(unused)]
-macro_rules! ref_mut_ {
-    ($anything:tt) => {
-        &mut $anything
-    };
-}
diff --git a/third_party/rust/packed_simd/.appveyor.yml b/third_party/rust/packed_simd_2/.appveyor.yml
similarity index 100%
rename from third_party/rust/packed_simd/.appveyor.yml
rename to third_party/rust/packed_simd_2/.appveyor.yml
diff --git a/third_party/rust/packed_simd/.cargo-checksum.json b/third_party/rust/packed_simd_2/.cargo-checksum.json
similarity index 66%
rename from third_party/rust/packed_simd/.cargo-checksum.json
rename to third_party/rust/packed_simd_2/.cargo-checksum.json
index 51a1cee537e3..3090b655a160 100644
--- a/third_party/rust/packed_simd/.cargo-checksum.json
+++ b/third_party/rust/packed_simd_2/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{".appveyor.yml":"f1ed01850e0d725f9498f52a1a63ddf40702ad6e0bf5b2d7c4c04d76e96794a3",".travis.yml":"d56de6531d3c4880e3aada85ac8e6d7388e5d781871e181cb8ade2a746d5d5f5","Cargo.toml":"b6f063e65c1f8d71c51204444d4e93cd514cb310dedfd1e85b731c1acc63ab4a","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"6485b8ed310d3f0340bf1ad1f47645069ce4069dcc6bb46c7d5c6faf41de1fdb","README.md":"49d01e49a33393af64fa6c813b6a724f68a4d1abfbedcb96413651ed105aa820","bors.toml":"dee881dc69b9b7834e4eba5d95c3ed5a416d4628815a167d6a22d4cb4fb064b8","build.rs":"9d7f69238f5dfefa3c49744159c2f484feb4c32c9aefe79696ebe97a89b2957f","ci/all.sh":"2ae6b2445b4db83833e40b37efd0016c6b9879ee988b9b3ef94db5439a3e1606","ci/android-install-ndk.sh":"0f1746108cc30bf9b9ba45bcde7b19fc1a8bdf5b0258035b4eb8dc69b75efac4","ci/android-install-sdk.sh":"3490432022c5c8f5a115c084f7a9aca1626f96c0c87ffb62019228c4346b47e4","ci/android-sysimage.sh":"ebf4e5daa1f0fe1b2092b79f0f3f161c4c4275cb744e52352c4d81ab451e4c5a","ci/benchmark.sh":"b61d19ef6b90deba8fb79dee74c8b062d94844676293da346da87bb78a9a49a4","ci/deploy_and_run_on_ios_simulator.rs":"ec8ecf82d92072676aa47f0d1a3d021b60a7ae3531153ef12d2ff4541fc294dc","ci/docker/aarch64-linux-android/Dockerfile":"ace2e7d33c87bc0f6d3962a4a3408c04557646f7f51ab99cfbf574906796b016","ci/docker/aarch64-unknown-linux-gnu/Dockerfile":"da88c0d50f16dc08448c7fdf1fa5ed2cbe576acf9e7dd85b5b818621b2a8c702","ci/docker/arm-linux-androideabi/Dockerfile":"370e55d3330a413a3ccf677b3afb3e0ef9018a5fab263faa97ae8ac017fc2286","ci/docker/arm-unknown-linux-gnueabi/Dockerfile":"bb5f8ae890707c128652290ffc544447643bf12037ddd73c6ad6989f848cb380","ci/docker/arm-unknown-linux-gnueabihf/Dockerfile":"1afaefcbc05b740859acd4e067bc92439be6bcbe8f2e9678474fb434bcd398d9","ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile":"8282ea707a94109beed47a57574755e2d58401735904a03f85fb64c578c53b4f","ci/docker/i586-unknown-linux-gnu/Dockerfile":"49792922269f371bd29da4727e9085101b27be67a6b97755d0196c63317f7abb","ci/docker/i686-unknown-linux-gnu/Dockerfile":"49792922269f371bd29da4727e9085101b27be67a6b97755d0196c63317f7abb","ci/docker/mips-unknown-linux-gnu/Dockerfile":"b2ebc25797612c4f8395fe9d407725156044955bfbcf442036b7f55b43a5f9da","ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile":"b0c1692ac65bc56dd30494b1993d8e929c48cc9c4b92029b7c7592af6d4f9220","ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile":"4e9249c179300138141d0b2b7401b11897f64aed69f541f078c1db4594df2827","ci/docker/mipsel-unknown-linux-musl/Dockerfile":"3164c52b0dcbb01afa78292b15b5c43503ccf0491cf6eb801ec2bf22ae274e52","ci/docker/powerpc-unknown-linux-gnu/Dockerfile":"786f799d0b56eb54d7b6c4b00e1aed4ce81776e14e44767e083c89d014b72004","ci/docker/powerpc64-unknown-linux-gnu/Dockerfile":"e8bc363837cd9c2d8b22402acb8c1c329efc11ba5d12170603d2fe2eae9da059","ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile":"47998d45b781d797b9e6085ebe898d90de0c952b54537a8db4e8d7503eb032d9","ci/docker/s390x-unknown-linux-gnu/Dockerfile":"93fb44df3d7fd31ead158570667c97b5076a05c3d968af4a84bc13819a8f2db8","ci/docker/sparc64-unknown-linux-gnu/Dockerfile":"da1c39a3ff1fe22e41395fa7c8934e90b4c1788e551b9aec6e38bfd94effc437","ci/docker/thumbv7neon-linux-androideabi/Dockerfile":"c2decd5591bd7a09378901bef629cd944acf052eb55e4f35b79eb9cb4d62246a","ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile":"51955a8bf3c4d440f47382af6f5426ebff94ab01a04da36175babda9a057740f","ci/docker/wasm32-unknown-unknown/Dockerfile":"3e5f294bc1e004aa599086c2af49d6f3e7459fa250f5fbdd60cf67d53db78758","ci/docker/x86_64-linux-android/Dockerfile":"685040273cf350d5509e580ac451555efa19790c8723ca2af066adadc6880ad2","ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile":"44b6203d9290bfdc53d81219f0937e1110847a23dd982ec8c4de388354f01536","ci/docker/x86_64-unknown-linux-gnu/Dockerfile":"7f4e3ca5fa288ea70edb4d1f75309708cd30b192e2e4444e61c4d5b3b58f89cf","ci/dox.sh":"434e9611c52e389312d2b03564adf09429f10cc76fe66a8644adb104903b87b7","ci/linux-s390x.sh":"d6b732d7795b4ba131326aff893bca6228a7d2eb0e9402f135705413dbbe0dce","ci/linux-sparc64.sh":"c92966838b1ab7ad3b7a344833ee726aba6b647cf5952e56f0ad1ba420b13325","ci/lld-shim.rs":"3d7f71ec23a49e2b67f694a0168786f9a954dda15f5a138815d966643fd3fcc3","ci/max_line_width.sh":"0a1518bba4c9ecaa55694cb2e9930d0e19c265baabf73143f17f9cf285aaa5bb","ci/run-docker.sh":"92e036390ad9b0d16f109579df1b5ced2e72e9afea40c7d011400ebd3a2a90de","ci/run.sh":"41dd6a60efaaeae9661a01370cce98b631f78392859a0cf68c946c0a16edf5f7","ci/run_examples.sh":"d1a23c6c35374a0678ba5114b9b8fefd8be0a79e774872a8bf0898d1baca18d0","ci/runtest-android.rs":"145a8e9799a5223975061fe7e586ade5669ee4877a7d7a4cf6b4ab48e8e36c7c","ci/setup_benchmarks.sh":"fae3960023f6f3d1388cd2ad22fdbab4b075f1f29dd4292d7994a20783beb6cf","ci/test-runner-linux":"c8aa6025cff5306f4f31d0c61dc5f9d4dd5a1d189ab613ef8d4c367c694d9ccd","contributing.md":"2cc8c9c560ae17867e69b06d09b758dbf7bc39eb774ada50a743724b10acc0a2","perf-guide/.gitignore":"fe82c7da551079d832cf74200b0b359b4df9828cb4a0416fa7384f07a2ae6a13","perf-guide/book.toml":"115a98284126c6b180178b44713314cc494f08a71662ee2ce15cf67f17a51064","perf-guide/src/SUMMARY.md":"3e03bffc991fdc2050f3d51842d72d9d21ea6abab56a3baf3b2d5973a78b89e1","perf-guide/src/ascii.css":"29afb08833b2fe2250f0412e1fa1161a2432a0820a14953c87124407417c741a","perf-guide/src/bound_checks.md":"5e4991ff58a183ef0cd9fdc1feb4cd12d083b44bdf87393bbb0927808ef3ce7d","perf-guide/src/float-math/approx.md":"8c09032fa2d795a0c5db1775826c850d28eb2627846d0965c60ee72de63735ad","perf-guide/src/float-math/fma.md":"311076ba4b741d604a82e74b83a8d7e8c318fcbd7f64c4392d1cf5af95c60243","perf-guide/src/float-math/fp.md":"04153e775ab6e4f0d7837bcc515230d327b04edfa34c84ce9c9e10ebaeef2be8","perf-guide/src/float-math/svml.md":"0798873b8eedaeda5fed62dc91645b57c20775a02d3cd74d8bd06958f1516506","perf-guide/src/introduction.md":"9f5a19e9e6751f25d2daad39891a0cc600974527ec4c8305843f9618910671bd","perf-guide/src/prof/linux.md":"447731eb5de7d69166728fdbc5ecb0c0c9db678ea493b45a592d67dd002184c0","perf-guide/src/prof/mca.md":"f56d54f3d20e7aa4d32052186e8237b03d65971eb5d112802b442570ff11d344","perf-guide/src/prof/profiling.md":"8a650c0fd6ede0964789bb6577557eeef1d8226a896788602ce61528e260e43c","perf-guide/src/target-feature/attribute.md":"615f88dca0a707b6c416fa605435dd6e1fb5361cc639429cbf68cd87624bd78b","perf-guide/src/target-feature/features.md":"17077760ff24c006b606dd21889c53d87228f4311f3ba3a574f9afdeacd86165","perf-guide/src/target-feature/inlining.md":"7ed1d7068d8173a00d84c16cfe5871cd68b9f04f8d0cca2d01ebc84957ebf2f6","perf-guide/src/target-feature/practice.md":"c4b371842e0086df178488fec97f20def8f0c62ee588bcd25fd948b9b1fa227e","perf-guide/src/target-feature/runtime.md":"835425f5ee597fb3e51d36e725a81ebee29f4561231d19563cd4da81dbb1cfcb","perf-guide/src/target-feature/rustflags.md":"ab49712e9293a65d74d540ba4784fcb57ff1119ec05a575d895c071f1a620f64","perf-guide/src/vert-hor-ops.md":"c6211c0ee91e60552ec592d89d9d957eedc21dee3cbd89e1ad6765ea06a27471","rustfmt.toml":"de6101d0670bad65fb3b337d56957d2a024e017e5ab146ec784d77312daaf8ff","src/api.rs":"f6e92f056565e6fd93f98829a408aee9e790251e0cbd8a8bc30c8662b4d6fabb","src/api/bit_manip.rs":"c47a4d0f7451f7e35d07715e4f39a472e07457fd456fdb726864a4f6887252a3","src/api/bitmask.rs":"6d2beefd62ee5d9c8eb060bee6abc641616bf828c99f82abf97b21bf004e894b","src/api/cast.rs":"03b94a3d316ac7b7be7068810044911e965e889a0ace7bae762749ca74a92747","src/api/cast/macros.rs":"b0a14d0c83ad2ebb7a275180f6d9e3f2bc312ba57a7d3d6c39fad4e0f20f9408","src/api/cast/v128.rs":"2107ea6a426a0fe37a0aa6a03a579ff0bdeb5a1599ea76e2d81734a82f41276d","src/api/cast/v16.rs":"d785cf93b8e61200c9ae1c32b9f5e9d9518e87c261c56bcaf92f2e47b0009eb4","src/api/cast/v256.rs":"b81fcfd367a5de532d922dedf18579e53666facef7957c0e1bc827825e500ae6","src/api/cast/v32.rs":"2aac9ec0a67a97328ba908b13a1ff98da3dcd7781910d592d31f9207cbd9a7d2","src/api/cast/v512.rs":"33b33de818f8d4eccc982bc2f3951a8b3d03e9762ec02789b3df82e3f5ed3fc3","src/api/cast/v64.rs":"ec878917d52a8c952633251b3a938a2cbe0a63fee6d12c15840d9f1343d1f394","src/api/cmp.rs":"357c3a2a09c6d4611c32dd7fa95be2fae933d513e229026ec9b44451a77b884e","src/api/cmp/eq.rs":"60f70f355bae4cb5b17db53204cacc3890f70670611c17df638d4c04f7cc8075","src/api/cmp/ord.rs":"589f7234761c294fa5df8f525bc4acd5a47cdb602207d524a0d4e19804cd9695","src/api/cmp/partial_eq.rs":"3ed23d2a930b0f9750c3a5309da766b03dc4f9c4d375b42ad3c50fe732693d15","src/api/cmp/partial_ord.rs":"e16b11805c94048acd058c93994b5bc74bb187f8d7e3b86a87df60e1601467f9","src/api/cmp/vertical.rs":"de3d62f38eba817299aa16f1e1939954c9a447e316509397465c2830852ba053","src/api/default.rs":"67bf21c134127d12a7028c8b88a57f0ceee8ccbd74976da8ca74eb9f16a174d5","src/api/fmt.rs":"67fb804bb86b6cd77cf8cd492b5733ce437071b66fe3297278b8a6552c325dda","src/api/fmt/binary.rs":"35cb5c266197d6224d598fb3d286e5fe48ef0c01ed356c2ff6fe9ba946f96a92","src/api/fmt/debug.rs":"aa18eea443bf353fea3db8b1a025132bbcaf91e747ecfa43b8d9fce9af395a0c","src/api/fmt/lower_hex.rs":"69d5be366631af309f214e8031c8c20267fcc27a695eac6f45c6bc1df72a67e6","src/api/fmt/octal.rs":"9eb11ba3d990213f3c7f1ec25edba7ce997cb1320e16d308c83498ba6b9bfbd9","src/api/fmt/upper_hex.rs":"a4637d085b7bb20e759ce58e08435b510a563ba3dd468af2b03560fdc5511562","src/api/from.rs":"2e599d8329cb05eaf06224cc441355c4b7b51254fc19256619333be8c149d444","src/api/from/from_array.rs":"dd3fc64fb17d6184bb60343f8da26a05edf0e5f3c14caf55d49fa15e21d948dc","src/api/from/from_vector.rs":"9764371aa9e6005aace74dea14f59e5611a095b7cf42707940924749282c52f0","src/api/hash.rs":"5076ece87969592c876486f5b1ea8affbeaec379d1a14a30859e0aa5592019de","src/api/into_bits.rs":"82297f0697d67b5a015e904e7e6e7b2a7066ba825bc54b94b4ff3e22d7a1eefb","src/api/into_bits/arch_specific.rs":"4acab22af90112072a2608fafc66fccf18cbf2e641b72af28404d30833cfe5c6","src/api/into_bits/macros.rs":"d762406de25aedff88d460dec7a80dc8e825a2a419d53218ce007efa6a1d3e04","src/api/into_bits/v128.rs":"3c502b9ce85bfcc727d6f053d49030b0ba9f46bd8e9fa5aa109382a2033f9f87","src/api/into_bits/v16.rs":"f4f4f61ba88aa51b158ec56ca3dce234349aea0daf2b3029a14ab5125d1e41e5","src/api/into_bits/v256.rs":"c24c3676707a0feb868dabe00766d74deab176794f905f79056337198c7cf790","src/api/into_bits/v32.rs":"905ba683d342fa32f4202b80bb46530807bd0a5b588f6c2e8c9f475223c47775","src/api/into_bits/v512.rs":"7cd89005215a9326eed8a742125dcbf981cba1aca72a313478eabf3df71b1160","src/api/into_bits/v64.rs":"d6238022ccff7b92e55b3f6017fc269acb6f36330a6d7e8fb389853a0f1b6478","src/api/math.rs":"8b2a2fc651917a850539f993aa0b9e5bf4da67b11685285b8de8cdca311719ec","src/api/math/float.rs":"61d2794d68262a1090ae473bd30793b5f65cf732f32a6694a3af2ce5d9225616","src/api/math/float/abs.rs":"5b6b2701e2e11135b7ce58a05052ea8120e10e4702c95d046b9d21b827b26bf8","src/api/math/float/consts.rs":"78acba000d3fa527111300b6327c1932de9c4c1e02d4174e1a5615c01463d38c","src/api/math/float/cos.rs":"4c2dd7173728ef189314f1576c9486e03be21b7da98843b2f9011282a7979e31","src/api/math/float/exp.rs":"7c6d5f1e304f498a01cfa23b92380c815d7da0ad94eae3483783bc377d287eef","src/api/math/float/ln.rs":"54c7583f3df793b39ff57534fade27b41bb992439e5dc178252f5ca3190a3e54","src/api/math/float/mul_add.rs":"62cac77660d20159276d4c9ef066eb90c81cbddb808e8e157182c607625ad2eb","src/api/math/float/mul_adde.rs":"bae056ee9f3a70df39ec3c3b2f6437c65303888a7b843ef1a5bcf1f5aca0e602","src/api/math/float/powf.rs":"9ddb938984b36d39d82a82f862f80df8f7fb013f1d222d45698d41d88472f568","src/api/math/float/recpre.rs":"589225794ff1dbf31158dff660e6d4509ecc8befbb57c633900dea5ac0b840d6","src/api/math/float/rsqrte.rs":"a32abdcc318d7ccc8448231f54d75b884b7cbeb03a7d595713ab6243036f4dbf","src/api/math/float/sin.rs":"cbd3622b7df74f19691743001c8cf747a201f8977ad90542fee915f37dcd1e49","src/api/math/float/sqrt.rs":"0c66d5d63fb08e4d99c6b82a8828e41173aff1ac9fa1a2764a11fac217ccf2ac","src/api/math/float/sqrte.rs":"731e1c9f321b662accdd27dacb3aac2e8043b7aecb2f2161dde733bd9f025362","src/api/minimal.rs":"1f22bcc528555444e76de569ec0ae2029b9ae9d04805efeafa93369c8098036b","src/api/minimal/iuf.rs":"819cff26d3e196f807645bcc1d79eb27d9f175edb89910f2274d52a1e913cd11","src/api/minimal/mask.rs":"0cae10ae1fc65f5070e686c0c79bfba27b86b33d6c399367bd4848fb367dcec4","src/api/minimal/ptr.rs":"f65ebf21866a863485344432d9a7a9b7418f7fad5fdf841a4e2fa56ec0766ad0","src/api/ops.rs":"3e273b277a0f3019d42c3c59ca94a5afd4885d5ae6d2182e5089bbeec9de42ee","src/api/ops/scalar_arithmetic.rs":"d2d5ad897a59dd0787544f927e0e7ca4072c3e58b0f4a2324083312b0d5a21d7","src/api/ops/scalar_bitwise.rs":"482204e459ca6be79568e1c9f70adbe2d2151412ddf122fb2161be8ebb51c40c","src/api/ops/scalar_mask_bitwise.rs":"c250f52042e37b22d57256c80d4604104cfd2fbe2a2e127c676267270ca5d350","src/api/ops/scalar_shifts.rs":"987f8fdebeedc16e3d77c1b732e7826ef70633c541d16dfa290845d5c6289150","src/api/ops/vector_arithmetic.rs":"ddca15d09ddeef502c2ed66117a62300ca65d87e959e8b622d767bdf1c307910","src/api/ops/vector_bitwise.rs":"b3968f7005b649edcc22a54e2379b14d5ee19045f2e784029805781ae043b5ee","src/api/ops/vector_float_min_max.rs":"76bf8cb607e2c442923c1da1061a6b80d742d607408033c2a3761161114cf2a0","src/api/ops/vector_int_min_max.rs":"a378789c6ff9b32a51fbd0a97ffd36ed102cd1fe6a067d2b02017c1df342def6","src/api/ops/vector_mask_bitwise.rs":"5052d18517d765415d40327e6e8e55a312daaca0a5e2aec959bfa54b1675f9c8","src/api/ops/vector_neg.rs":"5c62f6b0221983cdbd23cd0a3af3672e6ba1255f0dfe8b19aae6fbd6503e231b","src/api/ops/vector_rotates.rs":"03cbe8a400fd7c688e4ee771a990a6754f2031b1a59b19ae81158b21471167e5","src/api/ops/vector_shifts.rs":"9bf69d0087268f61009e39aea52e03a90f378910206b6a28e8393178b6a5d0e0","src/api/ptr.rs":"8a793251bed6130dcfb2f1519ceaa18b751bbb15875928d0fb6deb5a5e07523a","src/api/ptr/gather_scatter.rs":"138b02b0fa1fdd785b95fc7048488be7e3ef277e0bc6ac5affb26af6a11d41a6","src/api/reductions.rs":"ae5baca81352ecd44526d6c30c0a1feeda475ec73ddd3c3ec6b14e944e5448ee","src/api/reductions/bitwise.rs":"8bf910ae226188bd15fc7e125f058cd2566b6186fcd0cd8fd020f352c39ce139","src/api/reductions/float_arithmetic.rs":"3997125f87c7bac07fffda3a1d814e0e6c77ca83099546a9e2fb8dc92231129f","src/api/reductions/integer_arithmetic.rs":"47471da1c5f859489680bb5d34ced3d3aa20081c16053a3af121a4496fcb57bf","src/api/reductions/mask.rs":"db83327a950e33a317f37fd33ca4e20c347fb415975ec024f3e23da8509425af","src/api/reductions/min_max.rs":"d40ccad10220ae5982785015bef92e4b0749583c2b060cad0aa4f92d99491c3b","src/api/select.rs":"a98e2ccf9fc6bdeed32d337c8675bc96c2fbe2cc34fbf149ad6047fb8e749774","src/api/shuffle.rs":"6d1e5970b9fc8555a667c2924151070dd21584e81da8a9668d6bfe16f4a0db82","src/api/shuffle1_dyn.rs":"bfea5a91905b31444e9ef7ca6eddb7a9606b7e22d3f71bb842eb2795a0346620","src/api/slice.rs":"ee87484e8af329547b9a5d4f2a69e8bed6ea10bbd96270d706083843d4eea2ac","src/api/slice/from_slice.rs":"53691dc9958dec4180004a42d140552b405e8cd875caa282e89af378dd63c8bc","src/api/slice/write_to_slice.rs":"3dd2e511af43dc6fa911dd0b12f6f00323e0acd1202a01365db400557d52a89b","src/api/swap_bytes.rs":"4a6792a2e49a77475e1b237592b4b2804dbddb79c474331acd0dd71b36934259","src/codegen.rs":"a29d38fa0a85eaf787fb49989e625bf64effd5f39c126fbb2a24be206d2a3917","src/codegen/bit_manip.rs":"17ecebcff1f080e712fea5eb51602a73f4201ed56a198220342c8eb55bb92692","src/codegen/llvm.rs":"5bc6751293f9f184cf23d5df448c7d58b58b799e41c7a91f8ca41a5ba56e64ec","src/codegen/math.rs":"35f96e37a78fcf0cdb02146b7f27a45108fe06a37fc2a54d8851ce131a326178","src/codegen/math/float.rs":"dd86c0449e576c83b719700962ac017c332987fac08d91f2b7a2b1b883598170","src/codegen/math/float/abs.rs":"f56e2b4b8055ea861c1f5cbc6b6e1d8e7e5af163b62c13574ddee4e09513bfbc","src/codegen/math/float/cos.rs":"ef3b511a24d23045b310315e80348a9b7fedb576fc2de52d74290616a0abeb2a","src/codegen/math/float/cos_pi.rs":"4e7631a5d73dac21531e09ef1802d1180f8997509c2c8fa9f67f322194263a97","src/codegen/math/float/exp.rs":"61b691598c41b5622f24e4320c1bdd08701e612a516438bdddcc728fc3405c8c","src/codegen/math/float/ln.rs":"46b718b1ba8c9d99e1ad40f53d20dfde08a3063ca7bd2a9fdd6698e060da687e","src/codegen/math/float/macros.rs":"dd42135fff13f9aca4fd3a1a4e14c7e6c31aadc6d817d63b0d2fb9e62e062744","src/codegen/math/float/mul_add.rs":"a37bf764345d4b1714f97e83897b7cf0855fc2811704bcbc0012db91825339e1","src/codegen/math/float/mul_adde.rs":"c75702bfcb361de45964a93caf959a695ef2376bd069227600b8c6872665c755","src/codegen/math/float/powf.rs":"642346e982bc4c39203de0864d2149c4179cd7b21cf67a2951687932b4675872","src/codegen/math/float/sin.rs":"9d68164c90cdca6a85155040cdac42e27342ebe0b925273ef1593df721af4258","src/codegen/math/float/sin_cos_pi.rs":"9be02ad48585a1e8d99129382fbffbaed47852f15459256a708850b6b7a75405","src/codegen/math/float/sin_pi.rs":"9890347905b4d4a3c7341c3eb06406e46e60582bcf6960688bd727e5dadc6c57","src/codegen/math/float/sqrt.rs":"e3c60dcfb0c6d2fc62adabcc931b2d4040b83cab294dea36443fb4b89eb79e34","src/codegen/math/float/sqrte.rs":"f0f4ef9eb475ae41bcc7ec6a95ad744ba6b36925faa8b2c2814004396d196b63","src/codegen/pointer_sized_int.rs":"a70697169c28218b56fd2e8d5353f2e00671d1150d0c8cef77d613bdfacd84cb","src/codegen/reductions.rs":"645e2514746d01387ddd07f0aa4ffd8430cc9ab428d4fb13773ea319fa25dd95","src/codegen/reductions/mask.rs":"8f1afe6aabf096a3278e1fc3a30f736e04aa8b9ce96373cee22162d18cfe2702","src/codegen/reductions/mask/aarch64.rs":"cba6e17603d39795dcfe8339b6b7d8714c3e162a1f0a635979f037aa24fe4206","src/codegen/reductions/mask/arm.rs":"9447904818aa2c7c25d0963eead452a639a11ca7dbd6d21eedbfcaade07a0f33","src/codegen/reductions/mask/fallback.rs":"7a0ef9f7fd03ae318b495b95e121350cd61caffc5cc6ee17fabf130d5d933453","src/codegen/reductions/mask/fallback_impl.rs":"76547f396e55ef403327c77c314cf8db8c7a5c9b9819bfb925abeacf130249e5","src/codegen/reductions/mask/x86.rs":"4c0457b6276f9809223590092a4c77e73812330326cdabd28df06820de10a310","src/codegen/reductions/mask/x86/avx.rs":"b4913d87844c522903641cbbf10db4551addb1ce5e9e78278e21612fa65c733b","src/codegen/reductions/mask/x86/avx2.rs":"677aed3f056285285daa3adff8bc65e739630b4424defa6d9665e160f027507e","src/codegen/reductions/mask/x86/sse.rs":"5a827c6f8e1074e324f6e4c778942badb6c09d747a7142de01cadec1240b3428","src/codegen/reductions/mask/x86/sse2.rs":"bc38e6c31cb4b3d62147eba6cac264e519e2a48e0f7ce9010cfa9ef0cf0ec9fd","src/codegen/shuffle.rs":"99a0b52c2470097b028af134221099baba383446a01c7dc3ae560209880bcdb7","src/codegen/shuffle1_dyn.rs":"abbc95305dad815ab2ded3e8357791bcff080414668b55a4d397558a1d202d01","src/codegen/swap_bytes.rs":"1d6cdc716eadddc92b4fd506b2445a821caa8dc00860447de09d7ebd69c2087f","src/codegen/v128.rs":"94226b31ec403d18d9d2fe06713f147c9c79e9b5f9105089088266313f843185","src/codegen/v16.rs":"ddec4ffb66b6f7aaffb9a1780c5ddba82557abd74f45073d335047e04cf74924","src/codegen/v256.rs":"6b63917f0444118d6b1595bff2045e59b97c4d24012bd575f69f1f0efc5a0241","src/codegen/v32.rs":"3477b3c5540aed86e61e2f5807dd31db947413cec9181c587d93ed6ec74f0eba","src/codegen/v512.rs":"5854f99d3aabc4cd42b28a20d9ce447756dc2ba024a409a69b6a8ae1f1842fc5","src/codegen/v64.rs":"e9e89caebfe63d10c0cbca61e4dfdba3b7e02ee0989170f80beed23237ddd950","src/codegen/vPtr.rs":"711c753a08d53a2879c4fb87a0762c46ce4e34c22f0ca88d2e4c557a0f679969","src/codegen/vSize.rs":"eeee9858749aa82142b27bc120d1989bb74a6b82e1e4efbbeaccc9634dc9acfc","src/lib.rs":"41c2a5c5fb42225ce9c6a267653870fdb8af30f933b3b8534d57a15fb96ebb39","src/masks.rs":"be05e923ac58fe6eb61311561b5583cd306574f206dc09fe8e3c7de3dd0c1433","src/sealed.rs":"ae7fdeaf5d84cd7710ed730ca72ca7eaba93df6cb0acb183e5c0a7327acf197f","src/testing.rs":"1d3a7862ef625e235a5734ad7204e68d350f902c0695182b1f08a0552432416e","src/testing/macros.rs":"6378856d7a40ba5ec5c7c0dad6327d79f0c77266921c24296d10aed6c68e9b98","src/testing/utils.rs":"5ec6a47b836f364ec6dede19750a19eaac704162327d03041eb0f007d5f8d75c","src/v128.rs":"16cf9a8e7156b899ee9b9cd3f2dba9d13ec63289bea8c3ee9ae2e43ad9510288","src/v16.rs":"cb6465cf1e00bf530183af1819b9fe3d7eec978f8765d5e85d9b58a39a4b4045","src/v256.rs":"fe235017da18c7f3c361831c60e3173ad304d8ea1e95d64ebebc79da2d708511","src/v32.rs":"145d347855bac59b2de6508f9e594654e6c330423af9edc0e2ac8f4d1abdf45e","src/v512.rs":"f372f277f3e62eb5c945bb1c460333fdb17b6974fcc876633788ff53bded9599","src/v64.rs":"0b8079881b71575e3414be0b7f8f7eaba65281ba6732f2b2f61f73e95b6f48f7","src/vPtr.rs":"8b3e433d487180bb4304ff71245ecad90f0010f43e139a72027b672abe58facc","src/vSize.rs":"eda5aa020706cbf94d15bada41a0c2a35fc8f3f37cb7c2cd6f34d201399a495e","tests/endianness.rs":"7db22078f31fe1421fc2d21f2e6b9df5eb0bdc99c10f6985d3a74c0df8f205dc"},"package":null}
\ No newline at end of file
+{"files":{".appveyor.yml":"f1ed01850e0d725f9498f52a1a63ddf40702ad6e0bf5b2d7c4c04d76e96794a3",".travis.yml":"30a61a5ec53355fc1f3585e1690280308c2b7961701abc11e8389b235b647178","Cargo.toml":"f85e54e13a05f6e4f27c230ab81430af27b6ff80a1c036bd70c42ea115f89487","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"6485b8ed310d3f0340bf1ad1f47645069ce4069dcc6bb46c7d5c6faf41de1fdb","README.md":"882f8894b333becf490d23c9024a86fd1327c8edea33aa8dbb98dc2f2ddb3956","bors.toml":"dee881dc69b9b7834e4eba5d95c3ed5a416d4628815a167d6a22d4cb4fb064b8","build.rs":"019ed29c43989782d8eec3a961654cfc172d7a7898da4eca8f654700af7e1988","ci/all.sh":"2ae6b2445b4db83833e40b37efd0016c6b9879ee988b9b3ef94db5439a3e1606","ci/android-install-ndk.sh":"0f1746108cc30bf9b9ba45bcde7b19fc1a8bdf5b0258035b4eb8dc69b75efac4","ci/android-install-sdk.sh":"3490432022c5c8f5a115c084f7a9aca1626f96c0c87ffb62019228c4346b47e4","ci/android-sysimage.sh":"ebf4e5daa1f0fe1b2092b79f0f3f161c4c4275cb744e52352c4d81ab451e4c5a","ci/benchmark.sh":"b61d19ef6b90deba8fb79dee74c8b062d94844676293da346da87bb78a9a49a4","ci/deploy_and_run_on_ios_simulator.rs":"ec8ecf82d92072676aa47f0d1a3d021b60a7ae3531153ef12d2ff4541fc294dc","ci/docker/aarch64-linux-android/Dockerfile":"ace2e7d33c87bc0f6d3962a4a3408c04557646f7f51ab99cfbf574906796b016","ci/docker/aarch64-unknown-linux-gnu/Dockerfile":"da88c0d50f16dc08448c7fdf1fa5ed2cbe576acf9e7dd85b5b818621b2a8c702","ci/docker/arm-linux-androideabi/Dockerfile":"370e55d3330a413a3ccf677b3afb3e0ef9018a5fab263faa97ae8ac017fc2286","ci/docker/arm-unknown-linux-gnueabi/Dockerfile":"bb5f8ae890707c128652290ffc544447643bf12037ddd73c6ad6989f848cb380","ci/docker/arm-unknown-linux-gnueabihf/Dockerfile":"1afaefcbc05b740859acd4e067bc92439be6bcbe8f2e9678474fb434bcd398d9","ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile":"8282ea707a94109beed47a57574755e2d58401735904a03f85fb64c578c53b4f","ci/docker/i586-unknown-linux-gnu/Dockerfile":"49792922269f371bd29da4727e9085101b27be67a6b97755d0196c63317f7abb","ci/docker/i686-unknown-linux-gnu/Dockerfile":"49792922269f371bd29da4727e9085101b27be67a6b97755d0196c63317f7abb","ci/docker/mips-unknown-linux-gnu/Dockerfile":"b2ebc25797612c4f8395fe9d407725156044955bfbcf442036b7f55b43a5f9da","ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile":"b0c1692ac65bc56dd30494b1993d8e929c48cc9c4b92029b7c7592af6d4f9220","ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile":"4e9249c179300138141d0b2b7401b11897f64aed69f541f078c1db4594df2827","ci/docker/mipsel-unknown-linux-musl/Dockerfile":"3164c52b0dcbb01afa78292b15b5c43503ccf0491cf6eb801ec2bf22ae274e52","ci/docker/powerpc-unknown-linux-gnu/Dockerfile":"786f799d0b56eb54d7b6c4b00e1aed4ce81776e14e44767e083c89d014b72004","ci/docker/powerpc64-unknown-linux-gnu/Dockerfile":"e8bc363837cd9c2d8b22402acb8c1c329efc11ba5d12170603d2fe2eae9da059","ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile":"47998d45b781d797b9e6085ebe898d90de0c952b54537a8db4e8d7503eb032d9","ci/docker/s390x-unknown-linux-gnu/Dockerfile":"93fb44df3d7fd31ead158570667c97b5076a05c3d968af4a84bc13819a8f2db8","ci/docker/sparc64-unknown-linux-gnu/Dockerfile":"da1c39a3ff1fe22e41395fa7c8934e90b4c1788e551b9aec6e38bfd94effc437","ci/docker/thumbv7neon-linux-androideabi/Dockerfile":"c2decd5591bd7a09378901bef629cd944acf052eb55e4f35b79eb9cb4d62246a","ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile":"51955a8bf3c4d440f47382af6f5426ebff94ab01a04da36175babda9a057740f","ci/docker/wasm32-unknown-unknown/Dockerfile":"5a022299f56730cf8c432a07391e95e199cfa36dc8da2a96c9d185c8de93e913","ci/docker/x86_64-linux-android/Dockerfile":"685040273cf350d5509e580ac451555efa19790c8723ca2af066adadc6880ad2","ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile":"44b6203d9290bfdc53d81219f0937e1110847a23dd982ec8c4de388354f01536","ci/docker/x86_64-unknown-linux-gnu/Dockerfile":"7f4e3ca5fa288ea70edb4d1f75309708cd30b192e2e4444e61c4d5b3b58f89cf","ci/dox.sh":"434e9611c52e389312d2b03564adf09429f10cc76fe66a8644adb104903b87b7","ci/linux-s390x.sh":"d6b732d7795b4ba131326aff893bca6228a7d2eb0e9402f135705413dbbe0dce","ci/linux-sparc64.sh":"c92966838b1ab7ad3b7a344833ee726aba6b647cf5952e56f0ad1ba420b13325","ci/lld-shim.rs":"3d7f71ec23a49e2b67f694a0168786f9a954dda15f5a138815d966643fd3fcc3","ci/max_line_width.sh":"0a1518bba4c9ecaa55694cb2e9930d0e19c265baabf73143f17f9cf285aaa5bb","ci/run-docker.sh":"92e036390ad9b0d16f109579df1b5ced2e72e9afea40c7d011400ebd3a2a90de","ci/run.sh":"41dd6a60efaaeae9661a01370cce98b631f78392859a0cf68c946c0a16edf5f7","ci/run_examples.sh":"d1a23c6c35374a0678ba5114b9b8fefd8be0a79e774872a8bf0898d1baca18d0","ci/runtest-android.rs":"145a8e9799a5223975061fe7e586ade5669ee4877a7d7a4cf6b4ab48e8e36c7c","ci/setup_benchmarks.sh":"fae3960023f6f3d1388cd2ad22fdbab4b075f1f29dd4292d7994a20783beb6cf","ci/test-runner-linux":"c8aa6025cff5306f4f31d0c61dc5f9d4dd5a1d189ab613ef8d4c367c694d9ccd","contributing.md":"2d2629310ad4d464c482bdbb5819f0d6ce223c576aeef2cdce6a1f6857085ea5","perf-guide/.gitignore":"fe82c7da551079d832cf74200b0b359b4df9828cb4a0416fa7384f07a2ae6a13","perf-guide/book.toml":"115a98284126c6b180178b44713314cc494f08a71662ee2ce15cf67f17a51064","perf-guide/src/SUMMARY.md":"3e03bffc991fdc2050f3d51842d72d9d21ea6abab56a3baf3b2d5973a78b89e1","perf-guide/src/ascii.css":"29afb08833b2fe2250f0412e1fa1161a2432a0820a14953c87124407417c741a","perf-guide/src/bound_checks.md":"5e4991ff58a183ef0cd9fdc1feb4cd12d083b44bdf87393bbb0927808ef3ce7d","perf-guide/src/float-math/approx.md":"8c09032fa2d795a0c5db1775826c850d28eb2627846d0965c60ee72de63735ad","perf-guide/src/float-math/fma.md":"311076ba4b741d604a82e74b83a8d7e8c318fcbd7f64c4392d1cf5af95c60243","perf-guide/src/float-math/fp.md":"04153e775ab6e4f0d7837bcc515230d327b04edfa34c84ce9c9e10ebaeef2be8","perf-guide/src/float-math/svml.md":"0798873b8eedaeda5fed62dc91645b57c20775a02d3cd74d8bd06958f1516506","perf-guide/src/introduction.md":"9f5a19e9e6751f25d2daad39891a0cc600974527ec4c8305843f9618910671bd","perf-guide/src/prof/linux.md":"447731eb5de7d69166728fdbc5ecb0c0c9db678ea493b45a592d67dd002184c0","perf-guide/src/prof/mca.md":"f56d54f3d20e7aa4d32052186e8237b03d65971eb5d112802b442570ff11d344","perf-guide/src/prof/profiling.md":"8a650c0fd6ede0964789bb6577557eeef1d8226a896788602ce61528e260e43c","perf-guide/src/target-feature/attribute.md":"615f88dca0a707b6c416fa605435dd6e1fb5361cc639429cbf68cd87624bd78b","perf-guide/src/target-feature/features.md":"17077760ff24c006b606dd21889c53d87228f4311f3ba3a574f9afdeacd86165","perf-guide/src/target-feature/inlining.md":"7ed1d7068d8173a00d84c16cfe5871cd68b9f04f8d0cca2d01ebc84957ebf2f6","perf-guide/src/target-feature/practice.md":"c4b371842e0086df178488fec97f20def8f0c62ee588bcd25fd948b9b1fa227e","perf-guide/src/target-feature/runtime.md":"835425f5ee597fb3e51d36e725a81ebee29f4561231d19563cd4da81dbb1cfcb","perf-guide/src/target-feature/rustflags.md":"01197acf6f0adec8db32b8591811f69cecb6555a2b05dc5d5ec27d0e3f7b065e","perf-guide/src/vert-hor-ops.md":"c6211c0ee91e60552ec592d89d9d957eedc21dee3cbd89e1ad6765ea06a27471","rustfmt.toml":"d99a43f3f8ef9e425cf01c333fba9f0051f888f5d87ab4e8f63c2f7d0fe6620f","src/api.rs":"f6e92f056565e6fd93f98829a408aee9e790251e0cbd8a8bc30c8662b4d6fabb","src/api/bit_manip.rs":"c47a4d0f7451f7e35d07715e4f39a472e07457fd456fdb726864a4f6887252a3","src/api/bitmask.rs":"6d2beefd62ee5d9c8eb060bee6abc641616bf828c99f82abf97b21bf004e894b","src/api/cast.rs":"03b94a3d316ac7b7be7068810044911e965e889a0ace7bae762749ca74a92747","src/api/cast/macros.rs":"b0a14d0c83ad2ebb7a275180f6d9e3f2bc312ba57a7d3d6c39fad4e0f20f9408","src/api/cast/v128.rs":"edd0994efac4379dff26e178423a52dbb3ffeb38b1fc97cae975d744c00b4fb6","src/api/cast/v16.rs":"96bd98c2d21b0663abe6c0ab33005b1fa693f3db7ee6795351391343863484da","src/api/cast/v256.rs":"8c31fe91f5e78ef737dfba6979cc1240210cb094a89d284fe459bf8a991ca24b","src/api/cast/v32.rs":"a99a79dd84d2a5e6adf9db98705675915bd03fd1287d489c7fe38e84d7e4a086","src/api/cast/v512.rs":"c0dd526f41ed7b8a71c3743d91267554ec0a0c75834ccc2e3ecb0ef3004af642","src/api/cast/v64.rs":"6572fdba2a1241a6cd666d3f0cce3306cd2cb7e5e236172e59d5d4351c8a88af","src/api/cmp.rs":"357c3a2a09c6d4611c32dd7fa95be2fae933d513e229026ec9b44451a77b884e","src/api/cmp/eq.rs":"60f70f355bae4cb5b17db53204cacc3890f70670611c17df638d4c04f7cc8075","src/api/cmp/ord.rs":"589f7234761c294fa5df8f525bc4acd5a47cdb602207d524a0d4e19804cd9695","src/api/cmp/partial_eq.rs":"902ccb8aa01fd5738b30ba0b712669c21d4801958907e03bad23432c7dba0198","src/api/cmp/partial_ord.rs":"9db0c37d7434cdfc62d8d66912e972fa3d8c115ab2af051a6f45e414bd3e4f1c","src/api/cmp/vertical.rs":"de3d62f38eba817299aa16f1e1939954c9a447e316509397465c2830852ba053","src/api/default.rs":"67bf21c134127d12a7028c8b88a57f0ceee8ccbd74976da8ca74eb9f16a174d5","src/api/fmt.rs":"67fb804bb86b6cd77cf8cd492b5733ce437071b66fe3297278b8a6552c325dda","src/api/fmt/binary.rs":"02b2b287f7404f8a983813cf70c87108c8da3835578b63ab303116885f609413","src/api/fmt/debug.rs":"56e1c3bdc092747344fffaafff9da7163ee7827857f6fb7cb1c9923eca4f6fa0","src/api/fmt/lower_hex.rs":"558fd592f7f485712fb051509cecc7174a21e6bf62e5ce64766e75afc97bb8e1","src/api/fmt/octal.rs":"3b2e70877a4f368c7704f8e254236c014c365c74d93371c1feb5f030e6c66422","src/api/fmt/upper_hex.rs":"2a442f666bc80e22d41f903f881238fe114dd49344c3ed69849250e853cafc5d","src/api/from.rs":"2e599d8329cb05eaf06224cc441355c4b7b51254fc19256619333be8c149d444","src/api/from/from_array.rs":"dd3fc64fb17d6184bb60343f8da26a05edf0e5f3c14caf55d49fa15e21d948dc","src/api/from/from_vector.rs":"9764371aa9e6005aace74dea14f59e5611a095b7cf42707940924749282c52f0","src/api/hash.rs":"5076ece87969592c876486f5b1ea8affbeaec379d1a14a30859e0aa5592019de","src/api/into_bits.rs":"1ee15923352786b9ab4a31fa506762297116b18cfdb8e72853abc8ad001651d2","src/api/into_bits/arch_specific.rs":"e7445021f3908326bfee758835e5fc5ad56aa1baa77fc1c58abe4350c66c670a","src/api/into_bits/macros.rs":"bb4fe99be2af6a21d805efab44c8e4e61a7b2adb42a65504a0cf26d13efdadcd","src/api/into_bits/v128.rs":"145a44922b09a5ca5b62d88a461d327d399a997a15db4b11d7b17e554a9fa4c0","src/api/into_bits/v16.rs":"f4f4f61ba88aa51b158ec56ca3dce234349aea0daf2b3029a14ab5125d1e41e5","src/api/into_bits/v256.rs":"8cea9c5d9809f11323cb7cdc53b83df593fd17caf926251e412ae9777bed547f","src/api/into_bits/v32.rs":"905ba683d342fa32f4202b80bb46530807bd0a5b588f6c2e8c9f475223c47775","src/api/into_bits/v512.rs":"e25afa1fbf088a5d58e7d75d197b6cd4c56637ea28542ba18e46a451f29d04e7","src/api/into_bits/v64.rs":"d6238022ccff7b92e55b3f6017fc269acb6f36330a6d7e8fb389853a0f1b6478","src/api/math.rs":"8b2a2fc651917a850539f993aa0b9e5bf4da67b11685285b8de8cdca311719ec","src/api/math/float.rs":"61d2794d68262a1090ae473bd30793b5f65cf732f32a6694a3af2ce5d9225616","src/api/math/float/abs.rs":"5b6b2701e2e11135b7ce58a05052ea8120e10e4702c95d046b9d21b827b26bf8","src/api/math/float/consts.rs":"6302c9261da4291d144d5bb53493cdd073498feb40955fb6860ea3c4d06c978a","src/api/math/float/cos.rs":"4c2dd7173728ef189314f1576c9486e03be21b7da98843b2f9011282a7979e31","src/api/math/float/exp.rs":"7c6d5f1e304f498a01cfa23b92380c815d7da0ad94eae3483783bc377d287eef","src/api/math/float/ln.rs":"54c7583f3df793b39ff57534fade27b41bb992439e5dc178252f5ca3190a3e54","src/api/math/float/mul_add.rs":"62cac77660d20159276d4c9ef066eb90c81cbddb808e8e157182c607625ad2eb","src/api/math/float/mul_adde.rs":"bae056ee9f3a70df39ec3c3b2f6437c65303888a7b843ef1a5bcf1f5aca0e602","src/api/math/float/powf.rs":"9ddb938984b36d39d82a82f862f80df8f7fb013f1d222d45698d41d88472f568","src/api/math/float/recpre.rs":"589225794ff1dbf31158dff660e6d4509ecc8befbb57c633900dea5ac0b840d6","src/api/math/float/rsqrte.rs":"a32abdcc318d7ccc8448231f54d75b884b7cbeb03a7d595713ab6243036f4dbf","src/api/math/float/sin.rs":"cbd3622b7df74f19691743001c8cf747a201f8977ad90542fee915f37dcd1e49","src/api/math/float/sqrt.rs":"0c66d5d63fb08e4d99c6b82a8828e41173aff1ac9fa1a2764a11fac217ccf2ac","src/api/math/float/sqrte.rs":"731e1c9f321b662accdd27dacb3aac2e8043b7aecb2f2161dde733bd9f025362","src/api/minimal.rs":"1f22bcc528555444e76de569ec0ae2029b9ae9d04805efeafa93369c8098036b","src/api/minimal/iuf.rs":"819cff26d3e196f807645bcc1d79eb27d9f175edb89910f2274d52a1e913cd11","src/api/minimal/mask.rs":"0cae10ae1fc65f5070e686c0c79bfba27b86b33d6c399367bd4848fb367dcec4","src/api/minimal/ptr.rs":"f65ebf21866a863485344432d9a7a9b7418f7fad5fdf841a4e2fa56ec0766ad0","src/api/ops.rs":"3e273b277a0f3019d42c3c59ca94a5afd4885d5ae6d2182e5089bbeec9de42ee","src/api/ops/scalar_arithmetic.rs":"d2d5ad897a59dd0787544f927e0e7ca4072c3e58b0f4a2324083312b0d5a21d7","src/api/ops/scalar_bitwise.rs":"482204e459ca6be79568e1c9f70adbe2d2151412ddf122fb2161be8ebb51c40c","src/api/ops/scalar_mask_bitwise.rs":"c250f52042e37b22d57256c80d4604104cfd2fbe2a2e127c676267270ca5d350","src/api/ops/scalar_shifts.rs":"c4773d435c3f9da4454327e6fbb2b5b41a1c0ebb1cca7372e69dc7a344a1b6e4","src/api/ops/vector_arithmetic.rs":"ddca15d09ddeef502c2ed66117a62300ca65d87e959e8b622d767bdf1c307910","src/api/ops/vector_bitwise.rs":"b3968f7005b649edcc22a54e2379b14d5ee19045f2e784029805781ae043b5ee","src/api/ops/vector_float_min_max.rs":"76bf8cb607e2c442923c1da1061a6b80d742d607408033c2a3761161114cf2a0","src/api/ops/vector_int_min_max.rs":"a378789c6ff9b32a51fbd0a97ffd36ed102cd1fe6a067d2b02017c1df342def6","src/api/ops/vector_mask_bitwise.rs":"5052d18517d765415d40327e6e8e55a312daaca0a5e2aec959bfa54b1675f9c8","src/api/ops/vector_neg.rs":"5c62f6b0221983cdbd23cd0a3af3672e6ba1255f0dfe8b19aae6fbd6503e231b","src/api/ops/vector_rotates.rs":"ee319eaaa449dc50ea8ef05b89d38519c6faa6753dfdce432ea7bb8520e4e8e7","src/api/ops/vector_shifts.rs":"e510be14127c0ffd58a2573a39701da3557d66bedec09837ac8bbd44d579da00","src/api/ptr.rs":"8a793251bed6130dcfb2f1519ceaa18b751bbb15875928d0fb6deb5a5e07523a","src/api/ptr/gather_scatter.rs":"3d614f9d5b4ca201a9f7e46af4405e1d2c28ecee1620297c23b52e37b92cc0ea","src/api/reductions.rs":"ae5baca81352ecd44526d6c30c0a1feeda475ec73ddd3c3ec6b14e944e5448ee","src/api/reductions/bitwise.rs":"8bf910ae226188bd15fc7e125f058cd2566b6186fcd0cd8fd020f352c39ce139","src/api/reductions/float_arithmetic.rs":"47a5679896db2cbb56c31372fe42143da015b6beae7db5d2f3a0309ddf427ae1","src/api/reductions/integer_arithmetic.rs":"c2df3cf7493cca4174f2c65aea422a3d20d8a23af03f8d57cef72c19fee8f20d","src/api/reductions/mask.rs":"db83327a950e33a317f37fd33ca4e20c347fb415975ec024f3e23da8509425af","src/api/reductions/min_max.rs":"6af8c9aa45c69961b1b6fc205395f4767d4421869fb105fb3d563c5605fc13cd","src/api/select.rs":"6b07e7e8026df561f7307221a896f0fbb272536f41b9109040ac094c24c69331","src/api/shuffle.rs":"26458aec2557bfab41b7765f72aefbff3a7ee08cdc689981a81f133f58ee368b","src/api/shuffle1_dyn.rs":"bfea5a91905b31444e9ef7ca6eddb7a9606b7e22d3f71bb842eb2795a0346620","src/api/slice.rs":"ee87484e8af329547b9a5d4f2a69e8bed6ea10bbd96270d706083843d4eea2ac","src/api/slice/from_slice.rs":"9b6f01ace2d12ef45c84608bb7aad3a122e2cc319b2d99170fc332a568b8de63","src/api/slice/write_to_slice.rs":"244b6bd6ccffa6e5a195f8b1abc66d94251b6d16b2ec3fe4d76d32caec68261e","src/api/swap_bytes.rs":"4a6792a2e49a77475e1b237592b4b2804dbddb79c474331acd0dd71b36934259","src/codegen.rs":"a29d38fa0a85eaf787fb49989e625bf64effd5f39c126fbb2a24be206d2a3917","src/codegen/bit_manip.rs":"9991570a21ca98134b08b5c5935e2c259cea39c82d9d1529f52c561a84fec642","src/codegen/llvm.rs":"5bc6751293f9f184cf23d5df448c7d58b58b799e41c7a91f8ca41a5ba56e64ec","src/codegen/math.rs":"35f96e37a78fcf0cdb02146b7f27a45108fe06a37fc2a54d8851ce131a326178","src/codegen/math/float.rs":"dd86c0449e576c83b719700962ac017c332987fac08d91f2b7a2b1b883598170","src/codegen/math/float/abs.rs":"f56e2b4b8055ea861c1f5cbc6b6e1d8e7e5af163b62c13574ddee4e09513bfbc","src/codegen/math/float/cos.rs":"ef3b511a24d23045b310315e80348a9b7fedb576fc2de52d74290616a0abeb2a","src/codegen/math/float/cos_pi.rs":"4e7631a5d73dac21531e09ef1802d1180f8997509c2c8fa9f67f322194263a97","src/codegen/math/float/exp.rs":"61b691598c41b5622f24e4320c1bdd08701e612a516438bdddcc728fc3405c8c","src/codegen/math/float/ln.rs":"46b718b1ba8c9d99e1ad40f53d20dfde08a3063ca7bd2a9fdd6698e060da687e","src/codegen/math/float/macros.rs":"fc9924869ed85e4795983af228cacf23158f4f35919adce16c920ad4a3f0a009","src/codegen/math/float/mul_add.rs":"a37bf764345d4b1714f97e83897b7cf0855fc2811704bcbc0012db91825339e1","src/codegen/math/float/mul_adde.rs":"9aa6ed39825e61edb2522e002c59c9392d7c655c01af1cf8380ba22c8ddf69cd","src/codegen/math/float/powf.rs":"642346e982bc4c39203de0864d2149c4179cd7b21cf67a2951687932b4675872","src/codegen/math/float/sin.rs":"9d68164c90cdca6a85155040cdac42e27342ebe0b925273ef1593df721af4258","src/codegen/math/float/sin_cos_pi.rs":"e0c661d1d894fd4018723b9f3143ab6771c9405e41907cb1a7b9f9b380a97523","src/codegen/math/float/sin_pi.rs":"9890347905b4d4a3c7341c3eb06406e46e60582bcf6960688bd727e5dadc6c57","src/codegen/math/float/sqrt.rs":"e3c60dcfb0c6d2fc62adabcc931b2d4040b83cab294dea36443fb4b89eb79e34","src/codegen/math/float/sqrte.rs":"f0f4ef9eb475ae41bcc7ec6a95ad744ba6b36925faa8b2c2814004396d196b63","src/codegen/pointer_sized_int.rs":"a70697169c28218b56fd2e8d5353f2e00671d1150d0c8cef77d613bdfacd84cb","src/codegen/reductions.rs":"645e2514746d01387ddd07f0aa4ffd8430cc9ab428d4fb13773ea319fa25dd95","src/codegen/reductions/mask.rs":"dd68fd8bc5335fa2d0405e59dd1e9fff16fdf7651aa8db670ca86145fd5b5dda","src/codegen/reductions/mask/aarch64.rs":"84b101c17cad1ede4eb6d38cada0ac7da239dba8cea3badd3829b967e558431f","src/codegen/reductions/mask/arm.rs":"aaa07129bd078ae7e677cf8b8e67ec9f30536606a0c7ed1baaa18fd1793bb218","src/codegen/reductions/mask/fallback.rs":"3eb9319d2c7cf19216b607b8459612c4e027b643cf11b036937d36896bf76786","src/codegen/reductions/mask/fallback_impl.rs":"76547f396e55ef403327c77c314cf8db8c7a5c9b9819bfb925abeacf130249e5","src/codegen/reductions/mask/x86.rs":"36dcd8af4ab99730a078ed113d3955f74eb1a2876e2e6d9f224e0ff462c216d1","src/codegen/reductions/mask/x86/avx.rs":"3a40868b38c86e35aefb96d7578de6322efe89d8135e0366359b54ddd06f861a","src/codegen/reductions/mask/x86/avx2.rs":"677aed3f056285285daa3adff8bc65e739630b4424defa6d9665e160f027507e","src/codegen/reductions/mask/x86/sse.rs":"8522f6ed03f6c32dd577d4298df477c08aeaaa38563706f29096e1911ed731f2","src/codegen/reductions/mask/x86/sse2.rs":"54ec56e49b0c6841eccb719e4f310d65fe767c04136b2ec20bd8b9d7d9897b9e","src/codegen/shuffle.rs":"1ec2930f4e1acc43ac30b518af298d466a79e9e75734a51c380b7810efd1a27f","src/codegen/shuffle1_dyn.rs":"3f13ca1597378758d05106bf5ff3715eee531f3cb6d88f48b9182bd6c9386b51","src/codegen/swap_bytes.rs":"ac659780deb0c52daa9c73afb4ba8645c9fa35350cd897b23e567860492553b7","src/codegen/v128.rs":"94226b31ec403d18d9d2fe06713f147c9c79e9b5f9105089088266313f843185","src/codegen/v16.rs":"ddec4ffb66b6f7aaffb9a1780c5ddba82557abd74f45073d335047e04cf74924","src/codegen/v256.rs":"6b63917f0444118d6b1595bff2045e59b97c4d24012bd575f69f1f0efc5a0241","src/codegen/v32.rs":"3477b3c5540aed86e61e2f5807dd31db947413cec9181c587d93ed6ec74f0eba","src/codegen/v512.rs":"5854f99d3aabc4cd42b28a20d9ce447756dc2ba024a409a69b6a8ae1f1842fc5","src/codegen/v64.rs":"e9e89caebfe63d10c0cbca61e4dfdba3b7e02ee0989170f80beed23237ddd950","src/codegen/vPtr.rs":"711c753a08d53a2879c4fb87a0762c46ce4e34c22f0ca88d2e4c557a0f679969","src/codegen/vSize.rs":"c89f5fdeb28ac4c8272ed1816fce03d9d95308cc32bb2533bd8b20cd5ac102ac","src/lib.rs":"5efc09cb3d164e4e38b71fd4999afbfd234f5080dc84ce22fda2fc15d381e8c7","src/masks.rs":"70fc0abe4c2907ce2a491c574e1cfb9f3423385da2e1a923a48c9c13f8ba6ed8","src/sealed.rs":"ae7fdeaf5d84cd7710ed730ca72ca7eaba93df6cb0acb183e5c0a7327acf197f","src/testing.rs":"1d3a7862ef625e235a5734ad7204e68d350f902c0695182b1f08a0552432416e","src/testing/macros.rs":"403bbc5ecb7c786fe36156df302d0c07a8122408dbb15f7474d7682224ba1106","src/testing/utils.rs":"41912a92266dfe884647fc035e4242fd746100df8e839808ae0397af3759a3c8","src/v128.rs":"16cf9a8e7156b899ee9b9cd3f2dba9d13ec63289bea8c3ee9ae2e43ad9510288","src/v16.rs":"cb6465cf1e00bf530183af1819b9fe3d7eec978f8765d5e85d9b58a39a4b4045","src/v256.rs":"fe235017da18c7f3c361831c60e3173ad304d8ea1e95d64ebebc79da2d708511","src/v32.rs":"145d347855bac59b2de6508f9e594654e6c330423af9edc0e2ac8f4d1abdf45e","src/v512.rs":"f372f277f3e62eb5c945bb1c460333fdb17b6974fcc876633788ff53bded9599","src/v64.rs":"0b8079881b71575e3414be0b7f8f7eaba65281ba6732f2b2f61f73e95b6f48f7","src/vPtr.rs":"8b3e433d487180bb4304ff71245ecad90f0010f43e139a72027b672abe58facc","src/vSize.rs":"eda5aa020706cbf94d15bada41a0c2a35fc8f3f37cb7c2cd6f34d201399a495e","tests/endianness.rs":"2783d727e8ff8789211e03120634cd3ad9f8972fc484012681b5b63cf89408a7"},"package":null}
\ No newline at end of file
diff --git a/third_party/rust/packed_simd/.travis.yml b/third_party/rust/packed_simd_2/.travis.yml
similarity index 86%
rename from third_party/rust/packed_simd/.travis.yml
rename to third_party/rust/packed_simd_2/.travis.yml
index be3fb2369341..0ffc06afdda7 100644
--- a/third_party/rust/packed_simd/.travis.yml
+++ b/third_party/rust/packed_simd_2/.travis.yml
@@ -20,9 +20,6 @@ jobs:
     - env: TARGET=arm-linux-androideabi
       name: "arm-linux-androideabi"
       stage: build-test-verify
-    - env: TARGET=arm-linux-androideabi RUSTFLAGS="-C target-feature=+v7,+neon"
-      name: "arm-linux-androideabi + NEON"
-      stage: build-test-verify
     - name: "aarch64-unknown-linux-android + NEON"
       env: TARGET=aarch64-linux-android RUSTFLAGS="-C target-feature=+neon"
       stage: build-test-verify
@@ -50,21 +47,13 @@ jobs:
       stage: 32bit-tier1
     - env: TARGET=x86_64-unknown-linux-gnu RUSTFLAGS="-C target-feature=+sse4.2"
       name: "x86_64-unknown-linux-gnu + SSE4.2"
-      install: rustup component add rustfmt-preview
       stage: build-test-verify
     - env: TARGET=x86_64-unknown-linux-gnu RUSTFLAGS="-C target-feature=+avx2"
       name: "x86_64-unknown-linux-gnu + AVX2"
-      install: rustup component add rustfmt-preview
-      stage: build-test-verify
-    - env: TARGET=arm-unknown-linux-gnueabi RUSTFLAGS="-C target-feature=+v7,+neon"
-      name: "arm-unknown-linux-gnueabi + NEON"
       stage: build-test-verify
     - env: TARGET=arm-unknown-linux-gnueabihf
       name: "arm-unknown-linux-gnueabihf"
       stage: build-test-verify
-    - env: TARGET=arm-unknown-linux-gnueabihf RUSTFLAGS="-C target-feature=+v7,+neon"
-      name: "arm-unknown-linux-gnueabihf + NEON"
-      stage: build-test-verify
     - env: TARGET=armv7-unknown-linux-gnueabihf
       name: "armv7-unknown-linux-gnueabihf"
       stage: build-test-verify
@@ -181,16 +170,8 @@ jobs:
     - name: "rustfmt"
       install: true
       script: |
-        if rustup component add rustfmt-preview ; then
-            ci/all.sh check_fmt || true
-        fi
-      stage: tools
-    - name: "clippy"
-      install: true
-      script: |
-        if rustup component add clippy-preview ; then
-            ci/all.sh clippy
-        fi
+        rustup toolchain install nightly -c rustfmt --allow-downgrade
+        ci/all.sh check_fmt || true
       stage: tools
 
   allow_failures:
@@ -213,14 +194,6 @@ jobs:
     # Is this related to the above? Mysterious test failure
     - name: "aarch64-apple-ios + NEON"
 
-    # FIXME: https://github.com/rust-lang-nursery/packed_simd/issues/182
-    - env: TARGET=arm-unknown-linux-gnueabi RUSTFLAGS="-C target-feature=+v7,+neon"
-    - env: TARGET=arm-unknown-linux-gnueabihf RUSTFLAGS="-C target-feature=+v7,+neon"
-    - env: TARGET=armv7-unknown-linux-gnueabihf RUSTFLAGS="-C target-feature=+neon"
-
-    # FIXME: https://github.com/rust-lang-nursery/packed_simd/issues/183
-    - env: TARGET=wasm32-unknown-unknown
-
 install: travis_retry rustup target add $TARGET
 before_script: cargo generate-lockfile
 script: travis_wait 50 ci/run-docker.sh
diff --git a/third_party/rust/packed_simd_2/Cargo.toml b/third_party/rust/packed_simd_2/Cargo.toml
new file mode 100644
index 000000000000..f38706d05002
--- /dev/null
+++ b/third_party/rust/packed_simd_2/Cargo.toml
@@ -0,0 +1,42 @@
+[package]
+name = "packed_simd_2"
+version = "0.3.7"
+description = "Portable Packed SIMD vectors"
+documentation = "https://docs.rs/crate/packed_simd/"
+homepage = "https://github.com/rust-lang/packed_simd"
+repository = "https://github.com/rust-lang/packed_simd"
+keywords = ["simd", "vector", "portability"]
+categories = ["hardware-support", "concurrency", "no-std", "data-structures"]
+license = "MIT OR Apache-2.0"
+build = "build.rs"
+edition = "2018"
+
+[badges]
+appveyor = { repository = "rust-lang/packed_simd" }
+travis-ci = { repository = "rust-lang/packed_simd" }
+codecov = { repository = "rust-lang/packed_simd" }
+is-it-maintained-issue-resolution = { repository = "rust-lang/packed_simd" }
+is-it-maintained-open-issues = { repository = "rust-lang/packed_simd" }
+maintenance = { status = "experimental" }
+
+[dependencies]
+cfg-if = "1.0.0"
+core_arch = { version = "0.1.5", optional = true }
+
+[features]
+default = []
+into_bits = []
+libcore_neon = []
+
+[dev-dependencies]
+paste = "^0.1.3"
+arrayvec = { version = "^0.5", default-features = false }
+
+[target.'cfg(target_arch = "x86_64")'.dependencies.sleef-sys]
+version = "0.1.2"
+optional = true
+
+[target.wasm32-unknown-unknown.dev-dependencies]
+# Keep in sync with the version on Dockerfile.
+wasm-bindgen = "=0.2.73"
+wasm-bindgen-test = "=0.3.23"
diff --git a/third_party/rust/packed_simd/LICENSE-APACHE b/third_party/rust/packed_simd_2/LICENSE-APACHE
similarity index 100%
rename from third_party/rust/packed_simd/LICENSE-APACHE
rename to third_party/rust/packed_simd_2/LICENSE-APACHE
diff --git a/third_party/rust/packed_simd/LICENSE-MIT b/third_party/rust/packed_simd_2/LICENSE-MIT
similarity index 100%
rename from third_party/rust/packed_simd/LICENSE-MIT
rename to third_party/rust/packed_simd_2/LICENSE-MIT
diff --git a/third_party/rust/packed_simd/README.md b/third_party/rust/packed_simd_2/README.md
similarity index 85%
rename from third_party/rust/packed_simd/README.md
rename to third_party/rust/packed_simd_2/README.md
index ad4f3f27093f..41a1512d79fb 100644
--- a/third_party/rust/packed_simd/README.md
+++ b/third_party/rust/packed_simd_2/README.md
@@ -1,11 +1,24 @@
+# The Crates.io Version Can No Longer Be Updated!
+
+The original maintainer is out of contact, and the new maintainers (the Portable SIMD Project Group) do not have the appropriate crates.io permissions to issue updates.
+
+We are aware that the version available on crates.io is currently broken, and will not build.
+
+If you need to continue to use the crate, we have published a "next version" under an alternative name.
+
+Adjust your `[dependencies]` section of `Cargo.toml` to be the following:
+```toml
+packed_simd = { version = "0.3.6", package = "packed_simd_2" }
+```
+
 # `Simd<[T; N]>`
 
 ## Implementation of [Rust RFC #2366: `std::simd`][rfc2366]
 
-[![Travis-CI Status]][travis] [![Appveyor Status]][appveyor] [![Latest Version]][crates.io] [![docs]][master_docs]
+[![Travis-CI Status]][travis] <!-- [![Appveyor Status]][appveyor] --> [![Latest Version]][crates.io] [![docs]][master_docs]
 
 **WARNING**: this crate only supports the most recent nightly Rust toolchain
-and will be superceded by [stdsimd](https://github.com/rust-lang/stdsimd).
+and will be superseded by [stdsimd](https://github.com/rust-lang/stdsimd).
 
 ## Documentation
 
@@ -129,15 +142,15 @@ Unless you explicitly state otherwise, any contribution intentionally submitted
 for inclusion in `packed_simd` by you, as defined in the Apache-2.0 license, shall be
 dual licensed as above, without any additional terms or conditions.
 
-[travis]: https://travis-ci.com/rust-lang-nursery/packed_simd
-[Travis-CI Status]: https://travis-ci.com/rust-lang-nursery/packed_simd.svg?branch=master
+[travis]: https://travis-ci.com/rust-lang/packed_simd
+[Travis-CI Status]: https://travis-ci.com/rust-lang/packed_simd.svg?branch=master
 [appveyor]: https://ci.appveyor.com/project/gnzlbg/packed-simd
 [Appveyor Status]: https://ci.appveyor.com/api/projects/status/hd7v9dvr442hgdix?svg=true
-[Latest Version]: https://img.shields.io/crates/v/packed_simd.svg
-[crates.io]: https://crates.io/crates/packed_simd
-[docs]: https://docs.rs/packed_simd/badge.svg
-[docs.rs]: https://docs.rs/packed_simd/
-[master_docs]: https://rust-lang-nursery.github.io/packed_simd/packed_simd/
+[Latest Version]: https://img.shields.io/crates/v/packed_simd_2.svg
+[crates.io]: https://crates.io/crates/packed_simd_2
+[docs]: https://docs.rs/packed_simd_2/badge.svg
+[docs.rs]: https://docs.rs/packed_simd_2
+[master_docs]: https://rust-lang-nursery.github.io/packed_simd/packed_simd_2/
 [perf_guide]: https://rust-lang-nursery.github.io/packed_simd/perf-guide/
 [rfc2366]: https://github.com/rust-lang/rfcs/pull/2366
 [ISPC]: https://ispc.github.io/
diff --git a/third_party/rust/packed_simd/bors.toml b/third_party/rust/packed_simd_2/bors.toml
similarity index 100%
rename from third_party/rust/packed_simd/bors.toml
rename to third_party/rust/packed_simd_2/bors.toml
diff --git a/third_party/rust/packed_simd_2/build.rs b/third_party/rust/packed_simd_2/build.rs
new file mode 100644
index 000000000000..e87298a2de23
--- /dev/null
+++ b/third_party/rust/packed_simd_2/build.rs
@@ -0,0 +1,6 @@
+fn main() {
+    let target = std::env::var("TARGET").expect("TARGET environment variable not defined");
+    if target.contains("neon") {
+        println!("cargo:rustc-cfg=libcore_neon");
+    }
+}
diff --git a/third_party/rust/packed_simd/ci/all.sh b/third_party/rust/packed_simd_2/ci/all.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/all.sh
rename to third_party/rust/packed_simd_2/ci/all.sh
diff --git a/third_party/rust/packed_simd/ci/android-install-ndk.sh b/third_party/rust/packed_simd_2/ci/android-install-ndk.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/android-install-ndk.sh
rename to third_party/rust/packed_simd_2/ci/android-install-ndk.sh
diff --git a/third_party/rust/packed_simd/ci/android-install-sdk.sh b/third_party/rust/packed_simd_2/ci/android-install-sdk.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/android-install-sdk.sh
rename to third_party/rust/packed_simd_2/ci/android-install-sdk.sh
diff --git a/third_party/rust/packed_simd/ci/android-sysimage.sh b/third_party/rust/packed_simd_2/ci/android-sysimage.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/android-sysimage.sh
rename to third_party/rust/packed_simd_2/ci/android-sysimage.sh
diff --git a/third_party/rust/packed_simd/ci/benchmark.sh b/third_party/rust/packed_simd_2/ci/benchmark.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/benchmark.sh
rename to third_party/rust/packed_simd_2/ci/benchmark.sh
diff --git a/third_party/rust/packed_simd/ci/deploy_and_run_on_ios_simulator.rs b/third_party/rust/packed_simd_2/ci/deploy_and_run_on_ios_simulator.rs
similarity index 100%
rename from third_party/rust/packed_simd/ci/deploy_and_run_on_ios_simulator.rs
rename to third_party/rust/packed_simd_2/ci/deploy_and_run_on_ios_simulator.rs
diff --git a/third_party/rust/packed_simd/ci/docker/aarch64-linux-android/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/aarch64-linux-android/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/aarch64-linux-android/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/aarch64-linux-android/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/aarch64-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/aarch64-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/aarch64-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/aarch64-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/arm-linux-androideabi/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/arm-linux-androideabi/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/arm-linux-androideabi/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/arm-linux-androideabi/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/arm-unknown-linux-gnueabi/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/arm-unknown-linux-gnueabi/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/arm-unknown-linux-gnueabi/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/arm-unknown-linux-gnueabi/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/armv7-unknown-linux-gnueabihf/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/i586-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/i586-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/i586-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/i586-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/i686-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/i686-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/i686-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/i686-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/mips-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/mips-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/mips-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/mips-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/mipsel-unknown-linux-musl/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/mipsel-unknown-linux-musl/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/mipsel-unknown-linux-musl/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/mipsel-unknown-linux-musl/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/powerpc-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/powerpc-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/powerpc-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/powerpc-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/s390x-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/s390x-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/s390x-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/s390x-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/sparc64-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/sparc64-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/sparc64-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/sparc64-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/thumbv7neon-linux-androideabi/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/thumbv7neon-linux-androideabi/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/thumbv7neon-linux-androideabi/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/thumbv7neon-linux-androideabi/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/thumbv7neon-unknown-linux-gnueabihf/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/wasm32-unknown-unknown/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/wasm32-unknown-unknown/Dockerfile
similarity index 77%
rename from third_party/rust/packed_simd/ci/docker/wasm32-unknown-unknown/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/wasm32-unknown-unknown/Dockerfile
index f905cf1a36eb..bd97170bc7e8 100644
--- a/third_party/rust/packed_simd/ci/docker/wasm32-unknown-unknown/Dockerfile
+++ b/third_party/rust/packed_simd_2/ci/docker/wasm32-unknown-unknown/Dockerfile
@@ -17,14 +17,15 @@ RUN make -C wabt -j$(nproc)
 ENV PATH=$PATH:/wabt/bin
 
 # Install `wasm-bindgen-test-runner`
-RUN curl -L https://github.com/rustwasm/wasm-bindgen/releases/download/0.2.19/wasm-bindgen-0.2.19-x86_64-unknown-linux-musl.tar.gz \
+RUN curl -L https://github.com/rustwasm/wasm-bindgen/releases/download/0.2.73/wasm-bindgen-0.2.73-x86_64-unknown-linux-musl.tar.gz \
   | tar xzf -
-ENV PATH=$PATH:/wasm-bindgen-0.2.19-x86_64-unknown-linux-musl
+# Keep in sync with the version on Cargo.toml.
+ENV PATH=$PATH:/wasm-bindgen-0.2.73-x86_64-unknown-linux-musl
 ENV CARGO_TARGET_WASM32_UNKNOWN_UNKNOWN_RUNNER=wasm-bindgen-test-runner
 
 # Install `node`
-RUN curl https://nodejs.org/dist/v10.8.0/node-v10.8.0-linux-x64.tar.xz | tar xJf -
-ENV PATH=$PATH:/node-v10.8.0-linux-x64/bin
+RUN curl https://nodejs.org/dist/v14.16.0/node-v14.16.0-linux-x64.tar.xz | tar xJf -
+ENV PATH=$PATH:/node-v14.16.0-linux-x64/bin
 
 # We use a shim linker that removes `--strip-debug` when passed to LLD. While
 # this typically results in invalid debug information in release mode it doesn't
diff --git a/third_party/rust/packed_simd/ci/docker/x86_64-linux-android/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/x86_64-linux-android/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/x86_64-linux-android/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/x86_64-linux-android/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/x86_64-unknown-linux-gnu-emulated/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/docker/x86_64-unknown-linux-gnu/Dockerfile b/third_party/rust/packed_simd_2/ci/docker/x86_64-unknown-linux-gnu/Dockerfile
similarity index 100%
rename from third_party/rust/packed_simd/ci/docker/x86_64-unknown-linux-gnu/Dockerfile
rename to third_party/rust/packed_simd_2/ci/docker/x86_64-unknown-linux-gnu/Dockerfile
diff --git a/third_party/rust/packed_simd/ci/dox.sh b/third_party/rust/packed_simd_2/ci/dox.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/dox.sh
rename to third_party/rust/packed_simd_2/ci/dox.sh
diff --git a/third_party/rust/packed_simd/ci/linux-s390x.sh b/third_party/rust/packed_simd_2/ci/linux-s390x.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/linux-s390x.sh
rename to third_party/rust/packed_simd_2/ci/linux-s390x.sh
diff --git a/third_party/rust/packed_simd/ci/linux-sparc64.sh b/third_party/rust/packed_simd_2/ci/linux-sparc64.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/linux-sparc64.sh
rename to third_party/rust/packed_simd_2/ci/linux-sparc64.sh
diff --git a/third_party/rust/packed_simd/ci/lld-shim.rs b/third_party/rust/packed_simd_2/ci/lld-shim.rs
similarity index 100%
rename from third_party/rust/packed_simd/ci/lld-shim.rs
rename to third_party/rust/packed_simd_2/ci/lld-shim.rs
diff --git a/third_party/rust/packed_simd/ci/max_line_width.sh b/third_party/rust/packed_simd_2/ci/max_line_width.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/max_line_width.sh
rename to third_party/rust/packed_simd_2/ci/max_line_width.sh
diff --git a/third_party/rust/packed_simd/ci/run-docker.sh b/third_party/rust/packed_simd_2/ci/run-docker.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/run-docker.sh
rename to third_party/rust/packed_simd_2/ci/run-docker.sh
diff --git a/third_party/rust/packed_simd/ci/run.sh b/third_party/rust/packed_simd_2/ci/run.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/run.sh
rename to third_party/rust/packed_simd_2/ci/run.sh
diff --git a/third_party/rust/packed_simd/ci/run_examples.sh b/third_party/rust/packed_simd_2/ci/run_examples.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/run_examples.sh
rename to third_party/rust/packed_simd_2/ci/run_examples.sh
diff --git a/third_party/rust/packed_simd/ci/runtest-android.rs b/third_party/rust/packed_simd_2/ci/runtest-android.rs
similarity index 100%
rename from third_party/rust/packed_simd/ci/runtest-android.rs
rename to third_party/rust/packed_simd_2/ci/runtest-android.rs
diff --git a/third_party/rust/packed_simd/ci/setup_benchmarks.sh b/third_party/rust/packed_simd_2/ci/setup_benchmarks.sh
similarity index 100%
rename from third_party/rust/packed_simd/ci/setup_benchmarks.sh
rename to third_party/rust/packed_simd_2/ci/setup_benchmarks.sh
diff --git a/third_party/rust/packed_simd/ci/test-runner-linux b/third_party/rust/packed_simd_2/ci/test-runner-linux
similarity index 100%
rename from third_party/rust/packed_simd/ci/test-runner-linux
rename to third_party/rust/packed_simd_2/ci/test-runner-linux
diff --git a/third_party/rust/packed_simd/contributing.md b/third_party/rust/packed_simd_2/contributing.md
similarity index 99%
rename from third_party/rust/packed_simd/contributing.md
rename to third_party/rust/packed_simd_2/contributing.md
index 93fa92783740..79af8c199e8f 100644
--- a/third_party/rust/packed_simd/contributing.md
+++ b/third_party/rust/packed_simd_2/contributing.md
@@ -35,7 +35,7 @@ If LLVM is indeed the cause, the issue will be reported upstream to the
 ## Submitting Pull Requests
 
 New code is submitted to the crate using GitHub's [pull request] mechanism.
-You should first fork this repository, make your changes (preferrably in a new
+You should first fork this repository, make your changes (preferably in a new
 branch), then use GitHub's web UI to create a new PR.
 
 [pull request]: https://help.github.com/articles/about-pull-requests/
diff --git a/third_party/rust/packed_simd/perf-guide/.gitignore b/third_party/rust/packed_simd_2/perf-guide/.gitignore
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/.gitignore
rename to third_party/rust/packed_simd_2/perf-guide/.gitignore
diff --git a/third_party/rust/packed_simd/perf-guide/book.toml b/third_party/rust/packed_simd_2/perf-guide/book.toml
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/book.toml
rename to third_party/rust/packed_simd_2/perf-guide/book.toml
diff --git a/third_party/rust/packed_simd/perf-guide/src/SUMMARY.md b/third_party/rust/packed_simd_2/perf-guide/src/SUMMARY.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/SUMMARY.md
rename to third_party/rust/packed_simd_2/perf-guide/src/SUMMARY.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/ascii.css b/third_party/rust/packed_simd_2/perf-guide/src/ascii.css
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/ascii.css
rename to third_party/rust/packed_simd_2/perf-guide/src/ascii.css
diff --git a/third_party/rust/packed_simd/perf-guide/src/bound_checks.md b/third_party/rust/packed_simd_2/perf-guide/src/bound_checks.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/bound_checks.md
rename to third_party/rust/packed_simd_2/perf-guide/src/bound_checks.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/float-math/approx.md b/third_party/rust/packed_simd_2/perf-guide/src/float-math/approx.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/float-math/approx.md
rename to third_party/rust/packed_simd_2/perf-guide/src/float-math/approx.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/float-math/fma.md b/third_party/rust/packed_simd_2/perf-guide/src/float-math/fma.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/float-math/fma.md
rename to third_party/rust/packed_simd_2/perf-guide/src/float-math/fma.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/float-math/fp.md b/third_party/rust/packed_simd_2/perf-guide/src/float-math/fp.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/float-math/fp.md
rename to third_party/rust/packed_simd_2/perf-guide/src/float-math/fp.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/float-math/svml.md b/third_party/rust/packed_simd_2/perf-guide/src/float-math/svml.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/float-math/svml.md
rename to third_party/rust/packed_simd_2/perf-guide/src/float-math/svml.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/introduction.md b/third_party/rust/packed_simd_2/perf-guide/src/introduction.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/introduction.md
rename to third_party/rust/packed_simd_2/perf-guide/src/introduction.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/prof/linux.md b/third_party/rust/packed_simd_2/perf-guide/src/prof/linux.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/prof/linux.md
rename to third_party/rust/packed_simd_2/perf-guide/src/prof/linux.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/prof/mca.md b/third_party/rust/packed_simd_2/perf-guide/src/prof/mca.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/prof/mca.md
rename to third_party/rust/packed_simd_2/perf-guide/src/prof/mca.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/prof/profiling.md b/third_party/rust/packed_simd_2/perf-guide/src/prof/profiling.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/prof/profiling.md
rename to third_party/rust/packed_simd_2/perf-guide/src/prof/profiling.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/target-feature/attribute.md b/third_party/rust/packed_simd_2/perf-guide/src/target-feature/attribute.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/target-feature/attribute.md
rename to third_party/rust/packed_simd_2/perf-guide/src/target-feature/attribute.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/target-feature/features.md b/third_party/rust/packed_simd_2/perf-guide/src/target-feature/features.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/target-feature/features.md
rename to third_party/rust/packed_simd_2/perf-guide/src/target-feature/features.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/target-feature/inlining.md b/third_party/rust/packed_simd_2/perf-guide/src/target-feature/inlining.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/target-feature/inlining.md
rename to third_party/rust/packed_simd_2/perf-guide/src/target-feature/inlining.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/target-feature/practice.md b/third_party/rust/packed_simd_2/perf-guide/src/target-feature/practice.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/target-feature/practice.md
rename to third_party/rust/packed_simd_2/perf-guide/src/target-feature/practice.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/target-feature/runtime.md b/third_party/rust/packed_simd_2/perf-guide/src/target-feature/runtime.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/target-feature/runtime.md
rename to third_party/rust/packed_simd_2/perf-guide/src/target-feature/runtime.md
diff --git a/third_party/rust/packed_simd/perf-guide/src/target-feature/rustflags.md b/third_party/rust/packed_simd_2/perf-guide/src/target-feature/rustflags.md
similarity index 92%
rename from third_party/rust/packed_simd/perf-guide/src/target-feature/rustflags.md
rename to third_party/rust/packed_simd_2/perf-guide/src/target-feature/rustflags.md
index e2e806e085b6..f4c1d1304aaa 100644
--- a/third_party/rust/packed_simd/perf-guide/src/target-feature/rustflags.md
+++ b/third_party/rust/packed_simd_2/perf-guide/src/target-feature/rustflags.md
@@ -15,7 +15,7 @@ There are two flags which can be used to enable specific vector extensions:
 - Provides the compiler with a comma-separated set of instruction extensions
   to enable.
 
-  **Example**: Use `-C target-features=+sse3,+avx` to enable generating instructions
+  **Example**: Use `-C target-feature=+sse3,+avx` to enable generating instructions
   for [Streaming SIMD Extensions 3](https://en.wikipedia.org/wiki/SSE3) and
   [Advanced Vector Extensions](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions).
 
@@ -33,9 +33,9 @@ There are two flags which can be used to enable specific vector extensions:
 
 - Note that all CPU features are independent, and will have to be enabled individually.
 
-  **Example**: Setting `-C target-features=+avx2` will _not_ enable `fma`, even though
+  **Example**: Setting `-C target-feature=+avx2` will _not_ enable `fma`, even though
   all CPUs which support AVX2 also support FMA. To enable both, one has to use
-  `-C target-features=+avx2,+fma`
+  `-C target-feature=+avx2,+fma`
 
 - Some features also depend on other features, which need to be enabled for the
   target instructions to be generated.
diff --git a/third_party/rust/packed_simd/perf-guide/src/vert-hor-ops.md b/third_party/rust/packed_simd_2/perf-guide/src/vert-hor-ops.md
similarity index 100%
rename from third_party/rust/packed_simd/perf-guide/src/vert-hor-ops.md
rename to third_party/rust/packed_simd_2/perf-guide/src/vert-hor-ops.md
diff --git a/third_party/rust/packed_simd_2/rustfmt.toml b/third_party/rust/packed_simd_2/rustfmt.toml
new file mode 100644
index 000000000000..7316518b9980
--- /dev/null
+++ b/third_party/rust/packed_simd_2/rustfmt.toml
@@ -0,0 +1,5 @@
+max_width = 110
+use_small_heuristics = "Max"
+wrap_comments = true
+edition = "2018"
+error_on_line_overflow = true
\ No newline at end of file
diff --git a/third_party/rust/packed_simd/src/api.rs b/third_party/rust/packed_simd_2/src/api.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api.rs
rename to third_party/rust/packed_simd_2/src/api.rs
diff --git a/third_party/rust/packed_simd/src/api/bit_manip.rs b/third_party/rust/packed_simd_2/src/api/bit_manip.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/bit_manip.rs
rename to third_party/rust/packed_simd_2/src/api/bit_manip.rs
diff --git a/third_party/rust/packed_simd/src/api/bitmask.rs b/third_party/rust/packed_simd_2/src/api/bitmask.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/bitmask.rs
rename to third_party/rust/packed_simd_2/src/api/bitmask.rs
diff --git a/third_party/rust/packed_simd/src/api/cast.rs b/third_party/rust/packed_simd_2/src/api/cast.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/cast.rs
rename to third_party/rust/packed_simd_2/src/api/cast.rs
diff --git a/third_party/rust/packed_simd/src/api/cast/macros.rs b/third_party/rust/packed_simd_2/src/api/cast/macros.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/cast/macros.rs
rename to third_party/rust/packed_simd_2/src/api/cast/macros.rs
diff --git a/third_party/rust/packed_simd_2/src/api/cast/v128.rs b/third_party/rust/packed_simd_2/src/api/cast/v128.rs
new file mode 100644
index 000000000000..2e10b97b7737
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/cast/v128.rs
@@ -0,0 +1,302 @@
+//! `FromCast` and `IntoCast` implementations for portable 128-bit wide vectors
+#[rustfmt::skip]
+
+use crate::*;
+
+impl_from_cast!(i8x16[test_v128]: u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16, m32x16);
+impl_from_cast!(u8x16[test_v128]: i8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16, m32x16);
+impl_from_cast_mask!(m8x16[test_v128]: i8x16, u8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16, m32x16);
+
+impl_from_cast!(
+    i16x8[test_v128]: i8x8,
+    u8x8,
+    m8x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast!(
+    u16x8[test_v128]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast_mask!(
+    m16x8[test_v128]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+
+impl_from_cast!(
+    i32x4[test_v128]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast!(
+    u32x4[test_v128]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast!(
+    f32x4[test_v128]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast_mask!(
+    m32x4[test_v128]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+
+impl_from_cast!(
+    i64x2[test_v128]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast!(
+    u64x2[test_v128]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast!(
+    f64x2[test_v128]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast_mask!(
+    m64x2[test_v128]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+
+impl_from_cast!(
+    isizex2[test_v128]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    usizex2,
+    msizex2
+);
+impl_from_cast!(
+    usizex2[test_v128]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    msizex2
+);
+impl_from_cast_mask!(
+    msizex2[test_v128]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2
+);
+
+// FIXME[test_v128]: 64-bit single element vectors into_cast impls
+impl_from_cast!(i128x1[test_v128]: u128x1, m128x1);
+impl_from_cast!(u128x1[test_v128]: i128x1, m128x1);
+impl_from_cast!(m128x1[test_v128]: i128x1, u128x1);
diff --git a/third_party/rust/packed_simd_2/src/api/cast/v16.rs b/third_party/rust/packed_simd_2/src/api/cast/v16.rs
new file mode 100644
index 000000000000..896febacbb42
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/cast/v16.rs
@@ -0,0 +1,68 @@
+//! `FromCast` and `IntoCast` implementations for portable 16-bit wide vectors
+#[rustfmt::skip]
+
+use crate::*;
+
+impl_from_cast!(
+    i8x2[test_v16]: u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast!(
+    u8x2[test_v16]: i8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast_mask!(
+    m8x2[test_v16]: i8x2,
+    u8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
diff --git a/third_party/rust/packed_simd_2/src/api/cast/v256.rs b/third_party/rust/packed_simd_2/src/api/cast/v256.rs
new file mode 100644
index 000000000000..fe0c835e3c90
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/cast/v256.rs
@@ -0,0 +1,298 @@
+//! `FromCast` and `IntoCast` implementations for portable 256-bit wide vectors
+#[rustfmt::skip]
+
+use crate::*;
+
+impl_from_cast!(i8x32[test_v256]: u8x32, m8x32, i16x32, u16x32, m16x32);
+impl_from_cast!(u8x32[test_v256]: i8x32, m8x32, i16x32, u16x32, m16x32);
+impl_from_cast_mask!(m8x32[test_v256]: i8x32, u8x32, i16x32, u16x32, m16x32);
+
+impl_from_cast!(i16x16[test_v256]: i8x16, u8x16, m8x16, u16x16, m16x16, i32x16, u32x16, f32x16, m32x16);
+impl_from_cast!(u16x16[test_v256]: i8x16, u8x16, m8x16, i16x16, m16x16, i32x16, u32x16, f32x16, m32x16);
+impl_from_cast_mask!(m16x16[test_v256]: i8x16, u8x16, m8x16, i16x16, u16x16, i32x16, u32x16, f32x16, m32x16);
+
+impl_from_cast!(
+    i32x8[test_v256]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast!(
+    u32x8[test_v256]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast!(
+    f32x8[test_v256]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast_mask!(
+    m32x8[test_v256]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+
+impl_from_cast!(
+    i64x4[test_v256]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast!(
+    u64x4[test_v256]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast!(
+    f64x4[test_v256]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast_mask!(
+    m64x4[test_v256]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+
+impl_from_cast!(
+    i128x2[test_v256]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast!(
+    u128x2[test_v256]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast_mask!(
+    m128x2[test_v256]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    m64x2,
+    f64x2,
+    i128x2,
+    u128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+
+impl_from_cast!(
+    isizex4[test_v256]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    usizex4,
+    msizex4
+);
+impl_from_cast!(
+    usizex4[test_v256]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    msizex4
+);
+impl_from_cast_mask!(
+    msizex4[test_v256]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4
+);
diff --git a/third_party/rust/packed_simd_2/src/api/cast/v32.rs b/third_party/rust/packed_simd_2/src/api/cast/v32.rs
new file mode 100644
index 000000000000..4ad1cbf74d2e
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/cast/v32.rs
@@ -0,0 +1,132 @@
+//! `FromCast` and `IntoCast` implementations for portable 32-bit wide vectors
+#[rustfmt::skip]
+
+use crate::*;
+
+impl_from_cast!(
+    i8x4[test_v32]: u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast!(
+    u8x4[test_v32]: i8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast_mask!(
+    m8x4[test_v32]: i8x4,
+    u8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+
+impl_from_cast!(
+    i16x2[test_v32]: i8x2,
+    u8x2,
+    m8x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast!(
+    u16x2[test_v32]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast_mask!(
+    m16x2[test_v32]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
diff --git a/third_party/rust/packed_simd_2/src/api/cast/v512.rs b/third_party/rust/packed_simd_2/src/api/cast/v512.rs
new file mode 100644
index 000000000000..b64605045e33
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/cast/v512.rs
@@ -0,0 +1,209 @@
+//! `FromCast` and `IntoCast` implementations for portable 512-bit wide vectors
+#[rustfmt::skip]
+
+use crate::*;
+
+impl_from_cast!(i8x64[test_v512]: u8x64, m8x64);
+impl_from_cast!(u8x64[test_v512]: i8x64, m8x64);
+impl_from_cast_mask!(m8x64[test_v512]: i8x64, u8x64);
+
+impl_from_cast!(i16x32[test_v512]: i8x32, u8x32, m8x32, u16x32, m16x32);
+impl_from_cast!(u16x32[test_v512]: i8x32, u8x32, m8x32, i16x32, m16x32);
+impl_from_cast_mask!(m16x32[test_v512]: i8x32, u8x32, m8x32, i16x32, u16x32);
+
+impl_from_cast!(i32x16[test_v512]: i8x16, u8x16, m8x16, i16x16, u16x16, m16x16, u32x16, f32x16, m32x16);
+impl_from_cast!(u32x16[test_v512]: i8x16, u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, f32x16, m32x16);
+impl_from_cast!(f32x16[test_v512]: i8x16, u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, m32x16);
+impl_from_cast_mask!(m32x16[test_v512]: i8x16, u8x16, m8x16, i16x16, u16x16, m16x16, i32x16, u32x16, f32x16);
+
+impl_from_cast!(
+    i64x8[test_v512]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast!(
+    u64x8[test_v512]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast!(
+    f64x8[test_v512]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast_mask!(
+    m64x8[test_v512]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+
+impl_from_cast!(
+    i128x4[test_v512]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast!(
+    u128x4[test_v512]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast_mask!(
+    m128x4[test_v512]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    m64x4,
+    f64x4,
+    i128x4,
+    u128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+
+impl_from_cast!(
+    isizex8[test_v512]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    usizex8,
+    msizex8
+);
+impl_from_cast!(
+    usizex8[test_v512]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    msizex8
+);
+impl_from_cast_mask!(
+    msizex8[test_v512]: i8x8,
+    u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8
+);
diff --git a/third_party/rust/packed_simd_2/src/api/cast/v64.rs b/third_party/rust/packed_simd_2/src/api/cast/v64.rs
new file mode 100644
index 000000000000..b23d1a49171f
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/cast/v64.rs
@@ -0,0 +1,208 @@
+//! `FromCast` and `IntoCast` implementations for portable 64-bit wide vectors
+#[rustfmt::skip]
+
+use crate::*;
+
+impl_from_cast!(
+    i8x8[test_v64]: u8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast!(
+    u8x8[test_v64]: i8x8,
+    m8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+impl_from_cast_mask!(
+    m8x8[test_v64]: i8x8,
+    u8x8,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    isizex8,
+    usizex8,
+    msizex8
+);
+
+impl_from_cast!(
+    i16x4[test_v64]: i8x4,
+    u8x4,
+    m8x4,
+    u16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast!(
+    u16x4[test_v64]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    m16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+impl_from_cast_mask!(
+    m16x4[test_v64]: i8x4,
+    u8x4,
+    m8x4,
+    i16x4,
+    u16x4,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x4,
+    u128x4,
+    m128x4,
+    isizex4,
+    usizex4,
+    msizex4
+);
+
+impl_from_cast!(
+    i32x2[test_v64]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    u32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast!(
+    u32x2[test_v64]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    f32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast!(
+    f32x2[test_v64]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    m32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
+impl_from_cast_mask!(
+    m32x2[test_v64]: i8x2,
+    u8x2,
+    m8x2,
+    i16x2,
+    u16x2,
+    m16x2,
+    i32x2,
+    u32x2,
+    f32x2,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x2,
+    u128x2,
+    m128x2,
+    isizex2,
+    usizex2,
+    msizex2
+);
diff --git a/third_party/rust/packed_simd/src/api/cmp.rs b/third_party/rust/packed_simd_2/src/api/cmp.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/cmp.rs
rename to third_party/rust/packed_simd_2/src/api/cmp.rs
diff --git a/third_party/rust/packed_simd/src/api/cmp/eq.rs b/third_party/rust/packed_simd_2/src/api/cmp/eq.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/cmp/eq.rs
rename to third_party/rust/packed_simd_2/src/api/cmp/eq.rs
diff --git a/third_party/rust/packed_simd/src/api/cmp/ord.rs b/third_party/rust/packed_simd_2/src/api/cmp/ord.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/cmp/ord.rs
rename to third_party/rust/packed_simd_2/src/api/cmp/ord.rs
diff --git a/third_party/rust/packed_simd/src/api/cmp/partial_eq.rs b/third_party/rust/packed_simd_2/src/api/cmp/partial_eq.rs
similarity index 97%
rename from third_party/rust/packed_simd/src/api/cmp/partial_eq.rs
rename to third_party/rust/packed_simd_2/src/api/cmp/partial_eq.rs
index 1712a0de56cb..d69dd47425f7 100644
--- a/third_party/rust/packed_simd/src/api/cmp/partial_eq.rs
+++ b/third_party/rust/packed_simd_2/src/api/cmp/partial_eq.rs
@@ -21,9 +21,7 @@ macro_rules! impl_cmp_partial_eq {
 
         // FIXME: https://github.com/rust-lang-nursery/rust-clippy/issues/2892
         #[allow(clippy::partialeq_ne_impl)]
-        impl crate::cmp::PartialEq<LexicographicallyOrdered<$id>>
-            for LexicographicallyOrdered<$id>
-        {
+        impl crate::cmp::PartialEq<LexicographicallyOrdered<$id>> for LexicographicallyOrdered<$id> {
             #[inline]
             fn eq(&self, other: &Self) -> bool {
                 self.0 == other.0
diff --git a/third_party/rust/packed_simd/src/api/cmp/partial_ord.rs b/third_party/rust/packed_simd_2/src/api/cmp/partial_ord.rs
similarity index 98%
rename from third_party/rust/packed_simd/src/api/cmp/partial_ord.rs
rename to third_party/rust/packed_simd_2/src/api/cmp/partial_ord.rs
index a2292918bae1..76ed9ebe4e5a 100644
--- a/third_party/rust/packed_simd/src/api/cmp/partial_ord.rs
+++ b/third_party/rust/packed_simd_2/src/api/cmp/partial_ord.rs
@@ -12,13 +12,9 @@ macro_rules! impl_cmp_partial_ord {
             }
         }
 
-        impl crate::cmp::PartialOrd<LexicographicallyOrdered<$id>>
-            for LexicographicallyOrdered<$id>
-        {
+        impl crate::cmp::PartialOrd<LexicographicallyOrdered<$id>> for LexicographicallyOrdered<$id> {
             #[inline]
-            fn partial_cmp(
-                &self, other: &Self,
-            ) -> Option<crate::cmp::Ordering> {
+            fn partial_cmp(&self, other: &Self) -> Option<crate::cmp::Ordering> {
                 if PartialEq::eq(self, other) {
                     Some(crate::cmp::Ordering::Equal)
                 } else if PartialOrd::lt(self, other) {
diff --git a/third_party/rust/packed_simd/src/api/cmp/vertical.rs b/third_party/rust/packed_simd_2/src/api/cmp/vertical.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/cmp/vertical.rs
rename to third_party/rust/packed_simd_2/src/api/cmp/vertical.rs
diff --git a/third_party/rust/packed_simd/src/api/default.rs b/third_party/rust/packed_simd_2/src/api/default.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/default.rs
rename to third_party/rust/packed_simd_2/src/api/default.rs
diff --git a/third_party/rust/packed_simd/src/api/fmt.rs b/third_party/rust/packed_simd_2/src/api/fmt.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/fmt.rs
rename to third_party/rust/packed_simd_2/src/api/fmt.rs
diff --git a/third_party/rust/packed_simd/src/api/fmt/binary.rs b/third_party/rust/packed_simd_2/src/api/fmt/binary.rs
similarity index 94%
rename from third_party/rust/packed_simd/src/api/fmt/binary.rs
rename to third_party/rust/packed_simd_2/src/api/fmt/binary.rs
index b60769082d51..91c082555908 100644
--- a/third_party/rust/packed_simd/src/api/fmt/binary.rs
+++ b/third_party/rust/packed_simd_2/src/api/fmt/binary.rs
@@ -4,9 +4,7 @@ macro_rules! impl_fmt_binary {
     ([$elem_ty:ident; $elem_count:expr]: $id:ident | $test_tt:tt) => {
         impl crate::fmt::Binary for $id {
             #[allow(clippy::missing_inline_in_public_items)]
-            fn fmt(
-                &self, f: &mut crate::fmt::Formatter<'_>,
-            ) -> crate::fmt::Result {
+            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {
                 write!(f, "{}(", stringify!($id))?;
                 for i in 0..$elem_count {
                     if i > 0 {
diff --git a/third_party/rust/packed_simd/src/api/fmt/debug.rs b/third_party/rust/packed_simd_2/src/api/fmt/debug.rs
similarity index 95%
rename from third_party/rust/packed_simd/src/api/fmt/debug.rs
rename to third_party/rust/packed_simd_2/src/api/fmt/debug.rs
index ad0b8a59a1f0..1e209b3bff77 100644
--- a/third_party/rust/packed_simd/src/api/fmt/debug.rs
+++ b/third_party/rust/packed_simd_2/src/api/fmt/debug.rs
@@ -44,9 +44,7 @@ macro_rules! impl_fmt_debug {
     ([$elem_ty:ty; $elem_count:expr]: $id:ident | $test_tt:tt) => {
         impl crate::fmt::Debug for $id {
             #[allow(clippy::missing_inline_in_public_items)]
-            fn fmt(
-                &self, f: &mut crate::fmt::Formatter<'_>,
-            ) -> crate::fmt::Result {
+            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {
                 write!(f, "{}(", stringify!($id))?;
                 for i in 0..$elem_count {
                     if i > 0 {
diff --git a/third_party/rust/packed_simd/src/api/fmt/lower_hex.rs b/third_party/rust/packed_simd_2/src/api/fmt/lower_hex.rs
similarity index 94%
rename from third_party/rust/packed_simd/src/api/fmt/lower_hex.rs
rename to third_party/rust/packed_simd_2/src/api/fmt/lower_hex.rs
index 5a7aa14b5b8a..8f11d3119b70 100644
--- a/third_party/rust/packed_simd/src/api/fmt/lower_hex.rs
+++ b/third_party/rust/packed_simd_2/src/api/fmt/lower_hex.rs
@@ -4,9 +4,7 @@ macro_rules! impl_fmt_lower_hex {
     ([$elem_ty:ident; $elem_count:expr]: $id:ident | $test_tt:tt) => {
         impl crate::fmt::LowerHex for $id {
             #[allow(clippy::missing_inline_in_public_items)]
-            fn fmt(
-                &self, f: &mut crate::fmt::Formatter<'_>,
-            ) -> crate::fmt::Result {
+            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {
                 write!(f, "{}(", stringify!($id))?;
                 for i in 0..$elem_count {
                     if i > 0 {
diff --git a/third_party/rust/packed_simd/src/api/fmt/octal.rs b/third_party/rust/packed_simd_2/src/api/fmt/octal.rs
similarity index 94%
rename from third_party/rust/packed_simd/src/api/fmt/octal.rs
rename to third_party/rust/packed_simd_2/src/api/fmt/octal.rs
index 83ac8abc7dae..e708e094cee0 100644
--- a/third_party/rust/packed_simd/src/api/fmt/octal.rs
+++ b/third_party/rust/packed_simd_2/src/api/fmt/octal.rs
@@ -4,9 +4,7 @@ macro_rules! impl_fmt_octal {
     ([$elem_ty:ident; $elem_count:expr]: $id:ident | $test_tt:tt) => {
         impl crate::fmt::Octal for $id {
             #[allow(clippy::missing_inline_in_public_items)]
-            fn fmt(
-                &self, f: &mut crate::fmt::Formatter<'_>,
-            ) -> crate::fmt::Result {
+            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {
                 write!(f, "{}(", stringify!($id))?;
                 for i in 0..$elem_count {
                     if i > 0 {
diff --git a/third_party/rust/packed_simd/src/api/fmt/upper_hex.rs b/third_party/rust/packed_simd_2/src/api/fmt/upper_hex.rs
similarity index 94%
rename from third_party/rust/packed_simd/src/api/fmt/upper_hex.rs
rename to third_party/rust/packed_simd_2/src/api/fmt/upper_hex.rs
index aa88f673abf0..5ad455706baa 100644
--- a/third_party/rust/packed_simd/src/api/fmt/upper_hex.rs
+++ b/third_party/rust/packed_simd_2/src/api/fmt/upper_hex.rs
@@ -4,9 +4,7 @@ macro_rules! impl_fmt_upper_hex {
     ([$elem_ty:ident; $elem_count:expr]: $id:ident | $test_tt:tt) => {
         impl crate::fmt::UpperHex for $id {
             #[allow(clippy::missing_inline_in_public_items)]
-            fn fmt(
-                &self, f: &mut crate::fmt::Formatter<'_>,
-            ) -> crate::fmt::Result {
+            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {
                 write!(f, "{}(", stringify!($id))?;
                 for i in 0..$elem_count {
                     if i > 0 {
diff --git a/third_party/rust/packed_simd/src/api/from.rs b/third_party/rust/packed_simd_2/src/api/from.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/from.rs
rename to third_party/rust/packed_simd_2/src/api/from.rs
diff --git a/third_party/rust/packed_simd/src/api/from/from_array.rs b/third_party/rust/packed_simd_2/src/api/from/from_array.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/from/from_array.rs
rename to third_party/rust/packed_simd_2/src/api/from/from_array.rs
diff --git a/third_party/rust/packed_simd/src/api/from/from_vector.rs b/third_party/rust/packed_simd_2/src/api/from/from_vector.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/from/from_vector.rs
rename to third_party/rust/packed_simd_2/src/api/from/from_vector.rs
diff --git a/third_party/rust/packed_simd/src/api/hash.rs b/third_party/rust/packed_simd_2/src/api/hash.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/hash.rs
rename to third_party/rust/packed_simd_2/src/api/hash.rs
diff --git a/third_party/rust/packed_simd/src/api/into_bits.rs b/third_party/rust/packed_simd_2/src/api/into_bits.rs
similarity index 90%
rename from third_party/rust/packed_simd/src/api/into_bits.rs
rename to third_party/rust/packed_simd_2/src/api/into_bits.rs
index f2cc1bae5397..32b6d2ddcee4 100644
--- a/third_party/rust/packed_simd/src/api/into_bits.rs
+++ b/third_party/rust/packed_simd_2/src/api/into_bits.rs
@@ -19,9 +19,7 @@ where
 {
     #[inline]
     fn into_bits(self) -> U {
-        debug_assert!(
-            crate::mem::size_of::<Self>() == crate::mem::size_of::<U>()
-        );
+        debug_assert!(crate::mem::size_of::<Self>() == crate::mem::size_of::<U>());
         U::from_bits(self)
     }
 }
diff --git a/third_party/rust/packed_simd/src/api/into_bits/arch_specific.rs b/third_party/rust/packed_simd_2/src/api/into_bits/arch_specific.rs
similarity index 54%
rename from third_party/rust/packed_simd/src/api/into_bits/arch_specific.rs
rename to third_party/rust/packed_simd_2/src/api/into_bits/arch_specific.rs
index fee6140052f9..bfac915576c3 100644
--- a/third_party/rust/packed_simd/src/api/into_bits/arch_specific.rs
+++ b/third_party/rust/packed_simd_2/src/api/into_bits/arch_specific.rs
@@ -84,15 +84,48 @@ macro_rules! impl_arch {
 // FIXME: 64-bit single element types
 // FIXME: arm/aarch float16x4_t missing
 impl_arch!(
-    [arm["arm"]: int8x8_t, uint8x8_t, poly8x8_t, int16x4_t, uint16x4_t,
-     poly16x4_t, int32x2_t, uint32x2_t, float32x2_t, int64x1_t,
-     uint64x1_t],
-    [aarch64["aarch64"]: int8x8_t, uint8x8_t, poly8x8_t, int16x4_t, uint16x4_t,
-     poly16x4_t, int32x2_t, uint32x2_t, float32x2_t, int64x1_t, uint64x1_t,
-     float64x1_t] |
-    from: i8x8, u8x8, m8x8, i16x4, u16x4, m16x4, i32x2, u32x2, f32x2, m32x2 |
-    into: i8x8, u8x8, i16x4, u16x4, i32x2, u32x2, f32x2 |
-    test: test_v64
+    [
+        arm["arm"]: int8x8_t,
+        uint8x8_t,
+        poly8x8_t,
+        int16x4_t,
+        uint16x4_t,
+        poly16x4_t,
+        int32x2_t,
+        uint32x2_t,
+        float32x2_t,
+        int64x1_t,
+        uint64x1_t
+    ],
+    [
+        aarch64["aarch64"]: int8x8_t,
+        uint8x8_t,
+        poly8x8_t,
+        int16x4_t,
+        uint16x4_t,
+        poly16x4_t,
+        int32x2_t,
+        uint32x2_t,
+        float32x2_t,
+        int64x1_t,
+        uint64x1_t,
+        float64x1_t
+    ] | from: i8x8,
+    u8x8,
+    m8x8,
+    i16x4,
+    u16x4,
+    m16x4,
+    i32x2,
+    u32x2,
+    f32x2,
+    m32x2 | into: i8x8,
+    u8x8,
+    i16x4,
+    u16x4,
+    i32x2,
+    u32x2,
+    f32x2 | test: test_v64
 );
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -108,67 +141,169 @@ impl_arch!(
 // FIXME: ppc64 vector_unsigned___int128 missing
 impl_arch!(
     [x86["x86"]: __m128, __m128i, __m128d],
-    [x86_64["x86_64"]:  __m128, __m128i, __m128d],
-    [arm["arm"]: int8x16_t, uint8x16_t, poly8x16_t, int16x8_t, uint16x8_t,
-     poly16x8_t, int32x4_t, uint32x4_t, float32x4_t, int64x2_t, uint64x2_t],
-    [aarch64["aarch64"]: int8x16_t, uint8x16_t, poly8x16_t, int16x8_t,
-     uint16x8_t, poly16x8_t, int32x4_t, uint32x4_t, float32x4_t, int64x2_t,
-     uint64x2_t, float64x2_t],
-    [powerpc["powerpc"]: vector_signed_char, vector_unsigned_char,
-     vector_signed_short, vector_unsigned_short, vector_signed_int,
-     vector_unsigned_int, vector_float],
-    [powerpc64["powerpc64"]: vector_signed_char, vector_unsigned_char,
-     vector_signed_short, vector_unsigned_short, vector_signed_int,
-     vector_unsigned_int,  vector_float, vector_signed_long,
-     vector_unsigned_long, vector_double] |
-    from: i8x16, u8x16, m8x16, i16x8, u16x8, m16x8, i32x4, u32x4, f32x4, m32x4,
-    i64x2, u64x2, f64x2, m64x2, i128x1, u128x1, m128x1 |
-    into: i8x16, u8x16, i16x8, u16x8, i32x4, u32x4, f32x4, i64x2, u64x2, f64x2,
-    i128x1, u128x1 |
-    test: test_v128
+    [x86_64["x86_64"]: __m128, __m128i, __m128d],
+    [
+        arm["arm"]: int8x16_t,
+        uint8x16_t,
+        poly8x16_t,
+        int16x8_t,
+        uint16x8_t,
+        poly16x8_t,
+        int32x4_t,
+        uint32x4_t,
+        float32x4_t,
+        int64x2_t,
+        uint64x2_t
+    ],
+    [
+        aarch64["aarch64"]: int8x16_t,
+        uint8x16_t,
+        poly8x16_t,
+        int16x8_t,
+        uint16x8_t,
+        poly16x8_t,
+        int32x4_t,
+        uint32x4_t,
+        float32x4_t,
+        int64x2_t,
+        uint64x2_t,
+        float64x2_t
+    ],
+    [
+        powerpc["powerpc"]: vector_signed_char,
+        vector_unsigned_char,
+        vector_signed_short,
+        vector_unsigned_short,
+        vector_signed_int,
+        vector_unsigned_int,
+        vector_float
+    ],
+    [
+        powerpc64["powerpc64"]: vector_signed_char,
+        vector_unsigned_char,
+        vector_signed_short,
+        vector_unsigned_short,
+        vector_signed_int,
+        vector_unsigned_int,
+        vector_float,
+        vector_signed_long,
+        vector_unsigned_long,
+        vector_double
+    ] | from: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1 | into: i8x16,
+    u8x16,
+    i16x8,
+    u16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    i128x1,
+    u128x1 | test: test_v128
 );
 
 impl_arch!(
     [powerpc["powerpc"]: vector_bool_char],
-    [powerpc64["powerpc64"]: vector_bool_char] |
-    from: m8x16, m16x8, m32x4, m64x2, m128x1 |
-    into: i8x16, u8x16, i16x8, u16x8, i32x4, u32x4, f32x4,
-    i64x2, u64x2, f64x2, i128x1, u128x1,
+    [powerpc64["powerpc64"]: vector_bool_char] | from: m8x16,
+    m16x8,
+    m32x4,
+    m64x2,
+    m128x1 | into: i8x16,
+    u8x16,
+    i16x8,
+    u16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    i128x1,
+    u128x1,
     // Masks:
-    m8x16 |
-    test: test_v128
+    m8x16 | test: test_v128
 );
 
 impl_arch!(
     [powerpc["powerpc"]: vector_bool_short],
-    [powerpc64["powerpc64"]: vector_bool_short] |
-    from: m16x8, m32x4, m64x2, m128x1 |
-    into: i8x16, u8x16, i16x8, u16x8, i32x4, u32x4, f32x4,
-    i64x2, u64x2, f64x2, i128x1, u128x1,
+    [powerpc64["powerpc64"]: vector_bool_short] | from: m16x8,
+    m32x4,
+    m64x2,
+    m128x1 | into: i8x16,
+    u8x16,
+    i16x8,
+    u16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    i128x1,
+    u128x1,
     // Masks:
-    m8x16, m16x8 |
-    test: test_v128
+    m8x16,
+    m16x8 | test: test_v128
 );
 
 impl_arch!(
     [powerpc["powerpc"]: vector_bool_int],
-    [powerpc64["powerpc64"]: vector_bool_int] |
-    from: m32x4, m64x2, m128x1 |
-    into: i8x16, u8x16, i16x8, u16x8, i32x4, u32x4, f32x4,
-    i64x2, u64x2, f64x2, i128x1, u128x1,
+    [powerpc64["powerpc64"]: vector_bool_int] | from: m32x4,
+    m64x2,
+    m128x1 | into: i8x16,
+    u8x16,
+    i16x8,
+    u16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    i128x1,
+    u128x1,
     // Masks:
-    m8x16, m16x8, m32x4 |
-    test: test_v128
+    m8x16,
+    m16x8,
+    m32x4 | test: test_v128
 );
 
 impl_arch!(
-    [powerpc64["powerpc64"]: vector_bool_long] |
-    from: m64x2, m128x1 |
-    into: i8x16, u8x16, i16x8, u16x8, i32x4, u32x4, f32x4,
-    i64x2, u64x2, f64x2, i128x1, u128x1,
+    [powerpc64["powerpc64"]: vector_bool_long] | from: m64x2,
+    m128x1 | into: i8x16,
+    u8x16,
+    i16x8,
+    u16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    i128x1,
+    u128x1,
     // Masks:
-    m8x16, m16x8, m32x4, m64x2 |
-    test: test_v128
+    m8x16,
+    m16x8,
+    m32x4,
+    m64x2 | test: test_v128
 );
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -176,13 +311,34 @@ impl_arch!(
 
 impl_arch!(
     [x86["x86"]: __m256, __m256i, __m256d],
-    [x86_64["x86_64"]:  __m256, __m256i, __m256d] |
-    from: i8x32, u8x32, m8x32, i16x16, u16x16, m16x16,
-    i32x8, u32x8, f32x8, m32x8,
-    i64x4, u64x4, f64x4, m64x4, i128x2, u128x2, m128x2 |
-    into: i8x32, u8x32, i16x16, u16x16, i32x8, u32x8, f32x8,
-    i64x4, u64x4, f64x4, i128x2, u128x2 |
-    test: test_v256
+    [x86_64["x86_64"]: __m256, __m256i, __m256d] | from: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2 | into: i8x32,
+    u8x32,
+    i16x16,
+    u16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    i128x2,
+    u128x2 | test: test_v256
 );
 
 ////////////////////////////////////////////////////////////////////////////////
diff --git a/third_party/rust/packed_simd/src/api/into_bits/macros.rs b/third_party/rust/packed_simd_2/src/api/into_bits/macros.rs
similarity index 97%
rename from third_party/rust/packed_simd/src/api/into_bits/macros.rs
rename to third_party/rust/packed_simd_2/src/api/into_bits/macros.rs
index 8cec5b00479f..265ab34ae0f3 100644
--- a/third_party/rust/packed_simd/src/api/into_bits/macros.rs
+++ b/third_party/rust/packed_simd_2/src/api/into_bits/macros.rs
@@ -24,7 +24,7 @@ macro_rules! impl_from_bits_ {
                         use crate::IntoBits;
                         assert_eq!(size_of::<$id>(),
                                    size_of::<$from_ty>());
-                        // This is safe becasue we never create a reference to
+                        // This is safe because we never create a reference to
                         // uninitialized memory:
                         let a: $from_ty = unsafe { zeroed() };
 
diff --git a/third_party/rust/packed_simd_2/src/api/into_bits/v128.rs b/third_party/rust/packed_simd_2/src/api/into_bits/v128.rs
new file mode 100644
index 000000000000..639c09c2c4bd
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/into_bits/v128.rs
@@ -0,0 +1,232 @@
+//! `FromBits` and `IntoBits` implementations for portable 128-bit wide vectors
+#[rustfmt::skip]
+
+#[allow(unused)]  // wasm_bindgen_test
+use crate::*;
+
+impl_from_bits!(
+    i8x16[test_v128]: u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(
+    u8x16[test_v128]: i8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(m8x16[test_v128]: m16x8, m32x4, m64x2, m128x1);
+
+impl_from_bits!(
+    i16x8[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(
+    u16x8[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(m16x8[test_v128]: m32x4, m64x2, m128x1);
+
+impl_from_bits!(
+    i32x4[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(
+    u32x4[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(
+    f32x4[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(m32x4[test_v128]: m64x2, m128x1);
+
+impl_from_bits!(
+    i64x2[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(
+    u64x2[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(
+    f64x2[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    m64x2,
+    i128x1,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(m64x2[test_v128]: m128x1);
+
+impl_from_bits!(
+    i128x1[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    u128x1,
+    m128x1
+);
+impl_from_bits!(
+    u128x1[test_v128]: i8x16,
+    u8x16,
+    m8x16,
+    i16x8,
+    u16x8,
+    m16x8,
+    i32x4,
+    u32x4,
+    f32x4,
+    m32x4,
+    i64x2,
+    u64x2,
+    f64x2,
+    m64x2,
+    i128x1,
+    m128x1
+);
+// note: m128x1 cannot be constructed from all the other masks bit patterns in
+// here
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v16.rs b/third_party/rust/packed_simd_2/src/api/into_bits/v16.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/into_bits/v16.rs
rename to third_party/rust/packed_simd_2/src/api/into_bits/v16.rs
diff --git a/third_party/rust/packed_simd_2/src/api/into_bits/v256.rs b/third_party/rust/packed_simd_2/src/api/into_bits/v256.rs
new file mode 100644
index 000000000000..e432bbbc9f05
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/into_bits/v256.rs
@@ -0,0 +1,232 @@
+//! `FromBits` and `IntoBits` implementations for portable 256-bit wide vectors
+#[rustfmt::skip]
+
+#[allow(unused)]  // wasm_bindgen_test
+use crate::*;
+
+impl_from_bits!(
+    i8x32[test_v256]: u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(
+    u8x32[test_v256]: i8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(m8x32[test_v256]: m16x16, m32x8, m64x4, m128x2);
+
+impl_from_bits!(
+    i16x16[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(
+    u16x16[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(m16x16[test_v256]: m32x8, m64x4, m128x2);
+
+impl_from_bits!(
+    i32x8[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(
+    u32x8[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(
+    f32x8[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(m32x8[test_v256]: m64x4, m128x2);
+
+impl_from_bits!(
+    i64x4[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(
+    u64x4[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(
+    f64x4[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    m64x4,
+    i128x2,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(m64x4[test_v256]: m128x2);
+
+impl_from_bits!(
+    i128x2[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    u128x2,
+    m128x2
+);
+impl_from_bits!(
+    u128x2[test_v256]: i8x32,
+    u8x32,
+    m8x32,
+    i16x16,
+    u16x16,
+    m16x16,
+    i32x8,
+    u32x8,
+    f32x8,
+    m32x8,
+    i64x4,
+    u64x4,
+    f64x4,
+    m64x4,
+    i128x2,
+    m128x2
+);
+// note: m128x2 cannot be constructed from all the other masks bit patterns in
+// here
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v32.rs b/third_party/rust/packed_simd_2/src/api/into_bits/v32.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/into_bits/v32.rs
rename to third_party/rust/packed_simd_2/src/api/into_bits/v32.rs
diff --git a/third_party/rust/packed_simd_2/src/api/into_bits/v512.rs b/third_party/rust/packed_simd_2/src/api/into_bits/v512.rs
new file mode 100644
index 000000000000..f6e9bb8bf7a3
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/api/into_bits/v512.rs
@@ -0,0 +1,232 @@
+//! `FromBits` and `IntoBits` implementations for portable 512-bit wide vectors
+#[rustfmt::skip]
+
+#[allow(unused)]  // wasm_bindgen_test
+use crate::*;
+
+impl_from_bits!(
+    i8x64[test_v512]: u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(
+    u8x64[test_v512]: i8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(m8x64[test_v512]: m16x32, m32x16, m64x8, m128x4);
+
+impl_from_bits!(
+    i16x32[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(
+    u16x32[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(m16x32[test_v512]: m32x16, m64x8, m128x4);
+
+impl_from_bits!(
+    i32x16[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(
+    u32x16[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(
+    f32x16[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(m32x16[test_v512]: m64x8, m128x4);
+
+impl_from_bits!(
+    i64x8[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(
+    u64x8[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(
+    f64x8[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    m64x8,
+    i128x4,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(m64x8[test_v512]: m128x4);
+
+impl_from_bits!(
+    i128x4[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    u128x4,
+    m128x4
+);
+impl_from_bits!(
+    u128x4[test_v512]: i8x64,
+    u8x64,
+    m8x64,
+    i16x32,
+    u16x32,
+    m16x32,
+    i32x16,
+    u32x16,
+    f32x16,
+    m32x16,
+    i64x8,
+    u64x8,
+    f64x8,
+    m64x8,
+    i128x4,
+    m128x4
+);
+// note: m128x4 cannot be constructed from all the other masks bit patterns in
+// here
diff --git a/third_party/rust/packed_simd/src/api/into_bits/v64.rs b/third_party/rust/packed_simd_2/src/api/into_bits/v64.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/into_bits/v64.rs
rename to third_party/rust/packed_simd_2/src/api/into_bits/v64.rs
diff --git a/third_party/rust/packed_simd/src/api/math.rs b/third_party/rust/packed_simd_2/src/api/math.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math.rs
rename to third_party/rust/packed_simd_2/src/api/math.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float.rs b/third_party/rust/packed_simd_2/src/api/math/float.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float.rs
rename to third_party/rust/packed_simd_2/src/api/math/float.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/abs.rs b/third_party/rust/packed_simd_2/src/api/math/float/abs.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/abs.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/abs.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/consts.rs b/third_party/rust/packed_simd_2/src/api/math/float/consts.rs
similarity index 57%
rename from third_party/rust/packed_simd/src/api/math/float/consts.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/consts.rs
index 89f93a6d692b..7f41acbf1b51 100644
--- a/third_party/rust/packed_simd/src/api/math/float/consts.rs
+++ b/third_party/rust/packed_simd_2/src/api/math/float/consts.rs
@@ -8,8 +8,7 @@ macro_rules! impl_float_consts {
             pub const MIN: $id = $id::splat(core::$elem_ty::MIN);
 
             /// Smallest positive normal value.
-            pub const MIN_POSITIVE: $id =
-                $id::splat(core::$elem_ty::MIN_POSITIVE);
+            pub const MIN_POSITIVE: $id = $id::splat(core::$elem_ty::MIN_POSITIVE);
 
             /// Largest finite value.
             pub const MAX: $id = $id::splat(core::$elem_ty::MAX);
@@ -21,50 +20,40 @@ macro_rules! impl_float_consts {
             pub const INFINITY: $id = $id::splat(core::$elem_ty::INFINITY);
 
             /// Negative infinity (-).
-            pub const NEG_INFINITY: $id =
-                $id::splat(core::$elem_ty::NEG_INFINITY);
+            pub const NEG_INFINITY: $id = $id::splat(core::$elem_ty::NEG_INFINITY);
 
             /// Archimedes' constant ()
             pub const PI: $id = $id::splat(core::$elem_ty::consts::PI);
 
             /// /2
-            pub const FRAC_PI_2: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_PI_2);
+            pub const FRAC_PI_2: $id = $id::splat(core::$elem_ty::consts::FRAC_PI_2);
 
             /// /3
-            pub const FRAC_PI_3: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_PI_3);
+            pub const FRAC_PI_3: $id = $id::splat(core::$elem_ty::consts::FRAC_PI_3);
 
             /// /4
-            pub const FRAC_PI_4: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_PI_4);
+            pub const FRAC_PI_4: $id = $id::splat(core::$elem_ty::consts::FRAC_PI_4);
 
             /// /6
-            pub const FRAC_PI_6: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_PI_6);
+            pub const FRAC_PI_6: $id = $id::splat(core::$elem_ty::consts::FRAC_PI_6);
 
             /// /8
-            pub const FRAC_PI_8: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_PI_8);
+            pub const FRAC_PI_8: $id = $id::splat(core::$elem_ty::consts::FRAC_PI_8);
 
             /// 1/
-            pub const FRAC_1_PI: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_1_PI);
+            pub const FRAC_1_PI: $id = $id::splat(core::$elem_ty::consts::FRAC_1_PI);
 
             /// 2/
-            pub const FRAC_2_PI: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_2_PI);
+            pub const FRAC_2_PI: $id = $id::splat(core::$elem_ty::consts::FRAC_2_PI);
 
             /// 2/sqrt()
-            pub const FRAC_2_SQRT_PI: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_2_SQRT_PI);
+            pub const FRAC_2_SQRT_PI: $id = $id::splat(core::$elem_ty::consts::FRAC_2_SQRT_PI);
 
             /// sqrt(2)
             pub const SQRT_2: $id = $id::splat(core::$elem_ty::consts::SQRT_2);
 
             /// 1/sqrt(2)
-            pub const FRAC_1_SQRT_2: $id =
-                $id::splat(core::$elem_ty::consts::FRAC_1_SQRT_2);
+            pub const FRAC_1_SQRT_2: $id = $id::splat(core::$elem_ty::consts::FRAC_1_SQRT_2);
 
             /// Euler's number (e)
             pub const E: $id = $id::splat(core::$elem_ty::consts::E);
@@ -73,8 +62,7 @@ macro_rules! impl_float_consts {
             pub const LOG2_E: $id = $id::splat(core::$elem_ty::consts::LOG2_E);
 
             /// log<sub>10</sub>(e)
-            pub const LOG10_E: $id =
-                $id::splat(core::$elem_ty::consts::LOG10_E);
+            pub const LOG10_E: $id = $id::splat(core::$elem_ty::consts::LOG10_E);
 
             /// ln(2)
             pub const LN_2: $id = $id::splat(core::$elem_ty::consts::LN_2);
diff --git a/third_party/rust/packed_simd/src/api/math/float/cos.rs b/third_party/rust/packed_simd_2/src/api/math/float/cos.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/cos.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/cos.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/exp.rs b/third_party/rust/packed_simd_2/src/api/math/float/exp.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/exp.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/exp.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/ln.rs b/third_party/rust/packed_simd_2/src/api/math/float/ln.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/ln.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/ln.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/mul_add.rs b/third_party/rust/packed_simd_2/src/api/math/float/mul_add.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/mul_add.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/mul_add.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/mul_adde.rs b/third_party/rust/packed_simd_2/src/api/math/float/mul_adde.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/mul_adde.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/mul_adde.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/powf.rs b/third_party/rust/packed_simd_2/src/api/math/float/powf.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/powf.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/powf.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/recpre.rs b/third_party/rust/packed_simd_2/src/api/math/float/recpre.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/recpre.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/recpre.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/rsqrte.rs b/third_party/rust/packed_simd_2/src/api/math/float/rsqrte.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/rsqrte.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/rsqrte.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/sin.rs b/third_party/rust/packed_simd_2/src/api/math/float/sin.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/sin.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/sin.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/sqrt.rs b/third_party/rust/packed_simd_2/src/api/math/float/sqrt.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/sqrt.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/sqrt.rs
diff --git a/third_party/rust/packed_simd/src/api/math/float/sqrte.rs b/third_party/rust/packed_simd_2/src/api/math/float/sqrte.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/math/float/sqrte.rs
rename to third_party/rust/packed_simd_2/src/api/math/float/sqrte.rs
diff --git a/third_party/rust/packed_simd/src/api/minimal.rs b/third_party/rust/packed_simd_2/src/api/minimal.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/minimal.rs
rename to third_party/rust/packed_simd_2/src/api/minimal.rs
diff --git a/third_party/rust/packed_simd/src/api/minimal/iuf.rs b/third_party/rust/packed_simd_2/src/api/minimal/iuf.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/minimal/iuf.rs
rename to third_party/rust/packed_simd_2/src/api/minimal/iuf.rs
diff --git a/third_party/rust/packed_simd/src/api/minimal/mask.rs b/third_party/rust/packed_simd_2/src/api/minimal/mask.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/minimal/mask.rs
rename to third_party/rust/packed_simd_2/src/api/minimal/mask.rs
diff --git a/third_party/rust/packed_simd/src/api/minimal/ptr.rs b/third_party/rust/packed_simd_2/src/api/minimal/ptr.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/minimal/ptr.rs
rename to third_party/rust/packed_simd_2/src/api/minimal/ptr.rs
diff --git a/third_party/rust/packed_simd/src/api/ops.rs b/third_party/rust/packed_simd_2/src/api/ops.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops.rs
rename to third_party/rust/packed_simd_2/src/api/ops.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/scalar_arithmetic.rs b/third_party/rust/packed_simd_2/src/api/ops/scalar_arithmetic.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/scalar_arithmetic.rs
rename to third_party/rust/packed_simd_2/src/api/ops/scalar_arithmetic.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/scalar_bitwise.rs b/third_party/rust/packed_simd_2/src/api/ops/scalar_bitwise.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/scalar_bitwise.rs
rename to third_party/rust/packed_simd_2/src/api/ops/scalar_bitwise.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/scalar_mask_bitwise.rs b/third_party/rust/packed_simd_2/src/api/ops/scalar_mask_bitwise.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/scalar_mask_bitwise.rs
rename to third_party/rust/packed_simd_2/src/api/ops/scalar_mask_bitwise.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/scalar_shifts.rs b/third_party/rust/packed_simd_2/src/api/ops/scalar_shifts.rs
similarity index 94%
rename from third_party/rust/packed_simd/src/api/ops/scalar_shifts.rs
rename to third_party/rust/packed_simd_2/src/api/ops/scalar_shifts.rs
index 9c164ad56c0b..4a7a096263d0 100644
--- a/third_party/rust/packed_simd/src/api/ops/scalar_shifts.rs
+++ b/third_party/rust/packed_simd_2/src/api/ops/scalar_shifts.rs
@@ -36,11 +36,10 @@ macro_rules! impl_ops_scalar_shifts {
                     use super::*;
                     #[cfg_attr(not(target_arch = "wasm32"), test)] #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
                     #[cfg_attr(any(target_arch = "s390x", target_arch = "sparc64"),
-                               allow(unreachable_code,
-                                     unused_variables,
-                                     unused_mut)
+                               allow(unreachable_code, unused_variables)
                     )]
-                    // ^^^ FIXME: https://github.com/rust-lang/rust/issues/55344
+                    #[cfg(not(target_arch = "aarch64"))]
+                    //~^ FIXME: https://github.com/rust-lang/packed_simd/issues/317
                     fn ops_scalar_shifts() {
                         let z = $id::splat(0 as $elem_ty);
                         let o = $id::splat(1 as $elem_ty);
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_arithmetic.rs b/third_party/rust/packed_simd_2/src/api/ops/vector_arithmetic.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/vector_arithmetic.rs
rename to third_party/rust/packed_simd_2/src/api/ops/vector_arithmetic.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_bitwise.rs b/third_party/rust/packed_simd_2/src/api/ops/vector_bitwise.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/vector_bitwise.rs
rename to third_party/rust/packed_simd_2/src/api/ops/vector_bitwise.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_float_min_max.rs b/third_party/rust/packed_simd_2/src/api/ops/vector_float_min_max.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/vector_float_min_max.rs
rename to third_party/rust/packed_simd_2/src/api/ops/vector_float_min_max.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_int_min_max.rs b/third_party/rust/packed_simd_2/src/api/ops/vector_int_min_max.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/vector_int_min_max.rs
rename to third_party/rust/packed_simd_2/src/api/ops/vector_int_min_max.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_mask_bitwise.rs b/third_party/rust/packed_simd_2/src/api/ops/vector_mask_bitwise.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/vector_mask_bitwise.rs
rename to third_party/rust/packed_simd_2/src/api/ops/vector_mask_bitwise.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_neg.rs b/third_party/rust/packed_simd_2/src/api/ops/vector_neg.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ops/vector_neg.rs
rename to third_party/rust/packed_simd_2/src/api/ops/vector_neg.rs
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_rotates.rs b/third_party/rust/packed_simd_2/src/api/ops/vector_rotates.rs
similarity index 96%
rename from third_party/rust/packed_simd/src/api/ops/vector_rotates.rs
rename to third_party/rust/packed_simd_2/src/api/ops/vector_rotates.rs
index 6c794ecf4b93..147fc2e37d1f 100644
--- a/third_party/rust/packed_simd/src/api/ops/vector_rotates.rs
+++ b/third_party/rust/packed_simd_2/src/api/ops/vector_rotates.rs
@@ -47,6 +47,8 @@ macro_rules! impl_ops_vector_rotates {
                 pub mod [<$id _ops_vector_rotate>] {
                     use super::*;
                     #[cfg_attr(not(target_arch = "wasm32"), test)] #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
+                    #[cfg(not(target_arch = "aarch64"))]
+                    //~^ FIXME: https://github.com/rust-lang/packed_simd/issues/317
                     fn rotate_ops() {
                         let z = $id::splat(0 as $elem_ty);
                         let o = $id::splat(1 as $elem_ty);
diff --git a/third_party/rust/packed_simd/src/api/ops/vector_shifts.rs b/third_party/rust/packed_simd_2/src/api/ops/vector_shifts.rs
similarity index 94%
rename from third_party/rust/packed_simd/src/api/ops/vector_shifts.rs
rename to third_party/rust/packed_simd_2/src/api/ops/vector_shifts.rs
index 22e1fbc0ec76..8bb5ac2fc03a 100644
--- a/third_party/rust/packed_simd/src/api/ops/vector_shifts.rs
+++ b/third_party/rust/packed_simd_2/src/api/ops/vector_shifts.rs
@@ -37,11 +37,10 @@ macro_rules! impl_ops_vector_shifts {
                     use super::*;
                     #[cfg_attr(not(target_arch = "wasm32"), test)] #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
                     #[cfg_attr(any(target_arch = "s390x", target_arch = "sparc64"),
-                               allow(unreachable_code,
-                                     unused_variables,
-                                     unused_mut)
+                               allow(unreachable_code, unused_variables)
                     )]
-                    // ^^^ FIXME: https://github.com/rust-lang/rust/issues/55344
+                    #[cfg(not(target_arch = "aarch64"))]
+                    //~^ FIXME: https://github.com/rust-lang/packed_simd/issues/317
                     fn ops_vector_shifts() {
                         let z = $id::splat(0 as $elem_ty);
                         let o = $id::splat(1 as $elem_ty);
diff --git a/third_party/rust/packed_simd/src/api/ptr.rs b/third_party/rust/packed_simd_2/src/api/ptr.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/ptr.rs
rename to third_party/rust/packed_simd_2/src/api/ptr.rs
diff --git a/third_party/rust/packed_simd/src/api/ptr/gather_scatter.rs b/third_party/rust/packed_simd_2/src/api/ptr/gather_scatter.rs
similarity index 94%
rename from third_party/rust/packed_simd/src/api/ptr/gather_scatter.rs
rename to third_party/rust/packed_simd_2/src/api/ptr/gather_scatter.rs
index 430435620939..374482ac31c6 100644
--- a/third_party/rust/packed_simd/src/api/ptr/gather_scatter.rs
+++ b/third_party/rust/packed_simd_2/src/api/ptr/gather_scatter.rs
@@ -22,7 +22,8 @@ macro_rules! impl_ptr_read {
             /// pointers must be aligned to `mem::align_of::<T>()`.
             #[inline]
             pub unsafe fn read<M>(
-                self, mask: Simd<[M; $elem_count]>,
+                self,
+                mask: Simd<[M; $elem_count]>,
                 value: Simd<[T; $elem_count]>,
             ) -> Simd<[T; $elem_count]>
             where
@@ -128,10 +129,8 @@ macro_rules! impl_ptr_write {
             /// This method is unsafe because it dereferences raw pointers. The
             /// pointers must be aligned to `mem::align_of::<T>()`.
             #[inline]
-            pub unsafe fn write<M>(
-                self, mask: Simd<[M; $elem_count]>,
-                value: Simd<[T; $elem_count]>,
-            ) where
+            pub unsafe fn write<M>(self, mask: Simd<[M; $elem_count]>, value: Simd<[T; $elem_count]>)
+            where
                 M: sealed::Mask,
                 [M; $elem_count]: sealed::SimdArray,
             {
@@ -147,8 +146,8 @@ macro_rules! impl_ptr_write {
                     use super::*;
                     #[test]
                     fn write() {
-                        // fourty_two = [42, 42, 42, ...]
-                        let fourty_two
+                        // forty_two = [42, 42, 42, ...]
+                        let forty_two
                             = Simd::<[i32; $elem_count]>::splat(42_i32);
 
                         // This test will write to this array
@@ -166,11 +165,11 @@ macro_rules! impl_ptr_write {
                         }
                         // ptr = [&arr[0], &arr[1], ...]
 
-                        // write `fourty_two` to all elements of `v`
+                        // write `forty_two` to all elements of `v`
                         {
                             let backup = arr;
                             unsafe {
-                                ptr.write($mask_ty::splat(true), fourty_two)
+                                ptr.write($mask_ty::splat(true), forty_two)
                             };
                             assert_eq!(arr, [42_i32; $elem_count]);
                             arr = backup;  // arr = [0, 1, 2, ...]
@@ -196,7 +195,7 @@ macro_rules! impl_ptr_write {
                             }
 
                             let backup = arr;
-                            unsafe { ptr.write(mask, fourty_two) };
+                            unsafe { ptr.write(mask, forty_two) };
                             assert_eq!(arr, r);
                             arr = backup;  // arr = [0, 1, 2, 3, ...]
                         }
@@ -205,7 +204,7 @@ macro_rules! impl_ptr_write {
                         {
                             let backup = arr;
                             unsafe {
-                                ptr.write($mask_ty::splat(false), fourty_two)
+                                ptr.write($mask_ty::splat(false), forty_two)
                             };
                             assert_eq!(arr, backup);
                         }
diff --git a/third_party/rust/packed_simd/src/api/reductions.rs b/third_party/rust/packed_simd_2/src/api/reductions.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/reductions.rs
rename to third_party/rust/packed_simd_2/src/api/reductions.rs
diff --git a/third_party/rust/packed_simd/src/api/reductions/bitwise.rs b/third_party/rust/packed_simd_2/src/api/reductions/bitwise.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/reductions/bitwise.rs
rename to third_party/rust/packed_simd_2/src/api/reductions/bitwise.rs
diff --git a/third_party/rust/packed_simd/src/api/reductions/float_arithmetic.rs b/third_party/rust/packed_simd_2/src/api/reductions/float_arithmetic.rs
similarity index 97%
rename from third_party/rust/packed_simd/src/api/reductions/float_arithmetic.rs
rename to third_party/rust/packed_simd_2/src/api/reductions/float_arithmetic.rs
index 4a47452e5006..9dc8783dbbf6 100644
--- a/third_party/rust/packed_simd/src/api/reductions/float_arithmetic.rs
+++ b/third_party/rust/packed_simd_2/src/api/reductions/float_arithmetic.rs
@@ -144,8 +144,6 @@ macro_rules! impl_reduction_float_arithmetic {
                     #[cfg_attr(not(target_arch = "wasm32"), test)]
                     #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
                     #[allow(unreachable_code)]
-                    #[allow(unused_mut)]
-                    // ^^^ FIXME: https://github.com/rust-lang/rust/issues/55344
                     fn sum_nan() {
                         // FIXME: https://bugs.llvm.org/show_bug.cgi?id=36732
                         // https://github.com/rust-lang-nursery/packed_simd/issues/6
@@ -175,8 +173,6 @@ macro_rules! impl_reduction_float_arithmetic {
                     #[cfg_attr(not(target_arch = "wasm32"), test)]
                     #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
                     #[allow(unreachable_code)]
-                    #[allow(unused_mut)]
-                    // ^^^ FIXME: https://github.com/rust-lang/rust/issues/55344
                     fn product_nan() {
                         // FIXME: https://bugs.llvm.org/show_bug.cgi?id=36732
                         // https://github.com/rust-lang-nursery/packed_simd/issues/6
@@ -247,7 +243,7 @@ macro_rules! impl_reduction_float_arithmetic {
                                 tree_bits - red_bits
                             } < 2,
                             "vector: {:?} | simd_reduction: {:?} | \
-                             tree_reduction: {} | scalar_reduction: {}",
+tree_reduction: {} | scalar_reduction: {}",
                             v,
                             simd_reduction,
                             tree_reduction,
@@ -303,7 +299,7 @@ macro_rules! impl_reduction_float_arithmetic {
                                 tree_bits - red_bits
                             } < ulp_limit.try_into().unwrap(),
                             "vector: {:?} | simd_reduction: {:?} | \
-                             tree_reduction: {} | scalar_reduction: {}",
+tree_reduction: {} | scalar_reduction: {}",
                             v,
                             simd_reduction,
                             tree_reduction,
diff --git a/third_party/rust/packed_simd/src/api/reductions/integer_arithmetic.rs b/third_party/rust/packed_simd_2/src/api/reductions/integer_arithmetic.rs
similarity index 96%
rename from third_party/rust/packed_simd/src/api/reductions/integer_arithmetic.rs
rename to third_party/rust/packed_simd_2/src/api/reductions/integer_arithmetic.rs
index 91dffad31032..e99e6cb5d796 100644
--- a/third_party/rust/packed_simd/src/api/reductions/integer_arithmetic.rs
+++ b/third_party/rust/packed_simd_2/src/api/reductions/integer_arithmetic.rs
@@ -18,9 +18,7 @@ macro_rules! impl_reduction_integer_arithmetic {
                 #[cfg(not(target_arch = "aarch64"))]
                 {
                     use crate::llvm::simd_reduce_add_ordered;
-                    let v: $ielem_ty = unsafe {
-                        simd_reduce_add_ordered(self.0, 0 as $ielem_ty)
-                    };
+                    let v: $ielem_ty = unsafe { simd_reduce_add_ordered(self.0, 0 as $ielem_ty) };
                     v as $elem_ty
                 }
                 #[cfg(target_arch = "aarch64")]
@@ -49,9 +47,7 @@ macro_rules! impl_reduction_integer_arithmetic {
                 #[cfg(not(target_arch = "aarch64"))]
                 {
                     use crate::llvm::simd_reduce_mul_ordered;
-                    let v: $ielem_ty = unsafe {
-                        simd_reduce_mul_ordered(self.0, 1 as $ielem_ty)
-                    };
+                    let v: $ielem_ty = unsafe { simd_reduce_mul_ordered(self.0, 1 as $ielem_ty) };
                     v as $elem_ty
                 }
                 #[cfg(target_arch = "aarch64")]
diff --git a/third_party/rust/packed_simd/src/api/reductions/mask.rs b/third_party/rust/packed_simd_2/src/api/reductions/mask.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/reductions/mask.rs
rename to third_party/rust/packed_simd_2/src/api/reductions/mask.rs
diff --git a/third_party/rust/packed_simd/src/api/reductions/min_max.rs b/third_party/rust/packed_simd_2/src/api/reductions/min_max.rs
similarity index 86%
rename from third_party/rust/packed_simd/src/api/reductions/min_max.rs
rename to third_party/rust/packed_simd_2/src/api/reductions/min_max.rs
index c4c1400a8fc4..a3ce13a45123 100644
--- a/third_party/rust/packed_simd/src/api/reductions/min_max.rs
+++ b/third_party/rust/packed_simd_2/src/api/reductions/min_max.rs
@@ -123,7 +123,7 @@ macro_rules! impl_reduction_min_max {
 
 macro_rules! test_reduction_float_min_max {
     ([$elem_ty:ident; $elem_count:expr]: $id:ident | $test_tt:tt) => {
-        test_if!{
+        test_if! {
             $test_tt:
             paste::item! {
                 // Comparisons use integer casts within mantissa^1 range.
@@ -160,20 +160,7 @@ macro_rules! test_reduction_float_min_max {
                             // targets:
                             if i == $id::lanes() - 1 &&
                                 target_with_broken_last_lane_nan {
-                                // FIXME:
-                                // https://github.com/rust-lang-nursery/packed_simd/issues/5
-                                //
-                                // If there is a NaN, the result should always
-                                // the smallest element, but currently when the
-                                // last element is NaN the current
-                                // implementation incorrectly returns NaN.
-                                //
-                                // The targets mentioned above use different
-                                // codegen that produces the correct result.
-                                //
-                                // These asserts detect if this behavior changes
-                                    assert!(v.min_element().is_nan(),
-                                            // FIXME: ^^^ should be -3.
+                                    assert_eq!(v.min_element(), -3.,
                                             "[A]: nan at {} => {} | {:?}",
                                             i, v.min_element(), v);
 
@@ -181,14 +168,17 @@ macro_rules! test_reduction_float_min_max {
                                 // up-to the `i-th` lane with `NaN`s, the result
                                 // is still always `-3.` unless all elements of
                                 // the vector are `NaN`s:
-                                //
-                                // This is also broken:
                                 for j in 0..i {
                                     v = v.replace(j, n);
-                                    assert!(v.min_element().is_nan(),
-                                            // FIXME: ^^^ should be -3.
+                                    if j == i-1 {
+                                        assert!(v.min_element().is_nan(),
+                                            "[B]: nan at {} => {} | {:?}",
+                                            i, v.min_element(), v);
+                                    } else {
+                                        assert_eq!(v.min_element(), -3.,
                                             "[B]: nan at {} => {} | {:?}",
                                             i, v.min_element(), v);
+                                    }
                                 }
 
                                 // We are done here, since we were in the last
@@ -203,7 +193,7 @@ macro_rules! test_reduction_float_min_max {
                             if $id::lanes() == 1 {
                                 assert!(v.min_element().is_nan(),
                                         "[C]: all nans | v={:?} | min={} | \
-                                         is_nan: {}",
+is_nan: {}",
                                         v, v.min_element(),
                                         v.min_element().is_nan()
                                 );
@@ -235,7 +225,7 @@ macro_rules! test_reduction_float_min_max {
                                     // "i - 1" does not overflow.
                                     assert!(v.min_element().is_nan(),
                                             "[E]: all nans | v={:?} | min={} | \
-                                             is_nan: {}",
+is_nan: {}",
                                             v, v.min_element(),
                                             v.min_element().is_nan());
                                 } else {
@@ -280,21 +270,7 @@ macro_rules! test_reduction_float_min_max {
                             // targets:
                             if i == $id::lanes() - 1 &&
                               target_with_broken_last_lane_nan {
-                                // FIXME:
-                                // https://github.com/rust-lang-nursery/packed_simd/issues/5
-                                //
-                                // If there is a NaN, the result should
-                                // always the largest element, but currently
-                                // when the last element is NaN the current
-                                // implementation incorrectly returns NaN.
-                                //
-                                // The targets mentioned above use different
-                                // codegen that produces the correct result.
-                                //
-                                // These asserts detect if this behavior
-                                // changes
-                                assert!(v.max_element().is_nan(),
-                                        // FIXME: ^^^ should be -3.
+                                assert_eq!(v.max_element(), -3.,
                                         "[A]: nan at {} => {} | {:?}",
                                         i, v.max_element(), v);
 
@@ -302,14 +278,17 @@ macro_rules! test_reduction_float_min_max {
                                 // up-to the `i-th` lane with `NaN`s, the result
                                 // is still always `-3.` unless all elements of
                                 // the vector are `NaN`s:
-                                //
-                                // This is also broken:
                                 for j in 0..i {
                                     v = v.replace(j, n);
-                                    assert!(v.max_element().is_nan(),
-                                            // FIXME: ^^^ should be -3.
+                                    if j == i-1 {
+                                        assert!(v.min_element().is_nan(),
+                                        "[B]: nan at {} => {} | {:?}",
+                                        i, v.min_element(), v);
+                                    } else {
+                                        assert_eq!(v.max_element(), -3.,
                                             "[B]: nan at {} => {} | {:?}",
                                             i, v.max_element(), v);
+                                    }
                                 }
 
                                 // We are done here, since we were in the last
@@ -324,7 +303,7 @@ macro_rules! test_reduction_float_min_max {
                             if $id::lanes() == 1 {
                                 assert!(v.max_element().is_nan(),
                                         "[C]: all nans | v={:?} | min={} | \
-                                         is_nan: {}",
+is_nan: {}",
                                         v, v.max_element(),
                                         v.max_element().is_nan());
 
@@ -355,7 +334,7 @@ macro_rules! test_reduction_float_min_max {
                                     // "i - 1" does not overflow.
                                     assert!(v.max_element().is_nan(),
                                             "[E]: all nans | v={:?} | max={} | \
-                                             is_nan: {}",
+is_nan: {}",
                                             v, v.max_element(),
                                             v.max_element().is_nan());
                                 } else {
@@ -377,5 +356,5 @@ macro_rules! test_reduction_float_min_max {
                 }
             }
         }
-    }
+    };
 }
diff --git a/third_party/rust/packed_simd/src/api/select.rs b/third_party/rust/packed_simd_2/src/api/select.rs
similarity index 94%
rename from third_party/rust/packed_simd/src/api/select.rs
rename to third_party/rust/packed_simd_2/src/api/select.rs
index 24525df56c73..daf62947219e 100644
--- a/third_party/rust/packed_simd/src/api/select.rs
+++ b/third_party/rust/packed_simd_2/src/api/select.rs
@@ -12,9 +12,7 @@ macro_rules! impl_select {
             #[inline]
             pub fn select<T>(self, a: Simd<T>, b: Simd<T>) -> Simd<T>
             where
-                T: sealed::SimdArray<
-                    NT = <[$elem_ty; $elem_count] as sealed::SimdArray>::NT,
-                >,
+                T: sealed::SimdArray<NT = <[$elem_ty; $elem_count] as sealed::SimdArray>::NT>,
             {
                 use crate::llvm::simd_select;
                 Simd(unsafe { simd_select(self.0, a.0, b.0) })
diff --git a/third_party/rust/packed_simd/src/api/shuffle.rs b/third_party/rust/packed_simd_2/src/api/shuffle.rs
similarity index 97%
rename from third_party/rust/packed_simd/src/api/shuffle.rs
rename to third_party/rust/packed_simd_2/src/api/shuffle.rs
index 3fe1ad5f2701..fda29ccddc18 100644
--- a/third_party/rust/packed_simd/src/api/shuffle.rs
+++ b/third_party/rust/packed_simd_2/src/api/shuffle.rs
@@ -27,9 +27,7 @@
 /// Shuffling elements of two vectors:
 ///
 /// ```
-/// # #[macro_use]
-/// # extern crate packed_simd;
-/// # use packed_simd::*;
+/// # use packed_simd_2::*;
 /// # fn main() {
 /// // Shuffle allows reordering the elements:
 /// let x = i32x4::new(1, 2, 3, 4);
@@ -51,9 +49,7 @@
 /// Shuffling elements of one vector:
 ///
 /// ```
-/// # #[macro_use]
-/// # extern crate packed_simd;
-/// # use packed_simd::*;
+/// # use packed_simd_2::*;
 /// # fn main() {
 /// // Shuffle allows reordering the elements of a vector:
 /// let x = i32x4::new(1, 2, 3, 4);
diff --git a/third_party/rust/packed_simd/src/api/shuffle1_dyn.rs b/third_party/rust/packed_simd_2/src/api/shuffle1_dyn.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/shuffle1_dyn.rs
rename to third_party/rust/packed_simd_2/src/api/shuffle1_dyn.rs
diff --git a/third_party/rust/packed_simd/src/api/slice.rs b/third_party/rust/packed_simd_2/src/api/slice.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/slice.rs
rename to third_party/rust/packed_simd_2/src/api/slice.rs
diff --git a/third_party/rust/packed_simd/src/api/slice/from_slice.rs b/third_party/rust/packed_simd_2/src/api/slice/from_slice.rs
similarity index 90%
rename from third_party/rust/packed_simd/src/api/slice/from_slice.rs
rename to third_party/rust/packed_simd_2/src/api/slice/from_slice.rs
index 25082d1e6800..50f3914f7bbe 100644
--- a/third_party/rust/packed_simd/src/api/slice/from_slice.rs
+++ b/third_party/rust/packed_simd_2/src/api/slice/from_slice.rs
@@ -14,11 +14,7 @@ macro_rules! impl_slice_from_slice {
                 unsafe {
                     assert!(slice.len() >= $elem_count);
                     let target_ptr = slice.get_unchecked(0) as *const $elem_ty;
-                    assert_eq!(
-                        target_ptr
-                            .align_offset(crate::mem::align_of::<Self>()),
-                        0
-                    );
+                    assert_eq!(target_ptr.align_offset(crate::mem::align_of::<Self>()), 0);
                     Self::from_slice_aligned_unchecked(slice)
                 }
             }
@@ -43,15 +39,10 @@ macro_rules! impl_slice_from_slice {
             /// If `slice.len() < Self::lanes()` or `&slice[0]` is not aligned
             /// to an `align_of::<Self>()` boundary, the behavior is undefined.
             #[inline]
-            pub unsafe fn from_slice_aligned_unchecked(
-                slice: &[$elem_ty],
-            ) -> Self {
+            pub unsafe fn from_slice_aligned_unchecked(slice: &[$elem_ty]) -> Self {
                 debug_assert!(slice.len() >= $elem_count);
                 let target_ptr = slice.get_unchecked(0) as *const $elem_ty;
-                debug_assert_eq!(
-                    target_ptr.align_offset(crate::mem::align_of::<Self>()),
-                    0
-                );
+                debug_assert_eq!(target_ptr.align_offset(crate::mem::align_of::<Self>()), 0);
 
                 #[allow(clippy::cast_ptr_alignment)]
                 *(target_ptr as *const Self)
@@ -63,20 +54,13 @@ macro_rules! impl_slice_from_slice {
             ///
             /// If `slice.len() < Self::lanes()` the behavior is undefined.
             #[inline]
-            pub unsafe fn from_slice_unaligned_unchecked(
-                slice: &[$elem_ty],
-            ) -> Self {
+            pub unsafe fn from_slice_unaligned_unchecked(slice: &[$elem_ty]) -> Self {
                 use crate::mem::size_of;
                 debug_assert!(slice.len() >= $elem_count);
-                let target_ptr =
-                    slice.get_unchecked(0) as *const $elem_ty as *const u8;
+                let target_ptr = slice.get_unchecked(0) as *const $elem_ty as *const u8;
                 let mut x = Self::splat(0 as $elem_ty);
                 let self_ptr = &mut x as *mut Self as *mut u8;
-                crate::ptr::copy_nonoverlapping(
-                    target_ptr,
-                    self_ptr,
-                    size_of::<Self>(),
-                );
+                crate::ptr::copy_nonoverlapping(target_ptr, self_ptr, size_of::<Self>());
                 x
             }
         }
diff --git a/third_party/rust/packed_simd/src/api/slice/write_to_slice.rs b/third_party/rust/packed_simd_2/src/api/slice/write_to_slice.rs
similarity index 88%
rename from third_party/rust/packed_simd/src/api/slice/write_to_slice.rs
rename to third_party/rust/packed_simd_2/src/api/slice/write_to_slice.rs
index b634d98b9962..dd04a2634d90 100644
--- a/third_party/rust/packed_simd/src/api/slice/write_to_slice.rs
+++ b/third_party/rust/packed_simd_2/src/api/slice/write_to_slice.rs
@@ -13,13 +13,8 @@ macro_rules! impl_slice_write_to_slice {
             pub fn write_to_slice_aligned(self, slice: &mut [$elem_ty]) {
                 unsafe {
                     assert!(slice.len() >= $elem_count);
-                    let target_ptr =
-                        slice.get_unchecked_mut(0) as *mut $elem_ty;
-                    assert_eq!(
-                        target_ptr
-                            .align_offset(crate::mem::align_of::<Self>()),
-                        0
-                    );
+                    let target_ptr = slice.get_unchecked_mut(0) as *mut $elem_ty;
+                    assert_eq!(target_ptr.align_offset(crate::mem::align_of::<Self>()), 0);
                     self.write_to_slice_aligned_unchecked(slice);
                 }
             }
@@ -45,18 +40,13 @@ macro_rules! impl_slice_write_to_slice {
             /// aligned to an `align_of::<Self>()` boundary, the behavior is
             /// undefined.
             #[inline]
-            pub unsafe fn write_to_slice_aligned_unchecked(
-                self, slice: &mut [$elem_ty],
-            ) {
+            pub unsafe fn write_to_slice_aligned_unchecked(self, slice: &mut [$elem_ty]) {
                 debug_assert!(slice.len() >= $elem_count);
                 let target_ptr = slice.get_unchecked_mut(0) as *mut $elem_ty;
-                debug_assert_eq!(
-                    target_ptr.align_offset(crate::mem::align_of::<Self>()),
-                    0
-                );
+                debug_assert_eq!(target_ptr.align_offset(crate::mem::align_of::<Self>()), 0);
 
-                                #[allow(clippy::cast_ptr_alignment)]
-                        #[allow(clippy::cast_ptr_alignment)]
+                #[allow(clippy::cast_ptr_alignment)]
+                #[allow(clippy::cast_ptr_alignment)]
                 #[allow(clippy::cast_ptr_alignment)]
                 #[allow(clippy::cast_ptr_alignment)]
                 *(target_ptr as *mut Self) = self;
@@ -68,18 +58,11 @@ macro_rules! impl_slice_write_to_slice {
             ///
             /// If `slice.len() < Self::lanes()` the behavior is undefined.
             #[inline]
-            pub unsafe fn write_to_slice_unaligned_unchecked(
-                self, slice: &mut [$elem_ty],
-            ) {
+            pub unsafe fn write_to_slice_unaligned_unchecked(self, slice: &mut [$elem_ty]) {
                 debug_assert!(slice.len() >= $elem_count);
-                let target_ptr =
-                    slice.get_unchecked_mut(0) as *mut $elem_ty as *mut u8;
+                let target_ptr = slice.get_unchecked_mut(0) as *mut $elem_ty as *mut u8;
                 let self_ptr = &self as *const Self as *const u8;
-                crate::ptr::copy_nonoverlapping(
-                    self_ptr,
-                    target_ptr,
-                    crate::mem::size_of::<Self>(),
-                );
+                crate::ptr::copy_nonoverlapping(self_ptr, target_ptr, crate::mem::size_of::<Self>());
             }
         }
 
diff --git a/third_party/rust/packed_simd/src/api/swap_bytes.rs b/third_party/rust/packed_simd_2/src/api/swap_bytes.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/api/swap_bytes.rs
rename to third_party/rust/packed_simd_2/src/api/swap_bytes.rs
diff --git a/third_party/rust/packed_simd/src/codegen.rs b/third_party/rust/packed_simd_2/src/codegen.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen.rs
rename to third_party/rust/packed_simd_2/src/codegen.rs
diff --git a/third_party/rust/packed_simd/src/codegen/bit_manip.rs b/third_party/rust/packed_simd_2/src/codegen/bit_manip.rs
similarity index 96%
rename from third_party/rust/packed_simd/src/codegen/bit_manip.rs
rename to third_party/rust/packed_simd_2/src/codegen/bit_manip.rs
index 83c7d1987cac..5986916da438 100644
--- a/third_party/rust/packed_simd/src/codegen/bit_manip.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/bit_manip.rs
@@ -212,8 +212,7 @@ macro_rules! impl_bit_manip {
             fn ctpop(self) -> Self {
                 let mut ones = self;
                 for i in 0..Self::lanes() {
-                    ones = ones
-                        .replace(i, self.extract(i).count_ones() as $scalar);
+                    ones = ones.replace(i, self.extract(i).count_ones() as $scalar);
                 }
                 ones
             }
@@ -222,10 +221,7 @@ macro_rules! impl_bit_manip {
             fn ctlz(self) -> Self {
                 let mut lz = self;
                 for i in 0..Self::lanes() {
-                    lz = lz.replace(
-                        i,
-                        self.extract(i).leading_zeros() as $scalar,
-                    );
+                    lz = lz.replace(i, self.extract(i).leading_zeros() as $scalar);
                 }
                 lz
             }
@@ -234,10 +230,7 @@ macro_rules! impl_bit_manip {
             fn cttz(self) -> Self {
                 let mut tz = self;
                 for i in 0..Self::lanes() {
-                    tz = tz.replace(
-                        i,
-                        self.extract(i).trailing_zeros() as $scalar,
-                    );
+                    tz = tz.replace(i, self.extract(i).trailing_zeros() as $scalar);
                 }
                 tz
             }
diff --git a/third_party/rust/packed_simd/src/codegen/llvm.rs b/third_party/rust/packed_simd_2/src/codegen/llvm.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/llvm.rs
rename to third_party/rust/packed_simd_2/src/codegen/llvm.rs
diff --git a/third_party/rust/packed_simd/src/codegen/math.rs b/third_party/rust/packed_simd_2/src/codegen/math.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/math.rs
rename to third_party/rust/packed_simd_2/src/codegen/math.rs
diff --git a/third_party/rust/packed_simd/src/codegen/math/float.rs b/third_party/rust/packed_simd_2/src/codegen/math/float.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/math/float.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float.rs
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/abs.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/abs.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/math/float/abs.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/abs.rs
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/cos.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/cos.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/math/float/cos.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/cos.rs
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/cos_pi.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/cos_pi.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/math/float/cos_pi.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/cos_pi.rs
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/exp.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/exp.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/math/float/exp.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/exp.rs
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/ln.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/ln.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/math/float/ln.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/ln.rs
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/macros.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/macros.rs
similarity index 80%
rename from third_party/rust/packed_simd/src/codegen/math/float/macros.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/macros.rs
index 02d0ca3f5c7a..8daee1afe205 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/macros.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/macros.rs
@@ -1,7 +1,6 @@
 //! Utility macros
 #![allow(unused)]
 
-
 macro_rules! impl_unary_ {
     // implementation mapping 1:1
     (vec | $trait_id:ident, $trait_method:ident, $vec_id:ident,
@@ -64,10 +63,8 @@ macro_rules! impl_unary_ {
 
                     let mut halves = U { vec: self }.halves;
 
-                    *halves.get_unchecked_mut(0) =
-                        transmute($fun(transmute(*halves.get_unchecked(0))));
-                    *halves.get_unchecked_mut(1) =
-                        transmute($fun(transmute(*halves.get_unchecked(1))));
+                    *halves.get_unchecked_mut(0) = transmute($fun(transmute(*halves.get_unchecked(0))));
+                    *halves.get_unchecked_mut(1) = transmute($fun(transmute(*halves.get_unchecked(1))));
 
                     U { halves }.vec
                 }
@@ -89,14 +86,10 @@ macro_rules! impl_unary_ {
 
                     let mut quarters = U { vec: self }.quarters;
 
-                    *quarters.get_unchecked_mut(0) =
-                        transmute($fun(transmute(*quarters.get_unchecked(0))));
-                    *quarters.get_unchecked_mut(1) =
-                        transmute($fun(transmute(*quarters.get_unchecked(1))));
-                    *quarters.get_unchecked_mut(2) =
-                        transmute($fun(transmute(*quarters.get_unchecked(2))));
-                    *quarters.get_unchecked_mut(3) =
-                        transmute($fun(transmute(*quarters.get_unchecked(3))));
+                    *quarters.get_unchecked_mut(0) = transmute($fun(transmute(*quarters.get_unchecked(0))));
+                    *quarters.get_unchecked_mut(1) = transmute($fun(transmute(*quarters.get_unchecked(1))));
+                    *quarters.get_unchecked_mut(2) = transmute($fun(transmute(*quarters.get_unchecked(2))));
+                    *quarters.get_unchecked_mut(3) = transmute($fun(transmute(*quarters.get_unchecked(3))));
 
                     U { quarters }.vec
                 }
@@ -137,43 +130,19 @@ macro_rules! gen_unary_impl_table {
                 impl_unary_!(gen | $trait_id, $trait_method, $vid, $fun);
             };
             ($vid:ident[$sid:ident; $sc:expr]: $fun:ident) => {
-                impl_unary_!(
-                    scalar | $trait_id,
-                    $trait_method,
-                    $vid,
-                    [$sid; $sc],
-                    $fun
-                );
+                impl_unary_!(scalar | $trait_id, $trait_method, $vid, [$sid; $sc], $fun);
             };
             ($vid:ident[s]: $fun:ident) => {
                 impl_unary_!(scalar | $trait_id, $trait_method, $vid, $fun);
             };
             ($vid:ident[h => $vid_h:ident]: $fun:ident) => {
-                impl_unary_!(
-                    halves | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_h,
-                    $fun
-                );
+                impl_unary_!(halves | $trait_id, $trait_method, $vid, $vid_h, $fun);
             };
             ($vid:ident[q => $vid_q:ident]: $fun:ident) => {
-                impl_unary_!(
-                    quarter | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_q,
-                    $fun
-                );
+                impl_unary_!(quarter | $trait_id, $trait_method, $vid, $vid_q, $fun);
             };
             ($vid:ident[t => $vid_t:ident]: $fun:ident) => {
-                impl_unary_!(
-                    twice | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_t,
-                    $fun
-                );
+                impl_unary_!(twice | $trait_id, $trait_method, $vid, $vid_t, $fun);
             };
         }
     };
@@ -188,11 +157,7 @@ macro_rules! impl_tertiary_ {
             fn $trait_method(self, y: Self, z: Self) -> Self {
                 unsafe {
                     use crate::mem::transmute;
-                    transmute($fun(
-                        transmute(self),
-                        transmute(y),
-                        transmute(z),
-                    ))
+                    transmute($fun(transmute(self), transmute(y), transmute(z)))
                 }
             }
         }
@@ -314,11 +279,8 @@ macro_rules! impl_tertiary_ {
                     let x_twice = U { vec: [self, uninitialized()] }.twice;
                     let y_twice = U { vec: [y, uninitialized()] }.twice;
                     let z_twice = U { vec: [z, uninitialized()] }.twice;
-                    let twice: $vect_id = transmute($fun(
-                        transmute(x_twice),
-                        transmute(y_twice),
-                        transmute(z_twice),
-                    ));
+                    let twice: $vect_id =
+                        transmute($fun(transmute(x_twice), transmute(y_twice), transmute(z_twice)));
 
                     *(U { twice }.vec.get_unchecked(0))
                 }
@@ -334,43 +296,19 @@ macro_rules! gen_tertiary_impl_table {
                 impl_tertiary_!(vec | $trait_id, $trait_method, $vid, $fun);
             };
             ($vid:ident[$sid:ident; $sc:expr]: $fun:ident) => {
-                impl_tertiary_!(
-                    scalar | $trait_id,
-                    $trait_method,
-                    $vid,
-                    [$sid; $sc],
-                    $fun
-                );
+                impl_tertiary_!(scalar | $trait_id, $trait_method, $vid, [$sid; $sc], $fun);
             };
             ($vid:ident[s]: $fun:ident) => {
                 impl_tertiary_!(scalar | $trait_id, $trait_method, $vid, $fun);
             };
             ($vid:ident[h => $vid_h:ident]: $fun:ident) => {
-                impl_tertiary_!(
-                    halves | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_h,
-                    $fun
-                );
+                impl_tertiary_!(halves | $trait_id, $trait_method, $vid, $vid_h, $fun);
             };
             ($vid:ident[q => $vid_q:ident]: $fun:ident) => {
-                impl_tertiary_!(
-                    quarter | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_q,
-                    $fun
-                );
+                impl_tertiary_!(quarter | $trait_id, $trait_method, $vid, $vid_q, $fun);
             };
             ($vid:ident[t => $vid_t:ident]: $fun:ident) => {
-                impl_tertiary_!(
-                    twice | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_t,
-                    $fun
-                );
+                impl_tertiary_!(twice | $trait_id, $trait_method, $vid, $vid_t, $fun);
             };
         }
     };
@@ -497,10 +435,7 @@ macro_rules! impl_binary_ {
 
                     let x_twice = U { vec: [self, uninitialized()] }.twice;
                     let y_twice = U { vec: [y, uninitialized()] }.twice;
-                    let twice: $vect_id = transmute($fun(
-                        transmute(x_twice),
-                        transmute(y_twice),
-                    ));
+                    let twice: $vect_id = transmute($fun(transmute(x_twice), transmute(y_twice)));
 
                     *(U { twice }.vec.get_unchecked(0))
                 }
@@ -516,43 +451,19 @@ macro_rules! gen_binary_impl_table {
                 impl_binary_!(vec | $trait_id, $trait_method, $vid, $fun);
             };
             ($vid:ident[$sid:ident; $sc:expr]: $fun:ident) => {
-                impl_binary_!(
-                    scalar | $trait_id,
-                    $trait_method,
-                    $vid,
-                    [$sid; $sc],
-                    $fun
-                );
+                impl_binary_!(scalar | $trait_id, $trait_method, $vid, [$sid; $sc], $fun);
             };
             ($vid:ident[s]: $fun:ident) => {
                 impl_binary_!(scalar | $trait_id, $trait_method, $vid, $fun);
             };
             ($vid:ident[h => $vid_h:ident]: $fun:ident) => {
-                impl_binary_!(
-                    halves | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_h,
-                    $fun
-                );
+                impl_binary_!(halves | $trait_id, $trait_method, $vid, $vid_h, $fun);
             };
             ($vid:ident[q => $vid_q:ident]: $fun:ident) => {
-                impl_binary_!(
-                    quarter | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_q,
-                    $fun
-                );
+                impl_binary_!(quarter | $trait_id, $trait_method, $vid, $vid_q, $fun);
             };
             ($vid:ident[t => $vid_t:ident]: $fun:ident) => {
-                impl_binary_!(
-                    twice | $trait_id,
-                    $trait_method,
-                    $vid,
-                    $vid_t,
-                    $fun
-                );
+                impl_binary_!(twice | $trait_id, $trait_method, $vid, $vid_t, $fun);
             };
         }
     };
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/mul_add.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/mul_add.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/math/float/mul_add.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/mul_add.rs
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/mul_adde.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/mul_adde.rs
similarity index 89%
rename from third_party/rust/packed_simd/src/codegen/math/float/mul_adde.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/mul_adde.rs
index 8c41fb131d94..b030c26ccf46 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/mul_adde.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/mul_adde.rs
@@ -38,13 +38,7 @@ macro_rules! impl_mul_adde {
                 #[cfg(not(target_arch = "s390x"))]
                 {
                     use crate::mem::transmute;
-                    unsafe {
-                        transmute($fn(
-                            transmute(self),
-                            transmute(y),
-                            transmute(z),
-                        ))
-                    }
+                    unsafe { transmute($fn(transmute(self), transmute(y), transmute(z))) }
                 }
                 #[cfg(target_arch = "s390x")]
                 {
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/powf.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/powf.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/math/float/powf.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/powf.rs
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/sin.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/sin.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/math/float/sin.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/sin.rs
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/sin_cos_pi.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/sin_cos_pi.rs
similarity index 87%
rename from third_party/rust/packed_simd/src/codegen/math/float/sin_cos_pi.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/sin_cos_pi.rs
index 0f1249ec88f0..75c2c2c5fbb0 100644
--- a/third_party/rust/packed_simd/src/codegen/math/float/sin_cos_pi.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/math/float/sin_cos_pi.rs
@@ -85,17 +85,14 @@ macro_rules! impl_unary_t {
 
                     let halves = U { vec: self }.halves;
 
-                    let res_0: ($vid_h, $vid_h) =
-                        transmute($fun(transmute(*halves.get_unchecked(0))));
-                    let res_1: ($vid_h, $vid_h) =
-                        transmute($fun(transmute(*halves.get_unchecked(1))));
+                    let res_0: ($vid_h, $vid_h) = transmute($fun(transmute(*halves.get_unchecked(0))));
+                    let res_1: ($vid_h, $vid_h) = transmute($fun(transmute(*halves.get_unchecked(1))));
 
                     union R {
                         result: ($vid, $vid),
                         halves: ([$vid_h; 2], [$vid_h; 2]),
                     }
-                    R { halves: ([res_0.0, res_1.0], [res_0.1, res_1.1]) }
-                        .result
+                    R { halves: ([res_0.0, res_1.0], [res_0.1, res_1.1]) }.result
                 }
             }
         }
@@ -114,14 +111,10 @@ macro_rules! impl_unary_t {
 
                     let quarters = U { vec: self }.quarters;
 
-                    let res_0: ($vid_q, $vid_q) =
-                        transmute($fun(transmute(*quarters.get_unchecked(0))));
-                    let res_1: ($vid_q, $vid_q) =
-                        transmute($fun(transmute(*quarters.get_unchecked(1))));
-                    let res_2: ($vid_q, $vid_q) =
-                        transmute($fun(transmute(*quarters.get_unchecked(2))));
-                    let res_3: ($vid_q, $vid_q) =
-                        transmute($fun(transmute(*quarters.get_unchecked(3))));
+                    let res_0: ($vid_q, $vid_q) = transmute($fun(transmute(*quarters.get_unchecked(0))));
+                    let res_1: ($vid_q, $vid_q) = transmute($fun(transmute(*quarters.get_unchecked(1))));
+                    let res_2: ($vid_q, $vid_q) = transmute($fun(transmute(*quarters.get_unchecked(2))));
+                    let res_3: ($vid_q, $vid_q) = transmute($fun(transmute(*quarters.get_unchecked(3))));
 
                     union R {
                         result: ($vid, $vid),
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/sin_pi.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/sin_pi.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/math/float/sin_pi.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/sin_pi.rs
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/sqrt.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/sqrt.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/math/float/sqrt.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/sqrt.rs
diff --git a/third_party/rust/packed_simd/src/codegen/math/float/sqrte.rs b/third_party/rust/packed_simd_2/src/codegen/math/float/sqrte.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/math/float/sqrte.rs
rename to third_party/rust/packed_simd_2/src/codegen/math/float/sqrte.rs
diff --git a/third_party/rust/packed_simd/src/codegen/pointer_sized_int.rs b/third_party/rust/packed_simd_2/src/codegen/pointer_sized_int.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/pointer_sized_int.rs
rename to third_party/rust/packed_simd_2/src/codegen/pointer_sized_int.rs
diff --git a/third_party/rust/packed_simd/src/codegen/reductions.rs b/third_party/rust/packed_simd_2/src/codegen/reductions.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/reductions.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions.rs
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask.rs
similarity index 97%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask.rs
index 97260c6d4e03..0aec60969b86 100644
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask.rs
@@ -1,6 +1,6 @@
 //! Code generation workaround for `all()` mask horizontal reduction.
 //!
-//! Works arround [LLVM bug 36702].
+//! Works around [LLVM bug 36702].
 //!
 //! [LLVM bug 36702]: https://bugs.llvm.org/show_bug.cgi?id=36702
 #![allow(unused_macros)]
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/aarch64.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/aarch64.rs
similarity index 72%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/aarch64.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/aarch64.rs
index e9586eace1ff..b2db52c891c1 100644
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask/aarch64.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/aarch64.rs
@@ -19,7 +19,7 @@ macro_rules! aarch64_128_neon_impl {
                 $vmax(crate::mem::transmute(self)) != 0
             }
         }
-    }
+    };
 }
 
 /// 64-bit wide vectors
@@ -35,9 +35,7 @@ macro_rules! aarch64_64_neon_impl {
                     halves: ($id, $id),
                     vec: $vec128,
                 }
-                U {
-                    halves: (self, self),
-                }.vec.all()
+                U { halves: (self, self) }.vec.all()
             }
         }
         impl Any for $id {
@@ -48,9 +46,7 @@ macro_rules! aarch64_64_neon_impl {
                     halves: ($id, $id),
                     vec: $vec128,
                 }
-                U {
-                    halves: (self, self),
-                }.vec.any()
+                U { halves: (self, self) }.vec.any()
             }
         }
     };
@@ -59,13 +55,27 @@ macro_rules! aarch64_64_neon_impl {
 /// Mask reduction implementation for `aarch64` targets
 macro_rules! impl_mask_reductions {
     // 64-bit wide masks
-    (m8x8) => { aarch64_64_neon_impl!(m8x8, m8x16); };
-    (m16x4) => { aarch64_64_neon_impl!(m16x4, m16x8); };
-    (m32x2) => { aarch64_64_neon_impl!(m32x2, m32x4); };
+    (m8x8) => {
+        aarch64_64_neon_impl!(m8x8, m8x16);
+    };
+    (m16x4) => {
+        aarch64_64_neon_impl!(m16x4, m16x8);
+    };
+    (m32x2) => {
+        aarch64_64_neon_impl!(m32x2, m32x4);
+    };
     // 128-bit wide masks
-    (m8x16) => { aarch64_128_neon_impl!(m8x16, vminvq_u8, vmaxvq_u8); };
-    (m16x8) => { aarch64_128_neon_impl!(m16x8, vminvq_u16, vmaxvq_u16); };
-    (m32x4) => { aarch64_128_neon_impl!(m32x4, vminvq_u32, vmaxvq_u32); };
+    (m8x16) => {
+        aarch64_128_neon_impl!(m8x16, vminvq_u8, vmaxvq_u8);
+    };
+    (m16x8) => {
+        aarch64_128_neon_impl!(m16x8, vminvq_u16, vmaxvq_u16);
+    };
+    (m32x4) => {
+        aarch64_128_neon_impl!(m32x4, vminvq_u32, vmaxvq_u32);
+    };
     // Fallback to LLVM's default code-generation:
-    ($id:ident) => { fallback_impl!($id); };
+    ($id:ident) => {
+        fallback_impl!($id);
+    };
 }
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/arm.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/arm.rs
similarity index 69%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/arm.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/arm.rs
index 1987af7a9676..41c3cbc58afa 100644
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask/arm.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/arm.rs
@@ -15,10 +15,7 @@ macro_rules! arm_128_v7_neon_impl {
                     vec: $id,
                 }
                 let halves = U { vec: self }.halves;
-                let h: $half = transmute($vpmin(
-                    transmute(halves.0),
-                    transmute(halves.1),
-                ));
+                let h: $half = transmute($vpmin(transmute(halves.0), transmute(halves.1)));
                 h.all()
             }
         }
@@ -33,10 +30,7 @@ macro_rules! arm_128_v7_neon_impl {
                     vec: $id,
                 }
                 let halves = U { vec: self }.halves;
-                let h: $half = transmute($vpmax(
-                    transmute(halves.0),
-                    transmute(halves.1),
-                ));
+                let h: $half = transmute($vpmax(transmute(halves.0), transmute(halves.1)));
                 h.any()
             }
         }
@@ -46,9 +40,17 @@ macro_rules! arm_128_v7_neon_impl {
 /// Mask reduction implementation for `arm` targets
 macro_rules! impl_mask_reductions {
     // 128-bit wide masks
-    (m8x16) => { arm_128_v7_neon_impl!(m8x16, m8x8, vpmin_u8, vpmax_u8); };
-    (m16x8) => { arm_128_v7_neon_impl!(m16x8, m16x4, vpmin_u16, vpmax_u16); };
-    (m32x4) => { arm_128_v7_neon_impl!(m32x4, m32x2, vpmin_u32, vpmax_u32); };
+    (m8x16) => {
+        arm_128_v7_neon_impl!(m8x16, m8x8, vpmin_u8, vpmax_u8);
+    };
+    (m16x8) => {
+        arm_128_v7_neon_impl!(m16x8, m16x4, vpmin_u16, vpmax_u16);
+    };
+    (m32x4) => {
+        arm_128_v7_neon_impl!(m32x4, m32x2, vpmin_u32, vpmax_u32);
+    };
     // Fallback to LLVM's default code-generation:
-    ($id:ident) => { fallback_impl!($id); };
+    ($id:ident) => {
+        fallback_impl!($id);
+    };
 }
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/fallback.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/fallback.rs
similarity index 68%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/fallback.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/fallback.rs
index 25e5c813abca..4c377a68784e 100644
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask/fallback.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/fallback.rs
@@ -2,5 +2,7 @@
 
 /// Default mask reduction implementation
 macro_rules! impl_mask_reductions {
-    ($id:ident) => { fallback_impl!($id); };
+    ($id:ident) => {
+        fallback_impl!($id);
+    };
 }
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/fallback_impl.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/fallback_impl.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/fallback_impl.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/fallback_impl.rs
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86.rs
similarity index 80%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/x86.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86.rs
index bcfb1a6e1772..4bf509806545 100644
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86.rs
@@ -114,17 +114,17 @@ macro_rules! x86_m64x4_impl {
 /// Fallback implementation.
 macro_rules! x86_intr_impl {
     ($id:ident) => {
-    impl All for $id {
-        #[inline]
-        unsafe fn all(self) -> bool {
-        use crate::llvm::simd_reduce_all;
-            simd_reduce_all(self.0)
+        impl All for $id {
+            #[inline]
+            unsafe fn all(self) -> bool {
+                use crate::llvm::simd_reduce_all;
+                simd_reduce_all(self.0)
+            }
         }
-    }
         impl Any for $id {
             #[inline]
             unsafe fn any(self) -> bool {
-            use crate::llvm::simd_reduce_any;
+                use crate::llvm::simd_reduce_any;
                 simd_reduce_any(self.0)
             }
         }
@@ -134,21 +134,47 @@ macro_rules! x86_intr_impl {
 /// Mask reduction implementation for `x86` and `x86_64` targets
 macro_rules! impl_mask_reductions {
     // 64-bit wide masks
-    (m8x8) => { x86_m8x8_impl!(m8x8); };
-    (m16x4) => { x86_m8x8_impl!(m16x4); };
-    (m32x2) => { x86_m8x8_impl!(m32x2); };
+    (m8x8) => {
+        x86_m8x8_impl!(m8x8);
+    };
+    (m16x4) => {
+        x86_m8x8_impl!(m16x4);
+    };
+    (m32x2) => {
+        x86_m8x8_impl!(m32x2);
+    };
     // 128-bit wide masks
-    (m8x16) => { x86_m8x16_impl!(m8x16); };
-    (m16x8) => { x86_m8x16_impl!(m16x8); };
-    (m32x4) => { x86_m32x4_impl!(m32x4); };
-    (m64x2) => { x86_m64x2_impl!(m64x2); };
-    (m128x1) => { x86_intr_impl!(m128x1); };
+    (m8x16) => {
+        x86_m8x16_impl!(m8x16);
+    };
+    (m16x8) => {
+        x86_m8x16_impl!(m16x8);
+    };
+    (m32x4) => {
+        x86_m32x4_impl!(m32x4);
+    };
+    (m64x2) => {
+        x86_m64x2_impl!(m64x2);
+    };
+    (m128x1) => {
+        x86_intr_impl!(m128x1);
+    };
     // 256-bit wide masks:
-    (m8x32) => { x86_m8x32_impl!(m8x32, m8x16); };
-    (m16x16) => { x86_m8x32_impl!(m16x16, m16x8); };
-    (m32x8) => { x86_m32x8_impl!(m32x8, m32x4); };
-    (m64x4) => { x86_m64x4_impl!(m64x4, m64x2); };
-    (m128x2) => { x86_intr_impl!(m128x2); };
+    (m8x32) => {
+        x86_m8x32_impl!(m8x32, m8x16);
+    };
+    (m16x16) => {
+        x86_m8x32_impl!(m16x16, m16x8);
+    };
+    (m32x8) => {
+        x86_m32x8_impl!(m32x8, m32x4);
+    };
+    (m64x4) => {
+        x86_m64x4_impl!(m64x4, m64x2);
+    };
+    (m128x2) => {
+        x86_intr_impl!(m128x2);
+    };
     (msizex2) => {
         cfg_if! {
             if #[cfg(target_pointer_width = "64")] {
@@ -184,5 +210,7 @@ macro_rules! impl_mask_reductions {
     };
 
     // Fallback to LLVM's default code-generation:
-    ($id:ident) => { fallback_impl!($id); };
+    ($id:ident) => {
+        fallback_impl!($id);
+    };
 }
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/avx.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/avx.rs
similarity index 91%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/x86/avx.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/avx.rs
index d18736fb0399..61f352d22839 100644
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/avx.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/avx.rs
@@ -13,10 +13,7 @@ macro_rules! x86_m8x32_avx_impl {
                 use crate::arch::x86::_mm256_testc_si256;
                 #[cfg(target_arch = "x86_64")]
                 use crate::arch::x86_64::_mm256_testc_si256;
-                _mm256_testc_si256(
-                    crate::mem::transmute(self),
-                    crate::mem::transmute($id::splat(true)),
-                ) != 0
+                _mm256_testc_si256(crate::mem::transmute(self), crate::mem::transmute($id::splat(true))) != 0
             }
         }
         impl Any for $id {
@@ -27,10 +24,7 @@ macro_rules! x86_m8x32_avx_impl {
                 use crate::arch::x86::_mm256_testz_si256;
                 #[cfg(target_arch = "x86_64")]
                 use crate::arch::x86_64::_mm256_testz_si256;
-                _mm256_testz_si256(
-                    crate::mem::transmute(self),
-                    crate::mem::transmute(self),
-                ) == 0
+                _mm256_testz_si256(crate::mem::transmute(self), crate::mem::transmute(self)) == 0
             }
         }
     };
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/avx2.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/avx2.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/x86/avx2.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/avx2.rs
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/sse.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/sse.rs
similarity index 92%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/x86/sse.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/sse.rs
index eb1ef7fac922..e0c9aee92bd9 100644
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/sse.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/sse.rs
@@ -16,8 +16,7 @@ macro_rules! x86_m32x4_sse_impl {
                 // most significant bit of each lane of `a`. If all
                 // bits are set, then all 4 lanes of the mask are
                 // true.
-                _mm_movemask_ps(crate::mem::transmute(self))
-                    == 0b_1111_i32
+                _mm_movemask_ps(crate::mem::transmute(self)) == 0b_1111_i32
             }
         }
         impl Any for $id {
diff --git a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/sse2.rs b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/sse2.rs
similarity index 92%
rename from third_party/rust/packed_simd/src/codegen/reductions/mask/x86/sse2.rs
rename to third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/sse2.rs
index a99c606f5268..bbb52fa47e02 100644
--- a/third_party/rust/packed_simd/src/codegen/reductions/mask/x86/sse2.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/reductions/mask/x86/sse2.rs
@@ -16,8 +16,7 @@ macro_rules! x86_m64x2_sse2_impl {
                 // most significant bit of each lane of `a`. If all
                 // bits are set, then all 2 lanes of the mask are
                 // true.
-                _mm_movemask_pd(crate::mem::transmute(self))
-                    == 0b_11_i32
+                _mm_movemask_pd(crate::mem::transmute(self)) == 0b_11_i32
             }
         }
         impl Any for $id {
@@ -50,8 +49,7 @@ macro_rules! x86_m8x16_sse2_impl {
                 // most significant bit of each byte of `a`. If all
                 // bits are set, then all 16 lanes of the mask are
                 // true.
-                _mm_movemask_epi8(crate::mem::transmute(self))
-                    == i32::from(u16::max_value())
+                _mm_movemask_epi8(crate::mem::transmute(self)) == i32::from(u16::max_value())
             }
         }
         impl Any for $id {
diff --git a/third_party/rust/packed_simd/src/codegen/shuffle.rs b/third_party/rust/packed_simd_2/src/codegen/shuffle.rs
similarity index 99%
rename from third_party/rust/packed_simd/src/codegen/shuffle.rs
rename to third_party/rust/packed_simd_2/src/codegen/shuffle.rs
index d92c9ee22427..d3acd48f5bed 100644
--- a/third_party/rust/packed_simd/src/codegen/shuffle.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/shuffle.rs
@@ -2,7 +2,7 @@
 //! lanes and vector element types.
 
 use crate::masks::*;
-use crate::sealed::{Shuffle, Seal};
+use crate::sealed::{Seal, Shuffle};
 
 macro_rules! impl_shuffle {
     ($array:ty, $base:ty, $out:ty) => {
@@ -10,7 +10,7 @@ macro_rules! impl_shuffle {
         impl Shuffle<$array> for $base {
             type Output = $out;
         }
-    }
+    };
 }
 
 impl_shuffle! { [u32; 2], i8, crate::codegen::i8x2 }
diff --git a/third_party/rust/packed_simd/src/codegen/shuffle1_dyn.rs b/third_party/rust/packed_simd_2/src/codegen/shuffle1_dyn.rs
similarity index 96%
rename from third_party/rust/packed_simd/src/codegen/shuffle1_dyn.rs
rename to third_party/rust/packed_simd_2/src/codegen/shuffle1_dyn.rs
index a5403a06bb6e..19d457a45bfc 100644
--- a/third_party/rust/packed_simd/src/codegen/shuffle1_dyn.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/shuffle1_dyn.rs
@@ -16,8 +16,7 @@ macro_rules! impl_fallback {
             fn shuffle1_dyn(self, indices: Self::Indices) -> Self {
                 let mut result = Self::splat(0);
                 for i in 0..$id::lanes() {
-                    result = result
-                        .replace(i, self.extract(indices.extract(i) as usize));
+                    result = result.replace(i, self.extract(indices.extract(i) as usize));
                 }
                 result
             }
@@ -150,16 +149,12 @@ macro_rules! impl_shuffle1_dyn {
             #[inline]
             fn shuffle1_dyn(self, indices: Self::Indices) -> Self {
                 let indices: u8x8 = (indices * 2).cast();
-                let indices: u8x16 = shuffle!(
-                    indices, [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7]
-                );
-                let v = u8x16::new(
-                    0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
-                );
+                let indices: u8x16 = shuffle!(indices, [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7]);
+                let v = u8x16::new(0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1);
                 let indices = indices + v;
                 unsafe {
-                    let s: u8x16 =crate::mem::transmute(self);
-                   crate::mem::transmute(s.shuffle1_dyn(indices))
+                    let s: u8x16 = crate::mem::transmute(self);
+                    crate::mem::transmute(s.shuffle1_dyn(indices))
                 }
             }
         }
@@ -268,7 +263,9 @@ macro_rules! impl_shuffle1_dyn {
             }
         }
     };
-    ($id:ident) => { impl_fallback!($id); }
+    ($id:ident) => {
+        impl_fallback!($id);
+    };
 }
 
 impl_shuffle1_dyn!(u8x2);
diff --git a/third_party/rust/packed_simd/src/codegen/swap_bytes.rs b/third_party/rust/packed_simd_2/src/codegen/swap_bytes.rs
similarity index 90%
rename from third_party/rust/packed_simd/src/codegen/swap_bytes.rs
rename to third_party/rust/packed_simd_2/src/codegen/swap_bytes.rs
index b435fb5da120..a4435e3c3535 100644
--- a/third_party/rust/packed_simd/src/codegen/swap_bytes.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/swap_bytes.rs
@@ -119,52 +119,12 @@ macro_rules! impl_swap_bytes {
 impl_swap_bytes!(v16: u8x2, i8x2,);
 impl_swap_bytes!(v32: u8x4, i8x4, u16x2, i16x2,);
 // FIXME: 64-bit single element vector
-impl_swap_bytes!(
-    v64: u8x8,
-    i8x8,
-    u16x4,
-    i16x4,
-    u32x2,
-    i32x2, /* u64x1, i64x1, */
-);
+impl_swap_bytes!(v64: u8x8, i8x8, u16x4, i16x4, u32x2, i32x2 /* u64x1, i64x1, */,);
 
-impl_swap_bytes!(
-    v128: u8x16,
-    i8x16,
-    u16x8,
-    i16x8,
-    u32x4,
-    i32x4,
-    u64x2,
-    i64x2,
-    u128x1,
-    i128x1,
-);
-impl_swap_bytes!(
-    v256: u8x32,
-    i8x32,
-    u16x16,
-    i16x16,
-    u32x8,
-    i32x8,
-    u64x4,
-    i64x4,
-    u128x2,
-    i128x2,
-);
+impl_swap_bytes!(v128: u8x16, i8x16, u16x8, i16x8, u32x4, i32x4, u64x2, i64x2, u128x1, i128x1,);
+impl_swap_bytes!(v256: u8x32, i8x32, u16x16, i16x16, u32x8, i32x8, u64x4, i64x4, u128x2, i128x2,);
 
-impl_swap_bytes!(
-    v512: u8x64,
-    i8x64,
-    u16x32,
-    i16x32,
-    u32x16,
-    i32x16,
-    u64x8,
-    i64x8,
-    u128x4,
-    i128x4,
-);
+impl_swap_bytes!(v512: u8x64, i8x64, u16x32, i16x32, u32x16, i32x16, u64x8, i64x8, u128x4, i128x4,);
 
 cfg_if! {
     if #[cfg(target_pointer_width = "8")] {
diff --git a/third_party/rust/packed_simd/src/codegen/v128.rs b/third_party/rust/packed_simd_2/src/codegen/v128.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/v128.rs
rename to third_party/rust/packed_simd_2/src/codegen/v128.rs
diff --git a/third_party/rust/packed_simd/src/codegen/v16.rs b/third_party/rust/packed_simd_2/src/codegen/v16.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/v16.rs
rename to third_party/rust/packed_simd_2/src/codegen/v16.rs
diff --git a/third_party/rust/packed_simd/src/codegen/v256.rs b/third_party/rust/packed_simd_2/src/codegen/v256.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/v256.rs
rename to third_party/rust/packed_simd_2/src/codegen/v256.rs
diff --git a/third_party/rust/packed_simd/src/codegen/v32.rs b/third_party/rust/packed_simd_2/src/codegen/v32.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/v32.rs
rename to third_party/rust/packed_simd_2/src/codegen/v32.rs
diff --git a/third_party/rust/packed_simd/src/codegen/v512.rs b/third_party/rust/packed_simd_2/src/codegen/v512.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/v512.rs
rename to third_party/rust/packed_simd_2/src/codegen/v512.rs
diff --git a/third_party/rust/packed_simd/src/codegen/v64.rs b/third_party/rust/packed_simd_2/src/codegen/v64.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/v64.rs
rename to third_party/rust/packed_simd_2/src/codegen/v64.rs
diff --git a/third_party/rust/packed_simd/src/codegen/vPtr.rs b/third_party/rust/packed_simd_2/src/codegen/vPtr.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/codegen/vPtr.rs
rename to third_party/rust/packed_simd_2/src/codegen/vPtr.rs
diff --git a/third_party/rust/packed_simd/src/codegen/vSize.rs b/third_party/rust/packed_simd_2/src/codegen/vSize.rs
similarity index 55%
rename from third_party/rust/packed_simd/src/codegen/vSize.rs
rename to third_party/rust/packed_simd_2/src/codegen/vSize.rs
index 3911b21340c8..d5db03991d61 100644
--- a/third_party/rust/packed_simd/src/codegen/vSize.rs
+++ b/third_party/rust/packed_simd_2/src/codegen/vSize.rs
@@ -11,33 +11,6 @@ impl_simd_array!([isize; 4]: isizex4 | isize_, isize_, isize_, isize_);
 impl_simd_array!([usize; 4]: usizex4 | usize_, usize_, usize_, usize_);
 impl_simd_array!([msize; 4]: msizex4 | isize_, isize_, isize_, isize_);
 
-impl_simd_array!(
-    [isize; 8]: isizex8 | isize_,
-    isize_,
-    isize_,
-    isize_,
-    isize_,
-    isize_,
-    isize_,
-    isize_
-);
-impl_simd_array!(
-    [usize; 8]: usizex8 | usize_,
-    usize_,
-    usize_,
-    usize_,
-    usize_,
-    usize_,
-    usize_,
-    usize_
-);
-impl_simd_array!(
-    [msize; 8]: msizex8 | isize_,
-    isize_,
-    isize_,
-    isize_,
-    isize_,
-    isize_,
-    isize_,
-    isize_
-);
+impl_simd_array!([isize; 8]: isizex8 | isize_, isize_, isize_, isize_, isize_, isize_, isize_, isize_);
+impl_simd_array!([usize; 8]: usizex8 | usize_, usize_, usize_, usize_, usize_, usize_, usize_, usize_);
+impl_simd_array!([msize; 8]: msizex8 | isize_, isize_, isize_, isize_, isize_, isize_, isize_, isize_);
diff --git a/third_party/rust/packed_simd/src/lib.rs b/third_party/rust/packed_simd_2/src/lib.rs
similarity index 86%
rename from third_party/rust/packed_simd/src/lib.rs
rename to third_party/rust/packed_simd_2/src/lib.rs
index e3a747025f43..840bae38d6a3 100644
--- a/third_party/rust/packed_simd/src/lib.rs
+++ b/third_party/rust/packed_simd_2/src/lib.rs
@@ -13,8 +13,8 @@
 //! - [Vector types](#vector-types)
 //! - [Conditional operations](#conditional-operations)
 //! - [Conversions](#conversions)
-//! - [Performance
-//!   guide](https://rust-lang-nursery.github.io/packed_simd/perf-guide/)
+//! - [Hardware Features](#hardware-features)
+//! - [Performance guide](https://rust-lang-nursery.github.io/packed_simd/perf-guide/)
 //!
 //! ## Introduction
 //!
@@ -26,7 +26,7 @@
 //! are applied to each vector lane in isolation of the others:
 //!
 //! ```
-//! # use packed_simd::*;
+//! # use packed_simd_2::*;
 //! let a = i32x4::new(1, 2, 3, 4);
 //! let b = i32x4::new(5, 6, 7, 8);
 //! assert_eq!(a + b, i32x4::new(6, 8, 10, 12));
@@ -35,7 +35,7 @@
 //! Many "horizontal" operations are also provided:
 //!
 //! ```
-//! # use packed_simd::*;
+//! # use packed_simd_2::*;
 //! # let a = i32x4::new(1, 2, 3, 4);
 //! assert_eq!(a.wrapping_sum(), 10);
 //! ```
@@ -47,9 +47,9 @@
 //! and performing a single horizontal operation at the end:
 //!
 //! ```
-//! # use packed_simd::*;
+//! # use packed_simd_2::*;
 //! fn reduce(x: &[i32]) -> i32 {
-//!     assert!(x.len() % 4 == 0);
+//!     assert_eq!(x.len() % 4, 0);
 //!     let mut sum = i32x4::splat(0); // [0, 0, 0, 0]
 //!     for i in (0..x.len()).step_by(4) {
 //!         sum += i32x4::from_slice_unaligned(&x[i..]);
@@ -79,7 +79,7 @@
 //! ## Basic operations
 //!
 //! ```
-//! # use packed_simd::*;
+//! # use packed_simd_2::*;
 //! // Sets all elements to `0`:
 //! let a = i32x4::splat(0);
 //!
@@ -107,7 +107,7 @@
 //! to be performed:
 //!
 //! ```
-//! # use packed_simd::*;
+//! # use packed_simd_2::*;
 //! let a = i32x4::new(1, 1, 2, 2);
 //!
 //! // Add `1` to the first two lanes of the vector.
@@ -134,13 +134,13 @@
 //! > of lanes as the mask. The example shows this by using [`m16x4`] instead
 //! > of [`m32x4`]. It is _typically_ more performant to use a mask element
 //! > width equal to the element width of the vectors being operated upon.
-//! > This is, however, not true for 512-bit wide vectors when targetting
+//! > This is, however, not true for 512-bit wide vectors when targeting
 //! > AVX-512, where the most efficient masks use only 1-bit per element.
 //!
 //! All vertical comparison operations returns masks:
 //!
 //! ```
-//! # use packed_simd::*;
+//! # use packed_simd_2::*;
 //! let a = i32x4::new(1, 1, 3, 3);
 //! let b = i32x4::new(2, 2, 0, 0);
 //!
@@ -168,11 +168,11 @@
 //!   u8x8 = m8x8::splat(true).into_bits();` is provided because all `m8x8` bit
 //!   patterns are valid `u8x8` bit patterns. However, the opposite is not
 //! true,   not all `u8x8` bit patterns are valid `m8x8` bit-patterns, so this
-//!   operation cannot be peformed safely using `x.into_bits()`; one needs to
+//!   operation cannot be performed safely using `x.into_bits()`; one needs to
 //!   use `unsafe { crate::mem::transmute(x) }` for that, making sure that the
 //!   value in the `u8x8` is a valid bit-pattern of `m8x8`.
 //!
-//! * **numeric casts** (`as`): are peformed using [`FromCast`]/[`Cast`]
+//! * **numeric casts** (`as`): are performed using [`FromCast`]/[`Cast`]
 //! (`x.cast()`), just like `as`:
 //!
 //!   * casting integer vectors whose lane types have the same size (e.g.
@@ -198,10 +198,21 @@
 //!
 //!   Numeric casts are not very "precise": sometimes lossy, sometimes value
 //!   preserving, etc.
+//!
+//! ## Hardware Features
+//!
+//! This crate can use different hardware features based on your configured
+//! `RUSTFLAGS`. For example, with no configured `RUSTFLAGS`, `u64x8` on
+//! x86_64 will use SSE2 operations like `PCMPEQD`. If you configure
+//! `RUSTFLAGS='-C target-feature=+avx2,+avx'` on supported x86_64 hardware
+//! the same `u64x8` may use wider AVX2 operations like `VPCMPEQQ`. It is
+//! important for performance and for hardware support requirements that
+//! you choose an appropriate set of `target-feature` and `target-cpu`
+//! options during builds. For more information, see the [Performance
+//! guide](https://rust-lang-nursery.github.io/packed_simd/perf-guide/)
 
-#![cfg_attr(const_generics, feature(const_generics))]
-#![cfg_attr(not(const_generics), feature(adt_const_params))]
 #![feature(
+    adt_const_params,
     repr_simd,
     rustc_attrs,
     platform_intrinsics,
@@ -212,7 +223,7 @@
     core_intrinsics,
     stmt_expr_attributes,
     crate_visibility_modifier,
-    custom_inner_attributes
+    custom_inner_attributes,
 )]
 #![allow(non_camel_case_types, non_snake_case,
         // FIXME: these types are unsound in C FFI already
@@ -252,9 +263,8 @@ use wasm_bindgen_test::*;
 
 #[allow(unused_imports)]
 use core::{
-    /* arch (handled above), */ cmp, f32, f64, fmt, hash, hint, i128,
-    i16, i32, i64, i8, intrinsics, isize, iter, marker, mem, ops, ptr, slice,
-    u128, u16, u32, u64, u8, usize,
+    /* arch (handled above), */ cmp, f32, f64, fmt, hash, hint, i128, i16, i32, i64, i8, intrinsics,
+    isize, iter, marker, mem, ops, ptr, slice, u128, u16, u32, u64, u8, usize,
 };
 
 #[macro_use]
@@ -264,14 +274,14 @@ mod api;
 mod codegen;
 mod sealed;
 
-pub use crate::sealed::{Simd as SimdVector, Shuffle, SimdArray, Mask};
+pub use crate::sealed::{Mask, Shuffle, Simd as SimdVector, SimdArray};
 
 /// Packed SIMD vector type.
 ///
 /// # Examples
 ///
 /// ```
-/// # use packed_simd::Simd;
+/// # use packed_simd_2::Simd;
 /// let v = Simd::<[i32; 4]>::new(0, 1, 2, 3);
 /// assert_eq!(v.extract(2), 2);
 /// ```
@@ -330,8 +340,8 @@ pub use self::api::into_bits::*;
 // Re-export the shuffle intrinsics required by the `shuffle!` macro.
 #[doc(hidden)]
 pub use self::codegen::llvm::{
-    __shuffle_vector16, __shuffle_vector2, __shuffle_vector32,
-    __shuffle_vector4, __shuffle_vector64, __shuffle_vector8,
+    __shuffle_vector16, __shuffle_vector2, __shuffle_vector32, __shuffle_vector4, __shuffle_vector64,
+    __shuffle_vector8,
 };
 
 crate mod llvm {
diff --git a/third_party/rust/packed_simd/src/masks.rs b/third_party/rust/packed_simd_2/src/masks.rs
similarity index 92%
rename from third_party/rust/packed_simd/src/masks.rs
rename to third_party/rust/packed_simd_2/src/masks.rs
index aeb36d232804..04534eab2ba0 100644
--- a/third_party/rust/packed_simd/src/masks.rs
+++ b/third_party/rust/packed_simd_2/src/masks.rs
@@ -54,9 +54,7 @@ macro_rules! impl_mask_ty {
 
         impl PartialOrd<$id> for $id {
             #[inline]
-            fn partial_cmp(
-                &self, other: &Self,
-            ) -> Option<crate::cmp::Ordering> {
+            fn partial_cmp(&self, other: &Self) -> Option<crate::cmp::Ordering> {
                 use crate::cmp::Ordering;
                 if self == other {
                     Some(Ordering::Equal)
@@ -107,9 +105,7 @@ macro_rules! impl_mask_ty {
 
         impl crate::fmt::Debug for $id {
             #[inline]
-            fn fmt(
-                &self, fmtter: &mut crate::fmt::Formatter<'_>,
-            ) -> Result<(), crate::fmt::Error> {
+            fn fmt(&self, fmtter: &mut crate::fmt::Formatter<'_>) -> Result<(), crate::fmt::Error> {
                 write!(fmtter, "{}({})", stringify!($id), self.0 != 0)
             }
         }
diff --git a/third_party/rust/packed_simd/src/sealed.rs b/third_party/rust/packed_simd_2/src/sealed.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/sealed.rs
rename to third_party/rust/packed_simd_2/src/sealed.rs
diff --git a/third_party/rust/packed_simd/src/testing.rs b/third_party/rust/packed_simd_2/src/testing.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/testing.rs
rename to third_party/rust/packed_simd_2/src/testing.rs
diff --git a/third_party/rust/packed_simd_2/src/testing/macros.rs b/third_party/rust/packed_simd_2/src/testing/macros.rs
new file mode 100644
index 000000000000..7bc4268b9002
--- /dev/null
+++ b/third_party/rust/packed_simd_2/src/testing/macros.rs
@@ -0,0 +1,44 @@
+//! Testing macros
+
+macro_rules! test_if {
+    ($cfg_tt:tt: $it:item) => {
+        #[cfg(any(
+                                                            // Test everything if:
+                                                            //
+                                                            // * tests are enabled,
+                                                            // * no features about exclusively testing
+                                                            //   specific vector classes are enabled
+                                                            all(test, not(any(
+                                                                test_v16,
+                                                                test_v32,
+                                                                test_v64,
+                                                                test_v128,
+                                                                test_v256,
+                                                                test_v512,
+                                                                test_none,  // disables all tests
+                                                            ))),
+                                                            // Test if:
+                                                            //
+                                                            // * tests are enabled
+                                                            // * a particular cfg token tree returns true
+                                                            all(test, $cfg_tt),
+                                                        ))]
+        $it
+    };
+}
+
+#[cfg(test)]
+#[allow(unused)]
+macro_rules! ref_ {
+    ($anything:tt) => {
+        &$anything
+    };
+}
+
+#[cfg(test)]
+#[allow(unused)]
+macro_rules! ref_mut_ {
+    ($anything:tt) => {
+        &mut $anything
+    };
+}
diff --git a/third_party/rust/packed_simd/src/testing/utils.rs b/third_party/rust/packed_simd_2/src/testing/utils.rs
similarity index 83%
rename from third_party/rust/packed_simd/src/testing/utils.rs
rename to third_party/rust/packed_simd_2/src/testing/utils.rs
index 21f27aae5432..7d8f39573964 100644
--- a/third_party/rust/packed_simd/src/testing/utils.rs
+++ b/third_party/rust/packed_simd_2/src/testing/utils.rs
@@ -7,16 +7,15 @@
 use crate::{cmp::PartialOrd, fmt::Debug, LexicographicallyOrdered};
 
 /// Tests PartialOrd for `a` and `b` where `a < b` is true.
-pub fn test_lt<T>(
-    a: LexicographicallyOrdered<T>, b: LexicographicallyOrdered<T>,
-) where
+pub fn test_lt<T>(a: LexicographicallyOrdered<T>, b: LexicographicallyOrdered<T>)
+where
     LexicographicallyOrdered<T>: Debug + PartialOrd,
 {
     assert!(a < b, "{:?}, {:?}", a, b);
     assert!(b > a, "{:?}, {:?}", a, b);
 
     assert!(!(a == b), "{:?}, {:?}", a, b);
-    assert!(a != b, "{:?}, {:?}", a, b);
+    assert_ne!(a, b, "{:?}, {:?}", a, b);
 
     assert!(a <= b, "{:?}, {:?}", a, b);
     assert!(b >= a, "{:?}, {:?}", a, b);
@@ -37,9 +36,8 @@ pub fn test_lt<T>(
 }
 
 /// Tests PartialOrd for `a` and `b` where `a <= b` is true.
-pub fn test_le<T>(
-    a: LexicographicallyOrdered<T>, b: LexicographicallyOrdered<T>,
-) where
+pub fn test_le<T>(a: LexicographicallyOrdered<T>, b: LexicographicallyOrdered<T>)
+where
     LexicographicallyOrdered<T>: Debug + PartialOrd,
 {
     assert!(a <= b, "{:?}, {:?}", a, b);
@@ -54,14 +52,15 @@ pub fn test_le<T>(
 
         assert!(!(a != b), "{:?}, {:?}", a, b);
     } else {
-        assert!(a != b, "{:?}, {:?}", a, b);
+        assert_ne!(a, b, "{:?}, {:?}", a, b);
         test_lt(a, b);
     }
 }
 
 /// Test PartialOrd::partial_cmp for `a` and `b` returning `Ordering`
 pub fn test_cmp<T>(
-    a: LexicographicallyOrdered<T>, b: LexicographicallyOrdered<T>,
+    a: LexicographicallyOrdered<T>,
+    b: LexicographicallyOrdered<T>,
     o: Option<crate::cmp::Ordering>,
 ) where
     LexicographicallyOrdered<T>: PartialOrd + Debug,
@@ -72,18 +71,8 @@ pub fn test_cmp<T>(
     let mut arr_a: [T::Element; 64] = [Default::default(); 64];
     let mut arr_b: [T::Element; 64] = [Default::default(); 64];
 
-    unsafe {
-        crate::ptr::write_unaligned(
-            arr_a.as_mut_ptr() as *mut LexicographicallyOrdered<T>,
-            a,
-        )
-    }
-    unsafe {
-        crate::ptr::write_unaligned(
-            arr_b.as_mut_ptr() as *mut LexicographicallyOrdered<T>,
-            b,
-        )
-    }
+    unsafe { crate::ptr::write_unaligned(arr_a.as_mut_ptr() as *mut LexicographicallyOrdered<T>, a) }
+    unsafe { crate::ptr::write_unaligned(arr_b.as_mut_ptr() as *mut LexicographicallyOrdered<T>, b) }
     let expected = arr_a[0..T::LANES].partial_cmp(&arr_b[0..T::LANES]);
     let result = a.partial_cmp(&b);
     assert_eq!(expected, result, "{:?}, {:?}", a, b);
@@ -134,8 +123,7 @@ macro_rules! ptr_vals {
             // all bits cleared
             let clear: <$id as sealed::Simd>::Element = crate::mem::zeroed();
             // all bits set
-            let set: <$id as sealed::Simd>::Element =
-                crate::mem::transmute(-1_isize);
+            let set: <$id as sealed::Simd>::Element = crate::mem::transmute(-1_isize);
             (clear, set)
         }
     };
diff --git a/third_party/rust/packed_simd/src/v128.rs b/third_party/rust/packed_simd_2/src/v128.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/v128.rs
rename to third_party/rust/packed_simd_2/src/v128.rs
diff --git a/third_party/rust/packed_simd/src/v16.rs b/third_party/rust/packed_simd_2/src/v16.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/v16.rs
rename to third_party/rust/packed_simd_2/src/v16.rs
diff --git a/third_party/rust/packed_simd/src/v256.rs b/third_party/rust/packed_simd_2/src/v256.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/v256.rs
rename to third_party/rust/packed_simd_2/src/v256.rs
diff --git a/third_party/rust/packed_simd/src/v32.rs b/third_party/rust/packed_simd_2/src/v32.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/v32.rs
rename to third_party/rust/packed_simd_2/src/v32.rs
diff --git a/third_party/rust/packed_simd/src/v512.rs b/third_party/rust/packed_simd_2/src/v512.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/v512.rs
rename to third_party/rust/packed_simd_2/src/v512.rs
diff --git a/third_party/rust/packed_simd/src/v64.rs b/third_party/rust/packed_simd_2/src/v64.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/v64.rs
rename to third_party/rust/packed_simd_2/src/v64.rs
diff --git a/third_party/rust/packed_simd/src/vPtr.rs b/third_party/rust/packed_simd_2/src/vPtr.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/vPtr.rs
rename to third_party/rust/packed_simd_2/src/vPtr.rs
diff --git a/third_party/rust/packed_simd/src/vSize.rs b/third_party/rust/packed_simd_2/src/vSize.rs
similarity index 100%
rename from third_party/rust/packed_simd/src/vSize.rs
rename to third_party/rust/packed_simd_2/src/vSize.rs
diff --git a/third_party/rust/packed_simd/tests/endianness.rs b/third_party/rust/packed_simd_2/tests/endianness.rs
similarity index 96%
rename from third_party/rust/packed_simd/tests/endianness.rs
rename to third_party/rust/packed_simd_2/tests/endianness.rs
index 31fb7073afb3..da12c2338b1f 100644
--- a/third_party/rust/packed_simd/tests/endianness.rs
+++ b/third_party/rust/packed_simd_2/tests/endianness.rs
@@ -1,7 +1,7 @@
 #[cfg(target_arch = "wasm32")]
 use wasm_bindgen_test::*;
 
-use packed_simd::*;
+use packed_simd_2::*;
 use std::{mem, slice};
 
 #[cfg_attr(not(target_arch = "wasm32"), test)]
@@ -57,9 +57,7 @@ fn endian_load_and_stores() {
         8, 9, 10, 11, 12, 13, 14, 15,
     );
     let mut y: [i16; 8] = [0; 8];
-    x.write_to_slice_unaligned(unsafe {
-        slice::from_raw_parts_mut(&mut y as *mut _ as *mut i8, 16)
-    });
+    x.write_to_slice_unaligned(unsafe { slice::from_raw_parts_mut(&mut y as *mut _ as *mut i8, 16) });
 
     let e: [i16; 8] = if cfg!(target_endian = "little") {
         [256, 770, 1284, 1798, 2312, 2826, 3340, 3854]
@@ -68,9 +66,7 @@ fn endian_load_and_stores() {
     };
     assert_eq!(y, e);
 
-    let z = i8x16::from_slice_unaligned(unsafe {
-        slice::from_raw_parts(&y as *const _ as *const i8, 16)
-    });
+    let z = i8x16::from_slice_unaligned(unsafe { slice::from_raw_parts(&y as *const _ as *const i8, 16) });
     assert_eq!(z, x);
 }
 
-- 
2.37.1

