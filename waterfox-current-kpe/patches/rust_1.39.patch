From 87e993428b0805e96c76967477cb6c5e47610151 Mon Sep 17 00:00:00 2001
From: hawkeye116477 <hawkeye116477@gmail.com>
Date: Sun, 1 Dec 2019 20:04:31 +0100
Subject: [PATCH] Fix build with Rust 1.39

https://bugzilla.mozilla.org/show_bug.cgi?id=1583471
---
 Cargo.lock                                    |  32 +-
 js/rust/Cargo.toml                            |   2 +-
 js/src/wasm/cranelift/Cargo.toml              |   2 +-
 servo/components/style/Cargo.toml             |   2 +-
 third_party/rust/bindgen/.cargo-checksum.json |   2 +-
 third_party/rust/bindgen/Cargo.lock           | 413 +++++++++
 third_party/rust/bindgen/Cargo.toml           |  17 +-
 third_party/rust/bindgen/build.rs             |  11 +-
 .../rust/bindgen/csmith-fuzzing/README.md     |  65 ++
 third_party/rust/bindgen/src/callbacks.rs     |   3 +-
 third_party/rust/bindgen/src/clang.rs         | 326 ++++---
 .../rust/bindgen/src/codegen/bitfield_unit.rs |  74 +-
 .../src/codegen/bitfield_unit_tests.rs        |  81 +-
 third_party/rust/bindgen/src/codegen/error.rs |   2 +-
 .../rust/bindgen/src/codegen/helpers.rs       |  52 +-
 .../rust/bindgen/src/codegen/impl_debug.rs    |  24 +-
 .../bindgen/src/codegen/impl_partialeq.rs     |  45 +-
 third_party/rust/bindgen/src/codegen/mod.rs   | 818 ++++++++++--------
 .../rust/bindgen/src/codegen/struct_layout.rs |  35 +-
 third_party/rust/bindgen/src/features.rs      |  39 +-
 .../rust/bindgen/src/ir/analysis/derive.rs    | 220 +++--
 .../bindgen/src/ir/analysis/has_destructor.rs |  26 +-
 .../rust/bindgen/src/ir/analysis/has_float.rs |  77 +-
 .../ir/analysis/has_type_param_in_array.rs    |  24 +-
 .../bindgen/src/ir/analysis/has_vtable.rs     |  48 +-
 .../rust/bindgen/src/ir/analysis/mod.rs       |  28 +-
 .../rust/bindgen/src/ir/analysis/sizedness.rs | 101 ++-
 .../src/ir/analysis/template_params.rs        |  76 +-
 .../rust/bindgen/src/ir/annotations.rs        |  24 +-
 third_party/rust/bindgen/src/ir/comment.rs    |   8 +-
 third_party/rust/bindgen/src/ir/comp.rs       | 277 +++---
 third_party/rust/bindgen/src/ir/context.rs    | 476 +++++-----
 third_party/rust/bindgen/src/ir/derive.rs     |  26 +-
 third_party/rust/bindgen/src/ir/dot.rs        |   6 +-
 third_party/rust/bindgen/src/ir/enum_ty.rs    |  93 +-
 third_party/rust/bindgen/src/ir/function.rs   |  60 +-
 third_party/rust/bindgen/src/ir/int.rs        |  20 +-
 third_party/rust/bindgen/src/ir/item.rs       | 344 ++++----
 third_party/rust/bindgen/src/ir/item_kind.rs  |   6 +-
 third_party/rust/bindgen/src/ir/layout.rs     |  21 +-
 third_party/rust/bindgen/src/ir/mod.rs        |   6 +-
 third_party/rust/bindgen/src/ir/module.rs     |   6 +-
 third_party/rust/bindgen/src/ir/objc.rs       |   7 +-
 third_party/rust/bindgen/src/ir/template.rs   |  84 +-
 third_party/rust/bindgen/src/ir/traversal.rs  |  30 +-
 third_party/rust/bindgen/src/ir/ty.rs         | 202 ++---
 third_party/rust/bindgen/src/ir/var.rs        |  50 +-
 third_party/rust/bindgen/src/lib.rs           | 356 +++++---
 third_party/rust/bindgen/src/main.rs          |   9 +-
 third_party/rust/bindgen/src/options.rs       | 198 +++--
 third_party/rust/bindgen/src/time.rs          |  17 +-
 .../rust/rustc-hash/.cargo-checksum.json      |   1 +
 .../rust/rustc-hash/CODE_OF_CONDUCT.md        |  40 +
 .../rust/{which => rustc-hash}/Cargo.toml     |  21 +-
 third_party/rust/rustc-hash/LICENSE-APACHE    | 201 +++++
 third_party/rust/rustc-hash/LICENSE-MIT       |  23 +
 third_party/rust/rustc-hash/README.md         |  21 +
 third_party/rust/rustc-hash/src/lib.rs        | 136 +++
 third_party/rust/which/.cargo-checksum.json   |   1 -
 third_party/rust/which/LICENSE.txt            |  19 -
 third_party/rust/which/README.md              |  27 -
 third_party/rust/which/src/lib.rs             | 445 ----------
 62 files changed, 3382 insertions(+), 2524 deletions(-)
 create mode 100644 third_party/rust/bindgen/Cargo.lock
 create mode 100644 third_party/rust/bindgen/csmith-fuzzing/README.md
 create mode 100644 third_party/rust/rustc-hash/.cargo-checksum.json
 create mode 100644 third_party/rust/rustc-hash/CODE_OF_CONDUCT.md
 rename third_party/rust/{which => rustc-hash}/Cargo.toml (55%)
 create mode 100644 third_party/rust/rustc-hash/LICENSE-APACHE
 create mode 100644 third_party/rust/rustc-hash/LICENSE-MIT
 create mode 100644 third_party/rust/rustc-hash/README.md
 create mode 100644 third_party/rust/rustc-hash/src/lib.rs
 delete mode 100644 third_party/rust/which/.cargo-checksum.json
 delete mode 100644 third_party/rust/which/LICENSE.txt
 delete mode 100644 third_party/rust/which/README.md
 delete mode 100644 third_party/rust/which/src/lib.rs

diff --git a/Cargo.lock b/Cargo.lock
index 4555bba7f3bd..3144266ec3da 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -170,7 +170,7 @@ dependencies = [
 name = "baldrdash"
 version = "0.1.0"
 dependencies = [
- "bindgen 0.49.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bindgen 0.51.1-oldsyn (registry+https://github.com/rust-lang/crates.io-index)",
  "cranelift-codegen 0.30.0 (git+https://github.com/CraneStation/Cranelift?rev=cc216b46b35a797d03c0f3e8b16a2096f1c6db61)",
  "cranelift-wasm 0.30.0 (git+https://github.com/CraneStation/Cranelift?rev=cc216b46b35a797d03c0f3e8b16a2096f1c6db61)",
  "env_logger 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -232,22 +232,20 @@ dependencies = [
 
 [[package]]
 name = "bindgen"
-version = "0.49.1"
+version = "0.51.1-oldsyn"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
  "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
  "cexpr 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
  "cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)",
  "clang-sys 0.28.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "clap 2.31.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "fxhash 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "peeking_take_while 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "proc-macro2 0.4.27 (registry+https://github.com/rust-lang/crates.io-index)",
  "quote 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)",
  "regex 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "shlex 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "which 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
@@ -1475,7 +1473,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 name = "js"
 version = "0.1.4"
 dependencies = [
- "bindgen 0.49.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bindgen 0.51.1-oldsyn (registry+https://github.com/rust-lang/crates.io-index)",
  "cmake 0.1.29 (registry+https://github.com/rust-lang/crates.io-index)",
  "env_logger 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)",
  "glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -2602,6 +2600,14 @@ name = "rustc-demangle"
 version = "0.1.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
+[[package]]
+name = "rustc-hash"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "byteorder 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
 [[package]]
 name = "rustc_version"
 version = "0.2.3"
@@ -2881,7 +2887,7 @@ dependencies = [
  "app_units 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "arrayvec 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
  "atomic_refcell 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "bindgen 0.49.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bindgen 0.51.1-oldsyn (registry+https://github.com/rust-lang/crates.io-index)",
  "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
  "byteorder 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "cssparser 0.25.5 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -3578,14 +3584,6 @@ dependencies = [
  "sha2 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
-[[package]]
-name = "which"
-version = "1.0.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "libc 0.2.51 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
 [[package]]
 name = "winapi"
 version = "0.2.8"
@@ -3758,7 +3756,7 @@ dependencies = [
 "checksum base64 0.9.3 (registry+https://github.com/rust-lang/crates.io-index)" = "489d6c0ed21b11d038c31b6ceccca973e65d73ba3bd8ecb9a2babf5546164643"
 "checksum binary-space-partition 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "88ceb0d16c4fd0e42876e298d7d3ce3780dd9ebdcbe4199816a32c77e08597ff"
 "checksum bincode 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)" = "bda13183df33055cbb84b847becce220d392df502ebe7a4a78d7021771ed94d0"
-"checksum bindgen 0.49.1 (registry+https://github.com/rust-lang/crates.io-index)" = "6bd7710ac8399ae1ebe1e3aac7c9047c4f39f2c94b33c997f482f49e96991f7c"
+"checksum bindgen 0.51.1-oldsyn (registry+https://github.com/rust-lang/crates.io-index)" = "ae8266cdd336dfd53d71a95c33251232f64553b8770ebd85158039b3a734244b"
 "checksum binjs_meta 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)" = "430239e4551e42b80fa5d92322ac80ea38c9dda56e5d5582e057e2288352b71a"
 "checksum bit-set 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)" = "6f1efcc46c18245a69c38fcc5cc650f16d3a59d034f3106e9ed63748f695730a"
 "checksum bit-vec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)" = "f59bbe95d4e52a6398ec21238d31577f2b28a9d86807f06ca59d191d8440d0bb"
@@ -3978,6 +3976,7 @@ dependencies = [
 "checksum rust-ini 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)" = "8a654c5bda722c699be6b0fe4c0d90de218928da5b724c3e467fc48865c37263"
 "checksum rust_cascade 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)" = "f3fe4900d38dab1ad21a515e44687dd0711e6b0ec5b214a3b1aa8857343bcf3a"
 "checksum rustc-demangle 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)" = "76d7ba1feafada44f2d38eed812bd2489a03c0f5abb975799251518b68848649"
+"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)" = "7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8"
 "checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)" = "138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a"
 "checksum ryu 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)" = "fd0568787116e13c652377b6846f5931454a363a8fdf8ae50463ee40935b278b"
 "checksum safemem 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)" = "8dca453248a96cb0749e36ccdfe2b0b4e54a61bfef89fb97ec621eb8e0a93dd9"
@@ -4060,7 +4059,6 @@ dependencies = [
 "checksum want 0.0.6 (registry+https://github.com/rust-lang/crates.io-index)" = "797464475f30ddb8830cc529aaaae648d581f99e2036a928877dfde027ddf6b3"
 "checksum wasmparser 0.29.2 (registry+https://github.com/rust-lang/crates.io-index)" = "981a8797cf89762e0233ec45fae731cb79a4dfaee12d9f0fe6cee01e4ac58d00"
 "checksum webidl 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)" = "d0f807f7488d680893f7188aa09d7672a3a0a8461975a098a2edf0a52e3fee29"
-"checksum which 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)" = "4be6cfa54dab45266e98b5d7be2f8ce959ddd49abd141a05d52dce4b07f803bb"
 "checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)" = "167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a"
 "checksum winapi 0.3.6 (git+https://github.com/froydnj/winapi-rs?branch=aarch64)" = "<none>"
 "checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc"
diff --git a/js/rust/Cargo.toml b/js/rust/Cargo.toml
index d1fa05382e9e..f962b903974b 100644
--- a/js/rust/Cargo.toml
+++ b/js/rust/Cargo.toml
@@ -7,7 +7,7 @@ license = "MPL-2.0"
 
 [build-dependencies]
 env_logger = {version = "0.5", default-features = false} # disable `regex` to reduce code size
-bindgen = {version = "0.49", default-features = false} # disable `logging` to reduce code size
+bindgen = {version = "0.51.1-oldsyn", default-features = false} # disable `logging` to reduce code size
 cmake = "0.1"
 glob = "0.2.11"
 
diff --git a/js/src/wasm/cranelift/Cargo.toml b/js/src/wasm/cranelift/Cargo.toml
index 7adc2868a725..a32a0747f07a 100644
--- a/js/src/wasm/cranelift/Cargo.toml
+++ b/js/src/wasm/cranelift/Cargo.toml
@@ -22,7 +22,7 @@ log = { version = "0.4.6", default-features = false, features = ["release_max_le
 env_logger = "0.5.6"
 
 [build-dependencies]
-bindgen = {version = "0.49", default-features = false} # disable `logging` to reduce code size
+bindgen = {version = "0.51.1-oldsyn", default-features = false} # disable `logging` to reduce code size
 
 [features]
 default = ['cranelift-codegen/std']
diff --git a/servo/components/style/Cargo.toml b/servo/components/style/Cargo.toml
index 54493548b67a..45dabc8e9d0c 100644
--- a/servo/components/style/Cargo.toml
+++ b/servo/components/style/Cargo.toml
@@ -81,7 +81,7 @@ void = "1.0.2"
 [build-dependencies]
 lazy_static = "1"
 log = "0.4"
-bindgen = {version = "0.49", optional = true, default-features = false}
+bindgen = {version = "0.51.1-oldsyn", optional = true, default-features = false}
 regex = {version = "1.0", optional = true}
 walkdir = "2.1.4"
 toml = {version = "0.4.5", optional = true, default-features = false}
diff --git a/third_party/rust/bindgen/.cargo-checksum.json b/third_party/rust/bindgen/.cargo-checksum.json
index fa420dfa3af4..3560675c0542 100644
--- a/third_party/rust/bindgen/.cargo-checksum.json
+++ b/third_party/rust/bindgen/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"Cargo.toml":"9af635e7bad9021a49742a312faf6178b757dbd48aabc998931d6f491f14c179","LICENSE":"c23953d9deb0a3312dbeaf6c128a657f3591acee45067612fa68405eaa4525db","README.md":"5a1f556c6a57c0a6ccc65e19c27718e0f4b32381a8efcc80f6601b33c58c5d59","build.rs":"a9f6915c54d75f357ce32f96327bf4df53dc81a505b70831978f9dac6f43841d","src/callbacks.rs":"b24d7982332c6a35928f134184ddf4072fe4545a45546b97b9b0e0c1fbb77c08","src/clang.rs":"e9203eb5a1b432efebafcd011896e35e8c9145037bf99e7bb3709dc1b8e8e783","src/codegen/bitfield_unit.rs":"88b0604322dc449fc9284850eadc1f5d14b42fa747d4258bae0b6b9535f52dfd","src/codegen/bitfield_unit_tests.rs":"2073ac6a36e0bc9afaef5b1207966817c8fb7a1a9f6368c3b1b8f79822efbfba","src/codegen/error.rs":"2613af1d833377fd4a70719f4a09951d9d45dc9227827b9a2a938a1bcaaea2dd","src/codegen/helpers.rs":"fbd23e68dd51ccaddeb9761394d5df2db49baded0e2dccf6bbc52a2d6de502eb","src/codegen/impl_debug.rs":"f82969461d522fb758eca552ceaf189122a404cbb47fcc16008bfe52fc62aefa","src/codegen/impl_partialeq.rs":"d40d9ee2849c4d3d557b033c4d3af5e6de4a44347f67c0f016198086338811af","src/codegen/mod.rs":"238d989e13b7556e5d120a2bfe85b43332fba56cbe8df886d4c32e650fff1247","src/codegen/struct_layout.rs":"3fa5524aff82365ce292b0cc85080514c85a6dbd31bce90f001773b995dda28e","src/extra_assertions.rs":"494534bd4f18b80d89b180c8a93733e6617edcf7deac413e9a73fd6e7bc9ced7","src/features.rs":"c5fd7149f4a3b41fd4f89ade08505170942f4bc791bcb6a34fdddd3ae61856f8","src/ir/analysis/derive.rs":"325d4c1c1e6194e743f42a2316f1501b0ef852fe309f2e9cac3434825ad235f0","src/ir/analysis/has_destructor.rs":"63644f479738df35e531d3324ff892614083c3656e0747aa34d9f20dada878ec","src/ir/analysis/has_float.rs":"76162a309e4285a806755a08c687a3e7bc894a100a63da4e88584035e215b11d","src/ir/analysis/has_type_param_in_array.rs":"fdbc0af28a144c88ea2de83e6e6da5e1ffb40e3dd63fd7a708095d085bb06f94","src/ir/analysis/has_vtable.rs":"5788372d27bdbaaf0454bc17be31a5480918bc41a8a1c4832e8c61185c07f9cd","src/ir/analysis/mod.rs":"1f218e15c19f6666512908abc853fa7ff9ca5d0fafd94f026d9e4b0ce287ec3c","src/ir/analysis/sizedness.rs":"8dc10043d872e68e660ef96edca4d9733f95be45cdad4893462fa929b335014f","src/ir/analysis/template_params.rs":"6312c008bbc80f50e72a766756c8daddea0b6eeb31ec924b83a231df931e170e","src/ir/annotations.rs":"39a5ab19f4d5dfa617577e4a0d0d2b67b5369d480c7cca4b14d172458c9843f0","src/ir/comment.rs":"c48abe01c5af0f09f583a89f1394bc6c161b40f6c8f0f600bbfe3c907b47969b","src/ir/comp.rs":"ca439407faefbe3a198246f0a1dbdf4e40307e45eaaad317e85d1aab37bb31fc","src/ir/context.rs":"599226eb04d337a1b1b13af91af91bdb02dbd5f26f274cbc0ebc4489eb144fc0","src/ir/derive.rs":"34f9aa76b6c9c05136bb69dcd6455397faef571a567254d2c541d50a962994db","src/ir/dot.rs":"95ed2968fc3239d87892e9f1edf1ed6dd18630d949564961765967ea1d16960c","src/ir/enum_ty.rs":"9cc242d6b3c1866665594e8b306860ee39c0ea42d22198d46b7fded473fe3e84","src/ir/function.rs":"2d41d9df19f42b0c383f338be4c026c005853a8d1caf5f3e5a2f3a8dad202232","src/ir/int.rs":"07e0c7dbd2dd977177fae3acd2a14adf271c6cf9ff4b57cddc11d50734fd4801","src/ir/item.rs":"3bcdb69b793350e5744aec3577cdbb1e5068ece5220c38763cecd82dfb5e8f03","src/ir/item_kind.rs":"dbeae8c4fd0e5c9485d325aea040e056a1f2cd6d43fc927dee8fe1c0c59a7197","src/ir/layout.rs":"d49582081f5f86f7595afbe4845f38fb3b969a840b568f4a49b265e7d790bb5b","src/ir/mod.rs":"2eae90f207fad2e45957ec9287064992a419e3fc916aba84faff2ea25cbeb5ee","src/ir/module.rs":"c4d90bf38fe3672e01923734ccbdb7951ea929949d5f413a9c2aee12395a5094","src/ir/objc.rs":"758aa955a0c5d6ad82606c88a1f4cd1d93e666b71e82d43b18b1aaae96cf888a","src/ir/template.rs":"c0f8570b927dfd6a421fc4ce3094ec837a3ed936445225dbfac961e8e0842ae5","src/ir/traversal.rs":"ea751379a5aec02f93f8d2c61e18232776b1f000dbeae64b9a7195ba21a19dd6","src/ir/ty.rs":"952fb04cd6a71a2bca5c509aecacb42a1de0cae75824941541a38dc589f0993a","src/ir/var.rs":"8bdafb6d02f2c55ae11c28d88b19fb7a65ba8466da12ff039ae4c16c790b291e","src/lib.rs":"d5c8b404c515d30fc2d78b28eb84cff6b256f1f1e2dbd6aca280529bb2af6879","src/log_stubs.rs":"6dfdd908b7c6453da416cf232893768f9480e551ca4add0858ef88bf71ee6ceb","src/main.rs":"e519053bcdde6bc88f60f955246a02d53b3db1cc5ccd1612e6675b790b7460b0","src/options.rs":"041d635c8f6712ca32676a68f06d0245faed5577d9513786e058540ea2a69a7f","src/parse.rs":"be7d13cc84fae79ec7b3aa9e77063fa475a48d74a854423e2c72d75006a25202","src/regex_set.rs":"5cb72fc3714c0d79e9e942d003349c0775fafd7cd0c9603c65f5261883bbf9cf","src/time.rs":"3b763e6fee51d0eb01228dfe28bc28a9f692aff73b2a7b90a030902e0238fca6"},"package":"6bd7710ac8399ae1ebe1e3aac7c9047c4f39f2c94b33c997f482f49e96991f7c"}
\ No newline at end of file
+{"files":{"Cargo.lock":"08acbc65a73a371ed1468a7937888e4a92da259bcff32f3f76c2207b45f0f75f","Cargo.toml":"03fdbfce44fd7e90fd59b8ffc43bcb8cb92ce05c9f4aa22c21040a2fc7979d63","LICENSE":"c23953d9deb0a3312dbeaf6c128a657f3591acee45067612fa68405eaa4525db","README.md":"5a1f556c6a57c0a6ccc65e19c27718e0f4b32381a8efcc80f6601b33c58c5d59","build.rs":"e1f148e01150af6a66b6af2e5d955c8b9fa092cb4697bae2bcec8a00119055ae","csmith-fuzzing/README.md":"7107b70fedb0c0a0cadb3c439a49c1bd0119a6d38dc63b1aecc74d1942256ef2","src/callbacks.rs":"82e0be9ca02e9a652af934ed546f1cedfc6db0716643123d9a5aab33b360c7d0","src/clang.rs":"66e86bfbbe872cc247cf3bc88a2155e25f587414834023515d184dc13f8f7287","src/codegen/bitfield_unit.rs":"a8fb1a2d97a99685106fcaac87d2013f79d2690d6a46ff05ad1e3629b6075664","src/codegen/bitfield_unit_tests.rs":"dd252134118450800b516e375c872e17b4c1aee63a7b8adbe5b2cd53434bbc7e","src/codegen/error.rs":"ebc9e0f50c6adc9558b76ce774346c02316500a1ebe3cbf56ed00e5e9fe3e456","src/codegen/helpers.rs":"304c9eb56ea6b2c054e1f9fefd5812b0df3a156eee5876f3051fd0b48c7aeac3","src/codegen/impl_debug.rs":"428df604b4be105e3275275e8be81e8306b940abddc1b89675f98a01bf5de8c1","src/codegen/impl_partialeq.rs":"83707f7b13501dc413c904a17163cb54af11e56138f36dfef40ce46c823200fd","src/codegen/mod.rs":"42732503dd25ed4b7924b71862f9100cf281e22f99016540da61a602c78a3650","src/codegen/struct_layout.rs":"482bab6384e65c78346de4f8d8e4d1c3b7df38250788b58bdd1f7b1c7bf70bac","src/extra_assertions.rs":"494534bd4f18b80d89b180c8a93733e6617edcf7deac413e9a73fd6e7bc9ced7","src/features.rs":"2d82f0700c22ea44e010a89c3ae857c3feaf2c85cab3fe4d0277a41a8c2841c4","src/ir/analysis/derive.rs":"2a2322f178760859cdb4b2d45d947ff213c7c684840b4ade46b7ceb34fa6705b","src/ir/analysis/has_destructor.rs":"10380d06ed03d058f10f6f6835d9b8fbebac455a1ea218780430a0ffd8d63472","src/ir/analysis/has_float.rs":"1838ba81eb05a9c3e311687e2247d561cc5093377b15ef8008257025ea56da04","src/ir/analysis/has_type_param_in_array.rs":"dddc5511a705e3a653b5e754e359637031b4862e1a1fc1e17f711fb2fbfc1cef","src/ir/analysis/has_vtable.rs":"8da9deec23c4552ecd5b883eaa036e4f2174a5949194c333a62ef463d28dcb6a","src/ir/analysis/mod.rs":"54993cb77df1870bb12cbc6b3a243c2da942cdc967a7d21dacb430601b49b2a1","src/ir/analysis/sizedness.rs":"d0673e19add38a07680ae3a9a5e998a0b2c3917e68efb6639ffe7ea193ada1b1","src/ir/analysis/template_params.rs":"9b662b5ec99cd8409d771a16ee42df500962b0c26f0da85e430ede19cc2b17c9","src/ir/annotations.rs":"268f90fc1d40fadee329c26b183b2aaa9de98f9246fea580404ee0e626315546","src/ir/comment.rs":"31d64a49ae3d9c3c348fa2539e03306ca3a23fae429cab452e42b31ecf632145","src/ir/comp.rs":"73d5d32d70b8e62d33ad4ed6bcbb9b23273c59b5b45570b85a2357c6e1116028","src/ir/context.rs":"c30be52b22fdb489afb34426bcb2e048ae2594846b15324693dd1b71e7dc3369","src/ir/derive.rs":"e5581852eec87918901a129284b4965aefc8a19394187a8095779a084f28fabe","src/ir/dot.rs":"5da8336bf5fd8efabd784a06e0d764eb91566c19ced8ce017a24ae237f0cbe18","src/ir/enum_ty.rs":"c303f3b271d2703c2487e4afaf4b8c9b5bbedb9e1c6a8044de667c21ad8f67fb","src/ir/function.rs":"7a25a55d7f2ded1724894bd1f7ee4766a4bf5f193967bf3a2628ec604b918018","src/ir/int.rs":"68a86182743ec338d58e42203364dc7c8970cb7ec3550433ca92f0c9489b4442","src/ir/item.rs":"203fe53efb0203e0ddc3fb9fcff7b2068f80f252d249a39c137e0cc070663a49","src/ir/item_kind.rs":"7666a1ff1b8260978b790a08b4139ab56b5c65714a5652bbcec7faa7443adc36","src/ir/layout.rs":"936f96fafab34e35b622a5f9e56b0fbd2c97d2e9222470e3687f882f40db1349","src/ir/mod.rs":"713cd537434567003197a123cbae679602c715e976d22f7b23dafd0826ea4c70","src/ir/module.rs":"a26bb0ac90d4cabb0a45d9c1a42b5515c74d4c233dc084e2f85161eac12bff15","src/ir/objc.rs":"ced8242068d5daa2940469693f7277c79368019f8e30ce1e4f55d834bf24c411","src/ir/template.rs":"6c2823c9bab82ab1d70f4d643e8f4d6420be5eafcb78324fb69649e407561cec","src/ir/traversal.rs":"c9bc1b8d7f1673d6f709e14bc04b684ec7097c2d12de446a2327296d5efc9547","src/ir/ty.rs":"5af2b62d278c679b7c4e597263fce01113e90242e7d263b948d93bc4274dfe9a","src/ir/var.rs":"9226241b188877b6a7bea6523e14318a8523a6dba57c4f15809c377f87540061","src/lib.rs":"b968f8d0858e3145137a2e33c0913acf19d21f884f914bc513bc18eea1c37bf1","src/log_stubs.rs":"6dfdd908b7c6453da416cf232893768f9480e551ca4add0858ef88bf71ee6ceb","src/main.rs":"6b42a74dfd5c3bde75b7fb984a82f3b3d652abd45aa54b31a40fbda6b02ae674","src/options.rs":"f08facc9d58cb79c7ab93c9d614f13d4d3eca2b5801012da56490a790a8d8c4c","src/parse.rs":"be7d13cc84fae79ec7b3aa9e77063fa475a48d74a854423e2c72d75006a25202","src/regex_set.rs":"5cb72fc3714c0d79e9e942d003349c0775fafd7cd0c9603c65f5261883bbf9cf","src/time.rs":"8efe317e7c6b5ba8e0865ce7b49ca775ee8a02590f4241ef62f647fa3c22b68e"},"package":"ae8266cdd336dfd53d71a95c33251232f64553b8770ebd85158039b3a734244b"}
\ No newline at end of file
diff --git a/third_party/rust/bindgen/Cargo.lock b/third_party/rust/bindgen/Cargo.lock
new file mode 100644
index 000000000000..285ae615a9e5
--- /dev/null
+++ b/third_party/rust/bindgen/Cargo.lock
@@ -0,0 +1,413 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+[[package]]
+name = "aho-corasick"
+version = "0.6.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "memchr 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "ansi_term"
+version = "0.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "atty"
+version = "0.2.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
+ "termion 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "bindgen"
+version = "0.51.1-oldsyn"
+dependencies = [
+ "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "cexpr 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "cfg-if 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "clang-sys 0.28.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)",
+ "env_logger 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "peeking_take_while 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "proc-macro2 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "regex 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "shlex 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "which 3.0.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "bitflags"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "byteorder"
+version = "1.2.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "cc"
+version = "1.0.25"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "cexpr"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "nom 4.0.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "cfg-if"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "clang-sys"
+version = "0.28.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libloading 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "clap"
+version = "2.32.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "strsim 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "textwrap 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "vec_map 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "diff"
+version = "0.1.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "env_logger"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
+ "humantime 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "regex 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "termcolor 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "glob"
+version = "0.2.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "humantime"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "lazy_static"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "version_check 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "libc"
+version = "0.2.43"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "libloading"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "log"
+version = "0.4.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cfg-if 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "memchr"
+version = "2.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cfg-if 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
+ "version_check 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "nom"
+version = "4.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "memchr 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "peeking_take_while"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "proc-macro2"
+version = "0.4.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "quick-error"
+version = "1.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "quote"
+version = "0.6.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "proc-macro2 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "redox_syscall"
+version = "0.1.40"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "redox_termios"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "regex"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "aho-corasick 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "memchr 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "regex-syntax 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "utf8-ranges 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "regex-syntax"
+version = "0.6.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "ucd-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rustc-hash"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "shlex"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "strsim"
+version = "0.7.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "termcolor"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "wincolor 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "termion"
+version = "1.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
+ "redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)",
+ "redox_termios 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "textwrap"
+version = "0.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "thread_local"
+version = "0.3.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "ucd-util"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "unicode-width"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "unicode-xid"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "utf8-ranges"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "vec_map"
+version = "0.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "version_check"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "which"
+version = "3.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "winapi"
+version = "0.3.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "winapi-i686-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "winapi-util"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "winapi-x86_64-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "wincolor"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[metadata]
+"checksum aho-corasick 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)" = "68f56c7353e5a9547cbd76ed90f7bb5ffc3ba09d4ea9bd1d8c06c8b1142eeb5a"
+"checksum ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)" = "ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b"
+"checksum atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)" = "9a7d5b8723950951411ee34d271d99dddcc2035a16ab25310ea2c8cfd4369652"
+"checksum bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)" = "228047a76f468627ca71776ecdebd732a3423081fcf5125585bcd7c49886ce12"
+"checksum byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)" = "94f88df23a25417badc922ab0f5716cc1330e87f71ddd9203b3a3ccd9cedf75d"
+"checksum cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)" = "f159dfd43363c4d08055a07703eb7a3406b0dac4d0584d96965a3262db3c9d16"
+"checksum cexpr 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "8fc0086be9ca82f7fc89fc873435531cb898b86e850005850de1f820e2db6e9b"
+"checksum cfg-if 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)" = "0c4e7bb64a8ebb0d856483e1e682ea3422f883c5f5615a90d51a2c82fe87fdd3"
+"checksum clang-sys 0.28.0 (registry+https://github.com/rust-lang/crates.io-index)" = "4227269cec09f5f83ff160be12a1e9b0262dd1aa305302d5ba296c2ebd291055"
+"checksum clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)" = "b957d88f4b6a63b9d70d5f454ac8011819c6efa7727858f458ab71c756ce2d3e"
+"checksum diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)" = "3c2b69f912779fbb121ceb775d74d51e915af17aaebc38d28a592843a2dd0a3a"
+"checksum env_logger 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)" = "afb070faf94c85d17d50ca44f6ad076bce18ae92f0037d350947240a36e9d42e"
+"checksum glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)" = "8be18de09a56b60ed0edf84bc9df007e30040691af7acd1c41874faac5895bfb"
+"checksum humantime 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "0484fda3e7007f2a4a0d9c3a703ca38c71c54c55602ce4660c419fd32e188c9e"
+"checksum lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "ca488b89a5657b0a2ecd45b95609b3e848cf1755da332a0da46e2b2b1cb371a7"
+"checksum libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)" = "76e3a3ef172f1a0b9a9ff0dd1491ae5e6c948b94479a3021819ba7d860c8645d"
+"checksum libloading 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)" = "9c3ad660d7cb8c5822cd83d10897b0f1f1526792737a179e73896152f85b88c2"
+"checksum log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)" = "d4fcce5fa49cc693c312001daf1d13411c4a5283796bac1084299ea3e567113f"
+"checksum memchr 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "4b3629fe9fdbff6daa6c33b90f7c08355c1aca05a3d01fa8063b822fcf185f3b"
+"checksum nom 4.0.0 (registry+https://github.com/rust-lang/crates.io-index)" = "898696750eb5c3ce5eb5afbfbe46e7f7c4e1936e19d3e97be4b7937da7b6d114"
+"checksum peeking_take_while 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "19b17cddbe7ec3f8bc800887bab5e717348c95ea2ca0b1bf0837fb964dc67099"
+"checksum proc-macro2 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)" = "ffe022fb8c8bd254524b0b3305906c1921fa37a84a644e29079a9e62200c3901"
+"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0"
+"checksum quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)" = "dd636425967c33af890042c483632d33fa7a18f19ad1d7ea72e8998c6ef8dea5"
+"checksum redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)" = "c214e91d3ecf43e9a4e41e578973adeb14b474f2bee858742d127af75a0112b1"
+"checksum redox_termios 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "7e891cfe48e9100a70a3b6eb652fef28920c117d366339687bd5576160db0f76"
+"checksum regex 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)" = "2069749032ea3ec200ca51e4a31df41759190a88edca0d2d86ee8bedf7073341"
+"checksum regex-syntax 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)" = "747ba3b235651f6e2f67dfa8bcdcd073ddb7c243cb21c442fc12395dfcac212d"
+"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)" = "7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8"
+"checksum shlex 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "7fdf1b9db47230893d76faad238fd6097fd6d6a9245cd7a4d90dbd639536bbd2"
+"checksum strsim 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)" = "bb4f380125926a99e52bc279241539c018323fab05ad6368b56f93d9369ff550"
+"checksum termcolor 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)" = "4096add70612622289f2fdcdbd5086dc81c1e2675e6ae58d6c4f62a16c6d7f2f"
+"checksum termion 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)" = "689a3bdfaab439fd92bc87df5c4c78417d3cbe537487274e9b0b2dce76e92096"
+"checksum textwrap 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)" = "307686869c93e71f94da64286f9a9524c0f308a9e1c87a583de8e9c9039ad3f6"
+"checksum thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)" = "c6b53e329000edc2b34dbe8545fd20e55a333362d0a321909685a19bd28c3f1b"
+"checksum ucd-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "fd2be2d6639d0f8fe6cdda291ad456e23629558d466e2789d2c3e9892bda285d"
+"checksum unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)" = "882386231c45df4700b275c7ff55b6f3698780a650026380e72dabe76fa46526"
+"checksum unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "fc72304796d0818e357ead4e000d19c9c174ab23dc11093ac919054d20a6a7fc"
+"checksum utf8-ranges 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)" = "fd70f467df6810094968e2fce0ee1bd0e87157aceb026a8c083bcf5e25b9efe4"
+"checksum vec_map 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)" = "05c78687fb1a80548ae3250346c3db86a80a7cdd77bda190189f2d0a0987c81a"
+"checksum version_check 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)" = "7716c242968ee87e5542f8021178248f267f295a5c4803beae8b8b7fd9bc6051"
+"checksum which 3.0.0 (registry+https://github.com/rust-lang/crates.io-index)" = "240a31163872f7e8e49f35b42b58485e35355b07eb009d9f3686733541339a69"
+"checksum winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)" = "773ef9dcc5f24b7d850d0ff101e542ff24c3b090a9768e03ff889fdef41f00fd"
+"checksum winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
+"checksum winapi-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "afc5508759c5bf4285e61feb862b6083c8480aec864fa17a81fdec6f69b461ab"
+"checksum winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
+"checksum wincolor 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)" = "561ed901ae465d6185fa7864d63fbd5720d0ef718366c9a4dc83cf6170d7e9ba"
diff --git a/third_party/rust/bindgen/Cargo.toml b/third_party/rust/bindgen/Cargo.toml
index 7299a515ae10..54f480b874cb 100644
--- a/third_party/rust/bindgen/Cargo.toml
+++ b/third_party/rust/bindgen/Cargo.toml
@@ -12,7 +12,7 @@
 
 [package]
 name = "bindgen"
-version = "0.49.1"
+version = "0.51.1-oldsyn"
 authors = ["Jyun-Yan You <jyyou.tw@gmail.com>", "Emilio Cobos √Ålvarez <emilio@crisal.io>", "Nick Fitzgerald <fitzgen@gmail.com>", "The Servo project developers"]
 build = "build.rs"
 include = ["LICENSE", "README.md", "Cargo.toml", "build.rs", "src/*.rs", "src/**/*.rs"]
@@ -32,6 +32,7 @@ path = "src/lib.rs"
 name = "bindgen"
 path = "src/main.rs"
 doc = false
+required-features = ["clap"]
 [dependencies.bitflags]
 version = "1.0.3"
 
@@ -47,14 +48,12 @@ features = ["runtime", "clang_6_0"]
 
 [dependencies.clap]
 version = "2"
+optional = true
 
 [dependencies.env_logger]
 version = "0.6"
 optional = true
 
-[dependencies.fxhash]
-version = "0.2"
-
 [dependencies.lazy_static]
 version = "1"
 
@@ -76,11 +75,16 @@ default-features = false
 [dependencies.regex]
 version = "1.0"
 
+[dependencies.rustc-hash]
+version = "1.0.1"
+
 [dependencies.shlex]
 version = "0.1"
 
 [dependencies.which]
-version = ">=1.0, <3.0"
+version = "3.0"
+optional = true
+default-features = false
 [dev-dependencies.clap]
 version = "2"
 
@@ -91,7 +95,7 @@ version = "0.1"
 version = "0.1"
 
 [features]
-default = ["logging"]
+default = ["logging", "clap", "which-rustfmt"]
 logging = ["env_logger", "log"]
 static = []
 testing_only_docs = []
@@ -100,5 +104,6 @@ testing_only_libclang_3_8 = []
 testing_only_libclang_3_9 = []
 testing_only_libclang_4 = []
 testing_only_libclang_5 = []
+which-rustfmt = ["which"]
 [badges.travis-ci]
 repository = "rust-lang/rust-bindgen"
diff --git a/third_party/rust/bindgen/build.rs b/third_party/rust/bindgen/build.rs
index cb33217d10ac..acae6d672282 100644
--- a/third_party/rust/bindgen/build.rs
+++ b/third_party/rust/bindgen/build.rs
@@ -7,8 +7,8 @@ mod target {
     pub fn main() {
         let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
 
-        let mut dst = File::create(Path::new(&out_dir).join("host-target.txt"))
-            .unwrap();
+        let mut dst =
+            File::create(Path::new(&out_dir).join("host-target.txt")).unwrap();
         dst.write_all(env::var("TARGET").unwrap().as_bytes())
             .unwrap();
     }
@@ -24,8 +24,8 @@ mod testgen {
 
     pub fn main() {
         let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
-        let mut dst = File::create(Path::new(&out_dir).join("tests.rs"))
-            .unwrap();
+        let mut dst =
+            File::create(Path::new(&out_dir).join("tests.rs")).unwrap();
 
         let manifest_dir =
             PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
@@ -57,7 +57,8 @@ mod testgen {
                         "test_header!(header_{}, {:?});",
                         func,
                         entry.path(),
-                    ).unwrap();
+                    )
+                    .unwrap();
                 }
                 _ => {}
             }
diff --git a/third_party/rust/bindgen/csmith-fuzzing/README.md b/third_party/rust/bindgen/csmith-fuzzing/README.md
new file mode 100644
index 000000000000..cdd6d0866a64
--- /dev/null
+++ b/third_party/rust/bindgen/csmith-fuzzing/README.md
@@ -0,0 +1,65 @@
+# Fuzzing `bindgen` with `csmith`
+
+[`csmith`][csmith] generates random C and C++ programs that can be used as test
+cases for compilers. When testing `bindgen` with `csmith`, we interpret the
+generated programs as header files, and emit Rust bindings to them. If `bindgen`
+panics, the emitted bindings won't compile with `rustc`, or the generated layout
+tests in the bindings fail, then we report an issue containing the test case!
+
+<!-- START doctoc generated TOC please keep comment here to allow auto update -->
+<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
+
+
+- [Prerequisites](#prerequisites)
+- [Running the Fuzzer](#running-the-fuzzer)
+- [Reporting Issues](#reporting-issues)
+
+<!-- END doctoc generated TOC please keep comment here to allow auto update -->
+
+## Prerequisites
+
+Requires `python3`, `csmith`, and `creduce` to be in `$PATH`.
+
+Many OS package managers have `csmith` and `creduce` packages:
+
+```
+$ sudo apt install csmith creduce
+$ brew install csmith creduce
+$ # Etc...
+```
+
+## Running the Fuzzer
+
+Run `csmith` and test `bindgen` on the generated test cases with this command:
+
+```
+$ ./driver.py
+```
+
+The driver will keep running until it encounters an error in `bindgen`.
+
+Each invocation of `./driver.py` will use its own temporary directories, so
+running it in multiple terminals in parallel is supported.
+
+`csmith` is run with `--no-checksum --nomain --max-block-size 1
+--max-block-depth 1` which disables the `main` function, and makes function
+bodies as simple as possible as `bindgen` does not care about them, but they
+cannot be completely disabled in `csmith`. Run `csmith --help` to see what
+exactly those options do.
+
+## Reporting Issues
+
+Once the fuzz driver finds a test case that causes some kind of error in
+`bindgen` or its emitted bindings, it is helpful to
+[run C-Reduce on the test case][creducing] to remove the parts that are
+irrelevant to reproducing the error. This is ***very*** helpful for the folks
+who further investigate the issue and come up with a fix!
+
+Additionally, mention that you discovered the issue via `csmith` and we will add
+the `A-csmith` label. You can find all the issues discovered with `csmith`, and
+related to fuzzing with `csmith`, by looking up
+[all issues tagged with the `A-csmith` label][csmith-issues].
+
+[csmith]: https://github.com/csmith-project/csmith
+[creducing]: ../CONTRIBUTING.md#using-creduce-to-minimize-test-cases
+[csmith-issues]: https://github.com/rust-lang/rust-bindgen/issues?q=label%3AA-csmith
diff --git a/third_party/rust/bindgen/src/callbacks.rs b/third_party/rust/bindgen/src/callbacks.rs
index 81fe0c0eb6f0..91920738d6e5 100644
--- a/third_party/rust/bindgen/src/callbacks.rs
+++ b/third_party/rust/bindgen/src/callbacks.rs
@@ -37,8 +37,7 @@ pub trait ParseCallbacks: fmt::Debug + UnwindSafe {
 
     /// This will be run on every string macro. The callback can not influence the further
     /// treatment of the macro, but may use the value to generate additional code or configuration.
-    fn str_macro(&self, _name: &str, _value: &[u8]) {
-    }
+    fn str_macro(&self, _name: &str, _value: &[u8]) {}
 
     /// This function should return whether, given an enum variant
     /// name, and value, this enum variant will forcibly be a constant.
diff --git a/third_party/rust/bindgen/src/clang.rs b/third_party/rust/bindgen/src/clang.rs
index e02d363fb98c..9af6b46d3e7f 100644
--- a/third_party/rust/bindgen/src/clang.rs
+++ b/third_party/rust/bindgen/src/clang.rs
@@ -6,14 +6,14 @@
 
 use cexpr;
 use clang_sys::*;
-use regex;
 use ir::context::BindgenContext;
-use std::{mem, ptr, slice};
+use regex;
 use std::ffi::{CStr, CString};
 use std::fmt;
 use std::hash::Hash;
 use std::hash::Hasher;
-use std::os::raw::{c_char, c_int, c_uint, c_ulong, c_longlong, c_ulonglong};
+use std::os::raw::{c_char, c_int, c_longlong, c_uint, c_ulong, c_ulonglong};
+use std::{mem, ptr, slice};
 
 /// A cursor into the Clang AST, pointing to an AST node.
 ///
@@ -43,7 +43,11 @@ impl Cursor {
     /// The USR can be used to compare entities across translation units.
     pub fn usr(&self) -> Option<String> {
         let s = unsafe { cxstring_into_string(clang_getCursorUSR(self.x)) };
-        if s.is_empty() { None } else { Some(s) }
+        if s.is_empty() {
+            None
+        } else {
+            Some(s)
+        }
     }
 
     /// Is this cursor's referent a declaration?
@@ -210,8 +214,9 @@ impl Cursor {
 
         while semantic_parent.is_some() &&
             (semantic_parent.unwrap().kind() == CXCursor_Namespace ||
-                 semantic_parent.unwrap().kind() == CXCursor_NamespaceAlias ||
-                 semantic_parent.unwrap().kind() == CXCursor_NamespaceRef)
+                semantic_parent.unwrap().kind() ==
+                    CXCursor_NamespaceAlias ||
+                semantic_parent.unwrap().kind() == CXCursor_NamespaceRef)
         {
             semantic_parent =
                 semantic_parent.unwrap().fallible_semantic_parent();
@@ -300,7 +305,11 @@ impl Cursor {
         let s = unsafe {
             cxstring_into_string(clang_Cursor_getRawCommentText(self.x))
         };
-        if s.is_empty() { None } else { Some(s) }
+        if s.is_empty() {
+            None
+        } else {
+            Some(s)
+        }
     }
 
     /// Get the referent's parsed comment.
@@ -346,7 +355,11 @@ impl Cursor {
                 x: clang_getCursorReferenced(self.x),
             };
 
-            if ret.is_valid() { Some(ret) } else { None }
+            if ret.is_valid() {
+                Some(ret)
+            } else {
+                None
+            }
         }
     }
 
@@ -371,7 +384,11 @@ impl Cursor {
             let ret = Cursor {
                 x: clang_getSpecializedCursorTemplate(self.x),
             };
-            if ret.is_valid() { Some(ret) } else { None }
+            if ret.is_valid() {
+                Some(ret)
+            } else {
+                None
+            }
         }
     }
 
@@ -438,11 +455,13 @@ impl Cursor {
     pub fn contains_cursor(&self, kind: CXCursorKind) -> bool {
         let mut found = false;
 
-        self.visit(|c| if c.kind() == kind {
-            found = true;
-            CXChildVisit_Break
-        } else {
-            CXChildVisit_Continue
+        self.visit(|c| {
+            if c.kind() == kind {
+                found = true;
+                CXChildVisit_Break
+            } else {
+                CXChildVisit_Continue
+            }
         });
 
         found
@@ -459,7 +478,11 @@ impl Cursor {
     pub fn bit_width(&self) -> Option<u32> {
         unsafe {
             let w = clang_getFieldDeclBitWidth(self.x);
-            if w == -1 { None } else { Some(w as u32) }
+            if w == -1 {
+                None
+            } else {
+                Some(w as u32)
+            }
         }
     }
 
@@ -470,7 +493,11 @@ impl Cursor {
             let t = Type {
                 x: clang_getEnumDeclIntegerType(self.x),
             };
-            if t.is_valid() { Some(t) } else { None }
+            if t.is_valid() {
+                Some(t)
+            } else {
+                None
+            }
         }
     }
 
@@ -509,7 +536,8 @@ impl Cursor {
         self.visit(|cur| {
             if cur.kind() == CXCursor_UnexposedAttr {
                 found_attr = cur.tokens().iter().any(|t| {
-                    t.kind == CXToken_Identifier && t.spelling() == attr.as_bytes()
+                    t.kind == CXToken_Identifier &&
+                        t.spelling() == attr.as_bytes()
                 });
 
                 if found_attr {
@@ -530,7 +558,11 @@ impl Cursor {
             x: unsafe { clang_getTypedefDeclUnderlyingType(self.x) },
         };
 
-        if inner.is_valid() { Some(inner) } else { None }
+        if inner.is_valid() {
+            Some(inner)
+        } else {
+            None
+        }
     }
 
     /// Get the linkage kind for this cursor's referent.
@@ -559,12 +591,11 @@ impl Cursor {
         // CXCursor_FunctionDecl |
         // CXCursor_CXXMethod => {
         self.num_args().ok().map(|num| {
-            (0..num).map(|i| {
-                Cursor {
+            (0..num)
+                .map(|i| Cursor {
                     x: unsafe { clang_Cursor_getArgument(self.x, i as c_uint) },
-                }
-            })
-            .collect()
+                })
+                .collect()
         })
     }
 
@@ -576,7 +607,11 @@ impl Cursor {
     pub fn num_args(&self) -> Result<u32, ()> {
         unsafe {
             let w = clang_Cursor_getNumArguments(self.x);
-            if w == -1 { Err(()) } else { Ok(w as u32) }
+            if w == -1 {
+                Err(())
+            } else {
+                Ok(w as u32)
+            }
         }
     }
 
@@ -642,7 +677,11 @@ impl Cursor {
         let rt = Type {
             x: unsafe { clang_getCursorResultType(self.x) },
         };
-        if rt.is_valid() { Some(rt) } else { None }
+        if rt.is_valid() {
+            Some(rt)
+        } else {
+            None
+        }
     }
 
     /// Gets the tokens that correspond to that cursor.
@@ -654,26 +693,29 @@ impl Cursor {
     pub fn cexpr_tokens(self) -> Vec<cexpr::token::Token> {
         use cexpr::token;
 
-        self.tokens().iter().filter_map(|token| {
-            let kind = match token.kind {
-                CXToken_Punctuation => token::Kind::Punctuation,
-                CXToken_Literal => token::Kind::Literal,
-                CXToken_Identifier => token::Kind::Identifier,
-                CXToken_Keyword => token::Kind::Keyword,
-                // NB: cexpr is not too happy about comments inside
-                // expressions, so we strip them down here.
-                CXToken_Comment => return None,
-                _ => {
-                    error!("Found unexpected token kind: {:?}", token);
-                    return None;
-                }
-            };
+        self.tokens()
+            .iter()
+            .filter_map(|token| {
+                let kind = match token.kind {
+                    CXToken_Punctuation => token::Kind::Punctuation,
+                    CXToken_Literal => token::Kind::Literal,
+                    CXToken_Identifier => token::Kind::Identifier,
+                    CXToken_Keyword => token::Kind::Keyword,
+                    // NB: cexpr is not too happy about comments inside
+                    // expressions, so we strip them down here.
+                    CXToken_Comment => return None,
+                    _ => {
+                        error!("Found unexpected token kind: {:?}", token);
+                        return None;
+                    }
+                };
 
-            Some(token::Token {
-                kind,
-                raw: token.spelling().to_vec().into_boxed_slice(),
+                Some(token::Token {
+                    kind,
+                    raw: token.spelling().to_vec().into_boxed_slice(),
+                })
             })
-        }).collect()
+            .collect()
     }
 }
 
@@ -690,11 +732,14 @@ impl<'a> RawTokens<'a> {
         let mut tokens = ptr::null_mut();
         let mut token_count = 0;
         let range = cursor.extent();
-        let tu = unsafe {
-            clang_Cursor_getTranslationUnit(cursor.x)
-        };
+        let tu = unsafe { clang_Cursor_getTranslationUnit(cursor.x) };
         unsafe { clang_tokenize(tu, range, &mut tokens, &mut token_count) };
-        Self { cursor, tu, tokens, token_count }
+        Self {
+            cursor,
+            tu,
+            tokens,
+            token_count,
+        }
     }
 
     fn as_slice(&self) -> &[CXToken] {
@@ -717,7 +762,11 @@ impl<'a> Drop for RawTokens<'a> {
     fn drop(&mut self) {
         if !self.tokens.is_null() {
             unsafe {
-                clang_disposeTokens(self.tu, self.tokens, self.token_count as c_uint);
+                clang_disposeTokens(
+                    self.tu,
+                    self.tokens,
+                    self.token_count as c_uint,
+                );
             }
         }
     }
@@ -790,9 +839,7 @@ where
     Visitor: FnMut(Cursor) -> CXChildVisitResult,
 {
     let func: &mut Visitor = unsafe { mem::transmute(data) };
-    let child = Cursor {
-        x: cur,
-    };
+    let child = Cursor { x: cur };
 
     (*func)(child)
 }
@@ -942,8 +989,9 @@ impl Type {
     fn clang_size_of(&self, ctx: &BindgenContext) -> c_longlong {
         match self.kind() {
             // Work-around https://bugs.llvm.org/show_bug.cgi?id=40975
-            CXType_RValueReference |
-            CXType_LValueReference => ctx.target_pointer_size() as c_longlong,
+            CXType_RValueReference | CXType_LValueReference => {
+                ctx.target_pointer_size() as c_longlong
+            }
             // Work-around https://bugs.llvm.org/show_bug.cgi?id=40813
             CXType_Auto if self.is_non_deductible_auto_type() => return -6,
             _ => unsafe { clang_Type_getSizeOf(self.x) },
@@ -954,8 +1002,9 @@ impl Type {
     fn clang_align_of(&self, ctx: &BindgenContext) -> c_longlong {
         match self.kind() {
             // Work-around https://bugs.llvm.org/show_bug.cgi?id=40975
-            CXType_RValueReference |
-            CXType_LValueReference => ctx.target_pointer_size() as c_longlong,
+            CXType_RValueReference | CXType_LValueReference => {
+                ctx.target_pointer_size() as c_longlong
+            }
             // Work-around https://bugs.llvm.org/show_bug.cgi?id=40813
             CXType_Auto if self.is_non_deductible_auto_type() => return -6,
             _ => unsafe { clang_Type_getAlignOf(self.x) },
@@ -966,11 +1015,18 @@ impl Type {
     /// for them.
     pub fn size(&self, ctx: &BindgenContext) -> usize {
         let val = self.clang_size_of(ctx);
-        if val < 0 { 0 } else { val as usize }
+        if val < 0 {
+            0
+        } else {
+            val as usize
+        }
     }
 
     /// What is the size of this type?
-    pub fn fallible_size(&self, ctx: &BindgenContext) -> Result<usize, LayoutError> {
+    pub fn fallible_size(
+        &self,
+        ctx: &BindgenContext,
+    ) -> Result<usize, LayoutError> {
         let val = self.clang_size_of(ctx);
         if val < 0 {
             Err(LayoutError::from(val as i32))
@@ -983,11 +1039,18 @@ impl Type {
     /// returning `0`.
     pub fn align(&self, ctx: &BindgenContext) -> usize {
         let val = self.clang_align_of(ctx);
-        if val < 0 { 0 } else { val as usize }
+        if val < 0 {
+            0
+        } else {
+            val as usize
+        }
     }
 
     /// What is the alignment of this type?
-    pub fn fallible_align(&self, ctx: &BindgenContext) -> Result<usize, LayoutError> {
+    pub fn fallible_align(
+        &self,
+        ctx: &BindgenContext,
+    ) -> Result<usize, LayoutError> {
         let val = self.clang_align_of(ctx);
         if val < 0 {
             Err(LayoutError::from(val as i32))
@@ -998,7 +1061,10 @@ impl Type {
 
     /// Get the layout for this type, or an error describing why it does not
     /// have a valid layout.
-    pub fn fallible_layout(&self, ctx: &BindgenContext) -> Result<::ir::layout::Layout, LayoutError> {
+    pub fn fallible_layout(
+        &self,
+        ctx: &BindgenContext,
+    ) -> Result<::ir::layout::Layout, LayoutError> {
         use ir::layout::Layout;
         let size = self.fallible_size(ctx)?;
         let align = self.fallible_align(ctx)?;
@@ -1012,7 +1078,7 @@ impl Type {
         // question correctly. However, that's no reason to panic when
         // generating bindings for simple C headers with an old libclang.
         if !clang_Type_getNumTemplateArguments::is_loaded() {
-            return None
+            return None;
         }
 
         let n = unsafe { clang_Type_getNumTemplateArguments(self.x) };
@@ -1027,12 +1093,10 @@ impl Type {
     /// If this type is a class template specialization, return its
     /// template arguments. Otherwise, return None.
     pub fn template_args(&self) -> Option<TypeTemplateArgIterator> {
-        self.num_template_args().map(|n| {
-            TypeTemplateArgIterator {
-                x: self.x,
-                length: n,
-                index: 0,
-            }
+        self.num_template_args().map(|n| TypeTemplateArgIterator {
+            x: self.x,
+            length: n,
+            index: 0,
         })
     }
 
@@ -1041,12 +1105,11 @@ impl Type {
     /// Returns None if the type is not a function prototype.
     pub fn args(&self) -> Option<Vec<Type>> {
         self.num_args().ok().map(|num| {
-            (0..num).map(|i| {
-                Type {
+            (0..num)
+                .map(|i| Type {
                     x: unsafe { clang_getArgType(self.x, i as c_uint) },
-                }
-            })
-            .collect()
+                })
+                .collect()
         })
     }
 
@@ -1056,11 +1119,14 @@ impl Type {
     pub fn num_args(&self) -> Result<u32, ()> {
         unsafe {
             let w = clang_getNumArgTypes(self.x);
-            if w == -1 { Err(()) } else { Ok(w as u32) }
+            if w == -1 {
+                Err(())
+            } else {
+                Ok(w as u32)
+            }
         }
     }
 
-
     /// Given that this type is a pointer type, return the type that it points
     /// to.
     pub fn pointee_type(&self) -> Option<Type> {
@@ -1126,7 +1192,11 @@ impl Type {
         let rt = Type {
             x: unsafe { clang_getResultType(self.x) },
         };
-        if rt.is_valid() { Some(rt) } else { None }
+        if rt.is_valid() {
+            Some(rt)
+        } else {
+            None
+        }
     }
 
     /// Given that this type is a function type, get its calling convention. If
@@ -1186,15 +1256,19 @@ impl Type {
         // This is terrible :(
         fn hacky_parse_associated_type<S: AsRef<str>>(spelling: S) -> bool {
             lazy_static! {
-                static ref ASSOC_TYPE_RE: regex::Regex =
-                    regex::Regex::new(r"typename type\-parameter\-\d+\-\d+::.+").unwrap();
+                static ref ASSOC_TYPE_RE: regex::Regex = regex::Regex::new(
+                    r"typename type\-parameter\-\d+\-\d+::.+"
+                )
+                .unwrap();
             }
             ASSOC_TYPE_RE.is_match(spelling.as_ref())
         }
 
         self.kind() == CXType_Unexposed &&
             (hacky_parse_associated_type(self.spelling()) ||
-                 hacky_parse_associated_type(self.canonical_type().spelling()))
+                hacky_parse_associated_type(
+                    self.canonical_type().spelling(),
+                ))
     }
 }
 
@@ -1263,20 +1337,9 @@ impl SourceLocation {
             let mut col = 0;
             let mut off = 0;
             clang_getSpellingLocation(
-                self.x,
-                &mut file,
-                &mut line,
-                &mut col,
-                &mut off,
+                self.x, &mut file, &mut line, &mut col, &mut off,
             );
-            (
-                File {
-                    x: file,
-                },
-                line as usize,
-                col as usize,
-                off as usize,
-            )
+            (File { x: file }, line as usize, col as usize, off as usize)
         }
     }
 }
@@ -1375,14 +1438,14 @@ impl Iterator for CommentAttributesIterator {
             self.index += 1;
             Some(CommentAttribute {
                 name: unsafe {
-                    cxstring_into_string(
-                        clang_HTMLStartTag_getAttrName(self.x, idx),
-                    )
+                    cxstring_into_string(clang_HTMLStartTag_getAttrName(
+                        self.x, idx,
+                    ))
                 },
                 value: unsafe {
-                    cxstring_into_string(
-                        clang_HTMLStartTag_getAttrValue(self.x, idx),
-                    )
+                    cxstring_into_string(clang_HTMLStartTag_getAttrValue(
+                        self.x, idx,
+                    ))
                 },
             })
         } else {
@@ -1508,9 +1571,7 @@ impl TranslationUnit {
         if tu.is_null() {
             None
         } else {
-            Some(TranslationUnit {
-                x: tu,
-            })
+            Some(TranslationUnit { x: tu })
         }
     }
 
@@ -1552,7 +1613,6 @@ impl Drop for TranslationUnit {
     }
 }
 
-
 /// A diagnostic message generated while parsing a translation unit.
 pub struct Diagnostic {
     x: CXDiagnostic,
@@ -1615,8 +1675,7 @@ impl fmt::Debug for UnsavedFile {
         write!(
             fmt,
             "UnsavedFile(name: {:?}, contents: {:?})",
-            self.name,
-            self.contents
+            self.name, self.contents
         )
     }
 }
@@ -1672,7 +1731,11 @@ pub fn ast_dump(c: &Cursor, depth: isize) -> CXChildVisitResult {
         if templ_kind != CXCursor_NoDeclFound {
             print_indent(
                 depth,
-                format!(" {}template-kind = {}", prefix, kind_to_str(templ_kind)),
+                format!(
+                    " {}template-kind = {}",
+                    prefix,
+                    kind_to_str(templ_kind)
+                ),
             );
         }
         if let Some(usr) = c.usr() {
@@ -1769,18 +1832,18 @@ pub fn ast_dump(c: &Cursor, depth: isize) -> CXChildVisitResult {
             depth,
             format!(" {}spelling = \"{}\"", prefix, ty.spelling()),
         );
-        let num_template_args = if clang_Type_getNumTemplateArguments::is_loaded() {
-            unsafe { clang_Type_getNumTemplateArguments(ty.x) }
-        } else {
-            -1
-        };
+        let num_template_args =
+            if clang_Type_getNumTemplateArguments::is_loaded() {
+                unsafe { clang_Type_getNumTemplateArguments(ty.x) }
+            } else {
+                -1
+            };
         if num_template_args >= 0 {
             print_indent(
                 depth,
                 format!(
                     " {}number-of-template-args = {}",
-                    prefix,
-                    num_template_args
+                    prefix, num_template_args
                 ),
             );
         }
@@ -1875,27 +1938,26 @@ impl EvalResult {
             return None;
         }
 
-        // Clang has an internal assertion we can trigger if we try to evaluate
-        // a cursor containing a variadic template type reference. Triggering
-        // the assertion aborts the process, and we don't want that. Clang
-        // *also* doesn't expose any API for finding variadic vs non-variadic
-        // template type references, let alone whether a type referenced is a
-        // template type, instead they seem to show up as type references to an
-        // unexposed type. Our solution is to just flat out ban all
-        // `CXType_Unexposed` from evaluation.
-        let mut found_cant_eval = false;
-        cursor.visit(|c| if c.kind() == CXCursor_TypeRef &&
-            c.cur_type().kind() == CXType_Unexposed
+        // Work around https://bugs.llvm.org/show_bug.cgi?id=42532, see:
+        //  * https://github.com/rust-lang/rust-bindgen/issues/283
+        //  * https://github.com/rust-lang/rust-bindgen/issues/1590
         {
-            found_cant_eval = true;
-            CXChildVisit_Break
-        } else {
-            CXChildVisit_Recurse
-        });
-        if found_cant_eval {
-            return None;
-        }
+            let mut found_cant_eval = false;
+            cursor.visit(|c| {
+                if c.kind() == CXCursor_TypeRef &&
+                    c.cur_type().canonical_type().kind() == CXType_Unexposed
+                {
+                    found_cant_eval = true;
+                    return CXChildVisit_Break;
+                }
+
+                CXChildVisit_Recurse
+            });
 
+            if found_cant_eval {
+                return None;
+            }
+        }
         Some(EvalResult {
             x: unsafe { clang_Cursor_Evaluate(cursor.x) },
         })
@@ -1924,7 +1986,7 @@ impl EvalResult {
         if !clang_EvalResult_isUnsignedInt::is_loaded() {
             // FIXME(emilio): There's no way to detect underflow here, and clang
             // will just happily give us a value.
-            return Some(unsafe { clang_EvalResult_getAsInt(self.x) } as i64)
+            return Some(unsafe { clang_EvalResult_getAsInt(self.x) } as i64);
         }
 
         if unsafe { clang_EvalResult_isUnsignedInt(self.x) } != 0 {
@@ -1933,7 +1995,7 @@ impl EvalResult {
                 return None;
             }
 
-            return Some(value as i64)
+            return Some(value as i64);
         }
 
         let value = unsafe { clang_EvalResult_getAsLongLong(self.x) };
diff --git a/third_party/rust/bindgen/src/codegen/bitfield_unit.rs b/third_party/rust/bindgen/src/codegen/bitfield_unit.rs
index 7f263fd12f29..a5a8ac77d425 100755
--- a/third_party/rust/bindgen/src/codegen/bitfield_unit.rs
+++ b/third_party/rust/bindgen/src/codegen/bitfield_unit.rs
@@ -1,25 +1,21 @@
 #[repr(C)]
 #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
-pub struct __BindgenBitfieldUnit<Storage, Align>
-where
-    Storage: AsRef<[u8]> + AsMut<[u8]>,
-{
+pub struct __BindgenBitfieldUnit<Storage, Align> {
     storage: Storage,
     align: [Align; 0],
 }
 
+impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
+    #[inline]
+    pub const fn new(storage: Storage) -> Self {
+        Self { storage, align: [] }
+    }
+}
+
 impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
 where
     Storage: AsRef<[u8]> + AsMut<[u8]>,
 {
-    #[inline]
-    pub fn new(storage: Storage) -> Self {
-        Self {
-            storage,
-            align: [],
-        }
-    }
-
     #[inline]
     pub fn get_bit(&self, index: usize) -> bool {
         debug_assert!(index / 8 < self.storage.as_ref().len());
@@ -27,12 +23,11 @@ where
         let byte_index = index / 8;
         let byte = self.storage.as_ref()[byte_index];
 
-        let bit_index =
-            if cfg!(target_endian = "big") {
-                7 - (index % 8)
-            } else {
-                index % 8
-            };
+        let bit_index = if cfg!(target_endian = "big") {
+            7 - (index % 8)
+        } else {
+            index % 8
+        };
 
         let mask = 1 << bit_index;
 
@@ -46,12 +41,11 @@ where
         let byte_index = index / 8;
         let byte = &mut self.storage.as_mut()[byte_index];
 
-        let bit_index =
-            if cfg!(target_endian = "big") {
-                7 - (index % 8)
-            } else {
-                index % 8
-            };
+        let bit_index = if cfg!(target_endian = "big") {
+            7 - (index % 8)
+        } else {
+            index % 8
+        };
 
         let mask = 1 << bit_index;
         if val {
@@ -65,18 +59,20 @@ where
     pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
         debug_assert!(bit_width <= 64);
         debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
-        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
+        debug_assert!(
+            (bit_offset + (bit_width as usize)) / 8 <=
+                self.storage.as_ref().len()
+        );
 
         let mut val = 0;
 
         for i in 0..(bit_width as usize) {
             if self.get_bit(i + bit_offset) {
-                let index =
-                    if cfg!(target_endian = "big") {
-                        bit_width as usize - 1 - i
-                    } else {
-                        i
-                    };
+                let index = if cfg!(target_endian = "big") {
+                    bit_width as usize - 1 - i
+                } else {
+                    i
+                };
                 val |= 1 << index;
             }
         }
@@ -88,17 +84,19 @@ where
     pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
         debug_assert!(bit_width <= 64);
         debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
-        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
+        debug_assert!(
+            (bit_offset + (bit_width as usize)) / 8 <=
+                self.storage.as_ref().len()
+        );
 
         for i in 0..(bit_width as usize) {
             let mask = 1 << i;
             let val_bit_is_set = val & mask == mask;
-            let index =
-                if cfg!(target_endian = "big") {
-                    bit_width as usize - 1 - i
-                } else {
-                    i
-                };
+            let index = if cfg!(target_endian = "big") {
+                bit_width as usize - 1 - i
+            } else {
+                i
+            };
             self.set_bit(index + bit_offset, val_bit_is_set);
         }
     }
diff --git a/third_party/rust/bindgen/src/codegen/bitfield_unit_tests.rs b/third_party/rust/bindgen/src/codegen/bitfield_unit_tests.rs
index d39878ccd98e..3a9239c2c805 100644
--- a/third_party/rust/bindgen/src/codegen/bitfield_unit_tests.rs
+++ b/third_party/rust/bindgen/src/codegen/bitfield_unit_tests.rs
@@ -26,7 +26,8 @@ use std::mem;
 
 #[test]
 fn bitfield_unit_get_bit() {
-    let unit = __BindgenBitfieldUnit::<[u8; 2], u64>::new([0b10011101, 0b00011101]);
+    let unit =
+        __BindgenBitfieldUnit::<[u8; 2], u64>::new([0b10011101, 0b00011101]);
 
     let mut bits = vec![];
     for i in 0..16 {
@@ -35,32 +36,21 @@ fn bitfield_unit_get_bit() {
 
     println!();
     println!("bits = {:?}", bits);
-    assert_eq!(bits, &[
-        // 0b10011101
-        true,
-        false,
-        true,
-        true,
-        true,
-        false,
-        false,
-        true ,
-
-        // 0b00011101
-        true,
-        false,
-        true,
-        true,
-        true,
-        false,
-        false,
-        false
-    ]);
+    assert_eq!(
+        bits,
+        &[
+            // 0b10011101
+            true, false, true, true, true, false, false, true,
+            // 0b00011101
+            true, false, true, true, true, false, false, false
+        ]
+    );
 }
 
 #[test]
 fn bitfield_unit_set_bit() {
-    let mut unit = __BindgenBitfieldUnit::<[u8; 2], u64>::new([0b00000000, 0b00000000]);
+    let mut unit =
+        __BindgenBitfieldUnit::<[u8; 2], u64>::new([0b00000000, 0b00000000]);
 
     for i in 0..16 {
         if i % 3 == 0 {
@@ -72,7 +62,8 @@ fn bitfield_unit_set_bit() {
         assert_eq!(unit.get_bit(i), i % 3 == 0);
     }
 
-    let mut unit = __BindgenBitfieldUnit::<[u8; 2], u64>::new([0b11111111, 0b11111111]);
+    let mut unit =
+        __BindgenBitfieldUnit::<[u8; 2], u64>::new([0b11111111, 0b11111111]);
 
     for i in 0..16 {
         if i % 3 == 0 {
@@ -87,15 +78,39 @@ fn bitfield_unit_set_bit() {
 
 #[test]
 fn bitfield_unit_align() {
-    assert_eq!(mem::align_of::<__BindgenBitfieldUnit<[u8; 1], u8>>(),  mem::align_of::<u8>());
-    assert_eq!(mem::align_of::<__BindgenBitfieldUnit<[u8; 1], u16>>(), mem::align_of::<u16>());
-    assert_eq!(mem::align_of::<__BindgenBitfieldUnit<[u8; 1], u32>>(), mem::align_of::<u32>());
-    assert_eq!(mem::align_of::<__BindgenBitfieldUnit<[u8; 1], u64>>(), mem::align_of::<u64>());
-
-    assert_eq!(mem::align_of::<__BindgenBitfieldUnit<[u8; 8], u8>>(),  mem::align_of::<u8>());
-    assert_eq!(mem::align_of::<__BindgenBitfieldUnit<[u8; 8], u16>>(), mem::align_of::<u16>());
-    assert_eq!(mem::align_of::<__BindgenBitfieldUnit<[u8; 8], u32>>(), mem::align_of::<u32>());
-    assert_eq!(mem::align_of::<__BindgenBitfieldUnit<[u8; 8], u64>>(), mem::align_of::<u64>());
+    assert_eq!(
+        mem::align_of::<__BindgenBitfieldUnit<[u8; 1], u8>>(),
+        mem::align_of::<u8>()
+    );
+    assert_eq!(
+        mem::align_of::<__BindgenBitfieldUnit<[u8; 1], u16>>(),
+        mem::align_of::<u16>()
+    );
+    assert_eq!(
+        mem::align_of::<__BindgenBitfieldUnit<[u8; 1], u32>>(),
+        mem::align_of::<u32>()
+    );
+    assert_eq!(
+        mem::align_of::<__BindgenBitfieldUnit<[u8; 1], u64>>(),
+        mem::align_of::<u64>()
+    );
+
+    assert_eq!(
+        mem::align_of::<__BindgenBitfieldUnit<[u8; 8], u8>>(),
+        mem::align_of::<u8>()
+    );
+    assert_eq!(
+        mem::align_of::<__BindgenBitfieldUnit<[u8; 8], u16>>(),
+        mem::align_of::<u16>()
+    );
+    assert_eq!(
+        mem::align_of::<__BindgenBitfieldUnit<[u8; 8], u32>>(),
+        mem::align_of::<u32>()
+    );
+    assert_eq!(
+        mem::align_of::<__BindgenBitfieldUnit<[u8; 8], u64>>(),
+        mem::align_of::<u64>()
+    );
 }
 
 macro_rules! bitfield_unit_get {
diff --git a/third_party/rust/bindgen/src/codegen/error.rs b/third_party/rust/bindgen/src/codegen/error.rs
index ccb76c5bd7b6..8bf00e547d7e 100644
--- a/third_party/rust/bindgen/src/codegen/error.rs
+++ b/third_party/rust/bindgen/src/codegen/error.rs
@@ -20,7 +20,7 @@ impl fmt::Display for Error {
 }
 
 impl error::Error for Error {
-    fn cause(&self) -> Option<&error::Error> {
+    fn cause(&self) -> Option<&dyn error::Error> {
         None
     }
 
diff --git a/third_party/rust/bindgen/src/codegen/helpers.rs b/third_party/rust/bindgen/src/codegen/helpers.rs
index b630a70bd514..b1cf2050e6f6 100644
--- a/third_party/rust/bindgen/src/codegen/helpers.rs
+++ b/third_party/rust/bindgen/src/codegen/helpers.rs
@@ -17,14 +17,20 @@ pub mod attributes {
     }
 
     pub fn repr_list(which_ones: &[&str]) -> TokenStream {
-        let which_ones = which_ones.iter().cloned().map(|one| TokenStream::from_str(one).expect("repr to be valid"));
+        let which_ones = which_ones
+            .iter()
+            .cloned()
+            .map(|one| TokenStream::from_str(one).expect("repr to be valid"));
         quote! {
             #[repr( #( #which_ones ),* )]
         }
     }
 
     pub fn derives(which_ones: &[&str]) -> TokenStream {
-        let which_ones = which_ones.iter().cloned().map(|one| Ident::new(one, Span::call_site()));
+        let which_ones = which_ones
+            .iter()
+            .cloned()
+            .map(|one| Ident::new(one, Span::call_site()));
         quote! {
             #[derive( #( #which_ones ),* )]
         }
@@ -42,6 +48,12 @@ pub mod attributes {
         }
     }
 
+    pub fn non_exhaustive() -> TokenStream {
+        quote! {
+            #[non_exhaustive]
+        }
+    }
+
     pub fn doc(comment: String) -> TokenStream {
         // NOTE(emilio): By this point comments are already preprocessed and in
         // `///` form. Quote turns them into `#[doc]` comments, but oh well.
@@ -91,7 +103,10 @@ pub fn blob(ctx: &BindgenContext, layout: Layout) -> TokenStream {
 }
 
 /// Integer type of the same size as the given `Layout`.
-pub fn integer_type(ctx: &BindgenContext, layout: Layout) -> Option<TokenStream> {
+pub fn integer_type(
+    ctx: &BindgenContext,
+    layout: Layout,
+) -> Option<TokenStream> {
     let name = Layout::known_type_for_size(ctx, layout.size)?;
     let name = Ident::new(name, Span::call_site());
     Some(quote! { #name })
@@ -125,8 +140,8 @@ pub mod ast_ty {
     use ir::function::FunctionSig;
     use ir::layout::Layout;
     use ir::ty::FloatKind;
-    use std::str::FromStr;
     use proc_macro2::{self, TokenStream};
+    use std::str::FromStr;
 
     pub fn raw_type(ctx: &BindgenContext, name: &str) -> TokenStream {
         let ident = ctx.rust_ident_raw(name);
@@ -165,7 +180,8 @@ pub mod ast_ty {
                             8 => quote! { f64 },
                             // TODO(emilio): If rust ever gains f128 we should
                             // use it here and below.
-                            _ => super::integer_type(ctx, layout).unwrap_or(quote! { f64 }),
+                            _ => super::integer_type(ctx, layout)
+                                .unwrap_or(quote! { f64 }),
                         }
                     }
                     None => {
@@ -213,10 +229,7 @@ pub mod ast_ty {
         }
     }
 
-    pub fn float_expr(
-        ctx: &BindgenContext,
-        f: f64,
-    ) -> Result<TokenStream, ()> {
+    pub fn float_expr(ctx: &BindgenContext, f: f64) -> Result<TokenStream, ()> {
         if f.is_finite() {
             let val = proc_macro2::Literal::f64_unsuffixed(f);
 
@@ -255,17 +268,16 @@ pub mod ast_ty {
         signature
             .argument_types()
             .iter()
-            .map(|&(ref name, _ty)| {
-                match *name {
-                    Some(ref name) => {
-                        let name = ctx.rust_ident(name);
-                        quote! { #name }
-                    }
-                    None => {
-                        unnamed_arguments += 1;
-                        let name = ctx.rust_ident(format!("arg{}", unnamed_arguments));
-                        quote! { #name }
-                    }
+            .map(|&(ref name, _ty)| match *name {
+                Some(ref name) => {
+                    let name = ctx.rust_ident(name);
+                    quote! { #name }
+                }
+                None => {
+                    unnamed_arguments += 1;
+                    let name =
+                        ctx.rust_ident(format!("arg{}", unnamed_arguments));
+                    quote! { #name }
                 }
             })
             .collect()
diff --git a/third_party/rust/bindgen/src/codegen/impl_debug.rs b/third_party/rust/bindgen/src/codegen/impl_debug.rs
index fd4865111b2b..eac54fd16ba3 100644
--- a/third_party/rust/bindgen/src/codegen/impl_debug.rs
+++ b/third_party/rust/bindgen/src/codegen/impl_debug.rs
@@ -1,7 +1,7 @@
 use ir::comp::{BitfieldUnit, CompKind, Field, FieldData, FieldMethods};
 use ir::context::BindgenContext;
 use ir::item::{HasTypeParamInArray, IsOpaque, Item, ItemCanonicalName};
-use ir::ty::{RUST_DERIVE_IN_ARRAY_LIMIT, TypeKind};
+use ir::ty::{TypeKind, RUST_DERIVE_IN_ARRAY_LIMIT};
 use proc_macro2;
 
 pub fn gen_debug_impl(
@@ -177,9 +177,10 @@ impl<'a> ImplDebug<'a> for Item {
             TypeKind::Array(_, len) => {
                 // Generics are not required to implement Debug
                 if self.has_type_param_in_array(ctx) {
-                    Some(
-                        (format!("{}: Array with length {}", name, len), vec![]),
-                    )
+                    Some((
+                        format!("{}: Array with length {}", name, len),
+                        vec![],
+                    ))
                 } else if len < RUST_DERIVE_IN_ARRAY_LIMIT {
                     // The simple case
                     debug_print(name, quote! { #name_ident })
@@ -187,9 +188,7 @@ impl<'a> ImplDebug<'a> for Item {
                     if ctx.options().use_core {
                         // There is no String in core; reducing field visibility to avoid breaking
                         // no_std setups.
-                        Some((
-                            format!("{}: [...]", name), vec![]
-                        ))
+                        Some((format!("{}: [...]", name), vec![]))
                     } else {
                         // Let's implement our own print function
                         Some((
@@ -209,16 +208,14 @@ impl<'a> ImplDebug<'a> for Item {
                 if ctx.options().use_core {
                     // There is no format! in core; reducing field visibility to avoid breaking
                     // no_std setups.
-                    Some((
-                        format!("{}(...)", name), vec![]
-                    ))
+                    Some((format!("{}(...)", name), vec![]))
                 } else {
                     let self_ids = 0..len;
                     Some((
                         format!("{}({{}})", name),
                         vec![quote! {
                             #(format!("{:?}", self.#self_ids)),*
-                        }]
+                        }],
                     ))
                 }
             }
@@ -235,8 +232,9 @@ impl<'a> ImplDebug<'a> for Item {
                 let inner_type = ctx.resolve_type(inner).canonical_type(ctx);
                 match *inner_type.kind() {
                     TypeKind::Function(ref sig)
-                        if !sig.function_pointers_can_derive() => {
-                            Some((format!("{}: FunctionPointer", name), vec![]))
+                        if !sig.function_pointers_can_derive() =>
+                    {
+                        Some((format!("{}: FunctionPointer", name), vec![]))
                     }
                     _ => debug_print(name, quote! { #name_ident }),
                 }
diff --git a/third_party/rust/bindgen/src/codegen/impl_partialeq.rs b/third_party/rust/bindgen/src/codegen/impl_partialeq.rs
index ca61b4bf49e4..d73f36bb4ee5 100644
--- a/third_party/rust/bindgen/src/codegen/impl_partialeq.rs
+++ b/third_party/rust/bindgen/src/codegen/impl_partialeq.rs
@@ -1,4 +1,3 @@
-
 use ir::comp::{CompInfo, CompKind, Field, FieldMethods};
 use ir::context::BindgenContext;
 use ir::item::{IsOpaque, Item};
@@ -50,15 +49,17 @@ pub fn gen_partialeq_impl(
                     let name = fd.name().unwrap();
                     tokens.push(gen_field(ctx, ty_item, name));
                 }
-                Field::Bitfields(ref bu) => for bitfield in bu.bitfields() {
-                    if let Some(_) = bitfield.name() {
-                        let getter_name = bitfield.getter_name();
-                        let name_ident = ctx.rust_ident_raw(getter_name);
-                        tokens.push(quote! {
-                            self.#name_ident () == other.#name_ident ()
-                        });
+                Field::Bitfields(ref bu) => {
+                    for bitfield in bu.bitfields() {
+                        if let Some(_) = bitfield.name() {
+                            let getter_name = bitfield.getter_name();
+                            let name_ident = ctx.rust_ident_raw(getter_name);
+                            tokens.push(quote! {
+                                self.#name_ident () == other.#name_ident ()
+                            });
+                        }
                     }
-                },
+                }
             }
         }
     }
@@ -70,8 +71,14 @@ pub fn gen_partialeq_impl(
     })
 }
 
-fn gen_field(ctx: &BindgenContext, ty_item: &Item, name: &str) -> proc_macro2::TokenStream {
-    fn quote_equals(name_ident: proc_macro2::Ident) -> proc_macro2::TokenStream {
+fn gen_field(
+    ctx: &BindgenContext,
+    ty_item: &Item,
+    name: &str,
+) -> proc_macro2::TokenStream {
+    fn quote_equals(
+        name_ident: proc_macro2::Ident,
+    ) -> proc_macro2::TokenStream {
         quote! { self.#name_ident == other.#name_ident }
     }
 
@@ -106,20 +113,22 @@ fn gen_field(ctx: &BindgenContext, ty_item: &Item, name: &str) -> proc_macro2::T
             }
         }
 
-        TypeKind::Array(_, len) => if len <= RUST_DERIVE_IN_ARRAY_LIMIT {
-            quote_equals(name_ident)
-        } else {
-            quote! {
-                &self. #name_ident [..] == &other. #name_ident [..]
+        TypeKind::Array(_, len) => {
+            if len <= RUST_DERIVE_IN_ARRAY_LIMIT {
+                quote_equals(name_ident)
+            } else {
+                quote! {
+                    &self. #name_ident [..] == &other. #name_ident [..]
+                }
             }
-        },
+        }
         TypeKind::Vector(_, len) => {
             let self_ids = 0..len;
             let other_ids = 0..len;
             quote! {
                 #(self.#self_ids == other.#other_ids &&)* true
             }
-        },
+        }
 
         TypeKind::ResolvedTypeRef(t) |
         TypeKind::TemplateAlias(t, _) |
diff --git a/third_party/rust/bindgen/src/codegen/mod.rs b/third_party/rust/bindgen/src/codegen/mod.rs
index 289edf890358..c7f1b2bdb3cd 100644
--- a/third_party/rust/bindgen/src/codegen/mod.rs
+++ b/third_party/rust/bindgen/src/codegen/mod.rs
@@ -1,7 +1,7 @@
-mod impl_debug;
-mod impl_partialeq;
 mod error;
 mod helpers;
+mod impl_debug;
+mod impl_partialeq;
 pub mod struct_layout;
 
 #[cfg(test)]
@@ -18,12 +18,15 @@ use super::BindgenOptions;
 use ir::analysis::{HasVtable, Sizedness};
 use ir::annotations::FieldAccessorKind;
 use ir::comment;
-use ir::comp::{Base, Bitfield, BitfieldUnit, CompInfo, CompKind, Field,
-               FieldData, FieldMethods, Method, MethodKind};
+use ir::comp::{
+    Base, Bitfield, BitfieldUnit, CompInfo, CompKind, Field, FieldData,
+    FieldMethods, Method, MethodKind,
+};
 use ir::context::{BindgenContext, ItemId};
-use ir::derive::{CanDeriveCopy, CanDeriveDebug, CanDeriveDefault,
-                 CanDeriveHash, CanDerivePartialOrd, CanDeriveOrd,
-                 CanDerivePartialEq, CanDeriveEq, CanDerive};
+use ir::derive::{
+    CanDerive, CanDeriveCopy, CanDeriveDebug, CanDeriveDefault, CanDeriveEq,
+    CanDeriveHash, CanDeriveOrd, CanDerivePartialEq, CanDerivePartialOrd,
+};
 use ir::dot;
 use ir::enum_ty::{Enum, EnumVariant, EnumVariantValue};
 use ir::function::{Abi, Function, FunctionKind, FunctionSig, Linkage};
@@ -33,12 +36,14 @@ use ir::item_kind::ItemKind;
 use ir::layout::Layout;
 use ir::module::Module;
 use ir::objc::{ObjCInterface, ObjCMethod};
-use ir::template::{AsTemplateParam, TemplateInstantiation, TemplateParameters};
+use ir::template::{
+    AsTemplateParam, TemplateInstantiation, TemplateParameters,
+};
 use ir::ty::{Type, TypeKind};
 use ir::var::Var;
 
-use quote::TokenStreamExt;
 use proc_macro2::{self, Ident, Span};
+use quote::TokenStreamExt;
 
 use std;
 use std::borrow::Cow;
@@ -48,12 +53,15 @@ use std::fmt::Write;
 use std::iter;
 use std::ops;
 use std::str::FromStr;
-use {HashMap, HashSet, Entry};
+use {Entry, HashMap, HashSet};
 
 // Name of type defined in constified enum module
 pub static CONSTIFIED_ENUM_MODULE_REPR_NAME: &'static str = "Type";
 
-fn top_level_path(ctx: &BindgenContext, item: &Item) -> Vec<proc_macro2::TokenStream> {
+fn top_level_path(
+    ctx: &BindgenContext,
+    item: &Item,
+) -> Vec<proc_macro2::TokenStream> {
     let mut path = vec![quote! { self }];
 
     if ctx.options().enable_cxx_namespaces {
@@ -65,7 +73,10 @@ fn top_level_path(ctx: &BindgenContext, item: &Item) -> Vec<proc_macro2::TokenSt
     path
 }
 
-fn root_import(ctx: &BindgenContext, module: &Item) -> proc_macro2::TokenStream {
+fn root_import(
+    ctx: &BindgenContext,
+    module: &Item,
+) -> proc_macro2::TokenStream {
     assert!(ctx.options().enable_cxx_namespaces, "Somebody messed it up");
     assert!(module.is_module());
 
@@ -75,7 +86,6 @@ fn root_import(ctx: &BindgenContext, module: &Item) -> proc_macro2::TokenStream
     let root_ident = ctx.rust_ident(&root);
     path.push(quote! { #root_ident });
 
-
     let mut tokens = quote! {};
     tokens.append_separated(path, quote!(::));
 
@@ -268,10 +278,7 @@ impl AppendImplicitTemplateParams for proc_macro2::TokenStream {
         ctx: &BindgenContext,
         item: &Item,
     ) {
-        let item = item.id()
-            .into_resolver()
-            .through_type_refs()
-            .resolve(ctx);
+        let item = item.id().into_resolver().through_type_refs().resolve(ctx);
 
         match *item.expect_type().kind() {
             TypeKind::UnresolvedTypeRef(..) => {
@@ -297,13 +304,17 @@ impl AppendImplicitTemplateParams for proc_macro2::TokenStream {
             TypeKind::ObjCId |
             TypeKind::ObjCSel |
             TypeKind::TemplateInstantiation(..) => return,
-            _ => {},
+            _ => {}
         }
 
-        let params: Vec<_> = item.used_template_params(ctx).iter().map(|p| {
-            p.try_to_rust_ty(ctx, &())
-                .expect("template params cannot fail to be a rust type")
-        }).collect();
+        let params: Vec<_> = item
+            .used_template_params(ctx)
+            .iter()
+            .map(|p| {
+                p.try_to_rust_ty(ctx, &())
+                    .expect("template params cannot fail to be a rust type")
+            })
+            .collect();
         if !params.is_empty() {
             self.append_all(quote! {
                 < #( #params ),* >
@@ -410,7 +421,7 @@ impl CodeGenerator for Module {
                     utils::prepend_objc_header(ctx, &mut *result);
                 }
                 if result.saw_bitfield_unit {
-                    utils::prepend_bitfield_unit_type(&mut *result);
+                    utils::prepend_bitfield_unit_type(ctx, &mut *result);
                 }
             }
         };
@@ -431,7 +442,9 @@ impl CodeGenerator for Module {
             if let Some(raw_lines) = ctx.options().module_lines.get(&path) {
                 for raw_line in raw_lines {
                     found_any = true;
-                    result.push(proc_macro2::TokenStream::from_str(raw_line).unwrap());
+                    result.push(
+                        proc_macro2::TokenStream::from_str(raw_line).unwrap(),
+                    );
                 }
             }
 
@@ -500,7 +513,8 @@ impl CodeGenerator for Var {
                     });
                 }
                 VarType::Int(val) => {
-                    let int_kind = self.ty()
+                    let int_kind = self
+                        .ty()
                         .into_resolver()
                         .through_type_aliases()
                         .through_type_refs()
@@ -570,7 +584,7 @@ impl CodeGenerator for Var {
             }
 
             let maybe_mut = if self.is_const() {
-                quote! { }
+                quote! {}
             } else {
                 quote! { mut }
             };
@@ -627,13 +641,14 @@ impl CodeGenerator for Type {
                     return;
                 }
 
-                let inner_item = inner.into_resolver()
-                    .through_type_refs()
-                    .resolve(ctx);
+                let inner_item =
+                    inner.into_resolver().through_type_refs().resolve(ctx);
                 let name = item.canonical_name(ctx);
 
                 let inner_rust_type = {
-                    if let TypeKind::Function(fnsig) = inner_item.kind().expect_type().kind() {
+                    if let TypeKind::Function(fnsig) =
+                        inner_item.kind().expect_type().kind()
+                    {
                         utils::fnsig_block(ctx, fnsig)
                     } else {
                         panic!("invalid block typedef: {:?}", inner_item)
@@ -656,16 +671,15 @@ impl CodeGenerator for Type {
                 result.saw_block();
             }
             TypeKind::Comp(ref ci) => ci.codegen(ctx, result, item),
-            TypeKind::TemplateAlias(inner, _) |
-            TypeKind::Alias(inner) => {
-                let inner_item = inner.into_resolver()
-                    .through_type_refs()
-                    .resolve(ctx);
+            TypeKind::TemplateAlias(inner, _) | TypeKind::Alias(inner) => {
+                let inner_item =
+                    inner.into_resolver().through_type_refs().resolve(ctx);
                 let name = item.canonical_name(ctx);
                 let path = item.canonical_path(ctx);
 
                 {
-                    let through_type_aliases = inner.into_resolver()
+                    let through_type_aliases = inner
+                        .into_resolver()
                         .through_type_refs()
                         .through_type_aliases()
                         .resolve(ctx);
@@ -720,8 +734,7 @@ impl CodeGenerator for Type {
                         warn!(
                             "Item contained invalid named type, skipping: \
                              {:?}, {:?}",
-                            item,
-                            inner_item
+                            item, inner_item
                         );
                         return;
                     }
@@ -737,15 +750,12 @@ impl CodeGenerator for Type {
 
                 // We prefer using `pub use` over `pub type` because of:
                 // https://github.com/rust-lang/rust/issues/26264
-                if inner_rust_type.to_string()
-                    .chars()
-                    .all(|c| match c {
-                        // These are the only characters allowed in simple
-                        // paths, eg `good::dogs::Bront`.
-                        'A'...'Z' | 'a'...'z' | '0'...'9' | ':' | '_' | ' ' => true,
-                        _ => false,
-                    }) &&
-                    outer_params.is_empty() &&
+                if inner_rust_type.to_string().chars().all(|c| match c {
+                    // These are the only characters allowed in simple
+                    // paths, eg `good::dogs::Bront`.
+                    'A'..='Z' | 'a'..='z' | '0'..='9' | ':' | '_' | ' ' => true,
+                    _ => false,
+                }) && outer_params.is_empty() &&
                     inner_item.expect_type().canonical_type(ctx).is_enum()
                 {
                     tokens.append_all(quote! {
@@ -764,10 +774,14 @@ impl CodeGenerator for Type {
                     pub type #rust_name
                 });
 
-                let params: Vec<_> = outer_params.into_iter()
+                let params: Vec<_> = outer_params
+                    .into_iter()
                     .filter_map(|p| p.as_template_param(ctx, &()))
                     .collect();
-                if params.iter().any(|p| ctx.resolve_type(*p).is_invalid_type_param()) {
+                if params
+                    .iter()
+                    .any(|p| ctx.resolve_type(*p).is_invalid_type_param())
+                {
                     warn!(
                         "Item contained invalid template \
                          parameter: {:?}",
@@ -775,10 +789,14 @@ impl CodeGenerator for Type {
                     );
                     return;
                 }
-                let params: Vec<_> = params.iter().map(|p| {
-                    p.try_to_rust_ty(ctx, &())
-                        .expect("type parameters can always convert to rust ty OK")
-                }).collect();
+                let params: Vec<_> = params
+                    .iter()
+                    .map(|p| {
+                        p.try_to_rust_ty(ctx, &()).expect(
+                            "type parameters can always convert to rust ty OK",
+                        )
+                    })
+                    .collect();
 
                 if !params.is_empty() {
                     tokens.append_all(quote! {
@@ -1038,7 +1056,8 @@ impl<'a> FieldCodegen<'a> for FieldData {
         // `BitfieldUnit` and `Bitfield`.
         assert!(self.bitfield_width().is_none());
 
-        let field_item = self.ty().into_resolver().through_type_refs().resolve(ctx);
+        let field_item =
+            self.ty().into_resolver().through_type_refs().resolve(ctx);
         let field_ty = field_item.expect_type();
         let mut ty = self.ty().to_rust_ty_or_opaque(ctx, &());
         ty.append_implicit_template_params(ctx, field_item);
@@ -1082,10 +1101,10 @@ impl<'a> FieldCodegen<'a> for FieldData {
             }
         }
 
-        let field_name =
-            self.name()
-                .map(|name| ctx.rust_mangle(name).into_owned())
-                .expect("Each field should have a name in codegen!");
+        let field_name = self
+            .name()
+            .map(|name| ctx.rust_mangle(name).into_owned())
+            .expect("Each field should have a name in codegen!");
         let field_ident = ctx.rust_ident_raw(field_name.as_str());
 
         if !parent.is_union() {
@@ -1096,9 +1115,10 @@ impl<'a> FieldCodegen<'a> for FieldData {
             }
         }
 
-        let is_private = self.annotations().private_fields().unwrap_or(
-            fields_should_be_private,
-        );
+        let is_private = self
+            .annotations()
+            .private_fields()
+            .unwrap_or(fields_should_be_private);
 
         let accessor_kind =
             self.annotations().accessor_kind().unwrap_or(accessor_kind);
@@ -1168,7 +1188,10 @@ impl<'a> FieldCodegen<'a> for FieldData {
 impl BitfieldUnit {
     /// Get the constructor name for this bitfield unit.
     fn ctor_name(&self) -> proc_macro2::TokenStream {
-        let ctor_name = Ident::new(&format!("new_bitfield_{}", self.nth()), Span::call_site());
+        let ctor_name = Ident::new(
+            &format!("new_bitfield_{}", self.nth()),
+            Span::call_site(),
+        );
         quote! {
             #ctor_name
         }
@@ -1190,9 +1213,9 @@ impl Bitfield {
         mut ctor_impl: proc_macro2::TokenStream,
     ) -> proc_macro2::TokenStream {
         let bitfield_ty = ctx.resolve_type(self.ty());
-        let bitfield_ty_layout = bitfield_ty.layout(ctx).expect(
-            "Bitfield without layout? Gah!",
-        );
+        let bitfield_ty_layout = bitfield_ty
+            .layout(ctx)
+            .expect("Bitfield without layout? Gah!");
         let bitfield_int_ty = helpers::blob(ctx, bitfield_ty_layout);
 
         let offset = self.offset_into_unit();
@@ -1306,11 +1329,7 @@ impl<'a> FieldCodegen<'a> for BitfieldUnit {
             ctor_params.push(quote! {
                 #param_name : #bitfield_ty
             });
-            ctor_impl = bf.extend_ctor_impl(
-                ctx,
-                param_name,
-                ctor_impl,
-            );
+            ctor_impl = bf.extend_ctor_impl(ctx, param_name, ctor_impl);
         }
 
         if generate_ctor {
@@ -1373,19 +1392,20 @@ impl<'a> FieldCodegen<'a> for Bitfield {
         let bitfield_ty_item = ctx.resolve_item(self.ty());
         let bitfield_ty = bitfield_ty_item.expect_type();
 
-        let bitfield_ty_layout = bitfield_ty.layout(ctx).expect(
-            "Bitfield without layout? Gah!",
-        );
-        let bitfield_int_ty = match helpers::integer_type(ctx, bitfield_ty_layout) {
-            Some(int_ty) => {
-                *bitfield_representable_as_int = true;
-                int_ty
-            }
-            None => {
-                *bitfield_representable_as_int = false;
-                return;
-            }
-        };
+        let bitfield_ty_layout = bitfield_ty
+            .layout(ctx)
+            .expect("Bitfield without layout? Gah!");
+        let bitfield_int_ty =
+            match helpers::integer_type(ctx, bitfield_ty_layout) {
+                Some(int_ty) => {
+                    *bitfield_representable_as_int = true;
+                    int_ty
+                }
+                None => {
+                    *bitfield_representable_as_int = false;
+                    return;
+                }
+            };
 
         let bitfield_ty =
             bitfield_ty.to_rust_ty_or_opaque(ctx, bitfield_ty_item);
@@ -1529,7 +1549,8 @@ impl CodeGenerator for CompInfo {
             let codegen_depth = item.codegen_depth(ctx);
             let fields_should_be_private =
                 item.annotations().private_fields().unwrap_or(false);
-            let struct_accessor_kind = item.annotations()
+            let struct_accessor_kind = item
+                .annotations()
                 .accessor_kind()
                 .unwrap_or(FieldAccessorKind::None);
             for field in self.fields() {
@@ -1584,7 +1605,10 @@ impl CodeGenerator for CompInfo {
                     } else {
                         explicit_align = Some(layout.align);
                         if !ctx.options().rust_features.repr_align {
-                            let ty = helpers::blob(ctx, Layout::new(0, layout.align));
+                            let ty = helpers::blob(
+                                ctx,
+                                Layout::new(0, layout.align),
+                            );
                             fields.push(quote! {
                                 pub __bindgen_align: #ty ,
                             });
@@ -1618,7 +1642,7 @@ impl CodeGenerator for CompInfo {
         // is making the struct 1-byte sized.
         //
         // This is apparently not the case for C, see:
-        // https://github.com/rust-lang-nursery/rust-bindgen/issues/551
+        // https://github.com/rust-lang/rust-bindgen/issues/551
         //
         // Just get the layout, and assume C++ if not.
         //
@@ -1668,7 +1692,7 @@ impl CodeGenerator for CompInfo {
                 < #( #generic_param_names ),* >
             }
         } else {
-            quote! { }
+            quote! {}
         };
 
         let mut attributes = vec![];
@@ -1682,7 +1706,11 @@ impl CodeGenerator for CompInfo {
         if packed && !is_opaque {
             let n = layout.map_or(1, |l| l.align);
             assert!(ctx.options().rust_features().repr_packed_n || n == 1);
-            let packed_repr = if n == 1 { "packed".to_string() } else { format!("packed({})", n) };
+            let packed_repr = if n == 1 {
+                "packed".to_string()
+            } else {
+                format!("packed({})", n)
+            };
             attributes.push(attributes::repr_list(&["C", &packed_repr]));
         } else {
             attributes.push(attributes::repr("C"));
@@ -1699,13 +1727,12 @@ impl CodeGenerator for CompInfo {
             }
         }
 
-
         let mut derives = vec![];
         if item.can_derive_debug(ctx) {
             derives.push("Debug");
         } else {
-            needs_debug_impl = ctx.options().derive_debug &&
-                ctx.options().impl_debug
+            needs_debug_impl =
+                ctx.options().derive_debug && ctx.options().impl_debug
         }
 
         if item.can_derive_default(ctx) {
@@ -1750,10 +1777,10 @@ impl CodeGenerator for CompInfo {
         if item.can_derive_partialeq(ctx) {
             derives.push("PartialEq");
         } else {
-            needs_partialeq_impl =
-                ctx.options().derive_partialeq &&
+            needs_partialeq_impl = ctx.options().derive_partialeq &&
                 ctx.options().impl_partialeq &&
-                ctx.lookup_can_derive_partialeq_or_partialord(item.id()) == CanDerive::Manually;
+                ctx.lookup_can_derive_partialeq_or_partialord(item.id()) ==
+                    CanDerive::Manually;
         }
 
         if item.can_derive_eq(ctx) {
@@ -1827,34 +1854,36 @@ impl CodeGenerator for CompInfo {
                     let size = layout.size;
                     let align = layout.align;
 
-                    let check_struct_align =
-                        if align > ctx.target_pointer_size() &&
-                            !ctx.options().rust_features().repr_align
-                        {
-                            None
-                        } else {
-                            Some(quote! {
-                                assert_eq!(#align_of_expr,
-                                       #align,
-                                       concat!("Alignment of ", stringify!(#canonical_ident)));
+                    let check_struct_align = if align >
+                        ctx.target_pointer_size() &&
+                        !ctx.options().rust_features().repr_align
+                    {
+                        None
+                    } else {
+                        Some(quote! {
+                            assert_eq!(#align_of_expr,
+                                   #align,
+                                   concat!("Alignment of ", stringify!(#canonical_ident)));
 
-                            })
-                        };
+                        })
+                    };
 
-                    // FIXME when [issue #465](https://github.com/rust-lang-nursery/rust-bindgen/issues/465) ready
-                    let too_many_base_vtables = self.base_members()
+                    // FIXME when [issue #465](https://github.com/rust-lang/rust-bindgen/issues/465) ready
+                    let too_many_base_vtables = self
+                        .base_members()
                         .iter()
                         .filter(|base| base.ty.has_vtable(ctx))
-                        .count() > 1;
+                        .count() >
+                        1;
 
-                    let should_skip_field_offset_checks = is_opaque ||
-                        too_many_base_vtables;
+                    let should_skip_field_offset_checks =
+                        is_opaque || too_many_base_vtables;
 
-                    let check_field_offset =
-                        if should_skip_field_offset_checks {
-                            vec![]
-                        } else {
-                            let asserts = self.fields()
+                    let check_field_offset = if should_skip_field_offset_checks
+                    {
+                        vec![]
+                    } else {
+                        let asserts = self.fields()
                                 .iter()
                                 .filter_map(|field| match *field {
                                     Field::DataMember(ref f) if f.name().is_some() => Some(f),
@@ -1879,8 +1908,8 @@ impl CodeGenerator for CompInfo {
                                 })
                                 .collect::<Vec<proc_macro2::TokenStream>>();
 
-                            asserts
-                        };
+                        asserts
+                    };
 
                     let item = quote! {
                         #[test]
@@ -1918,7 +1947,8 @@ impl CodeGenerator for CompInfo {
                         *sig,
                         /* const */
                         false,
-                    ).codegen_method(
+                    )
+                    .codegen_method(
                         ctx,
                         &mut methods,
                         &mut method_names,
@@ -1983,15 +2013,19 @@ impl CodeGenerator for CompInfo {
         }
 
         if needs_partialeq_impl {
-            if let Some(impl_) = impl_partialeq::gen_partialeq_impl(ctx, self, item, &ty_for_impl) {
-
+            if let Some(impl_) = impl_partialeq::gen_partialeq_impl(
+                ctx,
+                self,
+                item,
+                &ty_for_impl,
+            ) {
                 let partialeq_bounds = if !generic_param_names.is_empty() {
                     let bounds = generic_param_names.iter().map(|t| {
                         quote! { #t: PartialEq }
                     });
                     quote! { where #( #bounds ),* }
                 } else {
-                    quote! { }
+                    quote! {}
                 };
 
                 let prefix = ctx.trait_prefix();
@@ -2067,7 +2101,9 @@ impl MethodCodegen for Method {
             _ => panic!("How in the world?"),
         };
 
-        if let (Abi::ThisCall, false) = (signature.abi(), ctx.options().rust_features().thiscall_abi) {
+        if let (Abi::ThisCall, false) =
+            (signature.abi(), ctx.options().rust_features().thiscall_abi)
+        {
             return;
         }
 
@@ -2118,10 +2154,9 @@ impl MethodCodegen for Method {
         // variable called `__bindgen_tmp` we're going to create.
         if self.is_constructor() {
             let prefix = ctx.trait_prefix();
-            let tmp_variable_decl =
-                quote! {
-                    let mut __bindgen_tmp = ::#prefix::mem::uninitialized()
-                };
+            let tmp_variable_decl = quote! {
+                let mut __bindgen_tmp = ::#prefix::mem::uninitialized()
+            };
             stmts.push(tmp_variable_decl);
             exprs[0] = quote! {
                 &mut __bindgen_tmp
@@ -2152,7 +2187,9 @@ impl MethodCodegen for Method {
         let mut attrs = vec![];
         attrs.push(attributes::inline());
 
-        if signature.must_use() && ctx.options().rust_features().must_use_function {
+        if signature.must_use() &&
+            ctx.options().rust_features().must_use_function
+        {
             attrs.push(attributes::must_use());
         }
 
@@ -2170,27 +2207,23 @@ impl MethodCodegen for Method {
 #[derive(Copy, Clone, PartialEq, Debug)]
 pub enum EnumVariation {
     /// The code for this enum will use a Rust enum
-    Rust,
+    Rust {
+        /// Indicates whether the generated struct should be #[non_exhaustive]
+        non_exhaustive: bool,
+    },
     /// The code for this enum will use a bitfield
     Bitfield,
     /// The code for this enum will use consts
     Consts,
     /// The code for this enum will use a module containing consts
-    ModuleConsts
+    ModuleConsts,
 }
 
 impl EnumVariation {
     fn is_rust(&self) -> bool {
         match *self {
-            EnumVariation::Rust => true,
-            _ => false
-        }
-    }
-
-    fn is_bitfield(&self) -> bool {
-        match *self {
-            EnumVariation::Bitfield {..} => true,
-            _ => false
+            EnumVariation::Rust { .. } => true,
+            _ => false,
         }
     }
 
@@ -2199,7 +2232,7 @@ impl EnumVariation {
     fn is_const(&self) -> bool {
         match *self {
             EnumVariation::Consts | EnumVariation::ModuleConsts => true,
-            _ => false
+            _ => false,
         }
     }
 }
@@ -2216,19 +2249,19 @@ impl std::str::FromStr for EnumVariation {
     /// Create a `EnumVariation` from a string.
     fn from_str(s: &str) -> Result<Self, Self::Err> {
         match s {
-            "rust" => Ok(EnumVariation::Rust),
+            "rust" => Ok(EnumVariation::Rust{ non_exhaustive: false }),
+            "rust_non_exhaustive" => Ok(EnumVariation::Rust{ non_exhaustive: true }),
             "bitfield" => Ok(EnumVariation::Bitfield),
             "consts" => Ok(EnumVariation::Consts),
             "moduleconsts" => Ok(EnumVariation::ModuleConsts),
             _ => Err(std::io::Error::new(std::io::ErrorKind::InvalidInput,
                                          concat!("Got an invalid EnumVariation. Accepted values ",
-                                                 "are 'rust', 'bitfield', 'consts', and ",
+                                                 "are 'rust', 'rust_non_exhaustive', 'bitfield', 'consts', and ",
                                                  "'moduleconsts'."))),
         }
     }
 }
 
-
 /// A helper type to construct different enum variations.
 enum EnumBuilder<'a> {
     Rust {
@@ -2277,18 +2310,16 @@ impl<'a> EnumBuilder<'a> {
         let ident = Ident::new(name, Span::call_site());
 
         match enum_variation {
-            EnumVariation::Bitfield => {
-                EnumBuilder::Bitfield {
-                    codegen_depth: enum_codegen_depth,
-                    canonical_name: name,
-                    tokens: quote! {
-                        #( #attrs )*
-                        pub struct #ident (pub #repr);
-                    },
-                }
-            }
+            EnumVariation::Bitfield => EnumBuilder::Bitfield {
+                codegen_depth: enum_codegen_depth,
+                canonical_name: name,
+                tokens: quote! {
+                    #( #attrs )*
+                    pub struct #ident (pub #repr);
+                },
+            },
 
-            EnumVariation::Rust => {
+            EnumVariation::Rust { .. } => {
                 let tokens = quote!();
                 EnumBuilder::Rust {
                     codegen_depth: enum_codegen_depth + 1,
@@ -2299,20 +2330,19 @@ impl<'a> EnumBuilder<'a> {
                 }
             }
 
-            EnumVariation::Consts => {
-                EnumBuilder::Consts {
-                    variants: vec![
-                        quote! {
-                            #( #attrs )*
-                            pub type #ident = #repr;
-                        }
-                    ],
-                    codegen_depth: enum_codegen_depth,
-                }
-            }
+            EnumVariation::Consts => EnumBuilder::Consts {
+                variants: vec![quote! {
+                    #( #attrs )*
+                    pub type #ident = #repr;
+                }],
+                codegen_depth: enum_codegen_depth,
+            },
 
             EnumVariation::ModuleConsts => {
-                let ident = Ident::new(CONSTIFIED_ENUM_MODULE_REPR_NAME, Span::call_site());
+                let ident = Ident::new(
+                    CONSTIFIED_ENUM_MODULE_REPR_NAME,
+                    Span::call_site(),
+                );
                 let type_definition = quote! {
                     #( #attrs )*
                     pub type #ident = #repr;
@@ -2346,13 +2376,20 @@ impl<'a> EnumBuilder<'a> {
         let mut doc = quote! {};
         if ctx.options().generate_comments {
             if let Some(raw_comment) = variant.comment() {
-                let comment = comment::preprocess(raw_comment, self.codegen_depth());
+                let comment =
+                    comment::preprocess(raw_comment, self.codegen_depth());
                 doc = attributes::doc(comment);
             }
         }
 
         match self {
-            EnumBuilder::Rust { attrs, ident, tokens, emitted_any_variants: _, codegen_depth } => {
+            EnumBuilder::Rust {
+                attrs,
+                ident,
+                tokens,
+                emitted_any_variants: _,
+                codegen_depth,
+            } => {
                 let name = ctx.rust_ident(variant_name);
                 EnumBuilder::Rust {
                     attrs,
@@ -2368,7 +2405,8 @@ impl<'a> EnumBuilder<'a> {
             }
 
             EnumBuilder::Bitfield { canonical_name, .. } => {
-                if ctx.options().rust_features().associated_const && is_ty_named {
+                if ctx.options().rust_features().associated_const && is_ty_named
+                {
                     let enum_ident = ctx.rust_ident(canonical_name);
                     let variant_ident = ctx.rust_ident(variant_name);
                     result.push(quote! {
@@ -2393,9 +2431,7 @@ impl<'a> EnumBuilder<'a> {
                 self
             }
 
-            EnumBuilder::Consts {
-                ..
-            } => {
+            EnumBuilder::Consts { .. } => {
                 let constant_name = match mangling_prefix {
                     Some(prefix) => {
                         Cow::Owned(format!("{}_{}", prefix, variant_name))
@@ -2439,7 +2475,13 @@ impl<'a> EnumBuilder<'a> {
         result: &mut CodegenResult<'b>,
     ) -> proc_macro2::TokenStream {
         match self {
-            EnumBuilder::Rust { attrs, ident, tokens, emitted_any_variants, .. } => {
+            EnumBuilder::Rust {
+                attrs,
+                ident,
+                tokens,
+                emitted_any_variants,
+                ..
+            } => {
                 let variants = if !emitted_any_variants {
                     quote!(__bindgen_cannot_repr_c_on_empty_enum = 0)
                 } else {
@@ -2539,12 +2581,10 @@ impl CodeGenerator for Enum {
 
         let repr = self.repr().map(|repr| ctx.resolve_type(repr));
         let repr = match repr {
-            Some(repr) => {
-                match *repr.canonical_type(ctx).kind() {
-                    TypeKind::Int(int_kind) => int_kind,
-                    _ => panic!("Unexpected type as enum repr"),
-                }
-            }
+            Some(repr) => match *repr.canonical_type(ctx).kind() {
+                TypeKind::Int(int_kind) => int_kind,
+                _ => panic!("Unexpected type as enum repr"),
+            },
             None => {
                 warn!(
                     "Guessing type of enum! Forward declarations of enums \
@@ -2580,22 +2620,36 @@ impl CodeGenerator for Enum {
         let variation = self.computed_enum_variation(ctx, item);
 
         // TODO(emilio): Delegate this to the builders?
-        if variation.is_rust() {
-            attrs.push(attributes::repr(repr_name));
-        } else if variation.is_bitfield() {
-            if ctx.options().rust_features.repr_transparent {
-                attrs.push(attributes::repr("transparent"));
-            } else {
-                attrs.push(attributes::repr("C"));
+        match variation {
+            EnumVariation::Rust { non_exhaustive } => {
+                attrs.push(attributes::repr(repr_name));
+                if non_exhaustive &&
+                    ctx.options().rust_features().non_exhaustive
+                {
+                    attrs.push(attributes::non_exhaustive());
+                } else if non_exhaustive &&
+                    !ctx.options().rust_features().non_exhaustive
+                {
+                    panic!("The rust target you're using doesn't seem to support non_exhaustive enums");
+                }
             }
-        }
+            EnumVariation::Bitfield => {
+                if ctx.options().rust_features.repr_transparent {
+                    attrs.push(attributes::repr("transparent"));
+                } else {
+                    attrs.push(attributes::repr("C"));
+                }
+            }
+            _ => {}
+        };
 
         if let Some(comment) = item.comment(ctx) {
             attrs.push(attributes::doc(comment));
         }
 
         if !variation.is_const() {
-            let mut derives = vec!["Debug", "Copy", "Clone", "PartialEq", "Eq", "Hash"];
+            let mut derives =
+                vec!["Debug", "Copy", "Clone", "PartialEq", "Eq", "Hash"];
 
             if item.can_derive_partialord(ctx) {
                 derives.push("PartialOrd");
@@ -2679,9 +2733,9 @@ impl CodeGenerator for Enum {
         let mut constified_variants = VecDeque::new();
 
         let mut iter = self.variants().iter().peekable();
-        while let Some(variant) = iter.next().or_else(|| {
-            constified_variants.pop_front()
-        }) {
+        while let Some(variant) =
+            iter.next().or_else(|| constified_variants.pop_front())
+        {
             if variant.hidden() {
                 continue;
             }
@@ -2702,17 +2756,20 @@ impl CodeGenerator for Enum {
                                 let parent_name =
                                     parent_canonical_name.as_ref().unwrap();
 
-                                Cow::Owned(
-                                    format!("{}_{}", parent_name, variant_name),
-                                )
+                                Cow::Owned(format!(
+                                    "{}_{}",
+                                    parent_name, variant_name
+                                ))
                             };
 
                         let existing_variant_name = entry.get();
                         // Use associated constants for named enums.
                         if enum_ty.name().is_some() &&
-                           ctx.options().rust_features().associated_const {
+                            ctx.options().rust_features().associated_const
+                        {
                             let enum_canonical_name = &ident;
-                            let variant_name = ctx.rust_ident_raw(&*mangled_name);
+                            let variant_name =
+                                ctx.rust_ident_raw(&*mangled_name);
                             result.push(quote! {
                                 impl #enum_rust_ty {
                                     pub const #variant_name : #enum_rust_ty =
@@ -2766,12 +2823,8 @@ impl CodeGenerator for Enum {
                                 parent_canonical_name.as_ref().unwrap();
 
                             Ident::new(
-                                &format!(
-                                    "{}_{}",
-                                    parent_name,
-                                    variant_name
-                                ),
-                                Span::call_site()
+                                &format!("{}_{}", parent_name, variant_name),
+                                Span::call_site(),
                             )
                         };
 
@@ -2817,9 +2870,8 @@ trait TryToOpaque {
         ctx: &BindgenContext,
         extra: &Self::Extra,
     ) -> error::Result<proc_macro2::TokenStream> {
-        self.try_get_layout(ctx, extra).map(|layout| {
-            helpers::blob(ctx, layout)
-        })
+        self.try_get_layout(ctx, extra)
+            .map(|layout| helpers::blob(ctx, layout))
     }
 }
 
@@ -2849,11 +2901,7 @@ trait ToOpaque: TryToOpaque {
     }
 }
 
-impl<T> ToOpaque for T
-where
-    T: TryToOpaque,
-{
-}
+impl<T> ToOpaque for T where T: TryToOpaque {}
 
 /// Fallible conversion from an IR thing to an *equivalent* Rust type.
 ///
@@ -2889,8 +2937,7 @@ trait TryToRustTyOrOpaque: TryToRustTy + TryToOpaque {
 
 impl<E, T> TryToRustTyOrOpaque for T
 where
-    T: TryToRustTy<Extra = E>
-        + TryToOpaque<Extra = E>,
+    T: TryToRustTy<Extra = E> + TryToOpaque<Extra = E>,
 {
     type Extra = E;
 
@@ -2899,15 +2946,13 @@ where
         ctx: &BindgenContext,
         extra: &E,
     ) -> error::Result<proc_macro2::TokenStream> {
-        self.try_to_rust_ty(ctx, extra).or_else(
-            |_| if let Ok(layout) =
-                self.try_get_layout(ctx, extra)
-            {
+        self.try_to_rust_ty(ctx, extra).or_else(|_| {
+            if let Ok(layout) = self.try_get_layout(ctx, extra) {
                 Ok(helpers::blob(ctx, layout))
             } else {
                 Err(error::Error::NoLayoutForOpaqueBlob)
-            },
-        )
+            }
+        })
     }
 }
 
@@ -2949,15 +2994,14 @@ where
         ctx: &BindgenContext,
         extra: &E,
     ) -> proc_macro2::TokenStream {
-        self.try_to_rust_ty(ctx, extra).unwrap_or_else(|_| {
-            self.to_opaque(ctx, extra)
-        })
+        self.try_to_rust_ty(ctx, extra)
+            .unwrap_or_else(|_| self.to_opaque(ctx, extra))
     }
 }
 
 impl<T> TryToOpaque for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     type Extra = ();
 
@@ -2972,7 +3016,7 @@ where
 
 impl<T> TryToRustTy for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     type Extra = ();
 
@@ -3035,15 +3079,11 @@ impl TryToRustTy for Type {
             TypeKind::Void => Ok(raw_type(ctx, "c_void")),
             // TODO: we should do something smart with nullptr, or maybe *const
             // c_void is enough?
-            TypeKind::NullPtr => {
-                Ok(raw_type(ctx, "c_void").to_ptr(true))
-            }
+            TypeKind::NullPtr => Ok(raw_type(ctx, "c_void").to_ptr(true)),
             TypeKind::Int(ik) => {
                 match ik {
                     IntKind::Bool => Ok(quote! { bool }),
-                    IntKind::Char {
-                        ..
-                    } => Ok(raw_type(ctx, "c_char")),
+                    IntKind::Char { .. } => Ok(raw_type(ctx, "c_char")),
                     IntKind::SChar => Ok(raw_type(ctx, "c_schar")),
                     IntKind::UChar => Ok(raw_type(ctx, "c_uchar")),
                     IntKind::Short => Ok(raw_type(ctx, "c_short")),
@@ -3054,12 +3094,15 @@ impl TryToRustTy for Type {
                     IntKind::ULong => Ok(raw_type(ctx, "c_ulong")),
                     IntKind::LongLong => Ok(raw_type(ctx, "c_longlong")),
                     IntKind::ULongLong => Ok(raw_type(ctx, "c_ulonglong")),
-                    IntKind::WChar { size } => {
-                        let ty = Layout::known_type_for_size(ctx, size)
+                    IntKind::WChar => {
+                        let layout = self
+                            .layout(ctx)
+                            .expect("Couldn't compute wchar_t's layout?");
+                        let ty = Layout::known_type_for_size(ctx, layout.size)
                             .expect("Non-representable wchar_t?");
                         let ident = ctx.rust_ident_raw(ty);
                         Ok(quote! { #ident })
-                    },
+                    }
 
                     IntKind::I8 => Ok(quote! { i8 }),
                     IntKind::U8 => Ok(quote! { u8 }),
@@ -3069,9 +3112,7 @@ impl TryToRustTy for Type {
                     IntKind::U32 => Ok(quote! { u32 }),
                     IntKind::I64 => Ok(quote! { i64 }),
                     IntKind::U64 => Ok(quote! { u64 }),
-                    IntKind::Custom {
-                        name, ..
-                    } => {
+                    IntKind::Custom { name, .. } => {
                         let ident = ctx.rust_ident_raw(name);
                         Ok(quote! {
                             #ident
@@ -3095,9 +3136,12 @@ impl TryToRustTy for Type {
                     }
                 }
             }
-            TypeKind::Float(fk) => Ok(float_kind_rust_type(ctx, fk, self.layout(ctx))),
+            TypeKind::Float(fk) => {
+                Ok(float_kind_rust_type(ctx, fk, self.layout(ctx)))
+            }
             TypeKind::Complex(fk) => {
-                let float_path = float_kind_rust_type(ctx, fk, self.layout(ctx));
+                let float_path =
+                    float_kind_rust_type(ctx, fk, self.layout(ctx));
 
                 ctx.generated_bindgen_complex();
                 Ok(if ctx.options().enable_cxx_namespaces {
@@ -3130,7 +3174,8 @@ impl TryToRustTy for Type {
             }
             TypeKind::Enum(..) => {
                 let path = item.namespace_aware_canonical_path(ctx);
-                let path = proc_macro2::TokenStream::from_str(&path.join("::")).unwrap();
+                let path = proc_macro2::TokenStream::from_str(&path.join("::"))
+                    .unwrap();
                 Ok(quote!(#path))
             }
             TypeKind::TemplateInstantiation(ref inst) => {
@@ -3144,14 +3189,18 @@ impl TryToRustTy for Type {
                     let void = raw_type(ctx, "c_void");
                     return Ok(void.to_ptr(/* is_const = */ false));
                 }
-                let template_params = item.used_template_params(ctx)
+                let template_params = item
+                    .used_template_params(ctx)
                     .into_iter()
                     .filter(|param| param.is_template_param(ctx, &()))
                     .collect::<Vec<_>>();
 
                 if item.is_opaque(ctx, &()) && !template_params.is_empty() {
                     self.try_to_opaque(ctx, item)
-                } else if let Some(ty) = self.name().and_then(|name| utils::type_from_named(ctx, name)) {
+                } else if let Some(ty) = self
+                    .name()
+                    .and_then(|name| utils::type_from_named(ctx, name))
+                {
                     Ok(ty)
                 } else {
                     utils::build_path(item, ctx)
@@ -3168,11 +3217,11 @@ impl TryToRustTy for Type {
                 utils::build_path(item, ctx)
             }
             TypeKind::Opaque => self.try_to_opaque(ctx, item),
-            TypeKind::Pointer(inner) |
-            TypeKind::Reference(inner) => {
+            TypeKind::Pointer(inner) | TypeKind::Reference(inner) => {
                 let is_const = ctx.resolve_type(inner).is_const();
 
-                let inner = inner.into_resolver().through_type_refs().resolve(ctx);
+                let inner =
+                    inner.into_resolver().through_type_refs().resolve(ctx);
                 let inner_ty = inner.expect_type();
 
                 // Regardless if we can properly represent the inner type, we
@@ -3196,13 +3245,10 @@ impl TryToRustTy for Type {
                     #ident
                 })
             }
-            TypeKind::ObjCSel => {
-                Ok(quote! {
-                    objc::runtime::Sel
-                })
-            }
-            TypeKind::ObjCId |
-            TypeKind::ObjCInterface(..) => Ok(quote! {
+            TypeKind::ObjCSel => Ok(quote! {
+                objc::runtime::Sel
+            }),
+            TypeKind::ObjCId | TypeKind::ObjCInterface(..) => Ok(quote! {
                 id
             }),
             ref u @ TypeKind::UnresolvedTypeRef(..) => {
@@ -3220,9 +3266,9 @@ impl TryToOpaque for TemplateInstantiation {
         ctx: &BindgenContext,
         item: &Item,
     ) -> error::Result<Layout> {
-        item.expect_type().layout(ctx).ok_or(
-            error::Error::NoLayoutForOpaqueBlob,
-        )
+        item.expect_type()
+            .layout(ctx)
+            .ok_or(error::Error::NoLayoutForOpaqueBlob)
     }
 }
 
@@ -3238,23 +3284,25 @@ impl TryToRustTy for TemplateInstantiation {
             return Err(error::Error::InstantiationOfOpaqueType);
         }
 
-        let def = self.template_definition()
+        let def = self
+            .template_definition()
             .into_resolver()
             .through_type_refs()
             .resolve(ctx);
 
         let mut ty = quote! {};
         let def_path = def.namespace_aware_canonical_path(ctx);
-        ty.append_separated(def_path.into_iter().map(|p| ctx.rust_ident(p)), quote!(::));
+        ty.append_separated(
+            def_path.into_iter().map(|p| ctx.rust_ident(p)),
+            quote!(::),
+        );
 
         let def_params = def.self_template_params(ctx);
         if def_params.is_empty() {
             // This can happen if we generated an opaque type for a partial
             // template specialization, and we've hit an instantiation of
             // that partial specialization.
-            extra_assert!(
-                def.is_opaque(ctx, &())
-            );
+            extra_assert!(def.is_opaque(ctx, &()));
             return Err(error::Error::InstantiationOfOpaqueType);
         }
 
@@ -3266,11 +3314,12 @@ impl TryToRustTy for TemplateInstantiation {
         // reconstruct them somehow. We don't have any means of doing
         // that reconstruction at this time.
 
-        let template_args = self.template_arguments()
+        let template_args = self
+            .template_arguments()
             .iter()
             .zip(def_params.iter())
-        // Only pass type arguments for the type parameters that
-        // the def uses.
+            // Only pass type arguments for the type parameters that
+            // the def uses.
             .filter(|&(_, param)| ctx.uses_template_parameter(def.id(), *param))
             .map(|(arg, _)| {
                 let arg = arg.into_resolver().through_type_refs().resolve(ctx);
@@ -3308,11 +3357,9 @@ impl TryToRustTy for FunctionSig {
                 warn!("Skipping function with thiscall ABI that isn't supported by the configured Rust target");
                 Ok(proc_macro2::TokenStream::new())
             }
-            _ => {
-                Ok(quote! {
-                    unsafe extern #abi fn ( #( #arguments ),* ) #ret
-                })
-            }
+            _ => Ok(quote! {
+                unsafe extern #abi fn ( #( #arguments ),* ) #ret
+            }),
         }
     }
 }
@@ -3339,10 +3386,12 @@ impl CodeGenerator for Function {
         // Pure virtual methods have no actual symbol, so we can't generate
         // something meaningful for them.
         match self.kind() {
-            FunctionKind::Method(ref method_kind) if method_kind.is_pure_virtual() => {
+            FunctionKind::Method(ref method_kind)
+                if method_kind.is_pure_virtual() =>
+            {
                 return;
             }
-            _ => {},
+            _ => {}
         }
 
         // Similar to static member variables in a class template, we can't
@@ -3380,7 +3429,9 @@ impl CodeGenerator for Function {
 
         let mut attributes = vec![];
 
-        if signature.must_use() && ctx.options().rust_features().must_use_function {
+        if signature.must_use() &&
+            ctx.options().rust_features().must_use_function
+        {
             attributes.push(attributes::must_use());
         }
 
@@ -3407,9 +3458,7 @@ impl CodeGenerator for Function {
             Abi::Unknown(unknown_abi) => {
                 panic!(
                     "Invalid or unknown abi {:?} for function {:?} ({:?})",
-                    unknown_abi,
-                    canonical_name,
-                    self
+                    unknown_abi, canonical_name, self
                 );
             }
             abi => abi,
@@ -3433,7 +3482,6 @@ impl CodeGenerator for Function {
     }
 }
 
-
 fn objc_method_codegen(
     ctx: &BindgenContext,
     method: &ObjCMethod,
@@ -3451,8 +3499,7 @@ fn objc_method_codegen(
         }
     } else {
         let fn_args = fn_args.clone();
-        let args = iter::once(quote! { self })
-            .chain(fn_args.into_iter());
+        let args = iter::once(quote! { self }).chain(fn_args.into_iter());
         quote! {
             ( #( #args ),* ) #fn_ret
         }
@@ -3464,7 +3511,10 @@ fn objc_method_codegen(
         let class_name = class_name
             .expect("Generating a class method without class name?")
             .to_owned();
-        let expect_msg = proc_macro2::Literal::string(&format!("Couldn't find {}", class_name));
+        let expect_msg = proc_macro2::Literal::string(&format!(
+            "Couldn't find {}",
+            class_name
+        ));
         quote! {
             msg_send!(objc::runtime::Class::get(#class_name).expect(#expect_msg), #methods_and_args)
         }
@@ -3474,7 +3524,8 @@ fn objc_method_codegen(
         }
     };
 
-    let method_name = ctx.rust_ident(format!("{}{}", prefix, method.rust_name()));
+    let method_name =
+        ctx.rust_ident(format!("{}{}", prefix, method.rust_name()));
 
     (
         quote! {
@@ -3484,7 +3535,7 @@ fn objc_method_codegen(
         },
         quote! {
             unsafe fn #method_name #sig ;
-        }
+        },
     )
 }
 
@@ -3509,12 +3560,8 @@ impl CodeGenerator for ObjCInterface {
             trait_items.push(trait_item)
         }
 
-        let instance_method_names: Vec<_> = self.methods()
-            .iter()
-            .map({
-                |m| m.rust_name()
-            })
-            .collect();
+        let instance_method_names: Vec<_> =
+            self.methods().iter().map({ |m| m.rust_name() }).collect();
 
         for class_method in self.class_methods() {
             let ambiquity =
@@ -3553,7 +3600,9 @@ impl CodeGenerator for ObjCInterface {
     }
 }
 
-pub(crate) fn codegen(context: BindgenContext) -> (Vec<proc_macro2::TokenStream>, BindgenOptions) {
+pub(crate) fn codegen(
+    context: BindgenContext,
+) -> (Vec<proc_macro2::TokenStream>, BindgenOptions) {
     context.gen(|context| {
         let _t = context.timer("codegen");
         let counter = Cell::new(0);
@@ -3572,30 +3621,47 @@ pub(crate) fn codegen(context: BindgenContext) -> (Vec<proc_macro2::TokenStream>
 
         if let Some(path) = context.options().emit_ir_graphviz.as_ref() {
             match dot::write_dot_file(context, path) {
-                Ok(()) => info!("Your dot file was generated successfully into: {}", path),
+                Ok(()) => info!(
+                    "Your dot file was generated successfully into: {}",
+                    path
+                ),
                 Err(e) => error!("{}", e),
             }
         }
 
-        context.resolve_item(context.root_module())
-            .codegen(context, &mut result, &());
+        context.resolve_item(context.root_module()).codegen(
+            context,
+            &mut result,
+            &(),
+        );
 
         result.items
     })
 }
 
 mod utils {
-    use super::{ToRustTyOrOpaque, error};
+    use super::{error, ToRustTyOrOpaque};
     use ir::context::BindgenContext;
     use ir::function::{Abi, FunctionSig};
     use ir::item::{Item, ItemCanonicalPath};
     use ir::ty::TypeKind;
     use proc_macro2;
+    use std::borrow::Cow;
     use std::mem;
     use std::str::FromStr;
 
-    pub fn prepend_bitfield_unit_type(result: &mut Vec<proc_macro2::TokenStream>) {
-        let bitfield_unit_type = proc_macro2::TokenStream::from_str(include_str!("./bitfield_unit.rs")).unwrap();
+    pub fn prepend_bitfield_unit_type(
+        ctx: &BindgenContext,
+        result: &mut Vec<proc_macro2::TokenStream>,
+    ) {
+        let bitfield_unit_src = include_str!("./bitfield_unit.rs");
+        let bitfield_unit_src = if ctx.options().rust_features().min_const_fn {
+            Cow::Borrowed(bitfield_unit_src)
+        } else {
+            Cow::Owned(bitfield_unit_src.replace("const fn ", "fn "))
+        };
+        let bitfield_unit_type =
+            proc_macro2::TokenStream::from_str(&bitfield_unit_src).unwrap();
         let bitfield_unit_type = quote!(#bitfield_unit_type);
 
         let items = vec![bitfield_unit_type];
@@ -3653,6 +3719,14 @@ mod utils {
     ) {
         let prefix = ctx.trait_prefix();
 
+        // If the target supports `const fn`, declare eligible functions
+        // as `const fn` else just `fn`.
+        let const_fn = if ctx.options().rust_features().min_const_fn {
+            quote! { const fn }
+        } else {
+            quote! { fn }
+        };
+
         // TODO(emilio): The fmt::Debug impl could be way nicer with
         // std::intrinsics::type_name, but...
         let union_field_decl = quote! {
@@ -3663,7 +3737,7 @@ mod utils {
         let union_field_impl = quote! {
             impl<T> __BindgenUnionField<T> {
                 #[inline]
-                pub fn new() -> Self {
+                pub #const_fn new() -> Self {
                     __BindgenUnionField(::#prefix::marker::PhantomData)
                 }
 
@@ -3732,15 +3806,17 @@ mod utils {
            }
         };
 
-        let items = vec![union_field_decl,
-                         union_field_impl,
-                         union_field_default_impl,
-                         union_field_clone_impl,
-                         union_field_copy_impl,
-                         union_field_debug_impl,
-                         union_field_hash_impl,
-                         union_field_partialeq_impl,
-                         union_field_eq_impl];
+        let items = vec![
+            union_field_decl,
+            union_field_impl,
+            union_field_default_impl,
+            union_field_clone_impl,
+            union_field_copy_impl,
+            union_field_debug_impl,
+            union_field_hash_impl,
+            union_field_partialeq_impl,
+            union_field_eq_impl,
+        ];
 
         let old_items = mem::replace(result, items);
         result.extend(old_items.into_iter());
@@ -3752,6 +3828,14 @@ mod utils {
     ) {
         let prefix = ctx.trait_prefix();
 
+        // If the target supports `const fn`, declare eligible functions
+        // as `const fn` else just `fn`.
+        let const_fn = if ctx.options().rust_features().min_const_fn {
+            quote! { const fn }
+        } else {
+            quote! { fn }
+        };
+
         let incomplete_array_decl = quote! {
             #[repr(C)]
             #[derive(Default)]
@@ -3762,7 +3846,7 @@ mod utils {
         let incomplete_array_impl = quote! {
             impl<T> __IncompleteArrayField<T> {
                 #[inline]
-                pub fn new() -> Self {
+                pub #const_fn new() -> Self {
                     __IncompleteArrayField(::#prefix::marker::PhantomData, [])
                 }
 
@@ -3806,18 +3890,18 @@ mod utils {
             }
         };
 
-        let items = vec![incomplete_array_decl,
-                         incomplete_array_impl,
-                         incomplete_array_debug_impl,
-                         incomplete_array_clone_impl];
+        let items = vec![
+            incomplete_array_decl,
+            incomplete_array_impl,
+            incomplete_array_debug_impl,
+            incomplete_array_clone_impl,
+        ];
 
         let old_items = mem::replace(result, items);
         result.extend(old_items.into_iter());
     }
 
-    pub fn prepend_complex_type(
-        result: &mut Vec<proc_macro2::TokenStream>,
-    ) {
+    pub fn prepend_complex_type(result: &mut Vec<proc_macro2::TokenStream>) {
         let complex_type = quote! {
             #[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
             #[repr(C)]
@@ -3837,12 +3921,16 @@ mod utils {
         ctx: &BindgenContext,
     ) -> error::Result<proc_macro2::TokenStream> {
         let path = item.namespace_aware_canonical_path(ctx);
-        let tokens = proc_macro2::TokenStream::from_str(&path.join("::")).unwrap();
+        let tokens =
+            proc_macro2::TokenStream::from_str(&path.join("::")).unwrap();
 
         Ok(tokens)
     }
 
-    fn primitive_ty(ctx: &BindgenContext, name: &str) -> proc_macro2::TokenStream {
+    fn primitive_ty(
+        ctx: &BindgenContext,
+        name: &str,
+    ) -> proc_macro2::TokenStream {
         let ident = ctx.rust_ident_raw(name);
         quote! {
             #ident
@@ -3878,7 +3966,7 @@ mod utils {
     ) -> proc_macro2::TokenStream {
         let return_item = ctx.resolve_item(sig.return_type());
         if let TypeKind::Void = *return_item.kind().expect_type().kind() {
-            quote! { }
+            quote! {}
         } else {
             let ret_ty = return_item.to_rust_ty_or_opaque(ctx, &());
             quote! {
@@ -3894,54 +3982,63 @@ mod utils {
         use super::ToPtr;
 
         let mut unnamed_arguments = 0;
-        let mut args = sig.argument_types().iter().map(|&(ref name, ty)| {
-            let arg_item = ctx.resolve_item(ty);
-            let arg_ty = arg_item.kind().expect_type();
-
-            // From the C90 standard[1]:
-            //
-            //     A declaration of a parameter as "array of type" shall be
-            //     adjusted to "qualified pointer to type", where the type
-            //     qualifiers (if any) are those specified within the [ and ] of
-            //     the array type derivation.
-            //
-            // [1]: http://c0x.coding-guidelines.com/6.7.5.3.html
-            let arg_ty = match *arg_ty.canonical_type(ctx).kind() {
-                TypeKind::Array(t, _) => {
-                    t.to_rust_ty_or_opaque(ctx, &())
-                        .to_ptr(ctx.resolve_type(t).is_const())
-                },
-                TypeKind::Pointer(inner) => {
-                    let inner = ctx.resolve_item(inner);
-                    let inner_ty = inner.expect_type();
-                    if let TypeKind::ObjCInterface(_) = *inner_ty.canonical_type(ctx).kind() {
-                        quote! {
-                            id
+        let mut args = sig
+            .argument_types()
+            .iter()
+            .map(|&(ref name, ty)| {
+                let arg_item = ctx.resolve_item(ty);
+                let arg_ty = arg_item.kind().expect_type();
+
+                // From the C90 standard[1]:
+                //
+                //     A declaration of a parameter as "array of type" shall be
+                //     adjusted to "qualified pointer to type", where the type
+                //     qualifiers (if any) are those specified within the [ and ] of
+                //     the array type derivation.
+                //
+                // [1]: http://c0x.coding-guidelines.com/6.7.5.3.html
+                let arg_ty = match *arg_ty.canonical_type(ctx).kind() {
+                    TypeKind::Array(t, _) => {
+                        let stream =
+                            if ctx.options().array_pointers_in_arguments {
+                                arg_ty.to_rust_ty_or_opaque(ctx, &arg_item)
+                            } else {
+                                t.to_rust_ty_or_opaque(ctx, &())
+                            };
+                        stream.to_ptr(ctx.resolve_type(t).is_const())
+                    }
+                    TypeKind::Pointer(inner) => {
+                        let inner = ctx.resolve_item(inner);
+                        let inner_ty = inner.expect_type();
+                        if let TypeKind::ObjCInterface(_) =
+                            *inner_ty.canonical_type(ctx).kind()
+                        {
+                            quote! {
+                                id
+                            }
+                        } else {
+                            arg_item.to_rust_ty_or_opaque(ctx, &())
                         }
-                    } else {
-                        arg_item.to_rust_ty_or_opaque(ctx, &())
                     }
-                },
-                _ => {
-                    arg_item.to_rust_ty_or_opaque(ctx, &())
-                }
-            };
+                    _ => arg_item.to_rust_ty_or_opaque(ctx, &()),
+                };
 
-            let arg_name = match *name {
-                Some(ref name) => ctx.rust_mangle(name).into_owned(),
-                None => {
-                    unnamed_arguments += 1;
-                    format!("arg{}", unnamed_arguments)
-                }
-            };
+                let arg_name = match *name {
+                    Some(ref name) => ctx.rust_mangle(name).into_owned(),
+                    None => {
+                        unnamed_arguments += 1;
+                        format!("arg{}", unnamed_arguments)
+                    }
+                };
 
-            assert!(!arg_name.is_empty());
-            let arg_name = ctx.rust_ident(arg_name);
+                assert!(!arg_name.is_empty());
+                let arg_name = ctx.rust_ident(arg_name);
 
-            quote! {
-                #arg_name : #arg_ty
-            }
-        }).collect::<Vec<_>>();
+                quote! {
+                    #arg_name : #arg_ty
+                }
+            })
+            .collect::<Vec<_>>();
 
         if sig.is_variadic() {
             args.push(quote! { ... })
@@ -3961,11 +4058,12 @@ mod utils {
         });
 
         let return_item = ctx.resolve_item(sig.return_type());
-        let ret_ty = if let TypeKind::Void = *return_item.kind().expect_type().kind() {
-            quote! { () }
-        } else {
-            return_item.to_rust_ty_or_opaque(ctx, &())
-        };
+        let ret_ty =
+            if let TypeKind::Void = *return_item.kind().expect_type().kind() {
+                quote! { () }
+            } else {
+                return_item.to_rust_ty_or_opaque(ctx, &())
+            };
 
         quote! {
             *const ::block::Block<(#(#args,)*), #ret_ty>
diff --git a/third_party/rust/bindgen/src/codegen/struct_layout.rs b/third_party/rust/bindgen/src/codegen/struct_layout.rs
index 29d281aa4b77..3c03ff1152db 100644
--- a/third_party/rust/bindgen/src/codegen/struct_layout.rs
+++ b/third_party/rust/bindgen/src/codegen/struct_layout.rs
@@ -166,7 +166,8 @@ impl<'a> StructLayoutTracker<'a> {
             // This means that the structs in the array are super-unsafe to
             // access, since they won't be properly aligned, but there's not too
             // much we can do about it.
-            if let Some(layout) = self.ctx.resolve_type(inner).layout(self.ctx) {
+            if let Some(layout) = self.ctx.resolve_type(inner).layout(self.ctx)
+            {
                 if layout.align > self.ctx.target_pointer_size() {
                     field_layout.size =
                         align_to(layout.size, layout.align) * len;
@@ -212,7 +213,10 @@ impl<'a> StructLayoutTracker<'a> {
             if need_padding && padding_bytes != 0 {
                 Some(Layout::new(
                     padding_bytes,
-                    cmp::min(field_layout.align, self.ctx.target_pointer_size())
+                    cmp::min(
+                        field_layout.align,
+                        self.ctx.target_pointer_size(),
+                    ),
                 ))
             } else {
                 None
@@ -235,11 +239,13 @@ impl<'a> StructLayoutTracker<'a> {
         padding_layout.map(|layout| self.padding_field(layout))
     }
 
-    pub fn pad_struct(&mut self, layout: Layout) -> Option<proc_macro2::TokenStream> {
+    pub fn pad_struct(
+        &mut self,
+        layout: Layout,
+    ) -> Option<proc_macro2::TokenStream> {
         debug!(
             "pad_struct:\n\tself = {:#?}\n\tlayout = {:#?}",
-            self,
-            layout
+            self, layout
         );
 
         if layout.size < self.latest_offset {
@@ -261,15 +267,15 @@ impl<'a> StructLayoutTracker<'a> {
         // other fields.
         if padding_bytes > 0 &&
             (padding_bytes >= layout.align ||
-                 (self.last_field_was_bitfield &&
-                      padding_bytes >=
-                          self.latest_field_layout.unwrap().align) ||
-                 layout.align > self.ctx.target_pointer_size())
+                (self.last_field_was_bitfield &&
+                    padding_bytes >=
+                        self.latest_field_layout.unwrap().align) ||
+                layout.align > self.ctx.target_pointer_size())
         {
             let layout = if self.is_packed {
                 Layout::new(padding_bytes, 1)
             } else if self.last_field_was_bitfield ||
-                       layout.align > self.ctx.target_pointer_size()
+                layout.align > self.ctx.target_pointer_size()
             {
                 // We've already given up on alignment here.
                 Layout::for_size(self.ctx, padding_bytes)
@@ -315,7 +321,10 @@ impl<'a> StructLayoutTracker<'a> {
 
         self.padding_count += 1;
 
-        let padding_field_name = Ident::new(&format!("__bindgen_padding_{}", padding_count), Span::call_site());
+        let padding_field_name = Ident::new(
+            &format!("__bindgen_padding_{}", padding_count),
+            Span::call_site(),
+        );
 
         self.max_field_align = cmp::max(self.max_field_align, layout.align);
 
@@ -342,9 +351,7 @@ impl<'a> StructLayoutTracker<'a> {
         // current field alignment and the bitfield size and alignment are.
         debug!(
             "align_to_bitfield? {}: {:?} {:?}",
-            self.last_field_was_bitfield,
-            layout,
-            new_field_layout
+            self.last_field_was_bitfield, layout, new_field_layout
         );
 
         // Avoid divide-by-zero errors if align is 0.
diff --git a/third_party/rust/bindgen/src/features.rs b/third_party/rust/bindgen/src/features.rs
index 50759c318968..e700ca75b375 100644
--- a/third_party/rust/bindgen/src/features.rs
+++ b/third_party/rust/bindgen/src/features.rs
@@ -102,6 +102,8 @@ macro_rules! rust_target_base {
             => Stable_1_27 => 1.27;
             /// Rust stable 1.28
             => Stable_1_28 => 1.28;
+            /// Rust stable 1.30
+            => Stable_1_30 => 1.30;
             /// Rust stable 1.33
             => Stable_1_33 => 1.33;
             /// Nightly rust
@@ -192,6 +194,11 @@ rust_feature_def!(
         /// repr(transparent) ([PR](https://github.com/rust-lang/rust/pull/51562))
         => repr_transparent;
     }
+    Stable_1_30 {
+        /// `const fn` support for limited cases
+        /// ([PR](https://github.com/rust-lang/rust/pull/54835/)
+        => min_const_fn;
+    }
     Stable_1_33 {
         /// repr(packed(N)) ([PR](https://github.com/rust-lang/rust/pull/57049))
         => repr_packed_n;
@@ -199,6 +206,8 @@ rust_feature_def!(
     Nightly {
         /// `thiscall` calling convention ([Tracking issue](https://github.com/rust-lang/rust/issues/42202))
         => thiscall_abi;
+        /// `non_exhaustive` enums/structs ([Tracking issue](https://github.com/rust-lang/rust/issues/44109))
+        => non_exhaustive;
     }
 );
 
@@ -218,27 +227,27 @@ mod test {
     fn target_features() {
         let f_1_0 = RustFeatures::from(RustTarget::Stable_1_0);
         assert!(
-            !f_1_0.untagged_union
-                && !f_1_0.associated_const
-                && !f_1_0.builtin_clone_impls
-                && !f_1_0.repr_align
-                && !f_1_0.thiscall_abi
+            !f_1_0.untagged_union &&
+                !f_1_0.associated_const &&
+                !f_1_0.builtin_clone_impls &&
+                !f_1_0.repr_align &&
+                !f_1_0.thiscall_abi
         );
         let f_1_21 = RustFeatures::from(RustTarget::Stable_1_21);
         assert!(
-            f_1_21.untagged_union
-                && f_1_21.associated_const
-                && f_1_21.builtin_clone_impls
-                && !f_1_21.repr_align
-                && !f_1_21.thiscall_abi
+            f_1_21.untagged_union &&
+                f_1_21.associated_const &&
+                f_1_21.builtin_clone_impls &&
+                !f_1_21.repr_align &&
+                !f_1_21.thiscall_abi
         );
         let f_nightly = RustFeatures::from(RustTarget::Nightly);
         assert!(
-            f_nightly.untagged_union
-                && f_nightly.associated_const
-                && f_nightly.builtin_clone_impls
-                && f_nightly.repr_align
-                && f_nightly.thiscall_abi
+            f_nightly.untagged_union &&
+                f_nightly.associated_const &&
+                f_nightly.builtin_clone_impls &&
+                f_nightly.repr_align &&
+                f_nightly.thiscall_abi
         );
     }
 
diff --git a/third_party/rust/bindgen/src/ir/analysis/derive.rs b/third_party/rust/bindgen/src/ir/analysis/derive.rs
index dbfe35a4a9dc..e07f6bc2c047 100644
--- a/third_party/rust/bindgen/src/ir/analysis/derive.rs
+++ b/third_party/rust/bindgen/src/ir/analysis/derive.rs
@@ -2,18 +2,18 @@
 
 use std::fmt;
 
-use super::{ConstrainResult, MonotoneFramework, generate_dependencies};
+use super::{generate_dependencies, ConstrainResult, MonotoneFramework};
 use ir::analysis::has_vtable::HasVtable;
 use ir::comp::CompKind;
 use ir::context::{BindgenContext, ItemId};
 use ir::derive::CanDerive;
 use ir::function::FunctionSig;
-use ir::item::{Item, IsOpaque};
+use ir::item::{IsOpaque, Item};
 use ir::template::TemplateParameters;
 use ir::traversal::{EdgeKind, Trace};
 use ir::ty::RUST_DERIVE_IN_ARRAY_LIMIT;
-use ir::ty::{TypeKind, Type};
-use {HashSet, HashMap, Entry};
+use ir::ty::{Type, TypeKind};
+use {Entry, HashMap, HashSet};
 
 /// Which trait to consider when doing the `CannotDerive` analysis.
 #[derive(Debug, Copy, Clone)]
@@ -110,19 +110,26 @@ impl<'ctx> CannotDerive<'ctx> {
         can_derive: CanDerive,
     ) -> ConstrainResult {
         let id = id.into();
-        trace!("inserting {:?} can_derive<{}>={:?}", id, self.derive_trait, can_derive);
+        trace!(
+            "inserting {:?} can_derive<{}>={:?}",
+            id,
+            self.derive_trait,
+            can_derive
+        );
 
         if let CanDerive::Yes = can_derive {
             return ConstrainResult::Same;
         }
 
         match self.can_derive.entry(id) {
-            Entry::Occupied(mut entry) => if *entry.get() < can_derive {
-                entry.insert(can_derive);
-                ConstrainResult::Changed
-            } else {
-                ConstrainResult::Same
-            },
+            Entry::Occupied(mut entry) => {
+                if *entry.get() < can_derive {
+                    entry.insert(can_derive);
+                    ConstrainResult::Changed
+                } else {
+                    ConstrainResult::Same
+                }
+            }
             Entry::Vacant(entry) => {
                 entry.insert(can_derive);
                 ConstrainResult::Changed
@@ -132,41 +139,50 @@ impl<'ctx> CannotDerive<'ctx> {
 
     fn constrain_type(&mut self, item: &Item, ty: &Type) -> CanDerive {
         if !self.ctx.whitelisted_items().contains(&item.id()) {
-            trace!("    cannot derive {} for blacklisted type", self.derive_trait);
+            trace!(
+                "    cannot derive {} for blacklisted type",
+                self.derive_trait
+            );
             return CanDerive::No;
         }
 
         if self.derive_trait.not_by_name(self.ctx, &item) {
-            trace!("    cannot derive {} for explicitly excluded type", self.derive_trait);
+            trace!(
+                "    cannot derive {} for explicitly excluded type",
+                self.derive_trait
+            );
             return CanDerive::No;
         }
 
         trace!("ty: {:?}", ty);
         if item.is_opaque(self.ctx, &()) {
-            if !self.derive_trait.can_derive_union()
-                && ty.is_union()
-                && self.ctx.options().rust_features().untagged_union
+            if !self.derive_trait.can_derive_union() &&
+                ty.is_union() &&
+                self.ctx.options().rust_features().untagged_union
             {
                 trace!(
-                    "    cannot derive {} for Rust unions", self.derive_trait
+                    "    cannot derive {} for Rust unions",
+                    self.derive_trait
                 );
                 return CanDerive::No;
             }
 
-            let layout_can_derive = ty.layout(self.ctx)
-                .map_or(CanDerive::Yes, |l| {
+            let layout_can_derive =
+                ty.layout(self.ctx).map_or(CanDerive::Yes, |l| {
                     l.opaque().array_size_within_derive_limit(self.ctx)
                 });
 
             match layout_can_derive {
                 CanDerive::Yes => {
                     trace!(
-                        "    we can trivially derive {} for the layout", self.derive_trait
+                        "    we can trivially derive {} for the layout",
+                        self.derive_trait
                     );
                 }
                 _ => {
                     trace!(
-                        "    we cannot derive {} for the layout", self.derive_trait
+                        "    we cannot derive {} for the layout",
+                        self.derive_trait
                     );
                 }
             };
@@ -194,7 +210,7 @@ impl<'ctx> CannotDerive<'ctx> {
                 let inner_type =
                     self.ctx.resolve_type(inner).canonical_type(self.ctx);
                 if let TypeKind::Function(ref sig) = *inner_type.kind() {
-                    return self.derive_trait.can_derive_fnptr(sig)
+                    return self.derive_trait.can_derive_fnptr(sig);
                 } else {
                     return self.derive_trait.can_derive_pointer();
                 }
@@ -205,31 +221,34 @@ impl<'ctx> CannotDerive<'ctx> {
 
             // Complex cases need more information
             TypeKind::Array(t, len) => {
-                let inner_type = self.can_derive
-                    .get(&t.into())
-                    .cloned()
-                    .unwrap_or_default();
+                let inner_type =
+                    self.can_derive.get(&t.into()).cloned().unwrap_or_default();
                 if inner_type != CanDerive::Yes {
                     trace!(
                         "    arrays of T for which we cannot derive {} \
-                         also cannot derive {}", self.derive_trait, self.derive_trait
+                         also cannot derive {}",
+                        self.derive_trait,
+                        self.derive_trait
                     );
                     return CanDerive::No;
                 }
 
-                if len == 0 && !self.derive_trait.can_derive_incomplete_array() {
+                if len == 0 && !self.derive_trait.can_derive_incomplete_array()
+                {
                     trace!(
-                        "    cannot derive {} for incomplete arrays", self.derive_trait
+                        "    cannot derive {} for incomplete arrays",
+                        self.derive_trait
                     );
                     return CanDerive::No;
                 } else {
                     if self.derive_trait.can_derive_large_array() {
-                            trace!("    array can derive {}", self.derive_trait);
-                            return CanDerive::Yes;
+                        trace!("    array can derive {}", self.derive_trait);
+                        return CanDerive::Yes;
                     } else {
                         if len <= RUST_DERIVE_IN_ARRAY_LIMIT {
                             trace!(
-                                "    array is small enough to derive {}", self.derive_trait
+                                "    array is small enough to derive {}",
+                                self.derive_trait
                             );
                             return CanDerive::Yes;
                         } else {
@@ -242,19 +261,19 @@ impl<'ctx> CannotDerive<'ctx> {
                 }
             }
             TypeKind::Vector(t, len) => {
-                let inner_type = self.can_derive
-                    .get(&t.into())
-                    .cloned()
-                    .unwrap_or_default();
+                let inner_type =
+                    self.can_derive.get(&t.into()).cloned().unwrap_or_default();
                 if inner_type != CanDerive::Yes {
                     trace!(
                         "    vectors of T for which we cannot derive {} \
-                         also cannot derive {}", self.derive_trait, self.derive_trait
+                         also cannot derive {}",
+                        self.derive_trait,
+                        self.derive_trait
                     );
                     return CanDerive::No;
                 }
                 assert_ne!(len, 0, "vectors cannot have zero length");
-                return self.derive_trait.can_derive_vector()
+                return self.derive_trait.can_derive_vector();
             }
 
             TypeKind::Comp(ref info) => {
@@ -263,19 +282,28 @@ impl<'ctx> CannotDerive<'ctx> {
                     "The early ty.is_opaque check should have handled this case"
                 );
 
-                if !self.derive_trait.can_derive_compound_forward_decl()
-                    && info.is_forward_declaration() {
-                    trace!("    cannot derive {} for forward decls", self.derive_trait);
+                if !self.derive_trait.can_derive_compound_forward_decl() &&
+                    info.is_forward_declaration()
+                {
+                    trace!(
+                        "    cannot derive {} for forward decls",
+                        self.derive_trait
+                    );
                     return CanDerive::No;
                 }
 
                 // NOTE: Take into account that while unions in C and C++ are copied by
                 // default, the may have an explicit destructor in C++, so we can't
                 // defer this check just for the union case.
-                if !self.derive_trait.can_derive_compound_with_destructor()
-                    && self.ctx.lookup_has_destructor(item.id().expect_type_id(self.ctx))
+                if !self.derive_trait.can_derive_compound_with_destructor() &&
+                    self.ctx.lookup_has_destructor(
+                        item.id().expect_type_id(self.ctx),
+                    )
                 {
-                    trace!("    comp has destructor which cannot derive {}", self.derive_trait);
+                    trace!(
+                        "    comp has destructor which cannot derive {}",
+                        self.derive_trait
+                    );
                     return CanDerive::No;
                 }
 
@@ -284,34 +312,39 @@ impl<'ctx> CannotDerive<'ctx> {
                         if self.ctx.options().rust_features().untagged_union &&
                            // https://github.com/rust-lang/rust/issues/36640
                            (!info.self_template_params(self.ctx).is_empty() ||
-                            !item.all_template_params(self.ctx).is_empty()) {
+                            !item.all_template_params(self.ctx).is_empty())
+                        {
                             trace!(
                                 "    cannot derive {} for Rust union because issue 36640", self.derive_trait
                             );
                             return CanDerive::No;
                         }
-                        // fall through to be same as non-union handling
+                    // fall through to be same as non-union handling
                     } else {
                         if self.ctx.options().rust_features().untagged_union {
                             trace!(
-                                "    cannot derive {} for Rust unions", self.derive_trait
+                                "    cannot derive {} for Rust unions",
+                                self.derive_trait
                             );
                             return CanDerive::No;
                         }
 
                         let layout_can_derive =
                             ty.layout(self.ctx).map_or(CanDerive::Yes, |l| {
-                                l.opaque().array_size_within_derive_limit(self.ctx)
+                                l.opaque()
+                                    .array_size_within_derive_limit(self.ctx)
                             });
                         match layout_can_derive {
                             CanDerive::Yes => {
                                 trace!(
-                                    "    union layout can trivially derive {}", self.derive_trait
+                                    "    union layout can trivially derive {}",
+                                    self.derive_trait
                                 );
                             }
                             _ => {
                                 trace!(
-                                    "    union layout cannot derive {}", self.derive_trait
+                                    "    union layout cannot derive {}",
+                                    self.derive_trait
                                 );
                             }
                         };
@@ -319,9 +352,13 @@ impl<'ctx> CannotDerive<'ctx> {
                     }
                 }
 
-                if !self.derive_trait.can_derive_compound_with_vtable()
-                    && item.has_vtable(self.ctx) {
-                    trace!("    cannot derive {} for comp with vtable", self.derive_trait);
+                if !self.derive_trait.can_derive_compound_with_vtable() &&
+                    item.has_vtable(self.ctx)
+                {
+                    trace!(
+                        "    cannot derive {} for comp with vtable",
+                        self.derive_trait
+                    );
                     return CanDerive::No;
                 }
 
@@ -348,7 +385,11 @@ impl<'ctx> CannotDerive<'ctx> {
         }
     }
 
-    fn constrain_join(&mut self, item: &Item, consider_edge: EdgePredicate) -> CanDerive {
+    fn constrain_join(
+        &mut self,
+        item: &Item,
+        consider_edge: EdgePredicate,
+    ) -> CanDerive {
         let mut candidate = None;
 
         item.trace(
@@ -378,7 +419,10 @@ impl<'ctx> CannotDerive<'ctx> {
         );
 
         if candidate.is_none() {
-            trace!("    can derive {} because there are no members", self.derive_trait);
+            trace!(
+                "    can derive {} because there are no members",
+                self.derive_trait
+            );
         }
         candidate.unwrap_or_default()
     }
@@ -389,8 +433,10 @@ impl DeriveTrait {
         match self {
             DeriveTrait::Copy => ctx.no_copy_by_name(item),
             DeriveTrait::Hash => ctx.no_hash_by_name(item),
-            DeriveTrait::PartialEqOrPartialOrd => ctx.no_partialeq_by_name(item),
-            _ => false
+            DeriveTrait::PartialEqOrPartialOrd => {
+                ctx.no_partialeq_by_name(item)
+            }
+            _ => false,
         }
     }
 
@@ -398,17 +444,16 @@ impl DeriveTrait {
         match self {
             DeriveTrait::PartialEqOrPartialOrd => consider_edge_default,
             _ => |kind| match kind {
-                EdgeKind::BaseMember |
-                EdgeKind::Field => true,
+                EdgeKind::BaseMember | EdgeKind::Field => true,
                 _ => false,
-            }
+            },
         }
     }
 
     fn consider_edge_typeref(&self) -> EdgePredicate {
         match self {
             DeriveTrait::PartialEqOrPartialOrd => consider_edge_default,
-            _ => |kind| kind == EdgeKind::TypeReference
+            _ => |kind| kind == EdgeKind::TypeReference,
         }
     }
 
@@ -416,10 +461,11 @@ impl DeriveTrait {
         match self {
             DeriveTrait::PartialEqOrPartialOrd => consider_edge_default,
             _ => |kind| match kind {
-                EdgeKind::TemplateArgument |
-                EdgeKind::TemplateDeclaration => true,
+                EdgeKind::TemplateArgument | EdgeKind::TemplateDeclaration => {
+                    true
+                }
                 _ => false,
-            }
+            },
         }
     }
 
@@ -460,16 +506,16 @@ impl DeriveTrait {
 
     fn can_derive_incomplete_array(&self) -> bool {
         match self {
-            DeriveTrait::Copy | DeriveTrait::Hash | DeriveTrait::PartialEqOrPartialOrd => false,
+            DeriveTrait::Copy |
+            DeriveTrait::Hash |
+            DeriveTrait::PartialEqOrPartialOrd => false,
             _ => true,
         }
     }
 
     fn can_derive_fnptr(&self, f: &FunctionSig) -> CanDerive {
         match (self, f.function_pointers_can_derive()) {
-            (DeriveTrait::Copy, _) |
-            (DeriveTrait::Default, _) |
-            (_, true) => {
+            (DeriveTrait::Copy, _) | (DeriveTrait::Default, _) | (_, true) => {
                 trace!("    function pointer can derive {}", self);
                 CanDerive::Yes
             }
@@ -526,21 +572,23 @@ impl DeriveTrait {
             (DeriveTrait::Default, TypeKind::ObjCSel) => {
                 trace!("    types that always cannot derive Default");
                 CanDerive::No
-            },
-            (DeriveTrait::Default, TypeKind::UnresolvedTypeRef(..)) => unreachable!(
-                "Type with unresolved type ref can't reach derive default"
-            ),
+            }
+            (DeriveTrait::Default, TypeKind::UnresolvedTypeRef(..)) => {
+                unreachable!(
+                    "Type with unresolved type ref can't reach derive default"
+                )
+            }
             // === Hash ===
             (DeriveTrait::Hash, TypeKind::Float(..)) |
             (DeriveTrait::Hash, TypeKind::Complex(..)) => {
                 trace!("    float cannot derive Hash");
                 CanDerive::No
-            },
+            }
             // === others ===
             _ => {
                 trace!("    simple type that can always derive {}", self);
                 CanDerive::Yes
-            },
+            }
         }
     }
 }
@@ -602,9 +650,7 @@ impl<'ctx> MonotoneFramework for CannotDerive<'ctx> {
         trace!("constrain: {:?}", id);
 
         if let Some(CanDerive::No) = self.can_derive.get(&id).cloned() {
-            trace!(
-                "    already know it cannot derive {}", self.derive_trait
-            );
+            trace!("    already know it cannot derive {}", self.derive_trait);
             return ConstrainResult::Same;
         }
 
@@ -614,7 +660,9 @@ impl<'ctx> MonotoneFramework for CannotDerive<'ctx> {
                 let mut can_derive = self.constrain_type(item, ty);
                 if let CanDerive::Yes = can_derive {
                     if !self.derive_trait.can_derive_large_array() &&
-                        ty.layout(self.ctx).map_or(false, |l| l.align > RUST_DERIVE_IN_ARRAY_LIMIT)
+                        ty.layout(self.ctx).map_or(false, |l| {
+                            l.align > RUST_DERIVE_IN_ARRAY_LIMIT
+                        })
                     {
                         // We have to be conservative: the struct *could* have enough
                         // padding that we emit an array that is longer than
@@ -647,12 +695,10 @@ impl<'ctx> MonotoneFramework for CannotDerive<'ctx> {
 
 impl<'ctx> From<CannotDerive<'ctx>> for HashMap<ItemId, CanDerive> {
     fn from(analysis: CannotDerive<'ctx>) -> Self {
-        extra_assert!(
-            analysis
-                .can_derive
-                .values()
-                .all(|v| *v != CanDerive::Yes)
-        );
+        extra_assert!(analysis
+            .can_derive
+            .values()
+            .all(|v| *v != CanDerive::Yes));
 
         analysis.can_derive
     }
@@ -662,9 +708,11 @@ impl<'ctx> From<CannotDerive<'ctx>> for HashMap<ItemId, CanDerive> {
 ///
 /// Elements that are not `CanDerive::Yes` are kept in the set, so that it
 /// represents all items that cannot derive.
-pub fn as_cannot_derive_set(can_derive: HashMap<ItemId, CanDerive>) -> HashSet<ItemId> {
+pub fn as_cannot_derive_set(
+    can_derive: HashMap<ItemId, CanDerive>,
+) -> HashSet<ItemId> {
     can_derive
         .into_iter()
-        .filter_map(|(k, v)| if v != CanDerive::Yes { Some(k) } else { None } )
+        .filter_map(|(k, v)| if v != CanDerive::Yes { Some(k) } else { None })
         .collect()
 }
diff --git a/third_party/rust/bindgen/src/ir/analysis/has_destructor.rs b/third_party/rust/bindgen/src/ir/analysis/has_destructor.rs
index c79b3645916a..12b6926069f4 100644
--- a/third_party/rust/bindgen/src/ir/analysis/has_destructor.rs
+++ b/third_party/rust/bindgen/src/ir/analysis/has_destructor.rs
@@ -1,9 +1,9 @@
 //! Determining which types have destructors
 
-use super::{ConstrainResult, MonotoneFramework, generate_dependencies};
+use super::{generate_dependencies, ConstrainResult, MonotoneFramework};
+use ir::comp::{CompKind, Field, FieldMethods};
 use ir::context::{BindgenContext, ItemId};
 use ir::traversal::EdgeKind;
-use ir::comp::{CompKind, Field, FieldMethods};
 use ir::ty::TypeKind;
 use {HashMap, HashSet};
 
@@ -121,14 +121,14 @@ impl<'ctx> MonotoneFramework for HasDestructorAnalysis<'ctx> {
                         let base_or_field_destructor =
                             info.base_members().iter().any(|base| {
                                 self.have_destructor.contains(&base.ty.into())
-                            }) ||
-                            info.fields().iter().any(|field| {
-                                match *field {
-                                    Field::DataMember(ref data) =>
-                                        self.have_destructor.contains(&data.ty().into()),
-                                    Field::Bitfields(_) => false
-                                }
-                            });
+                            }) || info.fields().iter().any(
+                                |field| match *field {
+                                    Field::DataMember(ref data) => self
+                                        .have_destructor
+                                        .contains(&data.ty().into()),
+                                    Field::Bitfields(_) => false,
+                                },
+                            );
                         if base_or_field_destructor {
                             self.insert(id)
                         } else {
@@ -139,9 +139,9 @@ impl<'ctx> MonotoneFramework for HasDestructorAnalysis<'ctx> {
             }
 
             TypeKind::TemplateInstantiation(ref inst) => {
-                let definition_or_arg_destructor =
-                    self.have_destructor.contains(&inst.template_definition().into())
-                    ||
+                let definition_or_arg_destructor = self
+                    .have_destructor
+                    .contains(&inst.template_definition().into()) ||
                     inst.template_arguments().iter().any(|arg| {
                         self.have_destructor.contains(&arg.into())
                     });
diff --git a/third_party/rust/bindgen/src/ir/analysis/has_float.rs b/third_party/rust/bindgen/src/ir/analysis/has_float.rs
index 69cfcc859ee3..7c62a9e278e7 100644
--- a/third_party/rust/bindgen/src/ir/analysis/has_float.rs
+++ b/third_party/rust/bindgen/src/ir/analysis/has_float.rs
@@ -1,12 +1,12 @@
 //! Determining which types has float.
 
-use super::{ConstrainResult, MonotoneFramework, generate_dependencies};
-use {HashSet, HashMap};
+use super::{generate_dependencies, ConstrainResult, MonotoneFramework};
+use ir::comp::Field;
+use ir::comp::FieldMethods;
 use ir::context::{BindgenContext, ItemId};
 use ir::traversal::EdgeKind;
 use ir::ty::TypeKind;
-use ir::comp::Field;
-use ir::comp::FieldMethods;
+use {HashMap, HashSet};
 
 /// An analysis that finds for each IR item whether it has float or not.
 ///
@@ -132,24 +132,27 @@ impl<'ctx> MonotoneFramework for HasFloat<'ctx> {
                 ConstrainResult::Same
             }
 
-            TypeKind::Float(..) |
-            TypeKind::Complex(..) => {
+            TypeKind::Float(..) | TypeKind::Complex(..) => {
                 trace!("    float type has float");
                 self.insert(id)
             }
 
             TypeKind::Array(t, _) => {
                 if self.has_float.contains(&t.into()) {
-                    trace!("    Array with type T that has float also has float");
-                    return self.insert(id)
+                    trace!(
+                        "    Array with type T that has float also has float"
+                    );
+                    return self.insert(id);
                 }
                 trace!("    Array with type T that do not have float also do not have float");
                 ConstrainResult::Same
             }
             TypeKind::Vector(t, _) => {
                 if self.has_float.contains(&t.into()) {
-                    trace!("    Vector with type T that has float also has float");
-                    return self.insert(id)
+                    trace!(
+                        "    Vector with type T that has float also has float"
+                    );
+                    return self.insert(id);
                 }
                 trace!("    Vector with type T that do not have float also do not have float");
                 ConstrainResult::Same
@@ -160,8 +163,10 @@ impl<'ctx> MonotoneFramework for HasFloat<'ctx> {
             TypeKind::Alias(t) |
             TypeKind::BlockPointer(t) => {
                 if self.has_float.contains(&t.into()) {
-                    trace!("    aliases and type refs to T which have float \
-                            also have float");
+                    trace!(
+                        "    aliases and type refs to T which have float \
+                         also have float"
+                    );
                     self.insert(id)
                 } else {
                     trace!("    aliases and type refs to T which do not have float \
@@ -171,28 +176,23 @@ impl<'ctx> MonotoneFramework for HasFloat<'ctx> {
             }
 
             TypeKind::Comp(ref info) => {
-                let bases_have = info.base_members()
+                let bases_have = info
+                    .base_members()
                     .iter()
                     .any(|base| self.has_float.contains(&base.ty.into()));
                 if bases_have {
                     trace!("    bases have float, so we also have");
                     return self.insert(id);
                 }
-                let fields_have = info.fields()
-                    .iter()
-                    .any(|f| {
-                        match *f {
-                            Field::DataMember(ref data) => {
-                                self.has_float.contains(&data.ty().into())
-                            }
-                            Field::Bitfields(ref bfu) => {
-                                bfu.bitfields()
-                                    .iter().any(|b| {
-                                        self.has_float.contains(&b.ty().into())
-                                    })
-                            },
-                        }
-                    });
+                let fields_have = info.fields().iter().any(|f| match *f {
+                    Field::DataMember(ref data) => {
+                        self.has_float.contains(&data.ty().into())
+                    }
+                    Field::Bitfields(ref bfu) => bfu
+                        .bitfields()
+                        .iter()
+                        .any(|b| self.has_float.contains(&b.ty().into())),
+                });
                 if fields_have {
                     trace!("    fields have float, so we also have");
                     return self.insert(id);
@@ -203,20 +203,26 @@ impl<'ctx> MonotoneFramework for HasFloat<'ctx> {
             }
 
             TypeKind::TemplateInstantiation(ref template) => {
-                let args_have = template.template_arguments()
+                let args_have = template
+                    .template_arguments()
                     .iter()
                     .any(|arg| self.has_float.contains(&arg.into()));
                 if args_have {
-                    trace!("    template args have float, so \
-                            insantiation also has float");
+                    trace!(
+                        "    template args have float, so \
+                         insantiation also has float"
+                    );
                     return self.insert(id);
                 }
 
-                let def_has = self.has_float
+                let def_has = self
+                    .has_float
                     .contains(&template.template_definition().into());
                 if def_has {
-                    trace!("    template definition has float, so \
-                            insantiation also has");
+                    trace!(
+                        "    template definition has float, so \
+                         insantiation also has"
+                    );
                     return self.insert(id);
                 }
 
@@ -227,7 +233,8 @@ impl<'ctx> MonotoneFramework for HasFloat<'ctx> {
     }
 
     fn each_depending_on<F>(&self, id: ItemId, mut f: F)
-        where F: FnMut(ItemId),
+    where
+        F: FnMut(ItemId),
     {
         if let Some(edges) = self.dependencies.get(&id) {
             for item in edges {
diff --git a/third_party/rust/bindgen/src/ir/analysis/has_type_param_in_array.rs b/third_party/rust/bindgen/src/ir/analysis/has_type_param_in_array.rs
index 98959f0f121c..4217f6f045c0 100644
--- a/third_party/rust/bindgen/src/ir/analysis/has_type_param_in_array.rs
+++ b/third_party/rust/bindgen/src/ir/analysis/has_type_param_in_array.rs
@@ -1,6 +1,6 @@
 //! Determining which types has typed parameters in array.
 
-use super::{ConstrainResult, MonotoneFramework, generate_dependencies};
+use super::{generate_dependencies, ConstrainResult, MonotoneFramework};
 use ir::comp::Field;
 use ir::comp::FieldMethods;
 use ir::context::{BindgenContext, ItemId};
@@ -88,9 +88,7 @@ impl<'ctx> MonotoneFramework for HasTypeParameterInArray<'ctx> {
     type Extra = &'ctx BindgenContext;
     type Output = HashSet<ItemId>;
 
-    fn new(
-        ctx: &'ctx BindgenContext,
-    ) -> HasTypeParameterInArray<'ctx> {
+    fn new(ctx: &'ctx BindgenContext) -> HasTypeParameterInArray<'ctx> {
         let has_type_parameter_in_array = HashSet::default();
         let dependencies = generate_dependencies(ctx, Self::consider_edge);
 
@@ -169,7 +167,7 @@ impl<'ctx> MonotoneFramework for HasTypeParameterInArray<'ctx> {
                 if self.has_type_parameter_in_array.contains(&t.into()) {
                     trace!(
                         "    aliases and type refs to T which have array \
-                            also have array"
+                         also have array"
                     );
                     self.insert(id)
                 } else {
@@ -190,9 +188,9 @@ impl<'ctx> MonotoneFramework for HasTypeParameterInArray<'ctx> {
                     return self.insert(id);
                 }
                 let fields_have = info.fields().iter().any(|f| match *f {
-                    Field::DataMember(ref data) => {
-                        self.has_type_parameter_in_array.contains(&data.ty().into())
-                    }
+                    Field::DataMember(ref data) => self
+                        .has_type_parameter_in_array
+                        .contains(&data.ty().into()),
                     Field::Bitfields(..) => false,
                 });
                 if fields_have {
@@ -212,18 +210,18 @@ impl<'ctx> MonotoneFramework for HasTypeParameterInArray<'ctx> {
                 if args_have {
                     trace!(
                         "    template args have array, so \
-                            insantiation also has array"
+                         insantiation also has array"
                     );
                     return self.insert(id);
                 }
 
-                let def_has = self.has_type_parameter_in_array.contains(
-                    &template.template_definition().into(),
-                );
+                let def_has = self
+                    .has_type_parameter_in_array
+                    .contains(&template.template_definition().into());
                 if def_has {
                     trace!(
                         "    template definition has array, so \
-                            insantiation also has"
+                         insantiation also has"
                     );
                     return self.insert(id);
                 }
diff --git a/third_party/rust/bindgen/src/ir/analysis/has_vtable.rs b/third_party/rust/bindgen/src/ir/analysis/has_vtable.rs
index 410fca057637..026eedd0e0fb 100644
--- a/third_party/rust/bindgen/src/ir/analysis/has_vtable.rs
+++ b/third_party/rust/bindgen/src/ir/analysis/has_vtable.rs
@@ -1,25 +1,25 @@
 //! Determining which types has vtable
 
-use super::{ConstrainResult, MonotoneFramework, generate_dependencies};
+use super::{generate_dependencies, ConstrainResult, MonotoneFramework};
 use ir::context::{BindgenContext, ItemId};
 use ir::traversal::EdgeKind;
 use ir::ty::TypeKind;
 use std::cmp;
 use std::ops;
-use {HashMap, Entry};
+use {Entry, HashMap};
 
 /// The result of the `HasVtableAnalysis` for an individual item.
-#[derive(Copy, Clone, Debug, PartialEq, Eq, Ord)]
+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
 pub enum HasVtableResult {
-    /// The item has a vtable, but the actual vtable pointer is in a base
-    /// member.
-    BaseHasVtable,
+    /// The item does not have a vtable pointer.
+    No,
 
     /// The item has a vtable and the actual vtable pointer is within this item.
     SelfHasVtable,
 
-    /// The item does not have a vtable pointer.
-    No
+    /// The item has a vtable, but the actual vtable pointer is in a base
+    /// member.
+    BaseHasVtable,
 }
 
 impl Default for HasVtableResult {
@@ -28,21 +28,6 @@ impl Default for HasVtableResult {
     }
 }
 
-impl cmp::PartialOrd for HasVtableResult {
-    fn partial_cmp(&self, rhs: &Self) -> Option<cmp::Ordering> {
-        use self::HasVtableResult::*;
-
-        match (*self, *rhs) {
-            (x, y) if x == y => Some(cmp::Ordering::Equal),
-            (BaseHasVtable, _) => Some(cmp::Ordering::Greater),
-            (_, BaseHasVtable) => Some(cmp::Ordering::Less),
-            (SelfHasVtable, _) => Some(cmp::Ordering::Greater),
-            (_, SelfHasVtable) => Some(cmp::Ordering::Less),
-            _ => unreachable!(),
-        }
-    }
-}
-
 impl HasVtableResult {
     /// Take the least upper bound of `self` and `rhs`.
     pub fn join(self, rhs: Self) -> Self {
@@ -104,7 +89,11 @@ impl<'ctx> HasVtableAnalysis<'ctx> {
         }
     }
 
-    fn insert<Id: Into<ItemId>>(&mut self, id: Id, result: HasVtableResult) -> ConstrainResult {
+    fn insert<Id: Into<ItemId>>(
+        &mut self,
+        id: Id,
+        result: HasVtableResult,
+    ) -> ConstrainResult {
         if let HasVtableResult::No = result {
             return ConstrainResult::Same;
         }
@@ -176,7 +165,9 @@ impl<'ctx> MonotoneFramework for HasVtableAnalysis<'ctx> {
             TypeKind::Alias(t) |
             TypeKind::ResolvedTypeRef(t) |
             TypeKind::Reference(t) => {
-                trace!("    aliases and references forward to their inner type");
+                trace!(
+                    "    aliases and references forward to their inner type"
+                );
                 self.forward(t, id)
             }
 
@@ -224,9 +215,10 @@ impl<'ctx> MonotoneFramework for HasVtableAnalysis<'ctx> {
 impl<'ctx> From<HasVtableAnalysis<'ctx>> for HashMap<ItemId, HasVtableResult> {
     fn from(analysis: HasVtableAnalysis<'ctx>) -> Self {
         // We let the lack of an entry mean "No" to save space.
-        extra_assert!(analysis.have_vtable.values().all(|v| {
-            *v != HasVtableResult::No
-        }));
+        extra_assert!(analysis
+            .have_vtable
+            .values()
+            .all(|v| { *v != HasVtableResult::No }));
 
         analysis.have_vtable
     }
diff --git a/third_party/rust/bindgen/src/ir/analysis/mod.rs b/third_party/rust/bindgen/src/ir/analysis/mod.rs
index 9de6833b8bf3..a3ba9848d94e 100644
--- a/third_party/rust/bindgen/src/ir/analysis/mod.rs
+++ b/third_party/rust/bindgen/src/ir/analysis/mod.rs
@@ -41,7 +41,7 @@
 mod template_params;
 pub use self::template_params::UsedTemplateParameters;
 mod derive;
-pub use self::derive::{CannotDerive, DeriveTrait, as_cannot_derive_set};
+pub use self::derive::{as_cannot_derive_set, CannotDerive, DeriveTrait};
 mod has_vtable;
 pub use self::has_vtable::{HasVtable, HasVtableAnalysis, HasVtableResult};
 mod has_destructor;
@@ -56,9 +56,9 @@ pub use self::sizedness::{Sizedness, SizednessAnalysis, SizednessResult};
 use ir::context::{BindgenContext, ItemId};
 
 use ir::traversal::{EdgeKind, Trace};
-use HashMap;
 use std::fmt;
 use std::ops;
+use HashMap;
 
 /// An analysis in the monotone framework.
 ///
@@ -164,10 +164,9 @@ where
 
     while let Some(node) = worklist.pop() {
         if let ConstrainResult::Changed = analysis.constrain(node) {
-            analysis.each_depending_on(
-                node,
-                |needs_work| { worklist.push(needs_work); },
-            );
+            analysis.each_depending_on(node, |needs_work| {
+                worklist.push(needs_work);
+            });
         }
     }
 
@@ -196,9 +195,10 @@ where
                     if ctx.whitelisted_items().contains(&sub_item) &&
                         consider_edge(edge_kind)
                     {
-                        dependencies.entry(sub_item).or_insert(vec![]).push(
-                            item,
-                        );
+                        dependencies
+                            .entry(sub_item)
+                            .or_insert(vec![])
+                            .push(item);
                     }
                 },
                 &(),
@@ -325,13 +325,17 @@ mod tests {
             // Yes, what follows is a **terribly** inefficient set union
             // implementation. Don't copy this code outside of this test!
 
-            let original_size =
-                self.reachable.entry(node).or_insert(HashSet::default()).len();
+            let original_size = self
+                .reachable
+                .entry(node)
+                .or_insert(HashSet::default())
+                .len();
 
             for sub_node in self.graph.0[&node].iter() {
                 self.reachable.get_mut(&node).unwrap().insert(*sub_node);
 
-                let sub_reachable = self.reachable
+                let sub_reachable = self
+                    .reachable
                     .entry(*sub_node)
                     .or_insert(HashSet::default())
                     .clone();
diff --git a/third_party/rust/bindgen/src/ir/analysis/sizedness.rs b/third_party/rust/bindgen/src/ir/analysis/sizedness.rs
index 12d679bb1453..1c9171bd99da 100644
--- a/third_party/rust/bindgen/src/ir/analysis/sizedness.rs
+++ b/third_party/rust/bindgen/src/ir/analysis/sizedness.rs
@@ -1,12 +1,14 @@
 //! Determining the sizedness of types (as base classes and otherwise).
 
-use super::{ConstrainResult, MonotoneFramework, HasVtable, generate_dependencies};
+use super::{
+    generate_dependencies, ConstrainResult, HasVtable, MonotoneFramework,
+};
 use ir::context::{BindgenContext, TypeId};
 use ir::item::IsOpaque;
 use ir::traversal::EdgeKind;
 use ir::ty::TypeKind;
 use std::{cmp, ops};
-use {HashMap, Entry};
+use {Entry, HashMap};
 
 /// The result of the `Sizedness` analysis for an individual item.
 ///
@@ -22,13 +24,14 @@ use {HashMap, Entry};
 ///
 /// We initially assume that all types are `ZeroSized` and then update our
 /// understanding as we learn more about each type.
-#[derive(Copy, Clone, Debug, PartialEq, Eq, Ord)]
+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
 pub enum SizednessResult {
-    /// Has some size that is known to be greater than zero. That doesn't mean
-    /// it has a static size, but it is not zero sized for sure. In other words,
-    /// it might contain an incomplete array or some other dynamically sized
-    /// type.
-    NonZeroSized,
+    /// The type is zero-sized.
+    ///
+    /// This means that if it is a C++ type, and is not being used as a base
+    /// member, then we must add an `_address` byte to enforce the
+    /// unique-address-per-distinct-object-instance rule.
+    ZeroSized,
 
     /// Whether this type is zero-sized or not depends on whether a type
     /// parameter is zero-sized or not.
@@ -49,15 +52,14 @@ pub enum SizednessResult {
     /// have an `_address` byte inserted.
     ///
     /// We don't properly handle this situation correctly right now:
-    /// https://github.com/rust-lang-nursery/rust-bindgen/issues/586
+    /// https://github.com/rust-lang/rust-bindgen/issues/586
     DependsOnTypeParam,
 
-    /// The type is zero-sized.
-    ///
-    /// This means that if it is a C++ type, and is not being used as a base
-    /// member, then we must add an `_address` byte to enforce the
-    /// unique-address-per-distinct-object-instance rule.
-    ZeroSized,
+    /// Has some size that is known to be greater than zero. That doesn't mean
+    /// it has a static size, but it is not zero sized for sure. In other words,
+    /// it might contain an incomplete array or some other dynamically sized
+    /// type.
+    NonZeroSized,
 }
 
 impl Default for SizednessResult {
@@ -66,21 +68,6 @@ impl Default for SizednessResult {
     }
 }
 
-impl cmp::PartialOrd for SizednessResult {
-    fn partial_cmp(&self, rhs: &Self) -> Option<cmp::Ordering> {
-        use self::SizednessResult::*;
-
-        match (*self, *rhs) {
-            (x, y) if x == y => Some(cmp::Ordering::Equal),
-            (NonZeroSized, _) => Some(cmp::Ordering::Greater),
-            (_, NonZeroSized) => Some(cmp::Ordering::Less),
-            (DependsOnTypeParam, _) => Some(cmp::Ordering::Greater),
-            (_, DependsOnTypeParam) => Some(cmp::Ordering::Less),
-            _ => unreachable!(),
-        }
-    }
-}
-
 impl SizednessResult {
     /// Take the least upper bound of `self` and `rhs`.
     pub fn join(self, rhs: Self) -> Self {
@@ -140,7 +127,11 @@ impl<'ctx> SizednessAnalysis<'ctx> {
 
     /// Insert an incremental result, and return whether this updated our
     /// knowledge of types and we should continue the analysis.
-    fn insert(&mut self, id: TypeId, result: SizednessResult) -> ConstrainResult {
+    fn insert(
+        &mut self,
+        id: TypeId,
+        result: SizednessResult,
+    ) -> ConstrainResult {
         trace!("inserting {:?} for {:?}", result, id);
 
         if let SizednessResult::ZeroSized = result {
@@ -180,15 +171,15 @@ impl<'ctx> MonotoneFramework for SizednessAnalysis<'ctx> {
         let dependencies = generate_dependencies(ctx, Self::consider_edge)
             .into_iter()
             .filter_map(|(id, sub_ids)| {
-                id.as_type_id(ctx)
-                    .map(|id| {
-                        (
-                            id,
-                            sub_ids.into_iter()
-                                .filter_map(|s| s.as_type_id(ctx))
-                                .collect::<Vec<_>>()
-                        )
-                    })
+                id.as_type_id(ctx).map(|id| {
+                    (
+                        id,
+                        sub_ids
+                            .into_iter()
+                            .filter_map(|s| s.as_type_id(ctx))
+                            .collect::<Vec<_>>(),
+                    )
+                })
             })
             .collect();
 
@@ -213,7 +204,9 @@ impl<'ctx> MonotoneFramework for SizednessAnalysis<'ctx> {
     fn constrain(&mut self, id: TypeId) -> ConstrainResult {
         trace!("constrain {:?}", id);
 
-        if let Some(SizednessResult::NonZeroSized) = self.sized.get(&id).cloned() {
+        if let Some(SizednessResult::NonZeroSized) =
+            self.sized.get(&id).cloned()
+        {
             trace!("    already know it is not zero-sized");
             return ConstrainResult::Same;
         }
@@ -227,8 +220,8 @@ impl<'ctx> MonotoneFramework for SizednessAnalysis<'ctx> {
 
         if id.is_opaque(self.ctx, &()) {
             trace!("    type is opaque; checking layout...");
-            let result = ty.layout(self.ctx)
-                .map_or(SizednessResult::ZeroSized, |l| {
+            let result =
+                ty.layout(self.ctx).map_or(SizednessResult::ZeroSized, |l| {
                     if l.size == 0 {
                         trace!("    ...layout has size == 0");
                         SizednessResult::ZeroSized
@@ -247,8 +240,10 @@ impl<'ctx> MonotoneFramework for SizednessAnalysis<'ctx> {
             }
 
             TypeKind::TypeParam => {
-                trace!("    type params sizedness depends on what they're \
-                        instantiated as");
+                trace!(
+                    "    type params sizedness depends on what they're \
+                     instantiated as"
+                );
                 self.insert(id, SizednessResult::DependsOnTypeParam)
             }
 
@@ -280,8 +275,10 @@ impl<'ctx> MonotoneFramework for SizednessAnalysis<'ctx> {
             }
 
             TypeKind::TemplateInstantiation(ref inst) => {
-                trace!("    template instantiations are zero-sized if their \
-                        definition is zero-sized");
+                trace!(
+                    "    template instantiations are zero-sized if their \
+                     definition is zero-sized"
+                );
                 self.forward(inst.template_definition(), id)
             }
 
@@ -305,7 +302,8 @@ impl<'ctx> MonotoneFramework for SizednessAnalysis<'ctx> {
                     return self.insert(id, SizednessResult::NonZeroSized);
                 }
 
-                let result = info.base_members()
+                let result = info
+                    .base_members()
                     .iter()
                     .filter_map(|base| self.sized.get(&base.ty))
                     .fold(SizednessResult::ZeroSized, |a, b| a.join(*b));
@@ -339,9 +337,10 @@ impl<'ctx> MonotoneFramework for SizednessAnalysis<'ctx> {
 impl<'ctx> From<SizednessAnalysis<'ctx>> for HashMap<TypeId, SizednessResult> {
     fn from(analysis: SizednessAnalysis<'ctx>) -> Self {
         // We let the lack of an entry mean "ZeroSized" to save space.
-        extra_assert!(analysis.sized.values().all(|v| {
-            *v != SizednessResult::ZeroSized
-        }));
+        extra_assert!(analysis
+            .sized
+            .values()
+            .all(|v| { *v != SizednessResult::ZeroSized }));
 
         analysis.sized
     }
diff --git a/third_party/rust/bindgen/src/ir/analysis/template_params.rs b/third_party/rust/bindgen/src/ir/analysis/template_params.rs
index bd1b51a2f004..da392162a1f1 100644
--- a/third_party/rust/bindgen/src/ir/analysis/template_params.rs
+++ b/third_party/rust/bindgen/src/ir/analysis/template_params.rs
@@ -203,18 +203,21 @@ impl<'ctx> UsedTemplateParameters<'ctx> {
         }
     }
 
-    fn take_this_id_usage_set<Id: Into<ItemId>>(&mut self, this_id: Id) -> ItemSet {
+    fn take_this_id_usage_set<Id: Into<ItemId>>(
+        &mut self,
+        this_id: Id,
+    ) -> ItemSet {
         let this_id = this_id.into();
         self.used
             .get_mut(&this_id)
             .expect(
                 "Should have a set of used template params for every item \
-                     id",
+                 id",
             )
             .take()
             .expect(
                 "Should maintain the invariant that all used template param \
-                     sets are `Some` upon entry of `constrain`",
+                 sets are `Some` upon entry of `constrain`",
             )
     }
 
@@ -231,7 +234,7 @@ impl<'ctx> UsedTemplateParameters<'ctx> {
     ) {
         trace!(
             "    instantiation of blacklisted template, uses all template \
-                arguments"
+             arguments"
         );
 
         let args = instantiation
@@ -252,8 +255,8 @@ impl<'ctx> UsedTemplateParameters<'ctx> {
                     .as_ref()
                     .expect(
                         "Because a != this_id, and all used template \
-                             param sets other than this_id's are `Some`, \
-                             a's used template param set should be `Some`",
+                         param sets other than this_id's are `Some`, \
+                         a's used template param set should be `Some`",
                     )
                     .iter()
                     .cloned()
@@ -289,7 +292,7 @@ impl<'ctx> UsedTemplateParameters<'ctx> {
         for (arg, param) in args.iter().zip(params.iter()) {
             trace!(
                 "      instantiation's argument {:?} is used if definition's \
-                    parameter {:?} is used",
+                 parameter {:?} is used",
                 arg,
                 param
             );
@@ -297,7 +300,8 @@ impl<'ctx> UsedTemplateParameters<'ctx> {
             if used_by_def.contains(&param.into()) {
                 trace!("        param is used by template definition");
 
-                let arg = arg.into_resolver()
+                let arg = arg
+                    .into_resolver()
                     .through_type_refs()
                     .through_type_aliases()
                     .resolve(self.ctx)
@@ -307,15 +311,16 @@ impl<'ctx> UsedTemplateParameters<'ctx> {
                     continue;
                 }
 
-                let used_by_arg = self.used
+                let used_by_arg = self
+                    .used
                     .get(&arg)
                     .expect("Should have a used entry for the template arg")
                     .as_ref()
                     .expect(
                         "Because arg != this_id, and all used template \
-                             param sets other than this_id's are `Some`, \
-                             arg's used template param set should be \
-                             `Some`",
+                         param sets other than this_id's are `Some`, \
+                         arg's used template param set should be \
+                         `Some`",
                     )
                     .iter()
                     .cloned();
@@ -339,7 +344,8 @@ impl<'ctx> UsedTemplateParameters<'ctx> {
                     return;
                 }
 
-                let used_by_sub_id = self.used
+                let used_by_sub_id = self
+                    .used
                     .get(&sub_id)
                     .expect("Should have a used set for the sub_id successor")
                     .as_ref()
@@ -370,9 +376,7 @@ impl<'ctx> MonotoneFramework for UsedTemplateParameters<'ctx> {
     type Extra = &'ctx BindgenContext;
     type Output = HashMap<ItemId, ItemSet>;
 
-    fn new(
-        ctx: &'ctx BindgenContext,
-    ) -> UsedTemplateParameters<'ctx> {
+    fn new(ctx: &'ctx BindgenContext) -> UsedTemplateParameters<'ctx> {
         let mut used = HashMap::default();
         let mut dependencies = HashMap::default();
         let whitelisted_items: HashSet<_> =
@@ -383,7 +387,13 @@ impl<'ctx> MonotoneFramework for UsedTemplateParameters<'ctx> {
             .cloned()
             .flat_map(|i| {
                 let mut reachable = vec![i];
-                i.trace(ctx, &mut |s, _| { reachable.push(s); }, &());
+                i.trace(
+                    ctx,
+                    &mut |s, _| {
+                        reachable.push(s);
+                    },
+                    &(),
+                );
                 reachable
             })
             .collect();
@@ -399,9 +409,10 @@ impl<'ctx> MonotoneFramework for UsedTemplateParameters<'ctx> {
                     ctx,
                     &mut |sub_item: ItemId, _| {
                         used.entry(sub_item).or_insert(Some(ItemSet::new()));
-                        dependencies.entry(sub_item).or_insert(vec![]).push(
-                            item,
-                        );
+                        dependencies
+                            .entry(sub_item)
+                            .or_insert(vec![])
+                            .push(item);
                     },
                     &(),
                 );
@@ -418,11 +429,11 @@ impl<'ctx> MonotoneFramework for UsedTemplateParameters<'ctx> {
                     // Although template definitions should always have
                     // template parameters, there is a single exception:
                     // opaque templates. Hence the unwrap_or.
-                    let params =
-                        decl.self_template_params(ctx);
+                    let params = decl.self_template_params(ctx);
 
                     for (arg, param) in args.iter().zip(params.iter()) {
-                        let arg = arg.into_resolver()
+                        let arg = arg
+                            .into_resolver()
                             .through_type_aliases()
                             .through_type_refs()
                             .resolve(ctx)
@@ -487,7 +498,13 @@ impl<'ctx> MonotoneFramework for UsedTemplateParameters<'ctx> {
             .cloned()
             .flat_map(|i| {
                 let mut reachable = vec![i];
-                i.trace(self.ctx, &mut |s, _| { reachable.push(s); }, &());
+                i.trace(
+                    self.ctx,
+                    &mut |s, _| {
+                        reachable.push(s);
+                    },
+                    &(),
+                );
                 reachable
             })
             .collect()
@@ -520,9 +537,9 @@ impl<'ctx> MonotoneFramework for UsedTemplateParameters<'ctx> {
             // Template instantiations only use their template arguments if the
             // template definition uses the corresponding template parameter.
             Some(&TypeKind::TemplateInstantiation(ref inst)) => {
-                if self.whitelisted_items.contains(
-                    &inst.template_definition().into(),
-                )
+                if self
+                    .whitelisted_items
+                    .contains(&inst.template_definition().into())
                 {
                     self.constrain_instantiation(
                         id,
@@ -548,7 +565,7 @@ impl<'ctx> MonotoneFramework for UsedTemplateParameters<'ctx> {
         assert!(
             new_len >= original_len,
             "This is the property that ensures this function is monotone -- \
-                 if it doesn't hold, the analysis might never terminate!"
+             if it doesn't hold, the analysis might never terminate!"
         );
 
         // Put the set back in the hash map and restore our invariant.
@@ -576,8 +593,7 @@ impl<'ctx> MonotoneFramework for UsedTemplateParameters<'ctx> {
     }
 }
 
-impl<'ctx> From<UsedTemplateParameters<'ctx>>
-    for HashMap<ItemId, ItemSet> {
+impl<'ctx> From<UsedTemplateParameters<'ctx>> for HashMap<ItemId, ItemSet> {
     fn from(used_templ_params: UsedTemplateParameters<'ctx>) -> Self {
         used_templ_params
             .used
diff --git a/third_party/rust/bindgen/src/ir/annotations.rs b/third_party/rust/bindgen/src/ir/annotations.rs
index 654e16860226..403bffc100ed 100644
--- a/third_party/rust/bindgen/src/ir/annotations.rs
+++ b/third_party/rust/bindgen/src/ir/annotations.rs
@@ -94,7 +94,11 @@ impl Annotations {
         let mut matched_one = false;
         anno.parse(&cursor.comment(), &mut matched_one);
 
-        if matched_one { Some(anno) } else { None }
+        if matched_one {
+            Some(anno)
+        } else {
+            None
+        }
     }
 
     /// Should this type be hidden?
@@ -157,9 +161,10 @@ impl Annotations {
         use clang_sys::CXComment_HTMLStartTag;
         if comment.kind() == CXComment_HTMLStartTag &&
             comment.get_tag_name() == "div" &&
-            comment.get_tag_attrs().next().map_or(false, |attr| {
-                attr.name == "rustbindgen"
-            })
+            comment
+                .get_tag_attrs()
+                .next()
+                .map_or(false, |attr| attr.name == "rustbindgen")
         {
             *matched = true;
             for attr in comment.get_tag_attrs() {
@@ -168,14 +173,11 @@ impl Annotations {
                     "hide" => self.hide = true,
                     "nocopy" => self.disallow_copy = true,
                     "replaces" => {
-                        self.use_instead_of =
-                            Some(
-                                attr.value.split("::").map(Into::into).collect(),
-                            )
-                    }
-                    "derive" => {
-                        self.derives.push(attr.value)
+                        self.use_instead_of = Some(
+                            attr.value.split("::").map(Into::into).collect(),
+                        )
                     }
+                    "derive" => self.derives.push(attr.value),
                     "private" => {
                         self.private_fields = Some(attr.value != "false")
                     }
diff --git a/third_party/rust/bindgen/src/ir/comment.rs b/third_party/rust/bindgen/src/ir/comment.rs
index a189fe8a0ac7..4ebe19a2253c 100644
--- a/third_party/rust/bindgen/src/ir/comment.rs
+++ b/third_party/rust/bindgen/src/ir/comment.rs
@@ -67,7 +67,8 @@ fn preprocess_multi_line(comment: &str, indent: usize) -> String {
     let indent = make_indent(indent);
     // Strip any potential `*` characters preceding each line.
     let mut is_first = true;
-    let mut lines: Vec<_> = comment.lines()
+    let mut lines: Vec<_> = comment
+        .lines()
         .map(|line| line.trim().trim_start_matches('*').trim_start_matches('!'))
         .skip_while(|line| line.trim().is_empty()) // Skip the first empty lines.
         .map(|line| {
@@ -78,7 +79,10 @@ fn preprocess_multi_line(comment: &str, indent: usize) -> String {
         .collect();
 
     // Remove the trailing line corresponding to the `*/`.
-    if lines.last().map_or(false, |l| l.trim().is_empty() || l.trim() == "///") {
+    if lines
+        .last()
+        .map_or(false, |l| l.trim().is_empty() || l.trim() == "///")
+    {
         lines.pop();
     }
 
diff --git a/third_party/rust/bindgen/src/ir/comp.rs b/third_party/rust/bindgen/src/ir/comp.rs
index ba249644b029..a82fd756afec 100644
--- a/third_party/rust/bindgen/src/ir/comp.rs
+++ b/third_party/rust/bindgen/src/ir/comp.rs
@@ -52,13 +52,13 @@ pub enum MethodKind {
     },
 }
 
-
 impl MethodKind {
     /// Is this a destructor method?
     pub fn is_destructor(&self) -> bool {
         match *self {
-            MethodKind::Destructor |
-            MethodKind::VirtualDestructor { .. } => true,
+            MethodKind::Destructor | MethodKind::VirtualDestructor { .. } => {
+                true
+            }
             _ => false,
         }
     }
@@ -87,7 +87,11 @@ pub struct Method {
 
 impl Method {
     /// Construct a new `Method`.
-    pub fn new(kind: MethodKind, signature: FunctionId, is_const: bool) -> Self {
+    pub fn new(
+        kind: MethodKind,
+        signature: FunctionId,
+        is_const: bool,
+    ) -> Self {
         Method {
             kind,
             signature,
@@ -198,9 +202,7 @@ impl Field {
     /// Get this field's layout.
     pub fn layout(&self, ctx: &BindgenContext) -> Option<Layout> {
         match *self {
-            Field::Bitfields(BitfieldUnit {
-                                 layout, ..
-                             }) => Some(layout),
+            Field::Bitfields(BitfieldUnit { layout, .. }) => Some(layout),
             Field::DataMember(ref data) => {
                 ctx.resolve_type(data.ty).layout(ctx)
             }
@@ -219,9 +221,7 @@ impl Trace for Field {
             Field::DataMember(ref data) => {
                 tracer.visit_kind(data.ty.into(), EdgeKind::Field);
             }
-            Field::Bitfields(BitfieldUnit {
-                                 ref bitfields, ..
-                             }) => {
+            Field::Bitfields(BitfieldUnit { ref bitfields, .. }) => {
                 for bf in bitfields {
                     tracer.visit_kind(bf.ty().into(), EdgeKind::Field);
                 }
@@ -242,10 +242,10 @@ impl DotAttributes for Field {
         match *self {
             Field::DataMember(ref data) => data.dot_attributes(ctx, out),
             Field::Bitfields(BitfieldUnit {
-                                 layout,
-                                 ref bitfields,
-                                 ..
-                             }) => {
+                layout,
+                ref bitfields,
+                ..
+            }) => {
                 writeln!(
                     out,
                     r#"<tr>
@@ -259,8 +259,7 @@ impl DotAttributes for Field {
                                     <td>unit.align</td><td>{}</td>
                                   </tr>
                          "#,
-                    layout.size,
-                    layout.align
+                    layout.size, layout.align
                 )?;
                 for bf in bitfields {
                     bf.dot_attributes(ctx, out)?;
@@ -373,7 +372,10 @@ impl Bitfield {
     /// Panics if called before assigning bitfield accessor names or if
     /// this bitfield have no name.
     pub fn getter_name(&self) -> &str {
-        assert!(self.name().is_some(), "`Bitfield::getter_name` called on anonymous field");
+        assert!(
+            self.name().is_some(),
+            "`Bitfield::getter_name` called on anonymous field"
+        );
         self.getter_name.as_ref().expect(
             "`Bitfield::getter_name` should only be called after\
              assigning bitfield accessor names",
@@ -385,7 +387,10 @@ impl Bitfield {
     /// Panics if called before assigning bitfield accessor names or if
     /// this bitfield have no name.
     pub fn setter_name(&self) -> &str {
-        assert!(self.name().is_some(), "`Bitfield::setter_name` called on anonymous field");
+        assert!(
+            self.name().is_some(),
+            "`Bitfield::setter_name` called on anonymous field"
+        );
         self.setter_name.as_ref().expect(
             "`Bitfield::setter_name` should only be called\
              after assigning bitfield accessor names",
@@ -423,7 +428,6 @@ impl FieldMethods for Bitfield {
     }
 }
 
-
 /// A raw field might be either of a plain data member or a bitfield within a
 /// bitfield allocation unit, but we haven't processed it and determined which
 /// yet (which would involve allocating it into a bitfield unit if it is a
@@ -597,9 +601,8 @@ where
 
     for bitfield in raw_bitfields {
         let bitfield_width = bitfield.bitfield_width().unwrap() as usize;
-        let bitfield_layout = ctx.resolve_type(bitfield.ty())
-            .layout(ctx)
-            .ok_or(())?;
+        let bitfield_layout =
+            ctx.resolve_type(bitfield.ty()).layout(ctx).ok_or(())?;
         let bitfield_size = bitfield_layout.size;
         let bitfield_align = bitfield_layout.align;
 
@@ -628,8 +631,8 @@ where
         } else {
             if offset != 0 &&
                 (bitfield_width == 0 ||
-                     (offset & (bitfield_align * 8 - 1)) + bitfield_width >
-                         bitfield_size * 8)
+                    (offset & (bitfield_align * 8 - 1)) + bitfield_width >
+                        bitfield_size * 8)
             {
                 offset = align_to(offset, bitfield_align * 8);
             }
@@ -724,20 +727,17 @@ impl CompFields {
             }
         };
 
-        let result =
-            raw_fields_to_fields_and_bitfield_units(ctx, raws);
+        let result = raw_fields_to_fields_and_bitfield_units(ctx, raws);
 
         match result {
             Ok(fields_and_units) => {
                 mem::replace(
                     self,
-                    CompFields::AfterComputingBitfieldUnits(fields_and_units));
+                    CompFields::AfterComputingBitfieldUnits(fields_and_units),
+                );
             }
             Err(()) => {
-                mem::replace(
-                    self,
-                    CompFields::ErrorComputingBitfieldUnits
-                );
+                mem::replace(self, CompFields::ErrorComputingBitfieldUnits);
             }
         }
     }
@@ -754,7 +754,11 @@ impl CompFields {
             }
         };
 
-        fn has_method(methods: &[Method], ctx: &BindgenContext, name: &str) -> bool {
+        fn has_method(
+            methods: &[Method],
+            ctx: &BindgenContext,
+            name: &str,
+        ) -> bool {
             methods.iter().any(|method| {
                 let method_name = ctx.resolve_func(method.signature()).name();
                 method_name == name || ctx.rust_mangle(&method_name) == name
@@ -776,7 +780,8 @@ impl CompFields {
             .map(|bitfield_name| {
                 let bitfield_name = bitfield_name.to_string();
                 let getter = {
-                    let mut getter = ctx.rust_mangle(&bitfield_name).to_string();
+                    let mut getter =
+                        ctx.rust_mangle(&bitfield_name).to_string();
                     if has_method(methods, ctx, &getter) {
                         getter.push_str("_bindgen_bitfield");
                     }
@@ -803,21 +808,24 @@ impl CompFields {
                     }
 
                     anon_field_counter += 1;
-                    let generated_name = format!("__bindgen_anon_{}", anon_field_counter);
+                    let generated_name =
+                        format!("__bindgen_anon_{}", anon_field_counter);
                     *name = Some(generated_name);
                 }
-                Field::Bitfields(ref mut bu) => for bitfield in &mut bu.bitfields {
-                    if bitfield.name().is_none() {
-                        continue;
-                    }
+                Field::Bitfields(ref mut bu) => {
+                    for bitfield in &mut bu.bitfields {
+                        if bitfield.name().is_none() {
+                            continue;
+                        }
 
-                    if let Some(AccessorNamesPair { getter, setter }) =
-                        accessor_names.remove(bitfield.name().unwrap())
-                    {
-                        bitfield.getter_name = Some(getter);
-                        bitfield.setter_name = Some(setter);
+                        if let Some(AccessorNamesPair { getter, setter }) =
+                            accessor_names.remove(bitfield.name().unwrap())
+                        {
+                            bitfield.getter_name = Some(getter);
+                            bitfield.setter_name = Some(setter);
+                        }
                     }
-                },
+                }
             }
         }
     }
@@ -1072,8 +1080,20 @@ impl CompInfo {
             return None;
         }
 
+        // By definition, we don't have the right layout information here if
+        // we're a forward declaration.
+        if self.is_forward_declaration() {
+            return None;
+        }
+
+        // empty union case
+        if self.fields().is_empty() {
+            return None;
+        }
+
         let mut max_size = 0;
-        let mut max_align = 0;
+        // Don't allow align(0)
+        let mut max_align = 1;
         for field in self.fields() {
             let field_layout = field.layout(ctx);
 
@@ -1173,8 +1193,7 @@ impl CompInfo {
         let mut ci = CompInfo::new(kind);
         ci.is_forward_declaration =
             location.map_or(true, |cur| match cur.kind() {
-                CXCursor_StructDecl |
-                CXCursor_UnionDecl |
+                CXCursor_StructDecl | CXCursor_UnionDecl |
                 CXCursor_ClassDecl => !cur.is_definition(),
                 _ => false,
             });
@@ -1183,16 +1202,20 @@ impl CompInfo {
         cursor.visit(|cur| {
             if cur.kind() != CXCursor_FieldDecl {
                 if let Some((ty, clang_ty, offset)) =
-                    maybe_anonymous_struct_field.take() {
+                    maybe_anonymous_struct_field.take()
+                {
                     if cur.kind() == CXCursor_TypedefDecl &&
-                       cur.typedef_type().unwrap().canonical_type() == clang_ty {
+                        cur.typedef_type().unwrap().canonical_type() ==
+                            clang_ty
+                    {
                         // Typedefs of anonymous structs appear later in the ast
                         // than the struct itself, that would otherwise be an
                         // anonymous field. Detect that case here, and do
                         // nothing.
                     } else {
-                        let field =
-                            RawField::new(None, ty, None, None, None, false, offset);
+                        let field = RawField::new(
+                            None, ty, None, None, None, false, offset,
+                        );
                         ci.fields.append_raw_field(field);
                     }
                 }
@@ -1201,7 +1224,8 @@ impl CompInfo {
             match cur.kind() {
                 CXCursor_FieldDecl => {
                     if let Some((ty, clang_ty, offset)) =
-                        maybe_anonymous_struct_field.take() {
+                        maybe_anonymous_struct_field.take()
+                    {
                         let mut used = false;
                         cur.visit(|child| {
                             if child.cur_type() == clang_ty {
@@ -1210,22 +1234,20 @@ impl CompInfo {
                             CXChildVisit_Continue
                         });
                         if !used {
-                            let field = RawField::new(None,
-                                                   ty,
-                                                   None,
-                                                   None,
-                                                   None,
-                                                   false,
-                                                   offset);
+                            let field = RawField::new(
+                                None, ty, None, None, None, false, offset,
+                            );
                             ci.fields.append_raw_field(field);
                         }
                     }
 
                     let bit_width = cur.bit_width();
-                    let field_type = Item::from_ty_or_ref(cur.cur_type(),
-                                                          cur,
-                                                          Some(potential_id),
-                                                          ctx);
+                    let field_type = Item::from_ty_or_ref(
+                        cur.cur_type(),
+                        cur,
+                        Some(potential_id),
+                        ctx,
+                    );
 
                     let comment = cur.raw_comment();
                     let annotations = Annotations::new(&cur);
@@ -1235,18 +1257,22 @@ impl CompInfo {
 
                     // Name can be empty if there are bitfields, for example,
                     // see tests/headers/struct_with_bitfields.h
-                    assert!(!name.is_empty() || bit_width.is_some(),
-                            "Empty field name?");
+                    assert!(
+                        !name.is_empty() || bit_width.is_some(),
+                        "Empty field name?"
+                    );
 
                     let name = if name.is_empty() { None } else { Some(name) };
 
-                    let field = RawField::new(name,
-                                              field_type,
-                                              comment,
-                                              annotations,
-                                              bit_width,
-                                              is_mutable,
-                                              offset);
+                    let field = RawField::new(
+                        name,
+                        field_type,
+                        comment,
+                        annotations,
+                        bit_width,
+                        is_mutable,
+                        offset,
+                    );
                     ci.fields.append_raw_field(field);
 
                     // No we look for things like attributes and stuff.
@@ -1256,7 +1282,6 @@ impl CompInfo {
                         }
                         CXChildVisit_Continue
                     });
-
                 }
                 CXCursor_UnexposedAttr => {
                     ci.found_unknown_attr = true;
@@ -1280,9 +1305,9 @@ impl CompInfo {
                     // Let's just assume that if the cursor we've found is a
                     // definition, it's a valid inner type.
                     //
-                    // [1]: https://github.com/rust-lang-nursery/rust-bindgen/issues/482
-                    let is_inner_struct = cur.semantic_parent() == cursor ||
-                                          cur.is_definition();
+                    // [1]: https://github.com/rust-lang/rust-bindgen/issues/482
+                    let is_inner_struct =
+                        cur.semantic_parent() == cursor || cur.is_definition();
                     if !is_inner_struct {
                         return CXChildVisit_Continue;
                     }
@@ -1299,19 +1324,22 @@ impl CompInfo {
                     // A declaration of an union or a struct without name could
                     // also be an unnamed field, unfortunately.
                     if cur.spelling().is_empty() &&
-                       cur.kind() != CXCursor_EnumDecl {
+                        cur.kind() != CXCursor_EnumDecl
+                    {
                         let ty = cur.cur_type();
                         let offset = cur.offset_of_field().ok();
-                        maybe_anonymous_struct_field = Some((inner, ty, offset));
+                        maybe_anonymous_struct_field =
+                            Some((inner, ty, offset));
                     }
                 }
                 CXCursor_PackedAttr => {
                     ci.packed_attr = true;
                 }
                 CXCursor_TemplateTypeParameter => {
-                    let param = Item::type_param(None, cur, ctx)
-                        .expect("Item::type_param should't fail when pointing \
-                                 at a TemplateTypeParameter");
+                    let param = Item::type_param(None, cur, ctx).expect(
+                        "Item::type_param should't fail when pointing \
+                         at a TemplateTypeParameter",
+                    );
                     ci.template_params.push(param);
                 }
                 CXCursor_CXXBaseSpecifier => {
@@ -1336,8 +1364,7 @@ impl CompInfo {
                         field_name: field_name,
                     });
                 }
-                CXCursor_Constructor |
-                CXCursor_Destructor |
+                CXCursor_Constructor | CXCursor_Destructor |
                 CXCursor_CXXMethod => {
                     let is_virtual = cur.method_is_virtual();
                     let is_static = cur.method_is_static();
@@ -1364,9 +1391,14 @@ impl CompInfo {
                     // `FunctionSig`.
                     let signature =
                         match Item::parse(cur, Some(potential_id), ctx) {
-                            Ok(item) if ctx.resolve_item(item)
-                                .kind()
-                                .is_function() => item,
+                            Ok(item)
+                                if ctx
+                                    .resolve_item(item)
+                                    .kind()
+                                    .is_function() =>
+                            {
+                                item
+                            }
                             _ => return CXChildVisit_Continue,
                         };
 
@@ -1412,7 +1444,8 @@ impl CompInfo {
                 CXCursor_VarDecl => {
                     let linkage = cur.linkage();
                     if linkage != CXLinkage_External &&
-                       linkage != CXLinkage_UniqueExternal {
+                        linkage != CXLinkage_UniqueExternal
+                    {
                         return CXChildVisit_Continue;
                     }
 
@@ -1421,9 +1454,8 @@ impl CompInfo {
                         return CXChildVisit_Continue;
                     }
 
-                    if let Ok(item) = Item::parse(cur,
-                                                  Some(potential_id),
-                                                  ctx) {
+                    if let Ok(item) = Item::parse(cur, Some(potential_id), ctx)
+                    {
                         ci.inner_vars.push(item.as_var_id_unchecked());
                     }
                 }
@@ -1433,11 +1465,13 @@ impl CompInfo {
                 CXCursor_FunctionTemplate |
                 CXCursor_ConversionFunction => {}
                 _ => {
-                    warn!("unhandled comp member `{}` (kind {:?}) in `{}` ({})",
-                          cur.spelling(),
-                          clang::kind_to_str(cur.kind()),
-                          cursor.spelling(),
-                          cur.location());
+                    warn!(
+                        "unhandled comp member `{}` (kind {:?}) in `{}` ({})",
+                        cur.spelling(),
+                        clang::kind_to_str(cur.kind()),
+                        cursor.spelling(),
+                        cur.location()
+                    );
                 }
             }
             CXChildVisit_Continue
@@ -1458,16 +1492,13 @@ impl CompInfo {
         use clang_sys::*;
         Ok(match cursor.kind() {
             CXCursor_UnionDecl => CompKind::Union,
-            CXCursor_ClassDecl |
-            CXCursor_StructDecl => CompKind::Struct,
+            CXCursor_ClassDecl | CXCursor_StructDecl => CompKind::Struct,
             CXCursor_CXXBaseSpecifier |
             CXCursor_ClassTemplatePartialSpecialization |
-            CXCursor_ClassTemplate => {
-                match cursor.template_kind() {
-                    CXCursor_UnionDecl => CompKind::Union,
-                    _ => CompKind::Struct,
-                }
-            }
+            CXCursor_ClassTemplate => match cursor.template_kind() {
+                CXCursor_UnionDecl => CompKind::Union,
+                _ => CompKind::Struct,
+            },
             _ => {
                 warn!("Unknown kind for comp type: {:?}", cursor);
                 return Err(ParseError::Continue);
@@ -1493,9 +1524,13 @@ impl CompInfo {
     }
 
     /// Is this compound type packed?
-    pub fn is_packed(&self, ctx: &BindgenContext, layout: &Option<Layout>) -> bool {
+    pub fn is_packed(
+        &self,
+        ctx: &BindgenContext,
+        layout: &Option<Layout>,
+    ) -> bool {
         if self.packed_attr {
-            return true
+            return true;
         }
 
         // Even though `libclang` doesn't expose `#pragma packed(...)`, we can
@@ -1620,7 +1655,7 @@ impl IsOpaque for CompInfo {
 
     fn is_opaque(&self, ctx: &BindgenContext, layout: &Option<Layout>) -> bool {
         if self.has_non_type_template_params {
-            return true
+            return true;
         }
 
         // When we do not have the layout for a bitfield's type (for example, it
@@ -1635,17 +1670,14 @@ impl IsOpaque for CompInfo {
         // some strange things going on, and the best we can do is make the
         // whole struct opaque.
         if self.fields().iter().any(|f| match *f {
-            Field::DataMember(_) => {
-                false
-            },
-            Field::Bitfields(ref unit) => {
-                unit.bitfields().iter().any(|bf| {
-                    let bitfield_layout = ctx.resolve_type(bf.ty())
-                        .layout(ctx)
-                        .expect("Bitfield without layout? Gah!");
-                    bf.width() / 8 > bitfield_layout.size as u32
-                })
-            }
+            Field::DataMember(_) => false,
+            Field::Bitfields(ref unit) => unit.bitfields().iter().any(|bf| {
+                let bitfield_layout = ctx
+                    .resolve_type(bf.ty())
+                    .layout(ctx)
+                    .expect("Bitfield without layout? Gah!");
+                bf.width() / 8 > bitfield_layout.size as u32
+            }),
         }) {
             return true;
         }
@@ -1654,9 +1686,11 @@ impl IsOpaque for CompInfo {
             // If we don't have `#[repr(packed(N)]`, the best we can
             // do is make this struct opaque.
             //
-            // See https://github.com/rust-lang-nursery/rust-bindgen/issues/537 and
+            // See https://github.com/rust-lang/rust-bindgen/issues/537 and
             // https://github.com/rust-lang/rust/issues/33158
-            if self.is_packed(ctx, layout) && layout.map_or(false, |l| l.align > 1) {
+            if self.is_packed(ctx, layout) &&
+                layout.map_or(false, |l| l.align > 1)
+            {
                 warn!("Found a type that is both packed and aligned to greater than \
                        1; Rust before version 1.33 doesn't have `#[repr(packed(N))]`, so we \
                        are treating it as opaque. You may wish to set bindgen's rust target \
@@ -1670,10 +1704,7 @@ impl IsOpaque for CompInfo {
 }
 
 impl TemplateParameters for CompInfo {
-    fn self_template_params(
-        &self,
-        _ctx: &BindgenContext,
-    ) -> Vec<TypeId> {
+    fn self_template_params(&self, _ctx: &BindgenContext) -> Vec<TypeId> {
         self.template_params.clone()
     }
 }
diff --git a/third_party/rust/bindgen/src/ir/context.rs b/third_party/rust/bindgen/src/ir/context.rs
index f2b6956a1207..0fefe399a4b4 100644
--- a/third_party/rust/bindgen/src/ir/context.rs
+++ b/third_party/rust/bindgen/src/ir/context.rs
@@ -1,13 +1,17 @@
 //! Common context that is passed around during parsing and codegen.
 
-use super::analysis::{CannotDerive, DeriveTrait, as_cannot_derive_set,
-                      HasTypeParameterInArray, HasVtableAnalysis,
-                      HasVtableResult, HasDestructorAnalysis,
-                      UsedTemplateParameters, HasFloat, SizednessAnalysis,
-                      SizednessResult, analyze};
-use super::derive::{CanDeriveCopy, CanDeriveDebug, CanDeriveDefault,
-                    CanDeriveHash, CanDerivePartialOrd, CanDeriveOrd,
-                    CanDerivePartialEq, CanDeriveEq, CanDerive};
+use super::super::time::Timer;
+use super::analysis::{
+    analyze, as_cannot_derive_set, CannotDerive, DeriveTrait,
+    HasDestructorAnalysis, HasFloat, HasTypeParameterInArray,
+    HasVtableAnalysis, HasVtableResult, SizednessAnalysis, SizednessResult,
+    UsedTemplateParameters,
+};
+use super::derive::{
+    CanDerive, CanDeriveCopy, CanDeriveDebug, CanDeriveDefault, CanDeriveEq,
+    CanDeriveHash, CanDeriveOrd, CanDerivePartialEq, CanDerivePartialOrd,
+};
+use super::function::Function;
 use super::int::IntKind;
 use super::item::{IsOpaque, Item, ItemAncestors, ItemSet};
 use super::item_kind::ItemKind;
@@ -15,9 +19,6 @@ use super::module::{Module, ModuleKind};
 use super::template::{TemplateInstantiation, TemplateParameters};
 use super::traversal::{self, Edge, ItemTraversal};
 use super::ty::{FloatKind, Type, TypeKind};
-use super::function::Function;
-use super::super::time::Timer;
-use BindgenOptions;
 use callbacks::ParseCallbacks;
 use cexpr;
 use clang::{self, Cursor};
@@ -26,10 +27,11 @@ use parse::ClangItemParser;
 use proc_macro2::{Ident, Span};
 use std::borrow::Cow;
 use std::cell::Cell;
+use std::collections::HashMap as StdHashMap;
 use std::iter::IntoIterator;
 use std::mem;
-use std::collections::HashMap as StdHashMap;
-use {HashMap, HashSet, Entry};
+use BindgenOptions;
+use {Entry, HashMap, HashSet};
 
 /// An identifier for some kind of IR item.
 #[derive(Debug, Copy, Clone, Eq, PartialOrd, Ord, Hash)]
@@ -199,7 +201,7 @@ impl ItemId {
 
 impl<T> ::std::cmp::PartialEq<T> for ItemId
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     fn eq(&self, rhs: &T) -> bool {
         let rhs: ItemId = (*rhs).into();
@@ -209,7 +211,7 @@ where
 
 impl<T> CanDeriveDebug for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     fn can_derive_debug(&self, ctx: &BindgenContext) -> bool {
         ctx.options().derive_debug && ctx.lookup_can_derive_debug(*self)
@@ -218,7 +220,7 @@ where
 
 impl<T> CanDeriveDefault for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     fn can_derive_default(&self, ctx: &BindgenContext) -> bool {
         ctx.options().derive_default && ctx.lookup_can_derive_default(*self)
@@ -227,7 +229,7 @@ where
 
 impl<T> CanDeriveCopy for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     fn can_derive_copy(&self, ctx: &BindgenContext) -> bool {
         ctx.options().derive_copy && ctx.lookup_can_derive_copy(*self)
@@ -236,7 +238,7 @@ where
 
 impl<T> CanDeriveHash for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     fn can_derive_hash(&self, ctx: &BindgenContext) -> bool {
         ctx.options().derive_hash && ctx.lookup_can_derive_hash(*self)
@@ -245,42 +247,46 @@ where
 
 impl<T> CanDerivePartialOrd for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     fn can_derive_partialord(&self, ctx: &BindgenContext) -> bool {
         ctx.options().derive_partialord &&
-            ctx.lookup_can_derive_partialeq_or_partialord(*self) == CanDerive::Yes
+            ctx.lookup_can_derive_partialeq_or_partialord(*self) ==
+                CanDerive::Yes
     }
 }
 
 impl<T> CanDerivePartialEq for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     fn can_derive_partialeq(&self, ctx: &BindgenContext) -> bool {
         ctx.options().derive_partialeq &&
-            ctx.lookup_can_derive_partialeq_or_partialord(*self) == CanDerive::Yes
+            ctx.lookup_can_derive_partialeq_or_partialord(*self) ==
+                CanDerive::Yes
     }
 }
 
 impl<T> CanDeriveEq for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     fn can_derive_eq(&self, ctx: &BindgenContext) -> bool {
         ctx.options().derive_eq &&
-            ctx.lookup_can_derive_partialeq_or_partialord(*self) == CanDerive::Yes &&
+            ctx.lookup_can_derive_partialeq_or_partialord(*self) ==
+                CanDerive::Yes &&
             !ctx.lookup_has_float(*self)
     }
 }
 
 impl<T> CanDeriveOrd for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     fn can_derive_ord(&self, ctx: &BindgenContext) -> bool {
         ctx.options().derive_ord &&
-            ctx.lookup_can_derive_partialeq_or_partialord(*self) == CanDerive::Yes &&
+            ctx.lookup_can_derive_partialeq_or_partialord(*self) ==
+                CanDerive::Yes &&
             !ctx.lookup_has_float(*self)
     }
 }
@@ -476,7 +482,7 @@ impl<'ctx> Iterator for WhitelistedItemsTraversal<'ctx> {
             let id = self.traversal.next()?;
 
             if self.ctx.resolve_item(id).is_blacklisted(self.ctx) {
-                continue
+                continue;
             }
 
             return Some(id);
@@ -526,7 +532,7 @@ fn find_effective_target(clang_args: &[String]) -> (String, bool) {
 
     // If we're running from a build script, try to find the cargo target.
     if let Ok(t) = env::var("TARGET") {
-        return (t, false)
+        return (t, false);
     }
 
     (HOST_TARGET.to_owned(), false)
@@ -577,8 +583,11 @@ If you encounter an error missing from this list, please file an issue or a PR!"
             if let Some(ref ti) = target_info {
                 if effective_target == HOST_TARGET {
                     assert_eq!(
-                        ti.pointer_width / 8, mem::size_of::<*mut ()>(),
-                        "{:?} {:?}", effective_target, HOST_TARGET
+                        ti.pointer_width / 8,
+                        mem::size_of::<*mut ()>(),
+                        "{:?} {:?}",
+                        effective_target,
+                        HOST_TARGET
                     );
                 }
             }
@@ -661,7 +670,7 @@ If you encounter an error missing from this list, please file an issue or a PR!"
     }
 
     /// Get the user-provided callbacks by reference, if any.
-    pub fn parse_callbacks(&self) -> Option<&ParseCallbacks> {
+    pub fn parse_callbacks(&self) -> Option<&dyn ParseCallbacks> {
         self.options().parse_callbacks.as_ref().map(|t| &**t)
     }
 
@@ -677,12 +686,11 @@ If you encounter an error missing from this list, please file an issue or a PR!"
     ) {
         debug!(
             "BindgenContext::add_item({:?}, declaration: {:?}, loc: {:?}",
-            item,
-            declaration,
-            location
+            item, declaration, location
         );
         debug_assert!(
-            declaration.is_some() || !item.kind().is_type() ||
+            declaration.is_some() ||
+                !item.kind().is_type() ||
                 item.kind().expect_type().is_builtin_or_type_param() ||
                 item.kind().expect_type().is_opaque(self, &item) ||
                 item.kind().expect_type().is_unresolved_ref(),
@@ -692,8 +700,8 @@ If you encounter an error missing from this list, please file an issue or a PR!"
         let id = item.id();
         let is_type = item.kind().is_type();
         let is_unnamed = is_type && item.expect_type().name().is_none();
-        let is_template_instantiation = is_type &&
-            item.expect_type().is_template_instantiation();
+        let is_template_instantiation =
+            is_type && item.expect_type().is_template_instantiation();
 
         if item.id() != self.root_module {
             self.add_item_to_module(&item);
@@ -731,7 +739,10 @@ If you encounter an error missing from this list, please file an issue or a PR!"
                 debug!(
                     "Invalid declaration {:?} found for type {:?}",
                     declaration,
-                    self.resolve_item_fallible(id).unwrap().kind().expect_type()
+                    self.resolve_item_fallible(id)
+                        .unwrap()
+                        .kind()
+                        .expect_type()
                 );
                 return;
             }
@@ -743,8 +754,7 @@ If you encounter an error missing from this list, please file an issue or a PR!"
             } else {
                 warn!(
                     "Valid declaration with no USR: {:?}, {:?}",
-                    declaration,
-                    location
+                    declaration, location
                 );
                 TypeKey::Declaration(declaration)
             };
@@ -794,8 +804,7 @@ If you encounter an error missing from this list, please file an issue or a PR!"
     pub fn add_type_param(&mut self, item: Item, definition: clang::Cursor) {
         debug!(
             "BindgenContext::add_type_param: item = {:?}; definition = {:?}",
-            item,
-            definition
+            item, definition
         );
 
         assert!(
@@ -816,7 +825,9 @@ If you encounter an error missing from this list, please file an issue or a PR!"
             "should not have already associated an item with the given id"
         );
 
-        let old_named_ty = self.type_params.insert(definition, id.as_type_id_unchecked());
+        let old_named_ty = self
+            .type_params
+            .insert(definition, id.as_type_id_unchecked());
         assert!(
             old_named_ty.is_none(),
             "should not have already associated a named type with this id"
@@ -841,61 +852,16 @@ If you encounter an error missing from this list, please file an issue or a PR!"
             name.contains("?") ||
             name.contains("$") ||
             match name {
-                "abstract" |
-                "alignof" |
-                "as" |
-                "async" |
-                "become" |
-                "box" |
-                "break" |
-                "const" |
-                "continue" |
-                "crate" |
-                "do" |
-                "else" |
-                "enum" |
-                "extern" |
-                "false" |
-                "final" |
-                "fn" |
-                "for" |
-                "if" |
-                "impl" |
-                "in" |
-                "let" |
-                "loop" |
-                "macro" |
-                "match" |
-                "mod" |
-                "move" |
-                "mut" |
-                "offsetof" |
-                "override" |
-                "priv" |
-                "proc" |
-                "pub" |
-                "pure" |
-                "ref" |
-                "return" |
-                "Self" |
-                "self" |
-                "sizeof" |
-                "static" |
-                "struct" |
-                "super" |
-                "trait" |
-                "true" |
-                "type" |
-                "typeof" |
-                "unsafe" |
-                "unsized" |
-                "use" |
-                "virtual" |
-                "where" |
-                "while" |
-                "yield" |
-                "bool" |
-                "_" => true,
+                "abstract" | "alignof" | "as" | "async" | "become" |
+                "box" | "break" | "const" | "continue" | "crate" | "do" |
+                "else" | "enum" | "extern" | "false" | "final" | "fn" |
+                "for" | "if" | "impl" | "in" | "let" | "loop" | "macro" |
+                "match" | "mod" | "move" | "mut" | "offsetof" |
+                "override" | "priv" | "proc" | "pub" | "pure" | "ref" |
+                "return" | "Self" | "self" | "sizeof" | "static" |
+                "struct" | "super" | "trait" | "true" | "type" | "typeof" |
+                "unsafe" | "unsized" | "use" | "virtual" | "where" |
+                "while" | "yield" | "bool" | "_" => true,
                 _ => false,
             }
         {
@@ -912,7 +878,7 @@ If you encounter an error missing from this list, please file an issue or a PR!"
     /// Returns a mangled name as a rust identifier.
     pub fn rust_ident<S>(&self, name: S) -> Ident
     where
-        S: AsRef<str>
+        S: AsRef<str>,
     {
         self.rust_ident_raw(self.rust_mangle(name.as_ref()))
     }
@@ -920,20 +886,17 @@ If you encounter an error missing from this list, please file an issue or a PR!"
     /// Returns a mangled name as a rust identifier.
     pub fn rust_ident_raw<T>(&self, name: T) -> Ident
     where
-        T: AsRef<str>
+        T: AsRef<str>,
     {
         Ident::new(name.as_ref(), Span::call_site())
     }
 
     /// Iterate over all items that have been defined.
     pub fn items(&self) -> impl Iterator<Item = (ItemId, &Item)> {
-        self.items
-            .iter()
-            .enumerate()
-            .filter_map(|(index, item)| {
-                let item = item.as_ref()?;
-                Some((ItemId(index), item))
-            })
+        self.items.iter().enumerate().filter_map(|(index, item)| {
+            let item = item.as_ref()?;
+            Some((ItemId(index), item))
+        })
     }
 
     /// Have we collected all unresolved type references yet?
@@ -971,19 +934,20 @@ If you encounter an error missing from this list, please file an issue or a PR!"
         let typerefs = self.collect_typerefs();
 
         for (id, ty, loc, parent_id) in typerefs {
-            let _resolved = {
-                let resolved = Item::from_ty(&ty, loc, parent_id, self)
+            let _resolved =
+                {
+                    let resolved = Item::from_ty(&ty, loc, parent_id, self)
                     .unwrap_or_else(|_| {
                         warn!("Could not resolve type reference, falling back \
                                to opaque blob");
                         Item::new_opaque_type(self.next_item_id(), &ty, self)
                     });
 
-                let item = self.items[id.0].as_mut().unwrap();
-                *item.kind_mut().as_type_mut().unwrap().kind_mut() =
-                    TypeKind::ResolvedTypeRef(resolved);
-                resolved
-            };
+                    let item = self.items[id.0].as_mut().unwrap();
+                    *item.kind_mut().as_type_mut().unwrap().kind_mut() =
+                        TypeKind::ResolvedTypeRef(resolved);
+                    resolved
+                };
 
             // Something in the STL is trolling me. I don't need this assertion
             // right now, but worth investigating properly once this lands.
@@ -1008,7 +972,7 @@ If you encounter an error missing from this list, please file an issue or a PR!"
     /// closure is made.
     fn with_loaned_item<F, T>(&mut self, id: ItemId, f: F) -> T
     where
-        F: (FnOnce(&BindgenContext, &mut Item) -> T)
+        F: (FnOnce(&BindgenContext, &mut Item) -> T),
     {
         let mut item = self.items[id.0].take().unwrap();
 
@@ -1043,7 +1007,8 @@ If you encounter an error missing from this list, please file an issue or a PR!"
     fn deanonymize_fields(&mut self) {
         let _t = self.timer("deanonymize_fields");
 
-        let comp_item_ids: Vec<ItemId> = self.items()
+        let comp_item_ids: Vec<ItemId> = self
+            .items()
             .filter_map(|(id, item)| {
                 if item.kind().as_type()?.is_comp() {
                     return Some(id);
@@ -1108,7 +1073,10 @@ If you encounter an error missing from this list, please file an issue or a PR!"
                     // We set this just after parsing the annotation. It's
                     // very unlikely, but this can happen.
                     if self.resolve_item_fallible(*replacement).is_some() {
-                        replacements.push((id.expect_type_id(self), replacement.expect_type_id(self)));
+                        replacements.push((
+                            id.expect_type_id(self),
+                            replacement.expect_type_id(self),
+                        ));
                     }
                 }
             }
@@ -1157,15 +1125,14 @@ If you encounter an error missing from this list, please file an issue or a PR!"
                         })
                     })
             };
-            let old_module = old_module.expect(
-                "Every replacement item should be in a module",
-            );
+            let old_module = old_module
+                .expect("Every replacement item should be in a module");
 
             let new_module = {
                 let immut_self = &*self;
-                new_parent.ancestors(immut_self).find(|id| {
-                    immut_self.resolve_item(*id).is_module()
-                })
+                new_parent
+                    .ancestors(immut_self)
+                    .find(|id| immut_self.resolve_item(*id).is_module())
             };
             let new_module = new_module.unwrap_or(self.root_module.into());
 
@@ -1274,26 +1241,25 @@ If you encounter an error missing from this list, please file an issue or a PR!"
 
                 assert!(
                     {
-                        let id = id.into_resolver()
+                        let id = id
+                            .into_resolver()
                             .through_type_refs()
                             .through_type_aliases()
                             .resolve(self)
                             .id();
-                        id.ancestors(self).chain(Some(self.root_module.into())).any(
-                            |ancestor| {
+                        id.ancestors(self)
+                            .chain(Some(self.root_module.into()))
+                            .any(|ancestor| {
                                 debug!(
                                     "Checking if {:?} is a child of {:?}",
-                                    id,
-                                    ancestor
+                                    id, ancestor
                                 );
-                                self.resolve_item(ancestor).as_module().map_or(
-                                    false,
-                                    |m| {
+                                self.resolve_item(ancestor)
+                                    .as_module()
+                                    .map_or(false, |m| {
                                         m.children().contains(&id)
-                                    },
-                                )
-                            },
-                        )
+                                    })
+                            })
                     },
                     "{:?} should be in some ancestor module's children set",
                     id
@@ -1377,7 +1343,10 @@ If you encounter an error missing from this list, please file an issue or a PR!"
             let mut used_params = HashMap::default();
             for &id in self.whitelisted_items() {
                 used_params.entry(id).or_insert(
-                    id.self_template_params(self).into_iter().map(|p| p.into()).collect()
+                    id.self_template_params(self)
+                        .into_iter()
+                        .map(|p| p.into())
+                        .collect(),
                 );
             }
             self.used_template_parameters = Some(used_params);
@@ -1493,12 +1462,16 @@ If you encounter an error missing from this list, please file an issue or a PR!"
     ///
     /// Panics if the id resolves to an item that is not a type.
     pub fn safe_resolve_type(&self, type_id: TypeId) -> Option<&Type> {
-        self.resolve_item_fallible(type_id).map(|t| t.kind().expect_type())
+        self.resolve_item_fallible(type_id)
+            .map(|t| t.kind().expect_type())
     }
 
     /// Resolve the given `ItemId` into an `Item`, or `None` if no such item
     /// exists.
-    pub fn resolve_item_fallible<Id: Into<ItemId>>(&self, id: Id) -> Option<&Item> {
+    pub fn resolve_item_fallible<Id: Into<ItemId>>(
+        &self,
+        id: Id,
+    ) -> Option<&Item> {
         self.items.get(id.into().0)?.as_ref()
     }
 
@@ -1537,12 +1510,11 @@ If you encounter an error missing from this list, please file an issue or a PR!"
     /// Returns a known semantic parent for a given definition.
     pub fn known_semantic_parent(
         &self,
-        definition: clang::Cursor
+        definition: clang::Cursor,
     ) -> Option<ItemId> {
         self.semantic_parents.get(&definition).cloned()
     }
 
-
     /// Given a cursor pointing to the location of a template instantiation,
     /// return a tuple of the form `(declaration_cursor, declaration_id,
     /// num_expected_template_args)`.
@@ -1560,7 +1532,8 @@ If you encounter an error missing from this list, please file an issue or a PR!"
             .and_then(|canon_decl| {
                 self.get_resolved_type(&canon_decl).and_then(
                     |template_decl_id| {
-                        let num_params = template_decl_id.num_self_template_params(self);
+                        let num_params =
+                            template_decl_id.num_self_template_params(self);
                         if num_params == 0 {
                             None
                         } else {
@@ -1590,7 +1563,8 @@ If you encounter an error missing from this list, please file an issue or a PR!"
                             .cloned()
                     })
                     .and_then(|template_decl| {
-                        let num_template_params = template_decl.num_self_template_params(self);
+                        let num_template_params =
+                            template_decl.num_self_template_params(self);
                         if num_template_params == 0 {
                             None
                         } else {
@@ -1644,11 +1618,12 @@ If you encounter an error missing from this list, please file an issue or a PR!"
         ty: &clang::Type,
         location: clang::Cursor,
     ) -> Option<TypeId> {
-        let num_expected_args = self.resolve_type(template).num_self_template_params(self);
+        let num_expected_args =
+            self.resolve_type(template).num_self_template_params(self);
         if num_expected_args == 0 {
             warn!(
                 "Tried to instantiate a template for which we could not \
-                   determine any template parameters"
+                 determine any template parameters"
             );
             return None;
         }
@@ -1668,13 +1643,14 @@ If you encounter an error missing from this list, please file an issue or a PR!"
             // being specialized via the `location`'s type, and if we do not
             // filter it out, we'll add an extra layer of template instantiation
             // on accident.
-            let idx = children.iter().position(|c| {
-                c.kind() == clang_sys::CXCursor_TemplateRef
-            });
+            let idx = children
+                .iter()
+                .position(|c| c.kind() == clang_sys::CXCursor_TemplateRef);
             if let Some(idx) = idx {
-                if children.iter().take(idx).all(|c| {
-                    c.kind() == clang_sys::CXCursor_NamespaceRef
-                })
+                if children
+                    .iter()
+                    .take(idx)
+                    .all(|c| c.kind() == clang_sys::CXCursor_NamespaceRef)
                 {
                     children = children.into_iter().skip(idx + 1).collect();
                 }
@@ -1701,8 +1677,13 @@ If you encounter an error missing from this list, please file an issue or a PR!"
                     args.push(ty);
                 }
                 clang_sys::CXCursor_TemplateRef => {
-                    let (template_decl_cursor, template_decl_id, num_expected_template_args) =
-                        self.get_declaration_info_for_template_instantiation(child)?;
+                    let (
+                        template_decl_cursor,
+                        template_decl_id,
+                        num_expected_template_args,
+                    ) = self.get_declaration_info_for_template_instantiation(
+                        child,
+                    )?;
 
                     if num_expected_template_args == 0 ||
                         child.has_at_least_num_children(
@@ -1727,7 +1708,7 @@ If you encounter an error missing from this list, please file an issue or a PR!"
                         if args_len < num_expected_template_args {
                             warn!(
                                 "Found a template instantiation without \
-                                   enough template arguments"
+                                 enough template arguments"
                             );
                             return None;
                         }
@@ -1767,7 +1748,7 @@ If you encounter an error missing from this list, please file an issue or a PR!"
                         // Bypass all the validations in add_item explicitly.
                         debug!(
                             "instantiate_template: inserting nested \
-                                instantiation item: {:?}",
+                             instantiation item: {:?}",
                             sub_item
                         );
                         self.add_item_to_module(&sub_item);
@@ -1795,7 +1776,7 @@ If you encounter an error missing from this list, please file an issue or a PR!"
             // situation...
             warn!(
                 "Found template instantiated with a const value; \
-                   bindgen can't handle this kind of template instantiation!"
+                 bindgen can't handle this kind of template instantiation!"
             );
             return None;
         }
@@ -1803,7 +1784,7 @@ If you encounter an error missing from this list, please file an issue or a PR!"
         if args.len() != num_expected_args {
             warn!(
                 "Found a template with an unexpected number of template \
-                   arguments"
+                 arguments"
             );
             return None;
         }
@@ -1845,9 +1826,9 @@ If you encounter an error missing from this list, please file an issue or a PR!"
         self.types
             .get(&TypeKey::Declaration(*decl.cursor()))
             .or_else(|| {
-                decl.cursor().usr().and_then(
-                    |usr| self.types.get(&TypeKey::USR(usr)),
-                )
+                decl.cursor()
+                    .usr()
+                    .and_then(|usr| self.types.get(&TypeKey::USR(usr)))
             })
             .cloned()
     }
@@ -1864,19 +1845,14 @@ If you encounter an error missing from this list, please file an issue or a PR!"
         use clang_sys::{CXCursor_TypeAliasTemplateDecl, CXCursor_TypeRef};
         debug!(
             "builtin_or_resolved_ty: {:?}, {:?}, {:?}",
-            ty,
-            location,
-            parent_id
+            ty, location, parent_id
         );
 
         if let Some(decl) = ty.canonical_declaration(location.as_ref()) {
             if let Some(id) = self.get_resolved_type(&decl) {
                 debug!(
                     "Already resolved ty {:?}, {:?}, {:?} {:?}",
-                    id,
-                    decl,
-                    ty,
-                    location
+                    id, decl, ty, location
                 );
                 // If the declaration already exists, then either:
                 //
@@ -1908,7 +1884,8 @@ If you encounter an error missing from this list, please file an issue or a PR!"
                         return None;
                     }
 
-                    return self.instantiate_template(with_id, id, ty, location)
+                    return self
+                        .instantiate_template(with_id, id, ty, location)
                         .or_else(|| Some(id));
                 }
 
@@ -1935,13 +1912,7 @@ If you encounter an error missing from this list, please file an issue or a PR!"
         parent_id: Option<ItemId>,
         ty: &clang::Type,
     ) -> TypeId {
-        self.build_wrapper(
-            with_id,
-            wrapped_id,
-            parent_id,
-            ty,
-            ty.is_const(),
-        )
+        self.build_wrapper(with_id, wrapped_id, parent_id, ty, ty.is_const())
     }
 
     /// A wrapper over a type that adds a const qualifier explicitly.
@@ -1955,11 +1926,7 @@ If you encounter an error missing from this list, please file an issue or a PR!"
         ty: &clang::Type,
     ) -> TypeId {
         self.build_wrapper(
-            with_id,
-            wrapped_id,
-            parent_id,
-            ty,
-            /* is_const = */ true,
+            with_id, wrapped_id, parent_id, ty, /* is_const = */ true,
         )
     }
 
@@ -2001,21 +1968,13 @@ If you encounter an error missing from this list, please file an issue or a PR!"
             CXType_Bool => TypeKind::Int(IntKind::Bool),
             CXType_Int => TypeKind::Int(IntKind::Int),
             CXType_UInt => TypeKind::Int(IntKind::UInt),
-            CXType_Char_S => TypeKind::Int(IntKind::Char {
-                is_signed: true,
-            }),
-            CXType_Char_U => TypeKind::Int(IntKind::Char {
-                is_signed: false,
-            }),
+            CXType_Char_S => TypeKind::Int(IntKind::Char { is_signed: true }),
+            CXType_Char_U => TypeKind::Int(IntKind::Char { is_signed: false }),
             CXType_SChar => TypeKind::Int(IntKind::SChar),
             CXType_UChar => TypeKind::Int(IntKind::UChar),
             CXType_Short => TypeKind::Int(IntKind::Short),
             CXType_UShort => TypeKind::Int(IntKind::UShort),
-            CXType_WChar => {
-                TypeKind::Int(IntKind::WChar {
-                    size: ty.fallible_size(self).expect("Couldn't compute size of wchar_t?"),
-                })
-            },
+            CXType_WChar => TypeKind::Int(IntKind::WChar),
             CXType_Char16 => TypeKind::Int(IntKind::U16),
             CXType_Char32 => TypeKind::Int(IntKind::U32),
             CXType_Long => TypeKind::Int(IntKind::Long),
@@ -2036,13 +1995,10 @@ If you encounter an error missing from this list, please file an issue or a PR!"
                     CXType_Double => FloatKind::Double,
                     CXType_LongDouble => FloatKind::LongDouble,
                     CXType_Float128 => FloatKind::Float128,
-                    _ => {
-                        panic!(
-                            "Non floating-type complex? {:?}, {:?}",
-                            ty,
-                            float_type,
-                        )
-                    },
+                    _ => panic!(
+                        "Non floating-type complex? {:?}, {:?}",
+                        ty, float_type,
+                    ),
                 };
                 TypeKind::Complex(float_kind)
             }
@@ -2054,8 +2010,13 @@ If you encounter an error missing from this list, please file an issue or a PR!"
         let layout = ty.fallible_layout(self).ok();
         let ty = Type::new(Some(spelling), layout, type_kind, is_const);
         let id = self.next_item_id();
-        let item =
-            Item::new(id, None, None, self.root_module.into(), ItemKind::Type(ty));
+        let item = Item::new(
+            id,
+            None,
+            None,
+            self.root_module.into(),
+            ItemKind::Type(ty),
+        );
         self.add_builtin_item(item);
         Some(id.as_type_id_unchecked())
     }
@@ -2071,7 +2032,9 @@ If you encounter an error missing from this list, please file an issue or a PR!"
     }
 
     /// Get the currently parsed macros.
-    pub fn parsed_macros(&self) -> &StdHashMap<Vec<u8>, cexpr::expr::EvalResult> {
+    pub fn parsed_macros(
+        &self,
+    ) -> &StdHashMap<Vec<u8>, cexpr::expr::EvalResult> {
         debug_assert!(!self.in_codegen_phase());
         &self.parsed_macros
     }
@@ -2100,15 +2063,14 @@ If you encounter an error missing from this list, please file an issue or a PR!"
             Entry::Vacant(entry) => {
                 debug!(
                     "Defining replacement for {:?} as {:?}",
-                    name,
-                    potential_ty
+                    name, potential_ty
                 );
                 entry.insert(potential_ty);
             }
             Entry::Occupied(occupied) => {
                 warn!(
                     "Replacement for {:?} already defined as {:?}; \
-                       ignoring duplicate replacement definition as {:?}",
+                     ignoring duplicate replacement definition as {:?}",
                     name,
                     occupied.get(),
                     potential_ty
@@ -2119,7 +2081,11 @@ If you encounter an error missing from this list, please file an issue or a PR!"
 
     /// Has the item with the given `name` and `id` been replaced by another
     /// type?
-    pub fn is_replaced_type<Id: Into<ItemId>>(&self, path: &[String], id: Id) -> bool {
+    pub fn is_replaced_type<Id: Into<ItemId>>(
+        &self,
+        path: &[String],
+        id: Id,
+    ) -> bool {
         let id = id.into();
         match self.replacements.get(path) {
             Some(replaced_by) if *replaced_by != id => true,
@@ -2189,7 +2155,8 @@ If you encounter an error missing from this list, please file an issue or a PR!"
                 }
                 name if found_namespace_keyword => {
                     if module_name.is_none() {
-                        module_name = Some(String::from_utf8_lossy(name).into_owned());
+                        module_name =
+                            Some(String::from_utf8_lossy(name).into_owned());
                     }
                     break;
                 }
@@ -2277,7 +2244,8 @@ If you encounter an error missing from this list, please file an issue or a PR!"
         let _t = self.timer("compute_whitelisted_and_codegen_items");
 
         let roots = {
-            let mut roots = self.items()
+            let mut roots = self
+                .items()
                 // Only consider roots that are enabled for codegen.
                 .filter(|&(_, item)| item.is_enabled_for_codegen(self))
                 .filter(|&(_, item)| {
@@ -2285,9 +2253,10 @@ If you encounter an error missing from this list, please file an issue or a PR!"
                     // game.
                     if self.options().whitelisted_types.is_empty() &&
                         self.options().whitelisted_functions.is_empty() &&
-                        self.options().whitelisted_vars.is_empty() {
-                            return true;
-                        }
+                        self.options().whitelisted_vars.is_empty()
+                    {
+                        return true;
+                    }
 
                     // If this is a type that explicitly replaces another, we assume
                     // you know what you're doing.
@@ -2328,7 +2297,7 @@ If you encounter an error missing from this list, please file an issue or a PR!"
                                     TypeKind::ResolvedTypeRef(..) |
                                     TypeKind::Opaque |
                                     TypeKind::TypeParam => return true,
-                                    _ => {},
+                                    _ => {}
                                 };
                             }
 
@@ -2342,7 +2311,6 @@ If you encounter an error missing from this list, please file an issue or a PR!"
                                 return false;
                             }
 
-
                             let enum_ = match *ty.kind() {
                                 TypeKind::Enum(ref e) => e,
                                 _ => return false,
@@ -2358,9 +2326,7 @@ If you encounter an error missing from this list, please file an issue or a PR!"
                                 prefix_path.push(variant.name().into());
                                 let name = prefix_path[1..].join("::");
                                 prefix_path.pop().unwrap();
-                                self.options()
-                                    .whitelisted_vars
-                                    .matches(&name)
+                                self.options().whitelisted_vars.matches(&name)
                             })
                         }
                     }
@@ -2390,14 +2356,16 @@ If you encounter an error missing from this list, please file an issue or a PR!"
             self,
             roots.clone(),
             whitelisted_items_predicate,
-        ).collect::<ItemSet>();
+        )
+        .collect::<ItemSet>();
 
         let codegen_items = if self.options().whitelist_recursively {
             WhitelistedItemsTraversal::new(
                 self,
                 roots.clone(),
                 traversal::codegen_edges,
-            ).collect::<ItemSet>()
+            )
+            .collect::<ItemSet>()
         } else {
             whitelisted.clone()
         };
@@ -2443,7 +2411,11 @@ If you encounter an error missing from this list, please file an issue or a PR!"
         let _t = self.timer("compute_cannot_derive_debug");
         assert!(self.cannot_derive_debug.is_none());
         if self.options.derive_debug {
-            self.cannot_derive_debug = Some(as_cannot_derive_set(analyze::<CannotDerive>((self, DeriveTrait::Debug))));
+            self.cannot_derive_debug =
+                Some(as_cannot_derive_set(analyze::<CannotDerive>((
+                    self,
+                    DeriveTrait::Debug,
+                ))));
         }
     }
 
@@ -2467,7 +2439,10 @@ If you encounter an error missing from this list, please file an issue or a PR!"
         assert!(self.cannot_derive_default.is_none());
         if self.options.derive_default {
             self.cannot_derive_default =
-                Some(as_cannot_derive_set(analyze::<CannotDerive>((self, DeriveTrait::Default))));
+                Some(as_cannot_derive_set(analyze::<CannotDerive>((
+                    self,
+                    DeriveTrait::Default,
+                ))));
         }
     }
 
@@ -2489,7 +2464,11 @@ If you encounter an error missing from this list, please file an issue or a PR!"
     fn compute_cannot_derive_copy(&mut self) {
         let _t = self.timer("compute_cannot_derive_copy");
         assert!(self.cannot_derive_copy.is_none());
-        self.cannot_derive_copy = Some(as_cannot_derive_set(analyze::<CannotDerive>((self, DeriveTrait::Copy))));
+        self.cannot_derive_copy =
+            Some(as_cannot_derive_set(analyze::<CannotDerive>((
+                self,
+                DeriveTrait::Copy,
+            ))));
     }
 
     /// Compute whether we can derive hash.
@@ -2497,7 +2476,11 @@ If you encounter an error missing from this list, please file an issue or a PR!"
         let _t = self.timer("compute_cannot_derive_hash");
         assert!(self.cannot_derive_hash.is_none());
         if self.options.derive_hash {
-            self.cannot_derive_hash = Some(as_cannot_derive_set(analyze::<CannotDerive>((self, DeriveTrait::Hash))));
+            self.cannot_derive_hash =
+                Some(as_cannot_derive_set(analyze::<CannotDerive>((
+                    self,
+                    DeriveTrait::Hash,
+                ))));
         }
     }
 
@@ -2519,13 +2502,23 @@ If you encounter an error missing from this list, please file an issue or a PR!"
     fn compute_cannot_derive_partialord_partialeq_or_eq(&mut self) {
         let _t = self.timer("compute_cannot_derive_partialord_partialeq_or_eq");
         assert!(self.cannot_derive_partialeq_or_partialord.is_none());
-        if self.options.derive_partialord || self.options.derive_partialeq || self.options.derive_eq {
-            self.cannot_derive_partialeq_or_partialord = Some(analyze::<CannotDerive>((self, DeriveTrait::PartialEqOrPartialOrd)));
+        if self.options.derive_partialord ||
+            self.options.derive_partialeq ||
+            self.options.derive_eq
+        {
+            self.cannot_derive_partialeq_or_partialord =
+                Some(analyze::<CannotDerive>((
+                    self,
+                    DeriveTrait::PartialEqOrPartialOrd,
+                )));
         }
     }
 
     /// Look up whether the item with `id` can derive `Partial{Eq,Ord}`.
-    pub fn lookup_can_derive_partialeq_or_partialord<Id: Into<ItemId>>(&self, id: Id) -> CanDerive {
+    pub fn lookup_can_derive_partialeq_or_partialord<Id: Into<ItemId>>(
+        &self,
+        id: Id,
+    ) -> CanDerive {
         let id = id.into();
         assert!(
             self.in_codegen_phase(),
@@ -2534,7 +2527,8 @@ If you encounter an error missing from this list, please file an issue or a PR!"
 
         // Look up the computed value for whether the item with `id` can
         // derive partialeq or not.
-        self.cannot_derive_partialeq_or_partialord.as_ref()
+        self.cannot_derive_partialeq_or_partialord
+            .as_ref()
             .unwrap()
             .get(&id)
             .cloned()
@@ -2565,7 +2559,10 @@ If you encounter an error missing from this list, please file an issue or a PR!"
     }
 
     /// Look up whether the item with `id` has type parameter in array or not.
-    pub fn lookup_has_type_param_in_array<Id: Into<ItemId>>(&self, id: Id) -> bool {
+    pub fn lookup_has_type_param_in_array<Id: Into<ItemId>>(
+        &self,
+        id: Id,
+    ) -> bool {
         assert!(
             self.in_codegen_phase(),
             "We only compute has array when we enter codegen"
@@ -2573,7 +2570,10 @@ If you encounter an error missing from this list, please file an issue or a PR!"
 
         // Look up the computed value for whether the item with `id` has
         // type parameter in array or not.
-        self.has_type_param_in_array.as_ref().unwrap().contains(&id.into())
+        self.has_type_param_in_array
+            .as_ref()
+            .unwrap()
+            .contains(&id.into())
     }
 
     /// Compute whether the type has float.
@@ -2587,8 +2587,10 @@ If you encounter an error missing from this list, please file an issue or a PR!"
 
     /// Look up whether the item with `id` has array or not.
     pub fn lookup_has_float<Id: Into<ItemId>>(&self, id: Id) -> bool {
-        assert!(self.in_codegen_phase(),
-                "We only compute has float when we enter codegen");
+        assert!(
+            self.in_codegen_phase(),
+            "We only compute has float when we enter codegen"
+        );
 
         // Look up the computed value for whether the item with `id` has
         // float or not.
@@ -2631,7 +2633,7 @@ impl ItemId {
 
 impl<T> From<T> for ItemResolver
 where
-    T: Into<ItemId>
+    T: Into<ItemId>,
 {
     fn from(id: T) -> ItemResolver {
         ItemResolver::new(id)
@@ -2671,14 +2673,16 @@ impl ItemResolver {
             let ty_kind = item.as_type().map(|t| t.kind());
             match ty_kind {
                 Some(&TypeKind::ResolvedTypeRef(next_id))
-                    if self.through_type_refs => {
+                    if self.through_type_refs =>
+                {
                     id = next_id.into();
                 }
                 // We intentionally ignore template aliases here, as they are
                 // more complicated, and don't represent a simple renaming of
                 // some type.
                 Some(&TypeKind::Alias(next_id))
-                    if self.through_type_aliases => {
+                    if self.through_type_aliases =>
+                {
                     id = next_id.into();
                 }
                 _ => return item,
@@ -2700,10 +2704,7 @@ impl PartialType {
     /// Construct a new `PartialType`.
     pub fn new(decl: Cursor, id: ItemId) -> PartialType {
         // assert!(decl == decl.canonical());
-        PartialType {
-            decl: decl,
-            id: id,
-        }
+        PartialType { decl: decl, id: id }
     }
 
     /// The cursor pointing to this partial type's declaration location.
@@ -2719,10 +2720,7 @@ impl PartialType {
 }
 
 impl TemplateParameters for PartialType {
-    fn self_template_params(
-        &self,
-        _ctx: &BindgenContext,
-    ) -> Vec<TypeId> {
+    fn self_template_params(&self, _ctx: &BindgenContext) -> Vec<TypeId> {
         // Maybe at some point we will eagerly parse named types, but for now we
         // don't and this information is unavailable.
         vec![]
diff --git a/third_party/rust/bindgen/src/ir/derive.rs b/third_party/rust/bindgen/src/ir/derive.rs
index d434b0a0fe35..594ce2ab8fc6 100644
--- a/third_party/rust/bindgen/src/ir/derive.rs
+++ b/third_party/rust/bindgen/src/ir/derive.rs
@@ -92,10 +92,10 @@ pub trait CanDeriveOrd {
 ///
 /// Initially we assume that we can derive trait for all types and then
 /// update our understanding as we learn more about each type.
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
 pub enum CanDerive {
-    /// No, we cannot.
-    No,
+    /// Yes, we can derive automatically.
+    Yes,
 
     /// The only thing that stops us from automatically deriving is that
     /// array with more than maximum number of elements is used.
@@ -103,8 +103,8 @@ pub enum CanDerive {
     /// This means we probably can "manually" implement such trait.
     Manually,
 
-    /// Yes, we can derive automatically.
-    Yes,
+    /// No, we cannot.
+    No,
 }
 
 impl Default for CanDerive {
@@ -113,22 +113,6 @@ impl Default for CanDerive {
     }
 }
 
-impl cmp::PartialOrd for CanDerive {
-    fn partial_cmp(&self, rhs: &Self) -> Option<cmp::Ordering> {
-        use self::CanDerive::*;
-
-        let ordering = match (*self, *rhs) {
-            (x, y) if x == y => cmp::Ordering::Equal,
-            (No, _) => cmp::Ordering::Greater,
-            (_, No) => cmp::Ordering::Less,
-            (Manually, _) => cmp::Ordering::Greater,
-            (_, Manually) => cmp::Ordering::Less,
-            _ => unreachable!()
-        };
-        Some(ordering)
-    }
-}
-
 impl CanDerive {
     /// Take the least upper bound of `self` and `rhs`.
     pub fn join(self, rhs: Self) -> Self {
diff --git a/third_party/rust/bindgen/src/ir/dot.rs b/third_party/rust/bindgen/src/ir/dot.rs
index 6caca781536d..d56902321dab 100644
--- a/third_party/rust/bindgen/src/ir/dot.rs
+++ b/third_party/rust/bindgen/src/ir/dot.rs
@@ -60,11 +60,7 @@ where
                     id.as_usize(),
                     sub_id.as_usize(),
                     edge_kind,
-                    if is_whitelisted {
-                        "black"
-                    } else {
-                        "gray"
-                    }
+                    if is_whitelisted { "black" } else { "gray" }
                 ) {
                     Ok(_) => {}
                     Err(e) => err = Some(Err(e)),
diff --git a/third_party/rust/bindgen/src/ir/enum_ty.rs b/third_party/rust/bindgen/src/ir/enum_ty.rs
index f3da21997afb..442b5e2e37b4 100644
--- a/third_party/rust/bindgen/src/ir/enum_ty.rs
+++ b/third_party/rust/bindgen/src/ir/enum_ty.rs
@@ -1,8 +1,8 @@
 //! Intermediate representation for C/C++ enumerations.
 
+use super::super::codegen::EnumVariation;
 use super::context::{BindgenContext, TypeId};
 use super::item::Item;
-use super::super::codegen::EnumVariation;
 use super::ty::TypeKind;
 use clang;
 use ir::annotations::Annotations;
@@ -38,10 +38,7 @@ pub struct Enum {
 impl Enum {
     /// Construct a new `Enum` with the given representation and variants.
     pub fn new(repr: Option<TypeId>, variants: Vec<EnumVariant>) -> Self {
-        Enum {
-            repr,
-            variants,
-        }
+        Enum { repr, variants }
     }
 
     /// Get this enumeration's representation.
@@ -67,15 +64,15 @@ impl Enum {
         }
 
         let declaration = ty.declaration().canonical();
-        let repr = declaration.enum_type().and_then(|et| {
-            Item::from_ty(&et, declaration, None, ctx).ok()
-        });
+        let repr = declaration
+            .enum_type()
+            .and_then(|et| Item::from_ty(&et, declaration, None, ctx).ok());
         let mut variants = vec![];
 
         // Assume signedness since the default type by the C standard is an int.
-        let is_signed = repr.and_then(
-            |r| ctx.resolve_type(r).safe_canonical_type(ctx),
-        ).map_or(true, |ty| match *ty.kind() {
+        let is_signed = repr
+            .and_then(|r| ctx.resolve_type(r).safe_canonical_type(ctx))
+            .map_or(true, |ty| match *ty.kind() {
                 TypeKind::Int(ref int_kind) => int_kind.is_signed(),
                 ref other => {
                     panic!("Since when enums can be non-integers? {:?}", other)
@@ -101,9 +98,11 @@ impl Enum {
                 if let Some(val) = value {
                     let name = cursor.spelling();
                     let annotations = Annotations::new(&cursor);
-                    let custom_behavior = ctx.parse_callbacks()
+                    let custom_behavior = ctx
+                        .parse_callbacks()
                         .and_then(|callbacks| {
-                            callbacks.enum_variant_behavior(type_name, &name, val)
+                            callbacks
+                                .enum_variant_behavior(type_name, &name, val)
                         })
                         .or_else(|| {
                             let annotations = annotations.as_ref()?;
@@ -116,12 +115,17 @@ impl Enum {
                             }
                         });
 
-                    let name = ctx.parse_callbacks()
+                    let name = ctx
+                        .parse_callbacks()
                         .and_then(|callbacks| {
                             callbacks.enum_variant_name(type_name, &name, val)
                         })
                         .or_else(|| {
-                            annotations.as_ref()?.use_instead_of()?.last().cloned()
+                            annotations
+                                .as_ref()?
+                                .use_instead_of()?
+                                .last()
+                                .cloned()
                         })
                         .unwrap_or(name);
 
@@ -139,7 +143,12 @@ impl Enum {
         Ok(Enum::new(repr, variants))
     }
 
-    fn is_matching_enum(&self, ctx: &BindgenContext, enums: &RegexSet, item: &Item) -> bool {
+    fn is_matching_enum(
+        &self,
+        ctx: &BindgenContext,
+        enums: &RegexSet,
+        item: &Item,
+    ) -> bool {
         let path = item.canonical_path(ctx);
         let enum_ty = item.expect_type();
 
@@ -156,16 +165,46 @@ impl Enum {
     }
 
     /// Returns the final representation of the enum.
-    pub fn computed_enum_variation(&self, ctx: &BindgenContext, item: &Item) -> EnumVariation {
+    pub fn computed_enum_variation(
+        &self,
+        ctx: &BindgenContext,
+        item: &Item,
+    ) -> EnumVariation {
         // ModuleConsts has higher precedence before Rust in order to avoid
         // problems with overlapping match patterns.
-        if self.is_matching_enum(ctx, &ctx.options().constified_enum_modules, item) {
+        if self.is_matching_enum(
+            ctx,
+            &ctx.options().constified_enum_modules,
+            item,
+        ) {
             EnumVariation::ModuleConsts
-        } else if self.is_matching_enum(ctx, &ctx.options().bitfield_enums, item) {
+        } else if self.is_matching_enum(
+            ctx,
+            &ctx.options().bitfield_enums,
+            item,
+        ) {
             EnumVariation::Bitfield
-        } else if self.is_matching_enum(ctx, &ctx.options().rustified_enums, item) {
-            EnumVariation::Rust
-        } else if self.is_matching_enum(ctx, &ctx.options().constified_enums, item) {
+        } else if self.is_matching_enum(
+            ctx,
+            &ctx.options().rustified_enums,
+            item,
+        ) {
+            EnumVariation::Rust {
+                non_exhaustive: false,
+            }
+        } else if self.is_matching_enum(
+            ctx,
+            &ctx.options().rustified_non_exhaustive_enums,
+            item,
+        ) {
+            EnumVariation::Rust {
+                non_exhaustive: true,
+            }
+        } else if self.is_matching_enum(
+            ctx,
+            &ctx.options().constified_enums,
+            item,
+        ) {
             EnumVariation::Consts
         } else {
             ctx.options().default_enum_style
@@ -233,16 +272,14 @@ impl EnumVariant {
     /// Returns whether this variant should be enforced to be a constant by code
     /// generation.
     pub fn force_constification(&self) -> bool {
-        self.custom_behavior.map_or(false, |b| {
-            b == EnumVariantCustomBehavior::Constify
-        })
+        self.custom_behavior
+            .map_or(false, |b| b == EnumVariantCustomBehavior::Constify)
     }
 
     /// Returns whether the current variant should be hidden completely from the
     /// resulting rust enum.
     pub fn hidden(&self) -> bool {
-        self.custom_behavior.map_or(false, |b| {
-            b == EnumVariantCustomBehavior::Hide
-        })
+        self.custom_behavior
+            .map_or(false, |b| b == EnumVariantCustomBehavior::Hide)
     }
 }
diff --git a/third_party/rust/bindgen/src/ir/function.rs b/third_party/rust/bindgen/src/ir/function.rs
index 4001e4d3dc1a..9ccf4e14c2e5 100644
--- a/third_party/rust/bindgen/src/ir/function.rs
+++ b/third_party/rust/bindgen/src/ir/function.rs
@@ -9,9 +9,9 @@ use super::ty::TypeKind;
 use clang;
 use clang_sys::{self, CXCallingConv};
 use parse::{ClangItemParser, ClangSubItemParser, ParseError, ParseResult};
+use proc_macro2;
 use quote;
 use quote::TokenStreamExt;
-use proc_macro2;
 use std::io;
 
 const RUST_DERIVE_FUNPTR_LIMIT: usize = 12;
@@ -30,18 +30,18 @@ impl FunctionKind {
         // FIXME(emilio): Deduplicate logic with `ir::comp`.
         Some(match cursor.kind() {
             clang_sys::CXCursor_FunctionDecl => FunctionKind::Function,
-            clang_sys::CXCursor_Constructor => FunctionKind::Method(
-                MethodKind::Constructor,
-            ),
-            clang_sys::CXCursor_Destructor => FunctionKind::Method(
-                if cursor.method_is_virtual() {
+            clang_sys::CXCursor_Constructor => {
+                FunctionKind::Method(MethodKind::Constructor)
+            }
+            clang_sys::CXCursor_Destructor => {
+                FunctionKind::Method(if cursor.method_is_virtual() {
                     MethodKind::VirtualDestructor {
                         pure_virtual: cursor.method_is_pure_virtual(),
                     }
                 } else {
                     MethodKind::Destructor
-                }
-            ),
+                })
+            }
             clang_sys::CXCursor_CXXMethod => {
                 if cursor.method_is_virtual() {
                     FunctionKind::Method(MethodKind::Virtual {
@@ -64,7 +64,7 @@ pub enum Linkage {
     /// Externally visible and can be linked against
     External,
     /// Not exposed externally. 'static inline' functions will have this kind of linkage
-    Internal
+    Internal,
 }
 
 /// A function declaration, with a signature, arguments, and argument names.
@@ -100,7 +100,7 @@ impl Function {
         signature: TypeId,
         comment: Option<String>,
         kind: FunctionKind,
-        linkage: Linkage
+        linkage: Linkage,
     ) -> Self {
         Function {
             name,
@@ -136,7 +136,6 @@ impl Function {
     pub fn linkage(&self) -> Linkage {
         self.linkage
     }
-
 }
 
 impl DotAttributes for Function {
@@ -253,7 +252,7 @@ pub fn cursor_mangling(
 
     // We early return here because libclang may crash in some case
     // if we pass in a variable inside a partial specialized template.
-    // See rust-lang-nursery/rust-bindgen#67, and rust-lang-nursery/rust-bindgen#462.
+    // See rust-lang/rust-bindgen#67, and rust-lang/rust-bindgen#462.
     if cursor.is_in_non_fully_specialized_template() {
         return None;
     }
@@ -325,16 +324,16 @@ fn args_from_ty_and_cursor(
     cursor_args
         .map(Some)
         .chain(std::iter::repeat(None))
-        .zip(
-            type_args
-            .map(Some)
-            .chain(std::iter::repeat(None))
-        )
+        .zip(type_args.map(Some).chain(std::iter::repeat(None)))
         .take_while(|(cur, ty)| cur.is_some() || ty.is_some())
         .map(|(arg_cur, arg_ty)| {
-            let name = arg_cur
-                .map(|a| a.spelling())
-                .and_then(|name| if name.is_empty() { None} else { Some(name) });
+            let name = arg_cur.map(|a| a.spelling()).and_then(|name| {
+                if name.is_empty() {
+                    None
+                } else {
+                    Some(name)
+                }
+            });
 
             let cursor = arg_cur.unwrap_or(*cursor);
             let ty = arg_ty.unwrap_or(cursor.cur_type());
@@ -404,7 +403,7 @@ impl FunctionSig {
             CXCursor_ObjCInstanceMethodDecl |
             CXCursor_ObjCClassMethodDecl => {
                 args_from_ty_and_cursor(&ty, &cursor, ctx)
-            },
+            }
             _ => {
                 // For non-CXCursor_FunctionDecl, visiting the cursor's children
                 // is the only reliable way to get parameter names.
@@ -424,8 +423,7 @@ impl FunctionSig {
             }
         };
 
-        let must_use =
-            ctx.options().enable_function_attribute_detection &&
+        let must_use = ctx.options().enable_function_attribute_detection &&
             cursor.has_simple_attr("warn_unused_result");
         let is_method = kind == CXCursor_CXXMethod;
         let is_constructor = kind == CXCursor_Constructor;
@@ -475,9 +473,9 @@ impl FunctionSig {
         let ty_ret_type = if kind == CXCursor_ObjCInstanceMethodDecl ||
             kind == CXCursor_ObjCClassMethodDecl
         {
-            ty.ret_type().or_else(|| cursor.ret_type()).ok_or(
-                ParseError::Continue,
-            )?
+            ty.ret_type()
+                .or_else(|| cursor.ret_type())
+                .ok_or(ParseError::Continue)?
         } else {
             ty.ret_type().ok_or(ParseError::Continue)?
         };
@@ -535,7 +533,7 @@ impl FunctionSig {
     ///
     /// For more details, see:
     ///
-    /// * https://github.com/rust-lang-nursery/rust-bindgen/issues/547,
+    /// * https://github.com/rust-lang/rust-bindgen/issues/547,
     /// * https://github.com/rust-lang/rust/issues/38848,
     /// * and https://github.com/rust-lang/rust/issues/40158
     pub fn function_pointers_can_derive(&self) -> bool {
@@ -583,12 +581,11 @@ impl ClangSubItemParser for Function {
         let linkage = match linkage {
             CXLinkage_External | CXLinkage_UniqueExternal => Linkage::External,
             CXLinkage_Internal => Linkage::Internal,
-            _ => return Err(ParseError::Continue)
+            _ => return Err(ParseError::Continue),
         };
 
         // Grab the signature using Item::from_ty.
-        let sig =
-            Item::from_ty(&cursor.cur_type(), cursor, None, context)?;
+        let sig = Item::from_ty(&cursor.cur_type(), cursor, None, context)?;
 
         let mut name = cursor.spelling();
         assert!(!name.is_empty(), "Empty function name?");
@@ -610,7 +607,8 @@ impl ClangSubItemParser for Function {
         let mangled_name = cursor_mangling(context, &cursor);
         let comment = cursor.raw_comment();
 
-        let function = Self::new(name, mangled_name, sig, comment, kind, linkage);
+        let function =
+            Self::new(name, mangled_name, sig, comment, kind, linkage);
         Ok(ParseResult::New(function, Some(cursor)))
     }
 }
diff --git a/third_party/rust/bindgen/src/ir/int.rs b/third_party/rust/bindgen/src/ir/int.rs
index 144a7dedadc4..22838e897c08 100644
--- a/third_party/rust/bindgen/src/ir/int.rs
+++ b/third_party/rust/bindgen/src/ir/int.rs
@@ -13,10 +13,7 @@ pub enum IntKind {
     UChar,
 
     /// An `wchar_t`.
-    WChar {
-        /// The size of the wchar_t in bytes, which will be 2 or 4.
-        size: usize,
-    },
+    WChar,
 
     /// A platform-dependent `char` type, with the signedness support.
     Char {
@@ -97,16 +94,14 @@ impl IntKind {
             // to know whether it is or not right now (unlike char, there's no
             // WChar_S / WChar_U).
             Bool | UChar | UShort | UInt | ULong | ULongLong | U8 | U16 |
-            WChar { .. } | U32 | U64 | U128 => false,
+            WChar | U32 | U64 | U128 => false,
 
             SChar | Short | Int | Long | LongLong | I8 | I16 | I32 | I64 |
             I128 => true,
 
             Char { is_signed } => is_signed,
 
-            Custom {
-                is_signed, ..
-            } => is_signed,
+            Custom { is_signed, .. } => is_signed,
         }
     }
 
@@ -116,14 +111,7 @@ impl IntKind {
     pub fn known_size(&self) -> Option<usize> {
         use self::IntKind::*;
         Some(match *self {
-            Bool |
-            UChar |
-            SChar |
-            U8 |
-            I8 |
-            Char {
-                ..
-            } => 1,
+            Bool | UChar | SChar | U8 | I8 | Char { .. } => 1,
             U16 | I16 => 2,
             U32 | I32 => 4,
             U64 | I64 => 8,
diff --git a/third_party/rust/bindgen/src/ir/item.rs b/third_party/rust/bindgen/src/ir/item.rs
index 5a0bd8c98880..7b4f3e834853 100644
--- a/third_party/rust/bindgen/src/ir/item.rs
+++ b/third_party/rust/bindgen/src/ir/item.rs
@@ -1,19 +1,20 @@
 //! Bindgen's core intermediate representation type.
 
+use super::super::codegen::{EnumVariation, CONSTIFIED_ENUM_MODULE_REPR_NAME};
 use super::analysis::{HasVtable, HasVtableResult, Sizedness, SizednessResult};
 use super::annotations::Annotations;
 use super::comment;
 use super::comp::MethodKind;
 use super::context::{BindgenContext, ItemId, PartialType, TypeId};
-use super::derive::{CanDeriveCopy, CanDeriveDebug, CanDeriveDefault,
-                    CanDeriveHash, CanDerivePartialOrd, CanDeriveOrd,
-                    CanDerivePartialEq, CanDeriveEq};
+use super::derive::{
+    CanDeriveCopy, CanDeriveDebug, CanDeriveDefault, CanDeriveEq,
+    CanDeriveHash, CanDeriveOrd, CanDerivePartialEq, CanDerivePartialOrd,
+};
 use super::dot::DotAttributes;
 use super::function::{Function, FunctionKind};
 use super::item_kind::ItemKind;
 use super::layout::Opaque;
 use super::module::Module;
-use super::super::codegen::{CONSTIFIED_ENUM_MODULE_REPR_NAME, EnumVariation};
 use super::template::{AsTemplateParam, TemplateParameters};
 use super::traversal::{EdgeKind, Trace, Tracer};
 use super::ty::{Type, TypeKind};
@@ -94,10 +95,7 @@ pub trait HasFloat {
 /// up to (but not including) the implicit root module.
 pub trait ItemAncestors {
     /// Get an iterable over this item's ancestors.
-    fn ancestors<'a>(
-        &self,
-        ctx: &'a BindgenContext,
-    ) -> ItemAncestorsIter<'a>;
+    fn ancestors<'a>(&self, ctx: &'a BindgenContext) -> ItemAncestorsIter<'a>;
 }
 
 cfg_if! {
@@ -158,7 +156,8 @@ impl<'a> Iterator for ItemAncestorsIter<'a> {
 
 impl<T> AsTemplateParam for T
 where
-    T: Copy + Into<ItemId> {
+    T: Copy + Into<ItemId>,
+{
     type Extra = ();
 
     fn as_template_param(
@@ -201,7 +200,7 @@ impl AsTemplateParam for ItemKind {
 
 impl<T> ItemCanonicalName for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     fn canonical_name(&self, ctx: &BindgenContext) -> String {
         debug_assert!(
@@ -213,8 +212,8 @@ where
 }
 
 impl<T> ItemCanonicalPath for T
-    where
-    T: Copy + Into<ItemId>
+where
+    T: Copy + Into<ItemId>,
 {
     fn namespace_aware_canonical_path(
         &self,
@@ -238,28 +237,22 @@ impl<T> ItemCanonicalPath for T
 
 impl<T> ItemAncestors for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
-    fn ancestors<'a>(
-        &self,
-        ctx: &'a BindgenContext,
-    ) -> ItemAncestorsIter<'a> {
+    fn ancestors<'a>(&self, ctx: &'a BindgenContext) -> ItemAncestorsIter<'a> {
         ItemAncestorsIter::new(ctx, *self)
     }
 }
 
 impl ItemAncestors for Item {
-    fn ancestors<'a>(
-        &self,
-        ctx: &'a BindgenContext,
-    ) -> ItemAncestorsIter<'a> {
+    fn ancestors<'a>(&self, ctx: &'a BindgenContext) -> ItemAncestorsIter<'a> {
         self.id().ancestors(ctx)
     }
 }
 
 impl<Id> Trace for Id
 where
-    Id: Copy + Into<ItemId>
+    Id: Copy + Into<ItemId>,
 {
     type Extra = ();
 
@@ -495,10 +488,10 @@ impl Item {
                         ctx.options().conservative_inline_namespaces
                 })
             })
-            .count() + 1
+            .count() +
+            1
     }
 
-
     /// Get this `Item`'s comment, if it has any, already preprocessed and with
     /// the right indentation.
     pub fn comment(&self, ctx: &BindgenContext) -> Option<String> {
@@ -567,7 +560,8 @@ impl Item {
     pub fn is_toplevel(&self, ctx: &BindgenContext) -> bool {
         // FIXME: Workaround for some types falling behind when parsing weird
         // stl classes, for example.
-        if ctx.options().enable_cxx_namespaces && self.kind().is_module() &&
+        if ctx.options().enable_cxx_namespaces &&
+            self.kind().is_module() &&
             self.id() != ctx.root_module()
         {
             return false;
@@ -583,7 +577,7 @@ impl Item {
             if parent_item.id() == ctx.root_module() {
                 return true;
             } else if ctx.options().enable_cxx_namespaces ||
-                       !parent_item.kind().is_module()
+                !parent_item.kind().is_module()
             {
                 return false;
             }
@@ -638,18 +632,17 @@ impl Item {
         let path = self.path_for_whitelisting(ctx);
         let name = path[1..].join("::");
         ctx.options().blacklisted_items.matches(&name) ||
-        match self.kind {
-            ItemKind::Type(..) => {
-                ctx.options().blacklisted_types.matches(&name) ||
-                    ctx.is_replaced_type(&path, self.id)
-            }
-            ItemKind::Function(..) => {
-                ctx.options().blacklisted_functions.matches(&name)
+            match self.kind {
+                ItemKind::Type(..) => {
+                    ctx.options().blacklisted_types.matches(&name) ||
+                        ctx.is_replaced_type(&path, self.id)
+                }
+                ItemKind::Function(..) => {
+                    ctx.options().blacklisted_functions.matches(&name)
+                }
+                // TODO: Add constant / namespace blacklisting?
+                ItemKind::Var(..) | ItemKind::Module(..) => false,
             }
-            // TODO: Add constant / namespace blacklisting?
-            ItemKind::Var(..) |
-            ItemKind::Module(..) => false,
-        }
     }
 
     /// Is this a reference to another type?
@@ -666,10 +659,7 @@ impl Item {
     }
 
     /// Take out item NameOptions
-    pub fn name<'a>(
-        &'a self,
-        ctx: &'a BindgenContext,
-    ) -> NameOptions<'a> {
+    pub fn name<'a>(&'a self, ctx: &'a BindgenContext) -> NameOptions<'a> {
         NameOptions::new(self, ctx)
     }
 
@@ -687,17 +677,15 @@ impl Item {
             }
 
             match *item.kind() {
-                ItemKind::Type(ref ty) => {
-                    match *ty.kind() {
-                        TypeKind::ResolvedTypeRef(inner) => {
-                            item = ctx.resolve_item(inner);
-                        }
-                        TypeKind::TemplateInstantiation(ref inst) => {
-                            item = ctx.resolve_item(inst.template_definition());
-                        }
-                        _ => return item.id(),
+                ItemKind::Type(ref ty) => match *ty.kind() {
+                    TypeKind::ResolvedTypeRef(inner) => {
+                        item = ctx.resolve_item(inner);
                     }
-                }
+                    TypeKind::TemplateInstantiation(ref inst) => {
+                        item = ctx.resolve_item(inst.template_definition());
+                    }
+                    _ => return item.id(),
+                },
                 _ => return item.id(),
             }
         }
@@ -752,7 +740,8 @@ impl Item {
                 if let TypeKind::Comp(ref ci) = *ty.kind() {
                     // All the constructors have the same name, so no need to
                     // resolve and check.
-                    return ci.constructors()
+                    return ci
+                        .constructors()
                         .iter()
                         .position(|c| *c == self.id())
                         .or_else(|| {
@@ -937,7 +926,8 @@ impl Item {
 
         match *type_.kind() {
             TypeKind::Enum(ref enum_) => {
-                enum_.computed_enum_variation(ctx, self) == EnumVariation::ModuleConsts
+                enum_.computed_enum_variation(ctx, self) ==
+                    EnumVariation::ModuleConsts
             }
             TypeKind::Alias(inner_id) => {
                 // TODO(emilio): Make this "hop through type aliases that aren't
@@ -962,17 +952,21 @@ impl Item {
             ItemKind::Module(..) => true,
             ItemKind::Var(_) => cc.vars(),
             ItemKind::Type(_) => cc.types(),
-            ItemKind::Function(ref f) => {
-                match f.kind() {
-                    FunctionKind::Function => cc.functions(),
-                    FunctionKind::Method(MethodKind::Constructor) => cc.constructors(),
-                    FunctionKind::Method(MethodKind::Destructor) |
-                    FunctionKind::Method(MethodKind::VirtualDestructor { ..  }) => cc.destructors(),
-                    FunctionKind::Method(MethodKind::Static) |
-                    FunctionKind::Method(MethodKind::Normal) |
-                    FunctionKind::Method(MethodKind::Virtual { .. }) => cc.methods(),
+            ItemKind::Function(ref f) => match f.kind() {
+                FunctionKind::Function => cc.functions(),
+                FunctionKind::Method(MethodKind::Constructor) => {
+                    cc.constructors()
                 }
-            }
+                FunctionKind::Method(MethodKind::Destructor) |
+                FunctionKind::Method(MethodKind::VirtualDestructor {
+                    ..
+                }) => cc.destructors(),
+                FunctionKind::Method(MethodKind::Static) |
+                FunctionKind::Method(MethodKind::Normal) |
+                FunctionKind::Method(MethodKind::Virtual { .. }) => {
+                    cc.methods()
+                }
+            },
         }
     }
 
@@ -982,7 +976,11 @@ impl Item {
         self.compute_path(ctx, UserMangled::No)
     }
 
-    fn compute_path(&self, ctx: &BindgenContext, mangled: UserMangled) -> Vec<String> {
+    fn compute_path(
+        &self,
+        ctx: &BindgenContext,
+        mangled: UserMangled,
+    ) -> Vec<String> {
         if let Some(path) = self.annotations().use_instead_of() {
             let mut ret =
                 vec![ctx.resolve_item(ctx.root_module()).name(ctx).get()];
@@ -1017,7 +1015,7 @@ impl Item {
 
 impl<T> IsOpaque for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     type Extra = ();
 
@@ -1046,7 +1044,7 @@ impl IsOpaque for Item {
 
 impl<T> HasVtable for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     fn has_vtable(&self, ctx: &BindgenContext) -> bool {
         let id: ItemId = (*self).into();
@@ -1079,7 +1077,7 @@ impl HasVtable for Item {
 
 impl<T> Sizedness for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     fn sizedness(&self, ctx: &BindgenContext) -> SizednessResult {
         let id: ItemId = (*self).into();
@@ -1096,7 +1094,7 @@ impl Sizedness for Item {
 
 impl<T> HasTypeParamInArray for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     fn has_type_param_in_array(&self, ctx: &BindgenContext) -> bool {
         debug_assert!(
@@ -1119,19 +1117,23 @@ impl HasTypeParamInArray for Item {
 
 impl<T> HasFloat for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
     fn has_float(&self, ctx: &BindgenContext) -> bool {
-        debug_assert!(ctx.in_codegen_phase(),
-                      "You're not supposed to call this yet");
+        debug_assert!(
+            ctx.in_codegen_phase(),
+            "You're not supposed to call this yet"
+        );
         ctx.lookup_has_float(*self)
     }
 }
 
 impl HasFloat for Item {
     fn has_float(&self, ctx: &BindgenContext) -> bool {
-        debug_assert!(ctx.in_codegen_phase(),
-                      "You're not supposed to call this yet");
+        debug_assert!(
+            ctx.in_codegen_phase(),
+            "You're not supposed to call this yet"
+        );
         ctx.lookup_has_float(self.id())
     }
 }
@@ -1166,40 +1168,30 @@ impl DotAttributes for Item {
 
 impl<T> TemplateParameters for T
 where
-    T: Copy + Into<ItemId>
+    T: Copy + Into<ItemId>,
 {
-    fn self_template_params(
-        &self,
-        ctx: &BindgenContext,
-    ) -> Vec<TypeId> {
-        ctx.resolve_item_fallible(*self).map_or(vec![], |item| {
-            item.self_template_params(ctx)
-        })
+    fn self_template_params(&self, ctx: &BindgenContext) -> Vec<TypeId> {
+        ctx.resolve_item_fallible(*self)
+            .map_or(vec![], |item| item.self_template_params(ctx))
     }
 }
 
 impl TemplateParameters for Item {
-    fn self_template_params(
-        &self,
-        ctx: &BindgenContext,
-    ) -> Vec<TypeId> {
+    fn self_template_params(&self, ctx: &BindgenContext) -> Vec<TypeId> {
         self.kind.self_template_params(ctx)
     }
 }
 
 impl TemplateParameters for ItemKind {
-    fn self_template_params(
-        &self,
-        ctx: &BindgenContext,
-    ) -> Vec<TypeId> {
+    fn self_template_params(&self, ctx: &BindgenContext) -> Vec<TypeId> {
         match *self {
             ItemKind::Type(ref ty) => ty.self_template_params(ctx),
             // If we start emitting bindings to explicitly instantiated
             // functions, then we'll need to check ItemKind::Function for
             // template params.
-            ItemKind::Function(_) |
-            ItemKind::Module(_) |
-            ItemKind::Var(_) => vec![],
+            ItemKind::Function(_) | ItemKind::Module(_) | ItemKind::Var(_) => {
+                vec![]
+            }
         }
     }
 }
@@ -1256,14 +1248,13 @@ impl ClangItemParser for Item {
         id.as_type_id_unchecked()
     }
 
-
     fn parse(
         cursor: clang::Cursor,
         parent_id: Option<ItemId>,
         ctx: &mut BindgenContext,
     ) -> Result<ItemId, ParseError> {
-        use ir::var::Var;
         use clang_sys::*;
+        use ir::var::Var;
 
         if !cursor.is_valid() {
             return Err(ParseError::Continue);
@@ -1281,20 +1272,28 @@ impl ClangItemParser for Item {
                     Ok(ParseResult::New(item, declaration)) => {
                         let id = ctx.next_item_id();
 
-                        ctx.add_item(Item::new(id, comment, annotations,
-                                               relevant_parent_id,
-                                               ItemKind::$what(item)),
-                                         declaration,
-                                         Some(cursor));
+                        ctx.add_item(
+                            Item::new(
+                                id,
+                                comment,
+                                annotations,
+                                relevant_parent_id,
+                                ItemKind::$what(item),
+                            ),
+                            declaration,
+                            Some(cursor),
+                        );
                         return Ok(id);
                     }
                     Ok(ParseResult::AlreadyResolved(id)) => {
                         return Ok(id);
                     }
-                    Err(ParseError::Recurse) => return Err(ParseError::Recurse),
-                    Err(ParseError::Continue) => {},
+                    Err(ParseError::Recurse) => {
+                        return Err(ParseError::Recurse)
+                    }
+                    Err(ParseError::Continue) => {}
                 }
-            }
+            };
         }
 
         try_parse!(Module);
@@ -1315,7 +1314,6 @@ impl ClangItemParser for Item {
             let definition = cursor.definition();
             let applicable_cursor = definition.unwrap_or(cursor);
 
-
             let relevant_parent_id = match definition {
                 Some(definition) => {
                     if definition != cursor {
@@ -1325,7 +1323,8 @@ impl ClangItemParser for Item {
                             cursor,
                             parent_id,
                             ctx,
-                        ).into());
+                        )
+                        .into());
                     }
                     ctx.known_semantic_parent(definition)
                         .or(parent_id)
@@ -1412,10 +1411,7 @@ impl ClangItemParser for Item {
     ) -> TypeId {
         debug!(
             "from_ty_or_ref_with_id: {:?} {:?}, {:?}, {:?}",
-            potential_id,
-            ty,
-            location,
-            parent_id
+            potential_id, ty, location, parent_id
         );
 
         if ctx.collected_typerefs() {
@@ -1426,9 +1422,8 @@ impl ClangItemParser for Item {
                 location,
                 parent_id,
                 ctx,
-            ).unwrap_or_else(
-                |_| Item::new_opaque_type(potential_id, &ty, ctx),
-            );
+            )
+            .unwrap_or_else(|_| Item::new_opaque_type(potential_id, &ty, ctx));
         }
 
         if let Some(ty) = ctx.builtin_or_resolved_ty(
@@ -1436,8 +1431,7 @@ impl ClangItemParser for Item {
             parent_id,
             &ty,
             Some(location),
-        )
-        {
+        ) {
             debug!("{:?} already resolved: {:?}", ty, location);
             return ty;
         }
@@ -1491,17 +1485,14 @@ impl ClangItemParser for Item {
 
         debug!(
             "Item::from_ty_with_id: {:?}\n\
-                \tty = {:?},\n\
-                \tlocation = {:?}",
-            id,
-            ty,
-            location
+             \tty = {:?},\n\
+             \tlocation = {:?}",
+            id, ty, location
         );
 
         if ty.kind() == clang_sys::CXType_Unexposed ||
             location.cur_type().kind() == clang_sys::CXType_Unexposed
         {
-
             if ty.is_associated_type() ||
                 location.cur_type().is_associated_type()
             {
@@ -1528,12 +1519,8 @@ impl ClangItemParser for Item {
             }
         }
 
-        if let Some(ty) = ctx.builtin_or_resolved_ty(
-            id,
-            parent_id,
-            ty,
-            Some(location),
-        )
+        if let Some(ty) =
+            ctx.builtin_or_resolved_ty(id, parent_id, ty, Some(location))
         {
             return Ok(ty);
         }
@@ -1550,11 +1537,10 @@ impl ClangItemParser for Item {
         };
 
         if valid_decl {
-            if let Some(partial) = ctx.currently_parsed_types().iter().find(
-                |ty| {
-                    *ty.decl() == declaration_to_look_for
-                },
-            )
+            if let Some(partial) = ctx
+                .currently_parsed_types()
+                .iter()
+                .find(|ty| *ty.decl() == declaration_to_look_for)
             {
                 debug!("Avoiding recursion parsing type: {:?}", ty);
                 // Unchecked because we haven't finished this type yet.
@@ -1571,7 +1557,9 @@ impl ClangItemParser for Item {
         let result = Type::from_clang_ty(id, ty, location, parent_id, ctx);
         let relevant_parent_id = parent_id.unwrap_or(current_module);
         let ret = match result {
-            Ok(ParseResult::AlreadyResolved(ty)) => Ok(ty.as_type_id_unchecked()),
+            Ok(ParseResult::AlreadyResolved(ty)) => {
+                Ok(ty.as_type_id_unchecked())
+            }
             Ok(ParseResult::New(item, declaration)) => {
                 ctx.add_item(
                     Item::new(
@@ -1619,7 +1607,7 @@ impl ClangItemParser for Item {
                 if let Err(ParseError::Recurse) = result {
                     warn!(
                         "Unknown type, assuming named template type: \
-                          id = {:?}; spelling = {}",
+                         id = {:?}; spelling = {}",
                         id,
                         ty.spelling()
                     );
@@ -1652,9 +1640,9 @@ impl ClangItemParser for Item {
 
         debug!(
             "Item::type_param:\n\
-                \twith_id = {:?},\n\
-                \tty = {} {:?},\n\
-                \tlocation: {:?}",
+             \twith_id = {:?},\n\
+             \tty = {} {:?},\n\
+             \tlocation: {:?}",
             with_id,
             ty.spelling(),
             ty,
@@ -1735,50 +1723,51 @@ impl ClangItemParser for Item {
                 (refd_spelling.is_empty() && ANON_TYPE_PARAM_RE.is_match(spelling.as_ref()))
         }
 
-        let definition =
-            if is_template_with_spelling(&location, &ty_spelling) {
-                // Situation (1)
-                location
-            } else if location.kind() == clang_sys::CXCursor_TypeRef {
-                // Situation (2)
-                match location.referenced() {
-                    Some(refd)
-                        if is_template_with_spelling(&refd, &ty_spelling) => {
-                        refd
-                    }
-                    _ => return None,
+        let definition = if is_template_with_spelling(&location, &ty_spelling) {
+            // Situation (1)
+            location
+        } else if location.kind() == clang_sys::CXCursor_TypeRef {
+            // Situation (2)
+            match location.referenced() {
+                Some(refd)
+                    if is_template_with_spelling(&refd, &ty_spelling) =>
+                {
+                    refd
                 }
-            } else {
-                // Situation (3)
-                let mut definition = None;
+                _ => return None,
+            }
+        } else {
+            // Situation (3)
+            let mut definition = None;
 
-                location.visit(|child| {
-                    let child_ty = child.cur_type();
-                    if child_ty.kind() == clang_sys::CXCursor_TypeRef &&
-                        child_ty.spelling() == ty_spelling
-                    {
-                        match child.referenced() {
-                            Some(refd)
-                                if is_template_with_spelling(
-                                    &refd,
-                                    &ty_spelling,
-                                ) => {
-                                definition = Some(refd);
-                                return clang_sys::CXChildVisit_Break;
-                            }
-                            _ => {}
+            location.visit(|child| {
+                let child_ty = child.cur_type();
+                if child_ty.kind() == clang_sys::CXCursor_TypeRef &&
+                    child_ty.spelling() == ty_spelling
+                {
+                    match child.referenced() {
+                        Some(refd)
+                            if is_template_with_spelling(
+                                &refd,
+                                &ty_spelling,
+                            ) =>
+                        {
+                            definition = Some(refd);
+                            return clang_sys::CXChildVisit_Break;
                         }
+                        _ => {}
                     }
+                }
 
-                    clang_sys::CXChildVisit_Continue
-                });
+                clang_sys::CXChildVisit_Continue
+            });
 
-                if let Some(def) = definition {
-                    def
-                } else {
-                    return None;
-                }
-            };
+            if let Some(def) = definition {
+                def
+            } else {
+                return None;
+            }
+        };
         assert!(is_template_with_spelling(&definition, &ty_spelling));
 
         // Named types are always parented to the root module. They are never
@@ -1789,9 +1778,12 @@ impl ClangItemParser for Item {
 
         if let Some(id) = ctx.get_type_param(&definition) {
             if let Some(with_id) = with_id {
-                return Some(
-                    ctx.build_ty_wrapper(with_id, id, Some(parent), &ty),
-                );
+                return Some(ctx.build_ty_wrapper(
+                    with_id,
+                    id,
+                    Some(parent),
+                    &ty,
+                ));
             } else {
                 return Some(id);
             }
diff --git a/third_party/rust/bindgen/src/ir/item_kind.rs b/third_party/rust/bindgen/src/ir/item_kind.rs
index 1e755e242ac3..4a12fef40d17 100644
--- a/third_party/rust/bindgen/src/ir/item_kind.rs
+++ b/third_party/rust/bindgen/src/ir/item_kind.rs
@@ -135,11 +135,7 @@ impl DotAttributes for ItemKind {
     where
         W: io::Write,
     {
-        writeln!(
-            out,
-            "<tr><td>kind</td><td>{}</td></tr>",
-            self.kind_name()
-        )?;
+        writeln!(out, "<tr><td>kind</td><td>{}</td></tr>", self.kind_name())?;
 
         match *self {
             ItemKind::Module(ref module) => module.dot_attributes(ctx, out),
diff --git a/third_party/rust/bindgen/src/ir/layout.rs b/third_party/rust/bindgen/src/ir/layout.rs
index 8438d2c46fb6..1c61b2ad2f88 100644
--- a/third_party/rust/bindgen/src/ir/layout.rs
+++ b/third_party/rust/bindgen/src/ir/layout.rs
@@ -1,9 +1,9 @@
 //! Intermediate representation for the physical layout of some type.
 
 use super::derive::CanDerive;
-use super::ty::{RUST_DERIVE_IN_ARRAY_LIMIT, Type, TypeKind};
-use ir::context::BindgenContext;
+use super::ty::{Type, TypeKind, RUST_DERIVE_IN_ARRAY_LIMIT};
 use clang;
+use ir::context::BindgenContext;
 use std::cmp;
 
 /// A type that represents the struct layout of a type.
@@ -107,7 +107,10 @@ impl Opaque {
 
     /// Return the known rust type we should use to create a correctly-aligned
     /// field with this layout.
-    pub fn known_rust_type_for_array(&self,ctx: &BindgenContext) -> Option<&'static str> {
+    pub fn known_rust_type_for_array(
+        &self,
+        ctx: &BindgenContext,
+    ) -> Option<&'static str> {
         Layout::known_type_for_size(ctx, self.0.align)
     }
 
@@ -124,10 +127,14 @@ impl Opaque {
     /// Return `true` if this opaque layout's array size will fit within the
     /// maximum number of array elements that Rust allows deriving traits
     /// with. Return `false` otherwise.
-    pub fn array_size_within_derive_limit(&self, ctx: &BindgenContext) -> CanDerive {
-        if self.array_size(ctx).map_or(false, |size| {
-            size <= RUST_DERIVE_IN_ARRAY_LIMIT
-        }) {
+    pub fn array_size_within_derive_limit(
+        &self,
+        ctx: &BindgenContext,
+    ) -> CanDerive {
+        if self
+            .array_size(ctx)
+            .map_or(false, |size| size <= RUST_DERIVE_IN_ARRAY_LIMIT)
+        {
             CanDerive::Yes
         } else {
             CanDerive::Manually
diff --git a/third_party/rust/bindgen/src/ir/mod.rs b/third_party/rust/bindgen/src/ir/mod.rs
index 93894f94db3b..8f6a2dac8861 100644
--- a/third_party/rust/bindgen/src/ir/mod.rs
+++ b/third_party/rust/bindgen/src/ir/mod.rs
@@ -3,10 +3,10 @@
 //! Parsing C/C++ generates the IR, while code generation outputs Rust code from
 //! the IR.
 
-pub mod annotations;
 pub mod analysis;
-pub mod comp;
+pub mod annotations;
 pub mod comment;
+pub mod comp;
 pub mod context;
 pub mod derive;
 pub mod dot;
@@ -17,8 +17,8 @@ pub mod item;
 pub mod item_kind;
 pub mod layout;
 pub mod module;
+pub mod objc;
 pub mod template;
 pub mod traversal;
 pub mod ty;
 pub mod var;
-pub mod objc;
diff --git a/third_party/rust/bindgen/src/ir/module.rs b/third_party/rust/bindgen/src/ir/module.rs
index af46d4acaed4..7a22106617c8 100644
--- a/third_party/rust/bindgen/src/ir/module.rs
+++ b/third_party/rust/bindgen/src/ir/module.rs
@@ -82,9 +82,9 @@ impl ClangSubItemParser for Module {
             CXCursor_Namespace => {
                 let module_id = ctx.module(cursor);
                 ctx.with_module(module_id, |ctx| {
-                    cursor.visit(
-                        |cursor| parse_one(ctx, cursor, Some(module_id.into())),
-                    )
+                    cursor.visit(|cursor| {
+                        parse_one(ctx, cursor, Some(module_id.into()))
+                    })
                 });
 
                 Ok(ParseResult::AlreadyResolved(module_id.into()))
diff --git a/third_party/rust/bindgen/src/ir/objc.rs b/third_party/rust/bindgen/src/ir/objc.rs
index c7801df10155..0b75e55ab4be 100644
--- a/third_party/rust/bindgen/src/ir/objc.rs
+++ b/third_party/rust/bindgen/src/ir/objc.rs
@@ -12,7 +12,7 @@ use clang_sys::CXCursor_ObjCClassRef;
 use clang_sys::CXCursor_ObjCInstanceMethodDecl;
 use clang_sys::CXCursor_ObjCProtocolDecl;
 use clang_sys::CXCursor_ObjCProtocolRef;
-use proc_macro2::{TokenStream, Ident, Span};
+use proc_macro2::{Ident, Span, TokenStream};
 
 /// Objective C interface as used in TypeKind
 ///
@@ -212,7 +212,8 @@ impl ObjCMethod {
 
     /// Formats the method call
     pub fn format_method_call(&self, args: &[TokenStream]) -> TokenStream {
-        let split_name: Vec<_> = self.name
+        let split_name: Vec<_> = self
+            .name
             .split(':')
             .filter(|p| !p.is_empty())
             .map(|name| Ident::new(name, Span::call_site()))
@@ -242,7 +243,7 @@ impl ObjCMethod {
             let name_and_sig: Vec<&str> = arg.split(' ').collect();
             let name = name_and_sig[0];
             args_without_types.push(Ident::new(name, Span::call_site()))
-        };
+        }
 
         let args = split_name
             .into_iter()
diff --git a/third_party/rust/bindgen/src/ir/template.rs b/third_party/rust/bindgen/src/ir/template.rs
index 14deb6c54573..30c578ced36d 100644
--- a/third_party/rust/bindgen/src/ir/template.rs
+++ b/third_party/rust/bindgen/src/ir/template.rs
@@ -99,7 +99,7 @@ use parse::ClangItemParser;
 /// ... |Wtf   | ... | [T]                  |
 /// ... |Qux   | ... | []                   |
 /// ----+------+-----+----------------------+
-pub trait TemplateParameters : Sized {
+pub trait TemplateParameters: Sized {
     /// Get the set of `ItemId`s that make up this template declaration's free
     /// template parameters.
     ///
@@ -135,9 +135,11 @@ pub trait TemplateParameters : Sized {
         Self: ItemAncestors,
     {
         let ancestors: Vec<_> = self.ancestors(ctx).collect();
-        ancestors.into_iter().rev().flat_map(|id| {
-            id.self_template_params(ctx).into_iter()
-        }).collect()
+        ancestors
+            .into_iter()
+            .rev()
+            .flat_map(|id| id.self_template_params(ctx).into_iter())
+            .collect()
     }
 
     /// Get only the set of template parameters that this item uses. This is a
@@ -153,10 +155,11 @@ pub trait TemplateParameters : Sized {
         );
 
         let id = *self.as_ref();
-        ctx.resolve_item(id).all_template_params(ctx)
-                    .into_iter()
-                    .filter(|p| ctx.uses_template_parameter(id, *p))
-                    .collect()
+        ctx.resolve_item(id)
+            .all_template_params(ctx)
+            .into_iter()
+            .filter(|p| ctx.uses_template_parameter(id, *p))
+            .collect()
     }
 }
 
@@ -221,34 +224,33 @@ impl TemplateInstantiation {
     ) -> Option<TemplateInstantiation> {
         use clang_sys::*;
 
-        let template_args = ty.template_args()
-            .map_or(vec![], |args| {
-                match ty.canonical_type().template_args() {
-                    Some(canonical_args) => {
-                        let arg_count = args.len();
-                        args.chain(canonical_args.skip(arg_count))
-                            .filter(|t| t.kind() != CXType_Invalid)
-                            .map(|t| {
-                                Item::from_ty_or_ref(t, t.declaration(), None, ctx)
-                            }).collect()
-                    }
-                    None => {
-                        args.filter(|t| t.kind() != CXType_Invalid)
-                            .map(|t| {
-                                Item::from_ty_or_ref(t, t.declaration(), None, ctx)
-                            }).collect()
-                    }
-                }
-            });
+        let template_args = ty.template_args().map_or(vec![], |args| match ty
+            .canonical_type()
+            .template_args()
+        {
+            Some(canonical_args) => {
+                let arg_count = args.len();
+                args.chain(canonical_args.skip(arg_count))
+                    .filter(|t| t.kind() != CXType_Invalid)
+                    .map(|t| {
+                        Item::from_ty_or_ref(t, t.declaration(), None, ctx)
+                    })
+                    .collect()
+            }
+            None => args
+                .filter(|t| t.kind() != CXType_Invalid)
+                .map(|t| Item::from_ty_or_ref(t, t.declaration(), None, ctx))
+                .collect(),
+        });
 
         let declaration = ty.declaration();
-        let definition =
-            if declaration.kind() == CXCursor_TypeAliasTemplateDecl {
-                Some(declaration)
-            } else {
-                declaration.specialized().or_else(|| {
-                    let mut template_ref = None;
-                    ty.declaration().visit(|child| {
+        let definition = if declaration.kind() == CXCursor_TypeAliasTemplateDecl
+        {
+            Some(declaration)
+        } else {
+            declaration.specialized().or_else(|| {
+                let mut template_ref = None;
+                ty.declaration().visit(|child| {
                     if child.kind() == CXCursor_TemplateRef {
                         template_ref = Some(child);
                         return CXVisit_Break;
@@ -261,9 +263,9 @@ impl TemplateInstantiation {
                     CXChildVisit_Recurse
                 });
 
-                    template_ref.and_then(|cur| cur.referenced())
-                })
-            };
+                template_ref.and_then(|cur| cur.referenced())
+            })
+        };
 
         let definition = match definition {
             Some(def) => def,
@@ -271,7 +273,7 @@ impl TemplateInstantiation {
                 if !ty.declaration().is_builtin() {
                     warn!(
                         "Could not find template definition for template \
-                           instantiation"
+                         instantiation"
                     );
                 }
                 return None;
@@ -305,7 +307,8 @@ impl IsOpaque for TemplateInstantiation {
         // arguments properly.
 
         let mut path = item.canonical_path(ctx);
-        let args: Vec<_> = self.template_arguments()
+        let args: Vec<_> = self
+            .template_arguments()
             .iter()
             .map(|arg| {
                 let arg_path = arg.canonical_path(ctx);
@@ -330,7 +333,8 @@ impl Trace for TemplateInstantiation {
     where
         T: Tracer,
     {
-        tracer.visit_kind(self.definition.into(), EdgeKind::TemplateDeclaration);
+        tracer
+            .visit_kind(self.definition.into(), EdgeKind::TemplateDeclaration);
         for arg in self.template_arguments() {
             tracer.visit_kind(arg.into(), EdgeKind::TemplateArgument);
         }
diff --git a/third_party/rust/bindgen/src/ir/traversal.rs b/third_party/rust/bindgen/src/ir/traversal.rs
index dba6ce0e0ae3..709a34ed6ab1 100644
--- a/third_party/rust/bindgen/src/ir/traversal.rs
+++ b/third_party/rust/bindgen/src/ir/traversal.rs
@@ -20,10 +20,7 @@ pub struct Edge {
 impl Edge {
     /// Construct a new edge whose referent is `to` and is of the given `kind`.
     pub fn new(to: ItemId, kind: EdgeKind) -> Edge {
-        Edge {
-            to,
-            kind,
-        }
+        Edge { to, kind }
     }
 }
 
@@ -236,7 +233,7 @@ pub fn codegen_edges(ctx: &BindgenContext, edge: Edge) -> bool {
         EdgeKind::InnerVar => cc.vars(),
         EdgeKind::Method => cc.methods(),
         EdgeKind::Constructor => cc.constructors(),
-        EdgeKind::Destructor => cc.destructors()
+        EdgeKind::Destructor => cc.destructors(),
     }
 }
 
@@ -269,10 +266,7 @@ impl<'ctx> TraversalStorage<'ctx> for ItemSet {
 /// each item. This is useful for providing debug assertions with meaningful
 /// diagnostic messages about dangling items.
 #[derive(Debug)]
-pub struct Paths<'ctx>(
-    BTreeMap<ItemId, ItemId>,
-    &'ctx BindgenContext
-);
+pub struct Paths<'ctx>(BTreeMap<ItemId, ItemId>, &'ctx BindgenContext);
 
 impl<'ctx> TraversalStorage<'ctx> for Paths<'ctx> {
     fn new(ctx: &'ctx BindgenContext) -> Self {
@@ -289,7 +283,7 @@ impl<'ctx> TraversalStorage<'ctx> for Paths<'ctx> {
             loop {
                 let predecessor = *self.0.get(&current).expect(
                     "We know we found this item id, so it must have a \
-                            predecessor",
+                     predecessor",
                 );
                 if predecessor == current {
                     break;
@@ -300,8 +294,7 @@ impl<'ctx> TraversalStorage<'ctx> for Paths<'ctx> {
             path.reverse();
             panic!(
                 "Found reference to dangling id = {:?}\nvia path = {:?}",
-                item,
-                path
+                item, path
             );
         }
 
@@ -495,13 +488,12 @@ where
 ///
 /// See `BindgenContext::assert_no_dangling_item_traversal` for more
 /// information.
-pub type AssertNoDanglingItemsTraversal<'ctx> =
-    ItemTraversal<
-        'ctx,
-        Paths<'ctx>,
-        VecDeque<ItemId>,
-        for<'a> fn(&'a BindgenContext, Edge) -> bool,
-    >;
+pub type AssertNoDanglingItemsTraversal<'ctx> = ItemTraversal<
+    'ctx,
+    Paths<'ctx>,
+    VecDeque<ItemId>,
+    for<'a> fn(&'a BindgenContext, Edge) -> bool,
+>;
 
 #[cfg(test)]
 mod tests {
diff --git a/third_party/rust/bindgen/src/ir/ty.rs b/third_party/rust/bindgen/src/ir/ty.rs
index 7330933007b5..0144bdbad1fc 100644
--- a/third_party/rust/bindgen/src/ir/ty.rs
+++ b/third_party/rust/bindgen/src/ir/ty.rs
@@ -9,8 +9,9 @@ use super::int::IntKind;
 use super::item::{IsOpaque, Item};
 use super::layout::{Layout, Opaque};
 use super::objc::ObjCInterface;
-use super::template::{AsTemplateParam, TemplateInstantiation,
-                      TemplateParameters};
+use super::template::{
+    AsTemplateParam, TemplateInstantiation, TemplateParameters,
+};
 use super::traversal::{EdgeKind, Trace, Tracer};
 use clang::{self, Cursor};
 use parse::{ClangItemParser, ParseError, ParseResult};
@@ -235,7 +236,11 @@ impl Type {
     pub fn is_incomplete_array(&self, ctx: &BindgenContext) -> Option<ItemId> {
         match self.kind {
             TypeKind::Array(item, len) => {
-                if len == 0 { Some(item.into()) } else { None }
+                if len == 0 {
+                    Some(item.into())
+                } else {
+                    None
+                }
             }
             TypeKind::ResolvedTypeRef(inner) => {
                 ctx.resolve_type(inner).is_incomplete_array(ctx)
@@ -249,14 +254,15 @@ impl Type {
         self.layout.or_else(|| {
             match self.kind {
                 TypeKind::Comp(ref ci) => ci.layout(ctx),
+                TypeKind::Array(inner, length) if length == 0 => Some(
+                    Layout::new(0, ctx.resolve_type(inner).layout(ctx)?.align),
+                ),
                 // FIXME(emilio): This is a hack for anonymous union templates.
                 // Use the actual pointer size!
-                TypeKind::Pointer(..) => {
-                    Some(Layout::new(
-                        ctx.target_pointer_size(),
-                        ctx.target_pointer_size(),
-                    ))
-                }
+                TypeKind::Pointer(..) => Some(Layout::new(
+                    ctx.target_pointer_size(),
+                    ctx.target_pointer_size(),
+                )),
                 TypeKind::ResolvedTypeRef(inner) => {
                     ctx.resolve_type(inner).layout(ctx)
                 }
@@ -295,8 +301,12 @@ impl Type {
         ctx: &BindgenContext,
     ) -> Option<Cow<'a, str>> {
         let name_info = match *self.kind() {
-            TypeKind::Pointer(inner) => Some((inner.into(), Cow::Borrowed("ptr"))),
-            TypeKind::Reference(inner) => Some((inner.into(), Cow::Borrowed("ref"))),
+            TypeKind::Pointer(inner) => {
+                Some((inner.into(), Cow::Borrowed("ptr")))
+            }
+            TypeKind::Reference(inner) => {
+                Some((inner.into(), Cow::Borrowed("ref")))
+            }
             TypeKind::Array(inner, length) => {
                 Some((inner, format!("array{}", length).into()))
             }
@@ -317,9 +327,8 @@ impl Type {
         &'tr self,
         ctx: &'tr BindgenContext,
     ) -> &'tr Type {
-        self.safe_canonical_type(ctx).expect(
-            "Should have been resolved after parsing!",
-        )
+        self.safe_canonical_type(ctx)
+            .expect("Should have been resolved after parsing!")
     }
 
     /// Returns the canonical type of this type, that is, the "inner type".
@@ -346,20 +355,19 @@ impl Type {
             TypeKind::Void |
             TypeKind::NullPtr |
             TypeKind::Pointer(..) |
+            TypeKind::BlockPointer(..) |
             TypeKind::ObjCId |
             TypeKind::ObjCSel |
             TypeKind::ObjCInterface(..) => Some(self),
 
             TypeKind::ResolvedTypeRef(inner) |
             TypeKind::Alias(inner) |
-            TypeKind::BlockPointer(inner) |
             TypeKind::TemplateAlias(inner, _) => {
                 ctx.resolve_type(inner).safe_canonical_type(ctx)
             }
-            TypeKind::TemplateInstantiation(ref inst) => {
-                ctx.resolve_type(inst.template_definition())
-                    .safe_canonical_type(ctx)
-            }
+            TypeKind::TemplateInstantiation(ref inst) => ctx
+                .resolve_type(inst.template_definition())
+                .safe_canonical_type(ctx),
 
             TypeKind::UnresolvedTypeRef(..) => None,
         }
@@ -439,8 +447,7 @@ impl DotAttributes for Type {
                 out,
                 "<tr><td>size</td><td>{}</td></tr>
                            <tr><td>align</td><td>{}</td></tr>",
-                layout.size,
-                layout.align
+                layout.size, layout.align
             )?;
             if layout.packed {
                 writeln!(out, "<tr><td>packed</td><td>true</td></tr>")?;
@@ -464,7 +471,11 @@ impl DotAttributes for TypeKind {
     where
         W: io::Write,
     {
-        writeln!(out, "<tr><td>type kind</td><td>{}</td></tr>", self.kind_name())?;
+        writeln!(
+            out,
+            "<tr><td>type kind</td><td>{}</td></tr>",
+            self.kind_name()
+        )?;
 
         if let TypeKind::Comp(ref comp) = *self {
             comp.dot_attributes(ctx, out)?;
@@ -553,19 +564,13 @@ fn is_invalid_type_param_empty_name() {
 }
 
 impl TemplateParameters for Type {
-    fn self_template_params(
-        &self,
-        ctx: &BindgenContext,
-    ) -> Vec<TypeId> {
+    fn self_template_params(&self, ctx: &BindgenContext) -> Vec<TypeId> {
         self.kind.self_template_params(ctx)
     }
 }
 
 impl TemplateParameters for TypeKind {
-    fn self_template_params(
-        &self,
-        ctx: &BindgenContext,
-    ) -> Vec<TypeId> {
+    fn self_template_params(&self, ctx: &BindgenContext) -> Vec<TypeId> {
         match *self {
             TypeKind::ResolvedTypeRef(id) => {
                 ctx.resolve_type(id).self_template_params(ctx)
@@ -681,7 +686,7 @@ pub enum TypeKind {
         clang::Type,
         clang::Cursor,
         /* parent_id */
-        Option<ItemId>
+        Option<ItemId>,
     ),
 
     /// An indirection to another type.
@@ -736,9 +741,7 @@ impl Type {
 
         debug!(
             "from_clang_ty: {:?}, ty: {:?}, loc: {:?}",
-            potential_id,
-            ty,
-            location
+            potential_id, ty, location
         );
         debug!("currently_parsed_types: {:?}", ctx.currently_parsed_types());
 
@@ -747,8 +750,9 @@ impl Type {
         // Parse objc protocols as if they were interfaces
         let mut ty_kind = ty.kind();
         match location.kind() {
-            CXCursor_ObjCProtocolDecl |
-            CXCursor_ObjCCategoryDecl => ty_kind = CXType_ObjCInterface,
+            CXCursor_ObjCProtocolDecl | CXCursor_ObjCCategoryDecl => {
+                ty_kind = CXType_ObjCInterface
+            }
             _ => {}
         }
 
@@ -758,10 +762,10 @@ impl Type {
         //        We are rewriting them as id to suppress multiple conflicting
         //        typedefs at root level
         if ty_kind == CXType_Typedef {
-            let is_template_type_param = ty.declaration().kind() ==
-                CXCursor_TemplateTypeParameter;
-            let is_canonical_objcpointer = canonical_ty.kind() ==
-                CXType_ObjCObjectPointer;
+            let is_template_type_param =
+                ty.declaration().kind() == CXCursor_TemplateTypeParameter;
+            let is_canonical_objcpointer =
+                canonical_ty.kind() == CXType_ObjCObjectPointer;
 
             // We have found a template type for objc interface
             if is_canonical_objcpointer && is_template_type_param {
@@ -769,19 +773,19 @@ impl Type {
                 // To keep it simple, just name them ids
                 name = "id".to_owned();
             }
-
         }
 
         if location.kind() == CXCursor_ClassTemplatePartialSpecialization {
             // Sorry! (Not sorry)
             warn!(
                 "Found a partial template specialization; bindgen does not \
-                   support partial template specialization! Constructing \
-                   opaque type instead."
-            );
-            return Ok(
-                ParseResult::New(Opaque::from_clang_ty(&canonical_ty, ctx), None),
+                 support partial template specialization! Constructing \
+                 opaque type instead."
             );
+            return Ok(ParseResult::New(
+                Opaque::from_clang_ty(&canonical_ty, ctx),
+                None,
+            ));
         }
 
         let kind = if location.kind() == CXCursor_TemplateRef ||
@@ -794,7 +798,8 @@ impl Type {
             }
         } else {
             match ty_kind {
-                CXType_Unexposed if *ty != canonical_ty &&
+                CXType_Unexposed
+                    if *ty != canonical_ty &&
                                     canonical_ty.kind() != CXType_Invalid &&
                                     ty.ret_type().is_none() &&
                                     // Sometime clang desugars some types more than
@@ -809,13 +814,16 @@ impl Type {
                                     //   => { ... }
                                     //
                                     // etc.
-                                    !canonical_ty.spelling().contains("type-parameter") => {
+                                    !canonical_ty.spelling().contains("type-parameter") =>
+                {
                     debug!("Looking for canonical type: {:?}", canonical_ty);
-                    return Self::from_clang_ty(potential_id,
-                                               &canonical_ty,
-                                               location,
-                                               parent_id,
-                                               ctx);
+                    return Self::from_clang_ty(
+                        potential_id,
+                        &canonical_ty,
+                        location,
+                        parent_id,
+                        ctx,
+                    );
                 }
                 CXType_Unexposed | CXType_Invalid => {
                     // For some reason Clang doesn't give us any hint in some
@@ -831,23 +839,21 @@ impl Type {
                     } else if ty.is_fully_instantiated_template() {
                         debug!(
                             "Template specialization: {:?}, {:?} {:?}",
-                            ty,
-                            location,
-                            canonical_ty
+                            ty, location, canonical_ty
                         );
                         let complex = CompInfo::from_ty(
                             potential_id,
                             ty,
                             Some(location),
                             ctx,
-                        ).expect("C'mon");
+                        )
+                        .expect("C'mon");
                         TypeKind::Comp(complex)
                     } else {
                         match location.kind() {
                             CXCursor_CXXBaseSpecifier |
                             CXCursor_ClassTemplate => {
-                                if location.kind() ==
-                                    CXCursor_CXXBaseSpecifier
+                                if location.kind() == CXCursor_CXXBaseSpecifier
                                 {
                                     // In the case we're parsing a base specifier
                                     // inside an unexposed or invalid type, it means
@@ -890,8 +896,7 @@ impl Type {
                                     // [4]: inherit-namespaced.hpp
                                     if location.spelling().chars().all(|c| {
                                         c.is_alphanumeric() || c == '_'
-                                    })
-                                    {
+                                    }) {
                                         return Err(ParseError::Recurse);
                                     }
                                 } else {
@@ -909,13 +914,14 @@ impl Type {
                                     Err(_) => {
                                         warn!(
                                             "Could not create complex type \
-                                               from class template or base \
-                                               specifier, using opaque blob"
-                                        );
-                                        let opaque = Opaque::from_clang_ty(ty, ctx);
-                                        return Ok(
-                                            ParseResult::New(opaque, None),
+                                             from class template or base \
+                                             specifier, using opaque blob"
                                         );
+                                        let opaque =
+                                            Opaque::from_clang_ty(ty, ctx);
+                                        return Ok(ParseResult::New(
+                                            opaque, None,
+                                        ));
                                     }
                                 }
                             }
@@ -938,7 +944,8 @@ impl Type {
 
                                             name = current.spelling();
 
-                                            let inner_ty = cur.typedef_type()
+                                            let inner_ty = cur
+                                                .typedef_type()
                                                 .expect("Not valid Type?");
                                             inner = Ok(Item::from_ty_or_ref(
                                                 inner_ty,
@@ -948,13 +955,14 @@ impl Type {
                                             ));
                                         }
                                         CXCursor_TemplateTypeParameter => {
-                                            let param =
-                                                Item::type_param(None,
-                                                                 cur,
-                                                                 ctx)
-                                                .expect("Item::type_param shouldn't \
-                                                         ever fail if we are looking \
-                                                         at a TemplateTypeParameter");
+                                            let param = Item::type_param(
+                                                None, cur, ctx,
+                                            )
+                                            .expect(
+                                                "Item::type_param shouldn't \
+                                                 ever fail if we are looking \
+                                                 at a TemplateTypeParameter",
+                                            );
                                             args.push(param);
                                         }
                                         _ => {}
@@ -967,7 +975,7 @@ impl Type {
                                     Err(..) => {
                                         error!(
                                             "Failed to parse template alias \
-                                               {:?}",
+                                             {:?}",
                                             location
                                         );
                                         return Err(ParseError::Continue);
@@ -1003,10 +1011,8 @@ impl Type {
 
                                 debug!(
                                     "TypeRef: location = {:?}; referenced = \
-                                        {:?}; referenced_ty = {:?}",
-                                    location,
-                                    referenced,
-                                    referenced_ty
+                                     {:?}; referenced_ty = {:?}",
+                                    location, referenced, referenced_ty
                                 );
 
                                 let id = Item::from_ty_or_ref_with_id(
@@ -1016,7 +1022,9 @@ impl Type {
                                     parent_id,
                                     ctx,
                                 );
-                                return Ok(ParseResult::AlreadyResolved(id.into()));
+                                return Ok(ParseResult::AlreadyResolved(
+                                    id.into(),
+                                ));
                             }
                             CXCursor_NamespaceRef => {
                                 return Err(ParseError::Continue);
@@ -1072,11 +1080,10 @@ impl Type {
                     let inner =
                         Item::from_ty_or_ref(pointee, location, None, ctx);
                     TypeKind::BlockPointer(inner)
-                },
+                }
                 // XXX: RValueReference is most likely wrong, but I don't think we
                 // can even add bindings for that, so huh.
-                CXType_RValueReference |
-                CXType_LValueReference => {
+                CXType_RValueReference | CXType_LValueReference => {
                     let inner = Item::from_ty_or_ref(
                         ty.pointee_type().unwrap(),
                         location,
@@ -1086,14 +1093,14 @@ impl Type {
                     TypeKind::Reference(inner)
                 }
                 // XXX DependentSizedArray is wrong
-                CXType_VariableArray |
-                CXType_DependentSizedArray => {
+                CXType_VariableArray | CXType_DependentSizedArray => {
                     let inner = Item::from_ty(
                         ty.elem_type().as_ref().unwrap(),
                         location,
                         None,
                         ctx,
-                    ).expect("Not able to resolve array element?");
+                    )
+                    .expect("Not able to resolve array element?");
                     TypeKind::Pointer(inner)
                 }
                 CXType_IncompleteArray => {
@@ -1102,13 +1109,12 @@ impl Type {
                         location,
                         None,
                         ctx,
-                    ).expect("Not able to resolve array element?");
+                    )
+                    .expect("Not able to resolve array element?");
                     TypeKind::Array(inner, 0)
                 }
-                CXType_FunctionNoProto |
-                CXType_FunctionProto => {
-                    let signature =
-                        FunctionSig::from_ty(ty, &location, ctx)?;
+                CXType_FunctionNoProto | CXType_FunctionProto => {
+                    let signature = FunctionSig::from_ty(ty, &location, ctx)?;
                     TypeKind::Function(signature)
                 }
                 CXType_Typedef => {
@@ -1135,7 +1141,8 @@ impl Type {
                         ty,
                         Some(location),
                         ctx,
-                    ).expect("Not a complex type?");
+                    )
+                    .expect("Not a complex type?");
 
                     if name.is_empty() {
                         // The pretty-printed name may contain typedefed name,
@@ -1154,7 +1161,8 @@ impl Type {
                         location,
                         None,
                         ctx,
-                    ).expect("Not able to resolve vector element?");
+                    )
+                    .expect("Not able to resolve vector element?");
                     TypeKind::Vector(inner, ty.num_elements().unwrap())
                 }
                 CXType_ConstantArray => {
@@ -1163,7 +1171,8 @@ impl Type {
                         location,
                         None,
                         ctx,
-                    ).expect("Not able to resolve array element?");
+                    )
+                    .expect("Not able to resolve array element?");
                     TypeKind::Array(inner, ty.num_elements().unwrap())
                 }
                 CXType_Elaborated => {
@@ -1177,8 +1186,7 @@ impl Type {
                 }
                 CXType_ObjCId => TypeKind::ObjCId,
                 CXType_ObjCSel => TypeKind::ObjCSel,
-                CXType_ObjCClass |
-                CXType_ObjCInterface => {
+                CXType_ObjCClass | CXType_ObjCInterface => {
                     let interface = ObjCInterface::from_ty(&location, ctx)
                         .expect("Not a valid objc interface?");
                     name = interface.rust_name();
diff --git a/third_party/rust/bindgen/src/ir/var.rs b/third_party/rust/bindgen/src/ir/var.rs
index 2180a1b8e115..921dcf98c706 100644
--- a/third_party/rust/bindgen/src/ir/var.rs
+++ b/third_party/rust/bindgen/src/ir/var.rs
@@ -1,12 +1,12 @@
 //! Intermediate representation of variables.
 
-use callbacks::MacroParsingBehavior;
 use super::context::{BindgenContext, TypeId};
 use super::dot::DotAttributes;
 use super::function::cursor_mangling;
 use super::int::IntKind;
 use super::item::Item;
 use super::ty::{FloatKind, TypeKind};
+use callbacks::MacroParsingBehavior;
 use cexpr;
 use clang;
 use parse::{ClangItemParser, ClangSubItemParser, ParseError, ParseResult};
@@ -133,9 +133,9 @@ impl ClangSubItemParser for Var {
         cursor: clang::Cursor,
         ctx: &mut BindgenContext,
     ) -> Result<ParseResult<Self>, ParseError> {
-        use clang_sys::*;
         use cexpr::expr::EvalResult;
         use cexpr::literal::CChar;
+        use clang_sys::*;
         match cursor.kind() {
             CXCursor_MacroDefinition => {
                 if let Some(callbacks) = ctx.parse_callbacks() {
@@ -205,9 +205,12 @@ impl ClangSubItemParser for Var {
                         (TypeKind::Pointer(char_ty), VarType::String(val))
                     }
                     EvalResult::Int(Wrapping(value)) => {
-                        let kind = ctx.parse_callbacks()
+                        let kind = ctx
+                            .parse_callbacks()
                             .and_then(|c| c.int_macro(&name, value))
-                            .unwrap_or_else(|| default_macro_constant_type(value));
+                            .unwrap_or_else(|| {
+                                default_macro_constant_type(value)
+                            });
 
                         (TypeKind::Int(kind), VarType::Int(value))
                     }
@@ -239,7 +242,7 @@ impl ClangSubItemParser for Var {
                             ty.kind(),
                             CXType_Auto,
                             "Couldn't resolve constant type, and it \
-                                   wasn't an nondeductible auto type!"
+                             wasn't an nondeductible auto type!"
                         );
                         return Err(e);
                     }
@@ -249,9 +252,9 @@ impl ClangSubItemParser for Var {
                 // tests/headers/inner_const.hpp
                 //
                 // That's fine because in that case we know it's not a literal.
-                let canonical_ty = ctx.safe_resolve_type(ty).and_then(|t| {
-                    t.safe_canonical_type(ctx)
-                });
+                let canonical_ty = ctx
+                    .safe_resolve_type(ty)
+                    .and_then(|t| t.safe_canonical_type(ctx));
 
                 let is_integer = canonical_ty.map_or(false, |t| t.is_integer());
                 let is_float = canonical_ty.map_or(false, |t| t.is_float());
@@ -266,27 +269,29 @@ impl ClangSubItemParser for Var {
                         _ => unreachable!(),
                     };
 
-                    let mut val = cursor
-                        .evaluate()
-                        .and_then(|v| v.as_int());
+                    let mut val = cursor.evaluate().and_then(|v| v.as_int());
                     if val.is_none() || !kind.signedness_matches(val.unwrap()) {
                         let tu = ctx.translation_unit();
                         val = get_integer_literal_from_cursor(&cursor, tu);
                     }
 
-                    val.map(|val| if kind == IntKind::Bool {
-                        VarType::Bool(val != 0)
-                    } else {
-                        VarType::Int(val)
+                    val.map(|val| {
+                        if kind == IntKind::Bool {
+                            VarType::Bool(val != 0)
+                        } else {
+                            VarType::Int(val)
+                        }
                     })
                 } else if is_float {
-                    cursor.evaluate().and_then(|v| v.as_double()).map(
-                        VarType::Float,
-                    )
+                    cursor
+                        .evaluate()
+                        .and_then(|v| v.as_double())
+                        .map(VarType::Float)
                 } else {
-                    cursor.evaluate().and_then(|v| v.as_literal_string()).map(
-                        VarType::String,
-                    )
+                    cursor
+                        .evaluate()
+                        .and_then(|v| v.as_literal_string())
+                        .map(VarType::String)
                 };
 
                 let mangling = cursor_mangling(ctx, &cursor);
@@ -355,8 +360,7 @@ fn get_integer_literal_from_cursor(
     let mut value = None;
     cursor.visit(|c| {
         match c.kind() {
-            CXCursor_IntegerLiteral |
-            CXCursor_UnaryOperator => {
+            CXCursor_IntegerLiteral | CXCursor_UnaryOperator => {
                 value = parse_int_literal_tokens(&c);
             }
             CXCursor_UnexposedExpr => {
diff --git a/third_party/rust/bindgen/src/lib.rs b/third_party/rust/bindgen/src/lib.rs
index 45944c1daa29..57d46be7236a 100644
--- a/third_party/rust/bindgen/src/lib.rs
+++ b/third_party/rust/bindgen/src/lib.rs
@@ -14,7 +14,7 @@
 // constant.
 #![allow(non_upper_case_globals)]
 // `quote!` nests quite deeply.
-#![recursion_limit="128"]
+#![recursion_limit = "128"]
 
 #[macro_use]
 extern crate bitflags;
@@ -23,7 +23,7 @@ extern crate cexpr;
 #[allow(unused_extern_crates)]
 extern crate cfg_if;
 extern crate clang_sys;
-extern crate fxhash;
+extern crate rustc_hash;
 #[macro_use]
 extern crate lazy_static;
 extern crate peeking_take_while;
@@ -32,6 +32,7 @@ extern crate quote;
 extern crate proc_macro2;
 extern crate regex;
 extern crate shlex;
+#[cfg(feature = "which-rustfmt")]
 extern crate which;
 
 #[cfg(feature = "logging")]
@@ -81,26 +82,26 @@ doc_mod!(ir, ir_docs);
 doc_mod!(parse, parse_docs);
 doc_mod!(regex_set, regex_set_docs);
 
-pub use features::{LATEST_STABLE_RUST, RUST_TARGET_STRINGS, RustTarget};
+pub use codegen::EnumVariation;
 use features::RustFeatures;
+pub use features::{RustTarget, LATEST_STABLE_RUST, RUST_TARGET_STRINGS};
 use ir::context::{BindgenContext, ItemId};
 use ir::item::Item;
 use parse::{ClangItemParser, ParseError};
 use regex_set::RegexSet;
-pub use codegen::EnumVariation;
 
 use std::borrow::Cow;
 use std::fs::{File, OpenOptions};
 use std::io::{self, Write};
-use std::iter;
 use std::path::{Path, PathBuf};
 use std::process::{Command, Stdio};
 use std::sync::Arc;
+use std::{env, iter};
 
 // Some convenient typedefs for a fast hash map and hash set.
-type HashMap<K, V> = ::fxhash::FxHashMap<K, V>;
-type HashSet<K> = ::fxhash::FxHashSet<K>;
-pub(crate) use ::std::collections::hash_map::Entry;
+type HashMap<K, V> = ::rustc_hash::FxHashMap<K, V>;
+type HashSet<K> = ::rustc_hash::FxHashSet<K>;
+pub(crate) use std::collections::hash_map::Entry;
 
 fn args_are_cpp(clang_args: &[String]) -> bool {
     return clang_args
@@ -224,13 +225,21 @@ impl Builder {
         output_vector.push(self.options.rust_target.into());
 
         if self.options.default_enum_style != Default::default() {
-            output_vector.push("--default-enum-variant=".into());
-            output_vector.push(match self.options.default_enum_style {
-                codegen::EnumVariation::Rust => "rust",
-                codegen::EnumVariation::Bitfield => "bitfield",
-                codegen::EnumVariation::Consts => "consts",
-                codegen::EnumVariation::ModuleConsts => "moduleconsts",
-            }.into())
+            output_vector.push("--default-enum-style=".into());
+            output_vector.push(
+                match self.options.default_enum_style {
+                    codegen::EnumVariation::Rust {
+                        non_exhaustive: false,
+                    } => "rust",
+                    codegen::EnumVariation::Rust {
+                        non_exhaustive: true,
+                    } => "rust_non_exhaustive",
+                    codegen::EnumVariation::Bitfield => "bitfield",
+                    codegen::EnumVariation::Consts => "consts",
+                    codegen::EnumVariation::ModuleConsts => "moduleconsts",
+                }
+                .into(),
+            )
         }
 
         self.options
@@ -253,6 +262,16 @@ impl Builder {
             })
             .count();
 
+        self.options
+            .rustified_non_exhaustive_enums
+            .get_items()
+            .iter()
+            .map(|item| {
+                output_vector.push("--rustified-enum-non-exhaustive".into());
+                output_vector.push(item.to_owned());
+            })
+            .count();
+
         self.options
             .constified_enum_modules
             .get_items()
@@ -444,6 +463,10 @@ impl Builder {
             output_vector.push("--no-prepend-enum-name".into());
         }
 
+        if self.options.array_pointers_in_arguments {
+            output_vector.push("--use-array-pointers-in-arguments".into());
+        }
+
         self.options
             .opaque_types
             .get_items()
@@ -523,7 +546,8 @@ impl Builder {
             output_vector.push("--no-rustfmt-bindings".into());
         }
 
-        if let Some(path) = self.options
+        if let Some(path) = self
+            .options
             .rustfmt_configuration_file
             .as_ref()
             .and_then(|f| f.to_str())
@@ -596,9 +620,8 @@ impl Builder {
     ///
     /// The file `name` will be added to the clang arguments.
     pub fn header_contents(mut self, name: &str, contents: &str) -> Builder {
-        self.input_header_contents.push(
-            (name.into(), contents.into()),
-        );
+        self.input_header_contents
+            .push((name.into(), contents.into()));
         self
     }
 
@@ -630,7 +653,7 @@ impl Builder {
     /// implement some processing on comments to work around issues as described
     /// in:
     ///
-    /// https://github.com/rust-lang-nursery/rust-bindgen/issues/426
+    /// https://github.com/rust-lang/rust-bindgen/issues/426
     pub fn generate_comments(mut self, doit: bool) -> Self {
         self.options.generate_comments = doit;
         self
@@ -694,7 +717,7 @@ impl Builder {
     /// However, some old libclang versions seem to return incorrect results in
     /// some cases for non-mangled functions, see [1], so we allow disabling it.
     ///
-    /// [1]: https://github.com/rust-lang-nursery/rust-bindgen/issues/528
+    /// [1]: https://github.com/rust-lang/rust-bindgen/issues/528
     pub fn trust_clang_mangling(mut self, doit: bool) -> Self {
         self.options.enable_mangling = doit;
         self
@@ -785,7 +808,10 @@ impl Builder {
     }
 
     /// Set the default style of code to generate for enums
-    pub fn default_enum_style(mut self, arg: codegen::EnumVariation) -> Builder {
+    pub fn default_enum_style(
+        mut self,
+        arg: codegen::EnumVariation,
+    ) -> Builder {
         self.options.default_enum_style = arg;
         self
     }
@@ -806,15 +832,27 @@ impl Builder {
     /// This makes bindgen generate enums instead of constants. Regular
     /// expressions are supported.
     ///
-    /// **Use this with caution.** You should not be using Rust enums unless
-    /// you have complete control of the C/C++ code that you're binding to.
-    /// Take a look at https://github.com/rust-lang/rust/issues/36927 for
-    /// more information.
+    /// **Use this with caution,** you probably want to use the non_exhaustive
+    /// flavor of rust enums instead of this one. Take a look at
+    /// https://github.com/rust-lang/rust/issues/36927 for more information.
     pub fn rustified_enum<T: AsRef<str>>(mut self, arg: T) -> Builder {
         self.options.rustified_enums.insert(arg);
         self
     }
 
+    /// Mark the given enum (or set of enums, if using a pattern) as a Rust
+    /// enum with the #[non_exhaustive] attribute.
+    ///
+    /// This makes bindgen generate enums instead of constants. Regular
+    /// expressions are supported.
+    pub fn rustified_non_exhaustive_enum<T: AsRef<str>>(
+        mut self,
+        arg: T,
+    ) -> Builder {
+        self.options.rustified_non_exhaustive_enums.insert(arg);
+        self
+    }
+
     /// Mark the given enum (or set of enums, if using a pattern) as a set of
     /// constants that are not to be put into a module.
     pub fn constified_enum<T: AsRef<str>>(mut self, arg: T) -> Builder {
@@ -1122,7 +1160,7 @@ impl Builder {
     /// [`ParseCallbacks`](./callbacks/trait.ParseCallbacks.html) documentation.
     pub fn parse_callbacks(
         mut self,
-        cb: Box<callbacks::ParseCallbacks>,
+        cb: Box<dyn callbacks::ParseCallbacks>,
     ) -> Self {
         self.options.parse_callbacks = Some(cb);
         self
@@ -1176,7 +1214,9 @@ impl Builder {
     /// Generate the Rust bindings using the options built up thus far.
     pub fn generate(mut self) -> Result<Bindings, ()> {
         // Add any extra arguments from the environment to the clang command line.
-        if let Some(extra_clang_args) = std::env::var("BINDGEN_EXTRA_CLANG_ARGS").ok() {
+        if let Some(extra_clang_args) =
+            env::var("BINDGEN_EXTRA_CLANG_ARGS").ok()
+        {
             // Try to parse it with shell quoting. If we fail, make it one single big argument.
             if let Some(strings) = shlex::split(&extra_clang_args) {
                 self.options.clang_args.extend(strings);
@@ -1187,18 +1227,18 @@ impl Builder {
 
         // Transform input headers to arguments on the clang command line.
         self.options.input_header = self.input_headers.pop();
-        self.options.clang_args.extend(
-            self.input_headers
-                .drain(..)
-                .flat_map(|header| {
-                    iter::once("-include".into()).chain(iter::once(header))
-                }),
-        );
+        self.options
+            .clang_args
+            .extend(self.input_headers.drain(..).flat_map(|header| {
+                iter::once("-include".into()).chain(iter::once(header))
+            }));
 
         self.options.input_unsaved_files.extend(
-            self.input_header_contents.drain(..).map(|(name, contents)| {
-                clang::UnsavedFile::new(&name, &contents)
-            }),
+            self.input_header_contents
+                .drain(..)
+                .map(|(name, contents)| {
+                    clang::UnsavedFile::new(&name, &contents)
+                }),
         );
 
         Bindings::generate(self.options)
@@ -1211,14 +1251,19 @@ impl Builder {
     /// `__bindgen.ii`
     pub fn dump_preprocessed_input(&self) -> io::Result<()> {
         fn check_is_cpp(name_file: &str) -> bool {
-            name_file.ends_with(".hpp") || name_file.ends_with(".hxx")
-                || name_file.ends_with(".hh")
-                || name_file.ends_with(".h++")
+            name_file.ends_with(".hpp") ||
+                name_file.ends_with(".hxx") ||
+                name_file.ends_with(".hh") ||
+                name_file.ends_with(".h++")
         }
 
-        let clang = clang_sys::support::Clang::find(None, &[]).ok_or_else(|| {
-            io::Error::new(io::ErrorKind::Other, "Cannot find clang executable")
-        })?;
+        let clang =
+            clang_sys::support::Clang::find(None, &[]).ok_or_else(|| {
+                io::Error::new(
+                    io::ErrorKind::Other,
+                    "Cannot find clang executable",
+                )
+            })?;
 
         // The contents of a wrapper file that includes all the input header
         // files.
@@ -1310,6 +1355,12 @@ impl Builder {
         self.options.no_hash_types.insert(arg.into());
         self
     }
+
+    /// Set whether `arr[size]` should be treated as `*mut T` or `*mut [T; size]` (same for mut)
+    pub fn array_pointers_in_arguments(mut self, doit: bool) -> Self {
+        self.options.array_pointers_in_arguments = doit;
+        self
+    }
 }
 
 /// Configuration options for generated bindings.
@@ -1357,6 +1408,8 @@ struct BindgenOptions {
     /// The enum patterns to mark an enum as a Rust enum.
     rustified_enums: RegexSet,
 
+    rustified_non_exhaustive_enums: RegexSet,
+
     /// The enum patterns to mark an enum as a module of constants.
     constified_enum_modules: RegexSet,
 
@@ -1468,7 +1521,7 @@ struct BindgenOptions {
 
     /// A user-provided visitor to allow customizing different kinds of
     /// situations.
-    parse_callbacks: Option<Box<callbacks::ParseCallbacks>>,
+    parse_callbacks: Option<Box<dyn callbacks::ParseCallbacks>>,
 
     /// Which kind of items should we generate? By default, we'll generate all
     /// of them.
@@ -1507,7 +1560,7 @@ struct BindgenOptions {
     /// However, some old libclang versions seem to return incorrect results in
     /// some cases for non-mangled functions, see [1], so we allow disabling it.
     ///
-    /// [1]: https://github.com/rust-lang-nursery/rust-bindgen/issues/528
+    /// [1]: https://github.com/rust-lang/rust-bindgen/issues/528
     enable_mangling: bool,
 
     /// Whether to detect include paths using clang_sys.
@@ -1533,7 +1586,6 @@ struct BindgenOptions {
 
     /// The absolute path to the rustfmt configuration file, if None, the standard rustfmt
     /// options are used.
-
     rustfmt_configuration_file: Option<PathBuf>,
 
     /// The set of types that we should not derive `PartialEq` for.
@@ -1544,6 +1596,9 @@ struct BindgenOptions {
 
     /// The set of types that we should not derive `Hash` for.
     no_hash_types: RegexSet,
+
+    /// Decide if C arrays should be regular pointers in rust or array pointers
+    array_pointers_in_arguments: bool,
 }
 
 /// TODO(emilio): This is sort of a lie (see the error message that results from
@@ -1607,6 +1662,7 @@ impl Default for BindgenOptions {
             default_enum_style: Default::default(),
             bitfield_enums: Default::default(),
             rustified_enums: Default::default(),
+            rustified_non_exhaustive_enums: Default::default(),
             constified_enums: Default::default(),
             constified_enum_modules: Default::default(),
             builtins: false,
@@ -1656,6 +1712,7 @@ impl Default for BindgenOptions {
             no_partialeq_types: Default::default(),
             no_copy_types: Default::default(),
             no_hash_types: Default::default(),
+            array_pointers_in_arguments: false,
         }
     }
 }
@@ -1672,9 +1729,10 @@ fn ensure_libclang_is_loaded() {
     lazy_static! {
         static ref LIBCLANG: Arc<clang_sys::SharedLibrary> = {
             clang_sys::load().expect("Unable to find libclang");
-            clang_sys::get_library()
-                .expect("We just loaded libclang and it had better still be \
-                        here!")
+            clang_sys::get_library().expect(
+                "We just loaded libclang and it had better still be \
+                 here!",
+            )
         };
     }
 
@@ -1695,7 +1753,10 @@ impl Bindings {
     ) -> Result<Bindings, ()> {
         ensure_libclang_is_loaded();
 
-        debug!("Generating bindings, libclang at {}", clang_sys::get_library().unwrap().path().display());
+        debug!(
+            "Generating bindings, libclang at {}",
+            clang_sys::get_library().unwrap().path().display()
+        );
 
         options.build();
 
@@ -1708,32 +1769,45 @@ impl Bindings {
             // promote them to `-isystem`.
             let clang_args_for_clang_sys = {
                 let mut last_was_include_prefix = false;
-                options.clang_args.iter().filter(|arg| {
-                    if last_was_include_prefix {
-                        last_was_include_prefix = false;
-                        return false;
-                    }
+                options
+                    .clang_args
+                    .iter()
+                    .filter(|arg| {
+                        if last_was_include_prefix {
+                            last_was_include_prefix = false;
+                            return false;
+                        }
 
-                    let arg = &**arg;
+                        let arg = &**arg;
 
-                    // https://clang.llvm.org/docs/ClangCommandLineReference.html
-                    // -isystem and -isystem-after are harmless.
-                    if arg == "-I" || arg == "--include-directory" {
-                        last_was_include_prefix = true;
-                        return false;
-                    }
+                        // https://clang.llvm.org/docs/ClangCommandLineReference.html
+                        // -isystem and -isystem-after are harmless.
+                        if arg == "-I" || arg == "--include-directory" {
+                            last_was_include_prefix = true;
+                            return false;
+                        }
 
-                    if arg.starts_with("-I") || arg.starts_with("--include-directory=") {
-                        return false;
-                    }
+                        if arg.starts_with("-I") ||
+                            arg.starts_with("--include-directory=")
+                        {
+                            return false;
+                        }
 
-                    true
-                }).cloned().collect::<Vec<_>>()
+                        true
+                    })
+                    .cloned()
+                    .collect::<Vec<_>>()
             };
 
-            debug!("Trying to find clang with flags: {:?}", clang_args_for_clang_sys);
+            debug!(
+                "Trying to find clang with flags: {:?}",
+                clang_args_for_clang_sys
+            );
 
-            let clang = match clang_sys::support::Clang::find(None, &clang_args_for_clang_sys) {
+            let clang = match clang_sys::support::Clang::find(
+                None,
+                &clang_args_for_clang_sys,
+            ) {
                 None => return,
                 Some(clang) => clang,
             };
@@ -1743,9 +1817,9 @@ impl Bindings {
             // Whether we are working with C or C++ inputs.
             let is_cpp = args_are_cpp(&options.clang_args);
             let search_paths = if is_cpp {
-              clang.cpp_search_paths
+                clang.cpp_search_paths
             } else {
-              clang.c_search_paths
+                clang.c_search_paths
             };
 
             if let Some(search_paths) = search_paths {
@@ -1778,7 +1852,10 @@ impl Bindings {
                     return Err(());
                 }
                 if !can_read(&md.permissions()) {
-                    eprintln!("error: insufficient permissions to read '{}'", h);
+                    eprintln!(
+                        "error: insufficient permissions to read '{}'",
+                        h
+                    );
                     return Err(());
                 }
                 options.clang_args.push(h.clone())
@@ -1798,8 +1875,7 @@ impl Bindings {
         let mut context = BindgenContext::new(options);
 
         {
-            let _t = time::Timer::new("parse")
-                                  .with_output(time_phases);
+            let _t = time::Timer::new("parse").with_output(time_phases);
             parse(&mut context)?;
         }
 
@@ -1809,14 +1885,14 @@ impl Bindings {
             options: options,
             module: quote! {
                 #( #items )*
-            }
+            },
         })
     }
 
     /// Convert these bindings into source text (with raw lines prepended).
     pub fn to_string(&self) -> String {
         let mut bytes = vec![];
-        self.write(Box::new(&mut bytes) as Box<Write>)
+        self.write(Box::new(&mut bytes) as Box<dyn Write>)
             .expect("writing to a vec cannot fail");
         String::from_utf8(bytes)
             .expect("we should only write bindings that are valid utf-8")
@@ -1834,7 +1910,7 @@ impl Bindings {
     }
 
     /// Write these bindings as source text to the given `Write`able.
-    pub fn write<'a>(&self, mut writer: Box<Write + 'a>) -> io::Result<()> {
+    pub fn write<'a>(&self, mut writer: Box<dyn Write + 'a>) -> io::Result<()> {
         writer.write(
             "/* automatically generated by rust-bindgen */\n\n".as_bytes(),
         )?;
@@ -1853,15 +1929,41 @@ impl Bindings {
         match self.rustfmt_generated_string(&bindings) {
             Ok(rustfmt_bindings) => {
                 writer.write(rustfmt_bindings.as_bytes())?;
-            },
+            }
             Err(err) => {
-                eprintln!("Failed to run rustfmt: {} (non-fatal, continuing)", err);
+                eprintln!(
+                    "Failed to run rustfmt: {} (non-fatal, continuing)",
+                    err
+                );
                 writer.write(bindings.as_bytes())?;
-            },
+            }
         }
         Ok(())
     }
 
+    /// Gets the rustfmt path to rustfmt the generated bindings.
+    fn rustfmt_path<'a>(&'a self) -> io::Result<Cow<'a, PathBuf>> {
+        debug_assert!(self.options.rustfmt_bindings);
+        if let Some(ref p) = self.options.rustfmt_path {
+            return Ok(Cow::Borrowed(p));
+        }
+        if let Ok(rustfmt) = env::var("RUSTFMT") {
+            return Ok(Cow::Owned(rustfmt.into()));
+        }
+        #[cfg(feature = "which-rustfmt")]
+        match which::which("rustfmt") {
+            Ok(p) => Ok(Cow::Owned(p)),
+            Err(e) => {
+                Err(io::Error::new(io::ErrorKind::Other, format!("{}", e)))
+            }
+        }
+        #[cfg(not(feature = "which-rustfmt"))]
+        Err(io::Error::new(
+            io::ErrorKind::Other,
+            "which wasn't enabled, and no rustfmt binary specified",
+        ))
+    }
+
     /// Checks if rustfmt_bindings is set and runs rustfmt on the string
     fn rustfmt_generated_string<'a>(
         &self,
@@ -1874,25 +1976,13 @@ impl Bindings {
             return Ok(Cow::Borrowed(source));
         }
 
-        let rustfmt = match self.options.rustfmt_path {
-            Some(ref p) => Cow::Borrowed(p),
-            None => {
-                let path = which::which("rustfmt")
-                    .map_err(|e| {
-                        io::Error::new(io::ErrorKind::Other, format!("{}", e))
-                    })?;
-
-                Cow::Owned(path)
-            }
-        };
-
+        let rustfmt = self.rustfmt_path()?;
         let mut cmd = Command::new(&*rustfmt);
 
-        cmd
-            .stdin(Stdio::piped())
-            .stdout(Stdio::piped());
+        cmd.stdin(Stdio::piped()).stdout(Stdio::piped());
 
-        if let Some(path) = self.options
+        if let Some(path) = self
+            .options
             .rustfmt_configuration_file
             .as_ref()
             .and_then(|f| f.to_str())
@@ -1918,29 +2008,28 @@ impl Bindings {
         io::copy(&mut child_stdout, &mut output)?;
 
         let status = child.wait()?;
-        let source = stdin_handle.join()
-            .expect("The thread writing to rustfmt's stdin doesn't do \
-                     anything that could panic");
+        let source = stdin_handle.join().expect(
+            "The thread writing to rustfmt's stdin doesn't do \
+             anything that could panic",
+        );
 
         match String::from_utf8(output) {
-            Ok(bindings) => {
-                match status.code() {
-                    Some(0) => Ok(Cow::Owned(bindings)),
-                    Some(2) => Err(io::Error::new(
-                        io::ErrorKind::Other,
-                        "Rustfmt parsing errors.".to_string(),
-                    )),
-                    Some(3) => {
-                        warn!("Rustfmt could not format some lines.");
-                        Ok(Cow::Owned(bindings))
-                    }
-                    _ => Err(io::Error::new(
-                        io::ErrorKind::Other,
-                        "Internal rustfmt error".to_string(),
-                    )),
+            Ok(bindings) => match status.code() {
+                Some(0) => Ok(Cow::Owned(bindings)),
+                Some(2) => Err(io::Error::new(
+                    io::ErrorKind::Other,
+                    "Rustfmt parsing errors.".to_string(),
+                )),
+                Some(3) => {
+                    warn!("Rustfmt could not format some lines.");
+                    Ok(Cow::Owned(bindings))
                 }
+                _ => Err(io::Error::new(
+                    io::ErrorKind::Other,
+                    "Internal rustfmt error".to_string(),
+                )),
             },
-            _ => Ok(Cow::Owned(source))
+            _ => Ok(Cow::Owned(source)),
         }
     }
 }
@@ -1991,7 +2080,6 @@ fn parse(context: &mut BindgenContext) -> Result<(), ()> {
     let cursor = context.translation_unit().cursor();
 
     if context.options().emit_ast {
-
         fn dump_if_not_builtin(cur: &clang::Cursor) -> CXChildVisitResult {
             if !cur.is_builtin() {
                 clang::ast_dump(&cur, 0)
@@ -2031,9 +2119,10 @@ pub fn clang_version() -> ClangVersion {
     }
 
     let raw_v: String = clang::extract_clang_version();
-    let split_v: Option<Vec<&str>> = raw_v.split_whitespace().nth(2).map(|v| {
-        v.split('.').collect()
-    });
+    let split_v: Option<Vec<&str>> = raw_v
+        .split_whitespace()
+        .nth(2)
+        .map(|v| v.split('.').collect());
     match split_v {
         Some(v) => {
             if v.len() >= 2 {
@@ -2070,13 +2159,14 @@ fn commandline_flag_unit_test_function() {
         "--no-derive-default",
         "--generate",
         "functions,types,vars,methods,constructors,destructors",
-    ].iter()
-        .map(|&x| x.into())
-        .collect::<Vec<String>>();
+    ]
+    .iter()
+    .map(|&x| x.into())
+    .collect::<Vec<String>>();
 
-    assert!(test_cases.iter().all(
-        |ref x| command_line_flags.contains(x),
-    ));
+    assert!(test_cases
+        .iter()
+        .all(|ref x| command_line_flags.contains(x),));
 
     //Test 2
     let bindings = ::builder()
@@ -2095,13 +2185,13 @@ fn commandline_flag_unit_test_function() {
         "Distinct_Type",
         "--whitelist-function",
         "safe_function",
-    ].iter()
-        .map(|&x| x.into())
-        .collect::<Vec<String>>();
+    ]
+    .iter()
+    .map(|&x| x.into())
+    .collect::<Vec<String>>();
     println!("{:?}", command_line_flags);
 
-    assert!(test_cases.iter().all(
-        |ref x| command_line_flags.contains(x),
-    ));
-
+    assert!(test_cases
+        .iter()
+        .all(|ref x| command_line_flags.contains(x),));
 }
diff --git a/third_party/rust/bindgen/src/main.rs b/third_party/rust/bindgen/src/main.rs
index a0e0f6bff8e5..5e22b1e6bc9b 100644
--- a/third_party/rust/bindgen/src/main.rs
+++ b/third_party/rust/bindgen/src/main.rs
@@ -45,7 +45,6 @@ pub fn main() {
 
     match builder_from_flags(bind_args.into_iter()) {
         Ok((builder, output, verbose)) => {
-
             let builder_result = panic::catch_unwind(|| {
                 builder.generate().expect("Unable to generate bindings")
             });
@@ -71,12 +70,12 @@ fn print_verbose_err() {
     println!("Bindgen unexpectedly panicked");
     println!(
         "This may be caused by one of the known-unsupported \
-              things (https://github.com/rust-lang-nursery/rust-bindgen#c), \
-              please modify the bindgen flags to work around it as \
-              described in https://github.com/rust-lang-nursery/rust-bindgen#c"
+         things (https://rust-lang.github.io/rust-bindgen/cpp.html), \
+         please modify the bindgen flags to work around it as \
+         described in https://rust-lang.github.io/rust-bindgen/cpp.html"
     );
     println!(
         "Otherwise, please file an issue at \
-              https://github.com/rust-lang-nursery/rust-bindgen/issues/new"
+         https://github.com/rust-lang/rust-bindgen/issues/new"
     );
 }
diff --git a/third_party/rust/bindgen/src/options.rs b/third_party/rust/bindgen/src/options.rs
index 64de93cc4306..6ead924141b2 100644
--- a/third_party/rust/bindgen/src/options.rs
+++ b/third_party/rust/bindgen/src/options.rs
@@ -1,14 +1,12 @@
-use bindgen::{Builder, CodegenConfig, RUST_TARGET_STRINGS, RustTarget, builder, EnumVariation};
+use bindgen::{builder, Builder, CodegenConfig, EnumVariation, RustTarget, RUST_TARGET_STRINGS};
 use clap::{App, Arg};
 use std::fs::File;
-use std::io::{self, Error, ErrorKind, Write, stderr};
+use std::io::{self, stderr, Error, ErrorKind, Write};
 use std::path::PathBuf;
 use std::str::FromStr;
 
 /// Construct a new [`Builder`](./struct.Builder.html) from command line flags.
-pub fn builder_from_flags<I>(
-    args: I,
-) -> Result<(Builder, Box<io::Write>, bool), io::Error>
+pub fn builder_from_flags<I>(args: I) -> Result<(Builder, Box<dyn io::Write>, bool), io::Error>
 where
     I: Iterator<Item = String>,
 {
@@ -31,12 +29,20 @@ where
                 .help("The default style of code used to generate enums.")
                 .value_name("variant")
                 .default_value("consts")
-                .possible_values(&["consts", "moduleconsts", "bitfield", "rust"])
+                .possible_values(&[
+                    "consts",
+                    "moduleconsts",
+                    "bitfield",
+                    "rust",
+                    "rust_non_exhaustive",
+                ])
                 .multiple(false),
             Arg::with_name("bitfield-enum")
                 .long("bitfield-enum")
-                .help("Mark any enum whose name matches <regex> as a set of \
-                       bitfield flags.")
+                .help(
+                    "Mark any enum whose name matches <regex> as a set of \
+                     bitfield flags.",
+                )
                 .value_name("regex")
                 .takes_value(true)
                 .multiple(true)
@@ -50,16 +56,20 @@ where
                 .number_of_values(1),
             Arg::with_name("constified-enum")
                 .long("constified-enum")
-                .help("Mark any enum whose name matches <regex> as a series of \
-                       constants.")
+                .help(
+                    "Mark any enum whose name matches <regex> as a series of \
+                     constants.",
+                )
                 .value_name("regex")
                 .takes_value(true)
                 .multiple(true)
                 .number_of_values(1),
             Arg::with_name("constified-enum-module")
                 .long("constified-enum-module")
-                .help("Mark any enum whose name matches <regex> as a module of \
-                       constants.")
+                .help(
+                    "Mark any enum whose name matches <regex> as a module of \
+                     constants.",
+                )
                 .value_name("regex")
                 .takes_value(true)
                 .multiple(true)
@@ -98,14 +108,16 @@ where
                 .long("no-derive-default")
                 .hidden(true)
                 .help("Avoid deriving Default on any type."),
-            Arg::with_name("impl-debug")
-                .long("impl-debug")
-                .help("Create Debug implementation, if it can not be derived \
-                       automatically."),
+            Arg::with_name("impl-debug").long("impl-debug").help(
+                "Create Debug implementation, if it can not be derived \
+                 automatically.",
+            ),
             Arg::with_name("impl-partialeq")
                 .long("impl-partialeq")
-                .help("Create PartialEq implementation, if it can not be derived \
-                       automatically."),
+                .help(
+                    "Create PartialEq implementation, if it can not be derived \
+                     automatically.",
+                ),
             Arg::with_name("with-derive-default")
                 .long("with-derive-default")
                 .help("Derive Default on any type."),
@@ -120,22 +132,30 @@ where
                 .help("Derive partialord on any type."),
             Arg::with_name("with-derive-eq")
                 .long("with-derive-eq")
-                .help("Derive eq on any type. Enable this option also \
-                       enables --with-derive-partialeq"),
+                .help(
+                    "Derive eq on any type. Enable this option also \
+                     enables --with-derive-partialeq",
+                ),
             Arg::with_name("with-derive-ord")
                 .long("with-derive-ord")
-                .help("Derive ord on any type. Enable this option also \
-                       enables --with-derive-partialord"),
+                .help(
+                    "Derive ord on any type. Enable this option also \
+                     enables --with-derive-partialord",
+                ),
             Arg::with_name("no-doc-comments")
                 .long("no-doc-comments")
-                .help("Avoid including doc comments in the output, see: \
-                      https://github.com/rust-lang-nursery/rust-bindgen/issues/426"),
+                .help(
+                    "Avoid including doc comments in the output, see: \
+                     https://github.com/rust-lang/rust-bindgen/issues/426",
+                ),
             Arg::with_name("no-recursive-whitelist")
                 .long("no-recursive-whitelist")
-                .help("Disable whitelisting types recursively. This will cause \
-                       bindgen to emit Rust code that won't compile! See the \
-                       `bindgen::Builder::whitelist_recursively` method's \
-                       documentation for details."),
+                .help(
+                    "Disable whitelisting types recursively. This will cause \
+                     bindgen to emit Rust code that won't compile! See the \
+                     `bindgen::Builder::whitelist_recursively` method's \
+                     documentation for details.",
+                ),
             Arg::with_name("objc-extern-crate")
                 .long("objc-extern-crate")
                 .help("Use extern crate instead of use for objc."),
@@ -148,23 +168,23 @@ where
             Arg::with_name("distrust-clang-mangling")
                 .long("distrust-clang-mangling")
                 .help("Do not trust the libclang-provided mangling"),
-            Arg::with_name("builtins")
-                .long("builtins")
-                .help("Output bindings for builtin definitions, e.g. \
-                       __builtin_va_list."),
+            Arg::with_name("builtins").long("builtins").help(
+                "Output bindings for builtin definitions, e.g. \
+                 __builtin_va_list.",
+            ),
             Arg::with_name("ctypes-prefix")
                 .long("ctypes-prefix")
-                .help("Use the given prefix before raw types instead of \
-                      ::std::os::raw.")
+                .help(
+                    "Use the given prefix before raw types instead of \
+                     ::std::os::raw.",
+                )
                 .value_name("prefix")
                 .takes_value(true),
             Arg::with_name("time-phases")
                 .long("time-phases")
                 .help("Time the different bindgen phases and print to stderr"),
             // All positional arguments after the end of options marker, `--`
-            Arg::with_name("clang-args")
-                .last(true)
-                .multiple(true),
+            Arg::with_name("clang-args").last(true).multiple(true),
             Arg::with_name("emit-clang-ast")
                 .long("emit-clang-ast")
                 .help("Output the Clang AST for debugging purposes."),
@@ -181,18 +201,24 @@ where
                 .help("Enable support for C++ namespaces."),
             Arg::with_name("disable-name-namespacing")
                 .long("disable-name-namespacing")
-                .help("Disable namespacing via mangling, causing bindgen to \
-                       generate names like \"Baz\" instead of \"foo_bar_Baz\" \
-                       for an input name \"foo::bar::Baz\"."),
+                .help(
+                    "Disable namespacing via mangling, causing bindgen to \
+                     generate names like \"Baz\" instead of \"foo_bar_Baz\" \
+                     for an input name \"foo::bar::Baz\".",
+                ),
             Arg::with_name("ignore-functions")
                 .long("ignore-functions")
-                .help("Do not generate bindings for functions or methods. This \
-                       is useful when you only care about struct layouts."),
+                .help(
+                    "Do not generate bindings for functions or methods. This \
+                     is useful when you only care about struct layouts.",
+                ),
             Arg::with_name("generate")
                 .long("generate")
-                .help("Generate only given items, split by commas. \
-                       Valid values are \"functions\",\"types\", \"vars\", \
-                       \"methods\", \"constructors\" and \"destructors\".")
+                .help(
+                    "Generate only given items, split by commas. \
+                     Valid values are \"functions\",\"types\", \"vars\", \
+                     \"methods\", \"constructors\" and \"destructors\".",
+                )
                 .takes_value(true),
             Arg::with_name("ignore-methods")
                 .long("ignore-methods")
@@ -237,16 +263,20 @@ where
                 .help("Use types from Rust core instead of std."),
             Arg::with_name("conservative-inline-namespaces")
                 .long("conservative-inline-namespaces")
-                .help("Conservatively generate inline namespaces to avoid name \
-                       conflicts."),
+                .help(
+                    "Conservatively generate inline namespaces to avoid name \
+                     conflicts.",
+                ),
             Arg::with_name("use-msvc-mangling")
                 .long("use-msvc-mangling")
                 .help("MSVC C++ ABI mangling. DEPRECATED: Has no effect."),
             Arg::with_name("whitelist-function")
                 .long("whitelist-function")
-                .help("Whitelist all the free-standing functions matching \
-                       <regex>. Other non-whitelisted functions will not be \
-                       generated.")
+                .help(
+                    "Whitelist all the free-standing functions matching \
+                     <regex>. Other non-whitelisted functions will not be \
+                     generated.",
+                )
                 .value_name("regex")
                 .takes_value(true)
                 .multiple(true)
@@ -256,17 +286,21 @@ where
                 .help("Generate inline functions."),
             Arg::with_name("whitelist-type")
                 .long("whitelist-type")
-                .help("Only generate types matching <regex>. Other non-whitelisted types will \
-                       not be generated.")
+                .help(
+                    "Only generate types matching <regex>. Other non-whitelisted types will \
+                     not be generated.",
+                )
                 .value_name("regex")
                 .takes_value(true)
                 .multiple(true)
                 .number_of_values(1),
             Arg::with_name("whitelist-var")
                 .long("whitelist-var")
-                .help("Whitelist all the free-standing variables matching \
-                       <regex>. Other non-whitelisted variables will not be \
-                       generated.")
+                .help(
+                    "Whitelist all the free-standing variables matching \
+                     <regex>. Other non-whitelisted variables will not be \
+                     generated.",
+                )
                 .value_name("regex")
                 .takes_value(true)
                 .multiple(true)
@@ -276,27 +310,35 @@ where
                 .help("Print verbose error messages."),
             Arg::with_name("dump-preprocessed-input")
                 .long("dump-preprocessed-input")
-                .help("Preprocess and dump the input header files to disk. \
-                       Useful when debugging bindgen, using C-Reduce, or when \
-                       filing issues. The resulting file will be named \
-                       something like `__bindgen.i` or `__bindgen.ii`."),
+                .help(
+                    "Preprocess and dump the input header files to disk. \
+                     Useful when debugging bindgen, using C-Reduce, or when \
+                     filing issues. The resulting file will be named \
+                     something like `__bindgen.i` or `__bindgen.ii`.",
+                ),
             Arg::with_name("no-record-matches")
                 .long("no-record-matches")
-                .help("Do not record matching items in the regex sets. \
-                      This disables reporting of unused items."),
+                .help(
+                    "Do not record matching items in the regex sets. \
+                     This disables reporting of unused items.",
+                ),
             Arg::with_name("no-rustfmt-bindings")
                 .long("no-rustfmt-bindings")
                 .help("Do not format the generated bindings with rustfmt."),
             Arg::with_name("rustfmt-bindings")
                 .long("rustfmt-bindings")
-                .help("Format the generated bindings with rustfmt. DEPRECATED: \
-                       --rustfmt-bindings is now enabled by default. Disable \
-                       with --no-rustfmt-bindings."),
+                .help(
+                    "Format the generated bindings with rustfmt. DEPRECATED: \
+                     --rustfmt-bindings is now enabled by default. Disable \
+                     with --no-rustfmt-bindings.",
+                ),
             Arg::with_name("rustfmt-configuration-file")
                 .long("rustfmt-configuration-file")
-                .help("The absolute path to the rustfmt configuration file. \
-                       The configuration file will be used for formatting the bindings. \
-                       This parameter is incompatible with --no-rustfmt-bindings.")
+                .help(
+                    "The absolute path to the rustfmt configuration file. \
+                     The configuration file will be used for formatting the bindings. \
+                     This parameter is incompatible with --no-rustfmt-bindings.",
+                )
                 .value_name("path")
                 .takes_value(true)
                 .multiple(false)
@@ -324,8 +366,13 @@ where
                 .number_of_values(1),
             Arg::with_name("enable-function-attribute-detection")
                 .long("enable-function-attribute-detection")
-                .help("Enables detecting unexposed attributes in functions (slow).
-                       Used to generate #[must_use] annotations."),
+                .help(
+                    "Enables detecting unexposed attributes in functions (slow).
+                       Used to generate #[must_use] annotations.",
+                ),
+            Arg::with_name("use-array-pointers-in-arguments")
+                .long("use-array-pointers-in-arguments")
+                .help("Use `*const [T; size]` instead of `*const T` for C arrays"),
         ]) // .args()
         .get_matches_from(args);
 
@@ -342,7 +389,8 @@ where
         writeln!(
             &mut stderr(),
             "warning: the `--unstable-rust` option is deprecated"
-        ).expect("Unable to write error message");
+        )
+        .expect("Unable to write error message");
     }
 
     if let Some(rust_target) = matches.value_of("rust-target") {
@@ -458,6 +506,10 @@ where
         builder = builder.time_phases(true);
     }
 
+    if matches.is_present("use-array-pointers-in-arguments") {
+        builder = builder.array_pointers_in_arguments(true);
+    }
+
     if let Some(prefix) = matches.value_of("ctypes-prefix") {
         builder = builder.ctypes_prefix(prefix);
     }
@@ -593,9 +645,9 @@ where
 
     let output = if let Some(path) = matches.value_of("output") {
         let file = File::create(path)?;
-        Box::new(io::BufWriter::new(file)) as Box<io::Write>
+        Box::new(io::BufWriter::new(file)) as Box<dyn io::Write>
     } else {
-        Box::new(io::BufWriter::new(io::stdout())) as Box<io::Write>
+        Box::new(io::BufWriter::new(io::stdout())) as Box<dyn io::Write>
     };
 
     if matches.is_present("dump-preprocessed-input") {
@@ -617,7 +669,7 @@ where
         if no_rustfmt_bindings {
             return Err(Error::new(
                 ErrorKind::Other,
-                "Cannot supply both --rustfmt-configuration-file and --no-rustfmt-bindings"
+                "Cannot supply both --rustfmt-configuration-file and --no-rustfmt-bindings",
             ));
         }
 
diff --git a/third_party/rust/bindgen/src/time.rs b/third_party/rust/bindgen/src/time.rs
index 5bd0da8d61da..c13a640c4664 100644
--- a/third_party/rust/bindgen/src/time.rs
+++ b/third_party/rust/bindgen/src/time.rs
@@ -1,6 +1,5 @@
 use std::io::{self, Write};
-use std::time::{Instant, Duration};
-
+use std::time::{Duration, Instant};
 
 /// RAII timer to measure how long phases take.
 #[derive(Debug)]
@@ -10,7 +9,6 @@ pub struct Timer<'a> {
     start: Instant,
 }
 
-
 impl<'a> Timer<'a> {
     /// Creates a Timer with the given name, and starts it. By default,
     /// will print to stderr when it is `drop`'d
@@ -18,7 +16,7 @@ impl<'a> Timer<'a> {
         Timer {
             output: true,
             name,
-            start: Instant::now()
+            start: Instant::now(),
         }
     }
 
@@ -37,19 +35,16 @@ impl<'a> Timer<'a> {
     fn print_elapsed(&mut self) {
         if self.output {
             let elapsed = self.elapsed();
-            let time = (elapsed.as_secs() as f64) * 1e3
-                       + (elapsed.subsec_nanos() as f64) / 1e6;
+            let time = (elapsed.as_secs() as f64) * 1e3 +
+                (elapsed.subsec_nanos() as f64) / 1e6;
             let stderr = io::stderr();
             // Arbitrary output format, subject to change.
-            writeln!(stderr.lock(),
-                     "  time: {:>9.3} ms.\t{}",
-                     time, self.name)
-                     .expect("timer write should not fail");
+            writeln!(stderr.lock(), "  time: {:>9.3} ms.\t{}", time, self.name)
+                .expect("timer write should not fail");
         }
     }
 }
 
-
 impl<'a> Drop for Timer<'a> {
     fn drop(&mut self) {
         self.print_elapsed();
diff --git a/third_party/rust/rustc-hash/.cargo-checksum.json b/third_party/rust/rustc-hash/.cargo-checksum.json
new file mode 100644
index 000000000000..70e1cdf5f6fa
--- /dev/null
+++ b/third_party/rust/rustc-hash/.cargo-checksum.json
@@ -0,0 +1 @@
+{"files":{"CODE_OF_CONDUCT.md":"edca092fde496419a9f1ba640048aa0270b62dfea576cd3175f0b53e3c230470","Cargo.toml":"5bb0914fd92b42e6b7f032bfc4dd238979e5c7e505c7b5e5530c11ab441ad941","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"23f18e03dc49df91622fe2a76176497404e46ced8a715d9d2b67a7446571cca3","README.md":"f2e2a279de9cc138952f50954ea95b17f567ac21c3ae1dbcaa12a21f48dbbf31","src/lib.rs":"91e3e3cf488d5ddffaa935996575750837a1acc636d0d747f7127e5e71f458fd"},"package":"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8"}
\ No newline at end of file
diff --git a/third_party/rust/rustc-hash/CODE_OF_CONDUCT.md b/third_party/rust/rustc-hash/CODE_OF_CONDUCT.md
new file mode 100644
index 000000000000..d70b2b52aca1
--- /dev/null
+++ b/third_party/rust/rustc-hash/CODE_OF_CONDUCT.md
@@ -0,0 +1,40 @@
+# The Rust Code of Conduct
+
+A version of this document [can be found online](https://www.rust-lang.org/conduct.html).
+
+## Conduct
+
+**Contact**: [rust-mods@rust-lang.org](mailto:rust-mods@rust-lang.org)
+
+* We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic.
+* On IRC, please avoid using overtly sexual nicknames or other nicknames that might detract from a friendly, safe and welcoming environment for all.
+* Please be kind and courteous. There's no need to be mean or rude.
+* Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer.
+* Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works.
+* We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behavior. We interpret the term "harassment" as including the definition in the <a href="http://citizencodeofconduct.org/">Citizen Code of Conduct</a>; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups.
+* Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact one of the channel ops or any of the [Rust moderation team][mod_team] immediately. Whether you're a regular contributor or a newcomer, we care about making this community a safe place for you and we've got your back.
+* Likewise any spamming, trolling, flaming, baiting or other attention-stealing behavior is not welcome.
+
+## Moderation
+
+
+These are the policies for upholding our community's standards of conduct. If you feel that a thread needs moderation, please contact the [Rust moderation team][mod_team].
+
+1. Remarks that violate the Rust standards of conduct, including hateful, hurtful, oppressive, or exclusionary remarks, are not allowed. (Cursing is allowed, but never targeting another user, and never in a hateful manner.)
+2. Remarks that moderators find inappropriate, whether listed in the code of conduct or not, are also not allowed.
+3. Moderators will first respond to such remarks with a warning.
+4. If the warning is unheeded, the user will be "kicked," i.e., kicked out of the communication channel to cool off.
+5. If the user comes back and continues to make trouble, they will be banned, i.e., indefinitely excluded.
+6. Moderators may choose at their discretion to un-ban the user if it was a first offense and they offer the offended party a genuine apology.
+7. If a moderator bans someone and you think it was unjustified, please take it up with that moderator, or with a different moderator, **in private**. Complaints about bans in-channel are not allowed.
+8. Moderators are held to a higher standard than other community members. If a moderator creates an inappropriate situation, they should expect less leeway than others.
+
+In the Rust community we strive to go the extra step to look out for each other. Don't just aim to be technically unimpeachable, try to be your best self. In particular, avoid flirting with offensive or sensitive issues, particularly if they're off-topic; this all too often leads to unnecessary fights, hurt feelings, and damaged trust; worse, it can drive people away from the community entirely.
+
+And if someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was they complained about and apologize. Even if you feel you were misinterpreted or unfairly accused, chances are good there was something you could've communicated better ‚Äî remember that it's your responsibility to make your fellow Rustaceans comfortable. Everyone wants to get along and we are all here first and foremost because we want to talk about cool technology. You will find that people will be eager to assume good intent and forgive as long as you earn their trust.
+
+The enforcement policies listed above apply to all official Rust venues; including official IRC channels (#rust, #rust-internals, #rust-tools, #rust-libs, #rustc, #rust-beginners, #rust-docs, #rust-community, #rust-lang, and #cargo); GitHub repositories under rust-lang, rust-lang-nursery, and rust-lang-deprecated; and all forums under rust-lang.org (users.rust-lang.org, internals.rust-lang.org). For other projects adopting the Rust Code of Conduct, please contact the maintainers of those projects for enforcement. If you wish to use this code of conduct for your own project, consider explicitly mentioning your moderation policy or making a copy with your own moderation policy so as to avoid confusion.
+
+*Adapted from the [Node.js Policy on Trolling](http://blog.izs.me/post/30036893703/policy-on-trolling) as well as the [Contributor Covenant v1.3.0](https://www.contributor-covenant.org/version/1/3/0/).*
+
+[mod_team]: https://www.rust-lang.org/team.html#Moderation-team
diff --git a/third_party/rust/which/Cargo.toml b/third_party/rust/rustc-hash/Cargo.toml
similarity index 55%
rename from third_party/rust/which/Cargo.toml
rename to third_party/rust/rustc-hash/Cargo.toml
index e93d3cb98149..524239ff5dfd 100644
--- a/third_party/rust/which/Cargo.toml
+++ b/third_party/rust/rustc-hash/Cargo.toml
@@ -11,16 +11,13 @@
 # will likely look very different (and much more reasonable)
 
 [package]
-name = "which"
-version = "1.0.3"
-authors = ["fangyuanziti <tiziyuanfang@gmail.com>"]
-description = "A Rust equivalent of Unix command \"which\". Locate installed execuable in cross platforms."
+name = "rustc-hash"
+version = "1.0.1"
+authors = ["The Rust Project Developers"]
+description = "speed, non-cryptographic hash used in rustc"
 readme = "README.md"
-keywords = ["which", "which-rs", "unix", "command"]
-categories = ["os", "filesystem"]
-license = "MIT"
-repository = "https://github.com/fangyuanziti/which-rs.git"
-[dependencies.libc]
-version = "0.2.10"
-[dev-dependencies.tempdir]
-version = "0.3.4"
+keywords = ["hash", "fxhash", "rustc"]
+license = "Apache-2.0/MIT"
+repository = "https://github.com/rust-lang-nursery/rustc-hash"
+[dependencies.byteorder]
+version = "1.1"
diff --git a/third_party/rust/rustc-hash/LICENSE-APACHE b/third_party/rust/rustc-hash/LICENSE-APACHE
new file mode 100644
index 000000000000..16fe87b06e80
--- /dev/null
+++ b/third_party/rust/rustc-hash/LICENSE-APACHE
@@ -0,0 +1,201 @@
+                              Apache License
+                        Version 2.0, January 2004
+                     http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+   "License" shall mean the terms and conditions for use, reproduction,
+   and distribution as defined by Sections 1 through 9 of this document.
+
+   "Licensor" shall mean the copyright owner or entity authorized by
+   the copyright owner that is granting the License.
+
+   "Legal Entity" shall mean the union of the acting entity and all
+   other entities that control, are controlled by, or are under common
+   control with that entity. For the purposes of this definition,
+   "control" means (i) the power, direct or indirect, to cause the
+   direction or management of such entity, whether by contract or
+   otherwise, or (ii) ownership of fifty percent (50%) or more of the
+   outstanding shares, or (iii) beneficial ownership of such entity.
+
+   "You" (or "Your") shall mean an individual or Legal Entity
+   exercising permissions granted by this License.
+
+   "Source" form shall mean the preferred form for making modifications,
+   including but not limited to software source code, documentation
+   source, and configuration files.
+
+   "Object" form shall mean any form resulting from mechanical
+   transformation or translation of a Source form, including but
+   not limited to compiled object code, generated documentation,
+   and conversions to other media types.
+
+   "Work" shall mean the work of authorship, whether in Source or
+   Object form, made available under the License, as indicated by a
+   copyright notice that is included in or attached to the work
+   (an example is provided in the Appendix below).
+
+   "Derivative Works" shall mean any work, whether in Source or Object
+   form, that is based on (or derived from) the Work and for which the
+   editorial revisions, annotations, elaborations, or other modifications
+   represent, as a whole, an original work of authorship. For the purposes
+   of this License, Derivative Works shall not include works that remain
+   separable from, or merely link (or bind by name) to the interfaces of,
+   the Work and Derivative Works thereof.
+
+   "Contribution" shall mean any work of authorship, including
+   the original version of the Work and any modifications or additions
+   to that Work or Derivative Works thereof, that is intentionally
+   submitted to Licensor for inclusion in the Work by the copyright owner
+   or by an individual or Legal Entity authorized to submit on behalf of
+   the copyright owner. For the purposes of this definition, "submitted"
+   means any form of electronic, verbal, or written communication sent
+   to the Licensor or its representatives, including but not limited to
+   communication on electronic mailing lists, source code control systems,
+   and issue tracking systems that are managed by, or on behalf of, the
+   Licensor for the purpose of discussing and improving the Work, but
+   excluding communication that is conspicuously marked or otherwise
+   designated in writing by the copyright owner as "Not a Contribution."
+
+   "Contributor" shall mean Licensor and any individual or Legal Entity
+   on behalf of whom a Contribution has been received by Licensor and
+   subsequently incorporated within the Work.
+
+2. Grant of Copyright License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   copyright license to reproduce, prepare Derivative Works of,
+   publicly display, publicly perform, sublicense, and distribute the
+   Work and such Derivative Works in Source or Object form.
+
+3. Grant of Patent License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   (except as stated in this section) patent license to make, have made,
+   use, offer to sell, sell, import, and otherwise transfer the Work,
+   where such license applies only to those patent claims licensable
+   by such Contributor that are necessarily infringed by their
+   Contribution(s) alone or by combination of their Contribution(s)
+   with the Work to which such Contribution(s) was submitted. If You
+   institute patent litigation against any entity (including a
+   cross-claim or counterclaim in a lawsuit) alleging that the Work
+   or a Contribution incorporated within the Work constitutes direct
+   or contributory patent infringement, then any patent licenses
+   granted to You under this License for that Work shall terminate
+   as of the date such litigation is filed.
+
+4. Redistribution. You may reproduce and distribute copies of the
+   Work or Derivative Works thereof in any medium, with or without
+   modifications, and in Source or Object form, provided that You
+   meet the following conditions:
+
+   (a) You must give any other recipients of the Work or
+       Derivative Works a copy of this License; and
+
+   (b) You must cause any modified files to carry prominent notices
+       stating that You changed the files; and
+
+   (c) You must retain, in the Source form of any Derivative Works
+       that You distribute, all copyright, patent, trademark, and
+       attribution notices from the Source form of the Work,
+       excluding those notices that do not pertain to any part of
+       the Derivative Works; and
+
+   (d) If the Work includes a "NOTICE" text file as part of its
+       distribution, then any Derivative Works that You distribute must
+       include a readable copy of the attribution notices contained
+       within such NOTICE file, excluding those notices that do not
+       pertain to any part of the Derivative Works, in at least one
+       of the following places: within a NOTICE text file distributed
+       as part of the Derivative Works; within the Source form or
+       documentation, if provided along with the Derivative Works; or,
+       within a display generated by the Derivative Works, if and
+       wherever such third-party notices normally appear. The contents
+       of the NOTICE file are for informational purposes only and
+       do not modify the License. You may add Your own attribution
+       notices within Derivative Works that You distribute, alongside
+       or as an addendum to the NOTICE text from the Work, provided
+       that such additional attribution notices cannot be construed
+       as modifying the License.
+
+   You may add Your own copyright statement to Your modifications and
+   may provide additional or different license terms and conditions
+   for use, reproduction, or distribution of Your modifications, or
+   for any such Derivative Works as a whole, provided Your use,
+   reproduction, and distribution of the Work otherwise complies with
+   the conditions stated in this License.
+
+5. Submission of Contributions. Unless You explicitly state otherwise,
+   any Contribution intentionally submitted for inclusion in the Work
+   by You to the Licensor shall be under the terms and conditions of
+   this License, without any additional terms or conditions.
+   Notwithstanding the above, nothing herein shall supersede or modify
+   the terms of any separate license agreement you may have executed
+   with Licensor regarding such Contributions.
+
+6. Trademarks. This License does not grant permission to use the trade
+   names, trademarks, service marks, or product names of the Licensor,
+   except as required for reasonable and customary use in describing the
+   origin of the Work and reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty. Unless required by applicable law or
+   agreed to in writing, Licensor provides the Work (and each
+   Contributor provides its Contributions) on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+   implied, including, without limitation, any warranties or conditions
+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+   PARTICULAR PURPOSE. You are solely responsible for determining the
+   appropriateness of using or redistributing the Work and assume any
+   risks associated with Your exercise of permissions under this License.
+
+8. Limitation of Liability. In no event and under no legal theory,
+   whether in tort (including negligence), contract, or otherwise,
+   unless required by applicable law (such as deliberate and grossly
+   negligent acts) or agreed to in writing, shall any Contributor be
+   liable to You for damages, including any direct, indirect, special,
+   incidental, or consequential damages of any character arising as a
+   result of this License or out of the use or inability to use the
+   Work (including but not limited to damages for loss of goodwill,
+   work stoppage, computer failure or malfunction, or any and all
+   other commercial damages or losses), even if such Contributor
+   has been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability. While redistributing
+   the Work or Derivative Works thereof, You may choose to offer,
+   and charge a fee for, acceptance of support, warranty, indemnity,
+   or other liability obligations and/or rights consistent with this
+   License. However, in accepting such obligations, You may act only
+   on Your own behalf and on Your sole responsibility, not on behalf
+   of any other Contributor, and only if You agree to indemnify,
+   defend, and hold each Contributor harmless for any liability
+   incurred by, or claims asserted against, such Contributor by reason
+   of your accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
+
+APPENDIX: How to apply the Apache License to your work.
+
+   To apply the Apache License to your work, attach the following
+   boilerplate notice, with the fields enclosed by brackets "[]"
+   replaced with your own identifying information. (Don't include
+   the brackets!)  The text should be enclosed in the appropriate
+   comment syntax for the file format. We also recommend that a
+   file or class name and description of purpose be included on the
+   same "printed page" as the copyright notice for easier
+   identification within third-party archives.
+
+Copyright [yyyy] [name of copyright owner]
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+	http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/third_party/rust/rustc-hash/LICENSE-MIT b/third_party/rust/rustc-hash/LICENSE-MIT
new file mode 100644
index 000000000000..31aa79387f27
--- /dev/null
+++ b/third_party/rust/rustc-hash/LICENSE-MIT
@@ -0,0 +1,23 @@
+Permission is hereby granted, free of charge, to any
+person obtaining a copy of this software and associated
+documentation files (the "Software"), to deal in the
+Software without restriction, including without
+limitation the rights to use, copy, modify, merge,
+publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software
+is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice
+shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
diff --git a/third_party/rust/rustc-hash/README.md b/third_party/rust/rustc-hash/README.md
new file mode 100644
index 000000000000..4be00a8c034a
--- /dev/null
+++ b/third_party/rust/rustc-hash/README.md
@@ -0,0 +1,21 @@
+# rustc-hash
+
+A speedy hash algorithm used within rustc. The hashmap in liballoc by
+default uses SipHash which isn't quite as speedy as we want. In the
+compiler we're not really worried about DOS attempts, so we use a fast
+non-cryptographic hash.
+
+This is the same as the algorithm used by Firefox -- which is a
+homespun one not based on any widely-known algorithm -- though
+modified to produce 64-bit hash values instead of 32-bit hash
+values. It consistently out-performs an FNV-based hash within rustc
+itself -- the collision rate is similar or slightly worse than FNV,
+but the speed of the hash function itself is much higher because it
+works on up to 8 bytes at a time.
+
+## Usage
+
+```
+use rustc_hash::FxHashMap;
+let map: FxHashMap<u32, u32> = FxHashMap::default();
+```
diff --git a/third_party/rust/rustc-hash/src/lib.rs b/third_party/rust/rustc-hash/src/lib.rs
new file mode 100644
index 000000000000..b3875cca9bf4
--- /dev/null
+++ b/third_party/rust/rustc-hash/src/lib.rs
@@ -0,0 +1,136 @@
+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT
+// file at the top-level directory of this distribution and at
+// http://rust-lang.org/COPYRIGHT.
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+//! Fast, non-cryptographic hash used by rustc and Firefox.
+//!
+//! # Example
+//!
+//! ```rust
+//! use rustc_hash::FxHashMap;
+//! let mut map: FxHashMap<u32, u32> = FxHashMap::default();
+//! map.insert(22, 44);
+//! ```
+
+extern crate byteorder;
+
+use std::collections::{HashMap, HashSet};
+use std::default::Default;
+use std::hash::{Hasher, BuildHasherDefault};
+use std::ops::BitXor;
+use std::mem::size_of;
+
+use byteorder::{ByteOrder, NativeEndian};
+
+/// Type alias for a hashmap using the `fx` hash algorithm.
+pub type FxHashMap<K, V> = HashMap<K, V, BuildHasherDefault<FxHasher>>;
+
+/// Type alias for a hashmap using the `fx` hash algorithm.
+pub type FxHashSet<V> = HashSet<V, BuildHasherDefault<FxHasher>>;
+
+/// A speedy hash algorithm for use within rustc. The hashmap in liballoc
+/// by default uses SipHash which isn't quite as speedy as we want. In the
+/// compiler we're not really worried about DOS attempts, so we use a fast
+/// non-cryptographic hash.
+///
+/// This is the same as the algorithm used by Firefox -- which is a homespun
+/// one not based on any widely-known algorithm -- though modified to produce
+/// 64-bit hash values instead of 32-bit hash values. It consistently
+/// out-performs an FNV-based hash within rustc itself -- the collision rate is
+/// similar or slightly worse than FNV, but the speed of the hash function
+/// itself is much higher because it works on up to 8 bytes at a time.
+pub struct FxHasher {
+    hash: usize
+}
+
+#[cfg(target_pointer_width = "32")]
+const K: usize = 0x9e3779b9;
+#[cfg(target_pointer_width = "64")]
+const K: usize = 0x517cc1b727220a95;
+
+impl Default for FxHasher {
+    #[inline]
+    fn default() -> FxHasher {
+        FxHasher { hash: 0 }
+    }
+}
+
+impl FxHasher {
+    #[inline]
+    fn add_to_hash(&mut self, i: usize) {
+        self.hash = self.hash.rotate_left(5).bitxor(i).wrapping_mul(K);
+    }
+}
+
+impl Hasher for FxHasher {
+    #[inline]
+    fn write(&mut self, mut bytes: &[u8]) {
+        #[cfg(target_pointer_width = "32")]
+        let read_usize = |bytes| NativeEndian::read_u32(bytes);
+        #[cfg(target_pointer_width = "64")]
+        let read_usize = |bytes| NativeEndian::read_u64(bytes);
+
+        let mut hash = FxHasher { hash: self.hash };
+        assert!(size_of::<usize>() <= 8);
+        while bytes.len() >= size_of::<usize>() {
+            hash.add_to_hash(read_usize(bytes) as usize);
+            bytes = &bytes[size_of::<usize>()..];
+        }
+        if (size_of::<usize>() > 4) && (bytes.len() >= 4) {
+            hash.add_to_hash(NativeEndian::read_u32(bytes) as usize);
+            bytes = &bytes[4..];
+        }
+        if (size_of::<usize>() > 2) && bytes.len() >= 2 {
+            hash.add_to_hash(NativeEndian::read_u16(bytes) as usize);
+            bytes = &bytes[2..];
+        }
+        if (size_of::<usize>() > 1) && bytes.len() >= 1 {
+            hash.add_to_hash(bytes[0] as usize);
+        }
+        self.hash = hash.hash;
+    }
+
+    #[inline]
+    fn write_u8(&mut self, i: u8) {
+        self.add_to_hash(i as usize);
+    }
+
+    #[inline]
+    fn write_u16(&mut self, i: u16) {
+        self.add_to_hash(i as usize);
+    }
+
+    #[inline]
+    fn write_u32(&mut self, i: u32) {
+        self.add_to_hash(i as usize);
+    }
+
+    #[cfg(target_pointer_width = "32")]
+    #[inline]
+    fn write_u64(&mut self, i: u64) {
+        self.add_to_hash(i as usize);
+        self.add_to_hash((i >> 32) as usize);
+    }
+
+    #[cfg(target_pointer_width = "64")]
+    #[inline]
+    fn write_u64(&mut self, i: u64) {
+        self.add_to_hash(i as usize);
+    }
+
+    #[inline]
+    fn write_usize(&mut self, i: usize) {
+        self.add_to_hash(i);
+    }
+
+    #[inline]
+    fn finish(&self) -> u64 {
+        self.hash as u64
+    }
+}
diff --git a/third_party/rust/which/.cargo-checksum.json b/third_party/rust/which/.cargo-checksum.json
deleted file mode 100644
index 791fc7b06c81..000000000000
--- a/third_party/rust/which/.cargo-checksum.json
+++ /dev/null
@@ -1 +0,0 @@
-{"files":{"Cargo.toml":"72267e6b8f7e153fc8adb396837ffd1fd46bf3c5ec51908f830ac92327d812e5","LICENSE.txt":"0041560f5d419c30e1594567f3b7ac2bc078ff6a68f437e0348ba85d9cf99112","README.md":"b300f303f88ca776a8f5f38050ca7c25ce9cc866dcb4a69e414aa1d45c6bed14","src/lib.rs":"4ead66ddef1b6824a656ff1be692b74dc099aae944fbb677352ad2a0c78782d3"},"package":"4be6cfa54dab45266e98b5d7be2f8ce959ddd49abd141a05d52dce4b07f803bb"}
\ No newline at end of file
diff --git a/third_party/rust/which/LICENSE.txt b/third_party/rust/which/LICENSE.txt
deleted file mode 100644
index 369139bbd1ec..000000000000
--- a/third_party/rust/which/LICENSE.txt
+++ /dev/null
@@ -1,19 +0,0 @@
-Copyright (c) 2015 fangyuanziti
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
diff --git a/third_party/rust/which/README.md b/third_party/rust/which/README.md
deleted file mode 100644
index 7394b4a06310..000000000000
--- a/third_party/rust/which/README.md
+++ /dev/null
@@ -1,27 +0,0 @@
-[![Build Status](https://travis-ci.org/fangyuanziti/which-rs.svg?branch=master)](https://travis-ci.org/fangyuanziti/which-rs)
-
-# which
-
-A Rust equivalent of Unix command "which". Locate installed execuable in cross platforms.
-
-## Support platforms
-
-* Linux
-* Windows
-* macOS
-
-## Example
-
-To find which rustc exectable binary is using. Locate installed execuable in cross platforms.
-
-``` rust
-use which::which;
-
-let result = which::which("rustc").unwrap();
-assert_eq!(result, PathBuf::from("/usr/bin/rustc"));
-
-```
-
-## Documentation
-
-The documentation is [available online](https://docs.rs/which/).
diff --git a/third_party/rust/which/src/lib.rs b/third_party/rust/which/src/lib.rs
deleted file mode 100644
index 36cc72929ae4..000000000000
--- a/third_party/rust/which/src/lib.rs
+++ /dev/null
@@ -1,445 +0,0 @@
-//! which
-//!
-//! A Rust equivalent of Unix command `which(1)`.
-//! # Example:
-//!
-//! To find which rustc executable binary is using:
-//!
-//! ``` norun
-//! use which::which;
-//!
-//! let result = which::which("rustc").unwrap();
-//! assert_eq!(result, PathBuf::from("/usr/bin/rustc"));
-//!
-//! ```
-
-extern crate libc;
-#[cfg(test)]
-extern crate tempdir;
-
-use std::ascii::AsciiExt;
-use std::path::{Path,PathBuf};
-use std::{env, fs};
-#[cfg(unix)]
-use std::ffi::CString;
-use std::ffi::OsStr;
-#[cfg(unix)]
-use std::os::unix::ffi::OsStrExt;
-
-/// Like `Path::with_extension`, but don't replace an existing extension.
-fn ensure_exe_extension<T: AsRef<Path>>(path: T) -> PathBuf {
-    if env::consts::EXE_EXTENSION.is_empty() {
-        // Nothing to do.
-        path.as_ref().to_path_buf()
-    } else {
-        match path.as_ref().extension().and_then(|e| e.to_str()).map(|e| e.eq_ignore_ascii_case(env::consts::EXE_EXTENSION)) {
-            // Already has the right extension.
-            Some(true) => path.as_ref().to_path_buf(),
-            _ => {
-                // Append the extension.
-                let mut s = path.as_ref().to_path_buf().into_os_string();
-                s.push(".");
-                s.push(env::consts::EXE_EXTENSION);
-                PathBuf::from(s)
-            }
-        }
-    }
-}
-
-
-/// Find a exectable binary's path by name.
-///
-/// If given an absolute path, returns it if the file exists and is executable.
-///
-/// If given a relative path, returns an absolute path to the file if
-/// it exists and is executable.
-///
-/// If given a string without path separators, looks for a file named
-/// `binary_name` at each directory in `$PATH` and if it finds an executable
-/// file there, returns it.
-///
-/// # Example
-///
-/// ``` norun
-/// use which::which;
-/// use std::path::PathBuf;
-///
-/// let result = which::which("rustc").unwrap();
-/// assert_eq!(result, PathBuf::from("/usr/bin/rustc"));
-///
-/// ```
-pub fn which<T: AsRef<OsStr>>(binary_name: T)
-             -> Result<PathBuf, &'static str> {
-    env::current_dir()
-        .or_else(|_| Err("Couldn't get current directory"))
-        .and_then(|cwd| which_in(binary_name, env::var_os("PATH"), &cwd))
-}
-
-/// Find `binary_name` in the path list `paths`, using `cwd` to resolve relative paths.
-pub fn which_in<T, U, V>(binary_name: T, paths: Option<U>, cwd: V)
-             -> Result<PathBuf, &'static str>
-                where T: AsRef<OsStr>,
-                      U: AsRef<OsStr>,
-                      V: AsRef<Path> {
-    let binary_checker = CompositeChecker::new()
-        .add_checker(Box::new(ExistedChecker::new()))
-        .add_checker(Box::new(ExecutableChecker::new()));
-
-    let finder = Finder::new();
-
-    finder.find(binary_name, paths, cwd, &binary_checker)
-}
-
-struct Finder;
-
-impl Finder {
-    fn new() -> Finder {
-        Finder
-    }
-
-    fn find<T, U, V>(&self, binary_name: T, paths: Option<U>, cwd: V,
-                     binary_checker: &Checker)
-                     -> Result<PathBuf, &'static str>
-        where T: AsRef<OsStr>,
-              U: AsRef<OsStr>,
-              V: AsRef<Path> {
-
-        let path = ensure_exe_extension(binary_name.as_ref());
-
-        // Does it have a path separator?
-        if path.components().count() > 1 {
-            if path.is_absolute() {
-                if binary_checker.is_valid(&path) {
-                    // Already fine.
-                    Ok(path)
-                } else {
-                    // Absolute path but it's not usable.
-                    Err("Bad absolute path")
-                }
-            } else {
-                // Try to make it absolute.
-                let mut new_path = PathBuf::from(cwd.as_ref());
-                new_path.push(path);
-                let new_path = ensure_exe_extension(new_path);
-                if binary_checker.is_valid(&new_path) {
-                    Ok(new_path)
-                } else {
-                    // File doesn't exist or isn't executable.
-                    Err("Bad relative path")
-                }
-            }
-        } else {
-            // No separator, look it up in `paths`.
-            paths.and_then(
-                |paths|
-                env::split_paths(paths.as_ref())
-                    .map(|p| ensure_exe_extension(p.join(binary_name.as_ref())))
-                    .skip_while(|p| !(binary_checker.is_valid(&p)))
-                    .next())
-                .ok_or("Cannot find binary path")
-        }
-    }
-}
-
-
-trait Checker {
-    fn is_valid(&self, path: &Path) -> bool;
-}
-
-struct ExecutableChecker;
-
-impl ExecutableChecker {
-    fn new() -> ExecutableChecker {
-        ExecutableChecker
-    }
-}
-
-impl Checker for ExecutableChecker {
-    #[cfg(unix)]
-    fn is_valid(&self, path: &Path) -> bool {
-        CString::new(path.as_os_str().as_bytes())
-            .and_then(|c| {
-                Ok(unsafe { libc::access(c.as_ptr(), libc::X_OK) == 0 })
-            })
-            .unwrap_or(false)
-    }
-
-    #[cfg(not(unix))]
-    fn is_valid(&self, _path: &Path) -> bool { true }
-}
-
-struct ExistedChecker;
-
-impl ExistedChecker {
-    fn new() -> ExistedChecker {
-        ExistedChecker
-    }
-}
-
-impl Checker for ExistedChecker {
-    fn is_valid(&self, path: &Path) -> bool {
-        fs::metadata(path).map(|metadata|{
-            metadata.is_file()
-        }).unwrap_or(false)
-    }
-}
-
-struct CompositeChecker {
-    checkers: Vec<Box<Checker>>
-}
-
-impl CompositeChecker {
-    fn new() -> CompositeChecker {
-        CompositeChecker {
-            checkers: Vec::new()
-        }
-    }
-
-    fn add_checker(mut self, checker: Box<Checker>) -> CompositeChecker {
-        self.checkers.push(checker);
-        self
-    }
-}
-
-impl Checker for CompositeChecker {
-    fn is_valid(&self, path: &Path) -> bool {
-        self.checkers.iter()
-            .all(|checker| checker.is_valid(path))
-    }
-}
-
-#[test]
-fn test_exe_extension() {
-    let expected = PathBuf::from("foo").with_extension(env::consts::EXE_EXTENSION);
-    assert_eq!(expected, ensure_exe_extension(PathBuf::from("foo")));
-    let p = expected.clone();
-    assert_eq!(expected, ensure_exe_extension(p));
-}
-
-#[test]
-#[cfg(windows)]
-fn test_exe_extension_existing_extension() {
-    assert_eq!(PathBuf::from("foo.bar.exe"),
-               ensure_exe_extension("foo.bar"));
-}
-
-#[test]
-#[cfg(windows)]
-fn test_exe_extension_existing_extension_uppercase() {
-    assert_eq!(PathBuf::from("foo.EXE"),
-               ensure_exe_extension("foo.EXE"));
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-
-    use std::env;
-    use std::ffi::{OsStr,OsString};
-    use std::fs;
-    use std::io;
-    use std::path::{Path,PathBuf};
-    use tempdir::TempDir;
-
-    struct TestFixture {
-        /// Temp directory.
-        pub tempdir: TempDir,
-        /// $PATH
-        pub paths: OsString,
-        /// Binaries created in $PATH
-        pub bins: Vec<PathBuf>,
-    }
-
-    const SUBDIRS: &'static [&'static str] = &["a", "b", "c"];
-    const BIN_NAME: &'static str = "bin";
-
-    #[cfg(unix)]
-    fn mk_bin(dir: &Path, path: &str) -> io::Result<PathBuf> {
-        use libc;
-        use std::os::unix::fs::OpenOptionsExt;
-        let bin = dir.join(path).with_extension(env::consts::EXE_EXTENSION);
-        fs::OpenOptions::new()
-            .write(true)
-            .create(true)
-            .mode(0o666 | (libc::S_IXUSR as u32))
-            .open(&bin)
-            .and_then(|_f| bin.canonicalize())
-    }
-
-    fn touch(dir: &Path, path: &str) -> io::Result<PathBuf> {
-        let b = dir.join(path).with_extension(env::consts::EXE_EXTENSION);
-        fs::File::create(&b)
-            .and_then(|_f| b.canonicalize())
-    }
-
-    #[cfg(not(unix))]
-    fn mk_bin(dir: &Path, path: &str) -> io::Result<PathBuf> {
-        touch(dir, path)
-    }
-
-    impl TestFixture {
-        pub fn new() -> TestFixture {
-            let tempdir = TempDir::new("which_tests").unwrap();
-            let mut builder = fs::DirBuilder::new();
-            builder.recursive(true);
-            let mut paths = vec!();
-            let mut bins = vec!();
-            for d in SUBDIRS.iter() {
-                let p = tempdir.path().join(d);
-                builder.create(&p).unwrap();
-                bins.push(mk_bin(&p, &BIN_NAME).unwrap());
-                paths.push(p);
-            }
-            TestFixture {
-                tempdir: tempdir,
-                paths: env::join_paths(paths).unwrap(),
-                bins: bins,
-            }
-        }
-
-        #[allow(dead_code)]
-        pub fn touch(&self, path: &str) -> io::Result<PathBuf> {
-            touch(self.tempdir.path(), &path)
-        }
-
-        pub fn mk_bin(&self, path: &str) -> io::Result<PathBuf> {
-            mk_bin(self.tempdir.path(), &path)
-        }
-    }
-
-    fn _which<T: AsRef<OsStr>>(f: &TestFixture, path: T) -> Result<PathBuf, &'static str> {
-        which_in(path, Some(f.paths.clone()), f.tempdir.path())
-    }
-
-    #[test]
-    #[cfg(unix)]
-    fn it_works() {
-        use std::process::Command;
-        let result = which("rustc");
-        assert!(result.is_ok());
-
-        let which_result = Command::new("which")
-            .arg("rustc")
-            .output();
-
-        assert_eq!(String::from(result.unwrap().to_str().unwrap()),
-                   String::from_utf8(which_result.unwrap().stdout).unwrap().trim());
-    }
-
-    #[test]
-    fn test_which() {
-        let f = TestFixture::new();
-        assert_eq!(_which(&f, &BIN_NAME).unwrap().canonicalize().unwrap(),
-                   f.bins[0])
-    }
-
-    #[test]
-    fn test_which_extension() {
-        let f = TestFixture::new();
-        let b = Path::new(&BIN_NAME).with_extension(env::consts::EXE_EXTENSION);
-        assert_eq!(_which(&f, &b).unwrap().canonicalize().unwrap(),
-                   f.bins[0])
-    }
-
-    #[test]
-    fn test_which_not_found() {
-        let f = TestFixture::new();
-        assert!(_which(&f, "a").is_err());
-    }
-
-    #[test]
-    fn test_which_second() {
-        let f = TestFixture::new();
-        let b = f.mk_bin("b/another").unwrap();
-        assert_eq!(_which(&f, "another").unwrap().canonicalize().unwrap(), b);
-    }
-
-    #[test]
-    fn test_which_absolute() {
-        let f = TestFixture::new();
-        assert_eq!(_which(&f, &f.bins[1]).unwrap().canonicalize().unwrap(),
-                   f.bins[1].canonicalize().unwrap());
-    }
-
-    #[test]
-    #[cfg(windows)]
-    fn test_which_absolute_path_case() {
-        // Test that an absolute path with an uppercase extension
-        // is accepted.
-        let f = TestFixture::new();
-        let p = f.bins[1].with_extension("EXE");
-        assert_eq!(_which(&f, &p).unwrap().canonicalize().unwrap(),
-                   f.bins[1].canonicalize().unwrap());
-    }
-
-    #[test]
-    fn test_which_absolute_extension() {
-        let f = TestFixture::new();
-        // Don't append EXE_EXTENSION here.
-        let b = f.bins[1].parent().unwrap().join(&BIN_NAME);
-        assert_eq!(_which(&f, &b).unwrap().canonicalize().unwrap(),
-                   f.bins[1].canonicalize().unwrap());
-    }
-
-    #[test]
-    fn test_which_relative() {
-        let f = TestFixture::new();
-        assert_eq!(_which(&f, "b/bin").unwrap().canonicalize().unwrap(),
-                   f.bins[1].canonicalize().unwrap());
-    }
-
-    #[test]
-    fn test_which_relative_extension() {
-        // test_which_relative tests a relative path without an extension,
-        // so test a relative path with an extension here.
-        let f = TestFixture::new();
-        let b = Path::new("b/bin").with_extension(env::consts::EXE_EXTENSION);
-        assert_eq!(_which(&f, &b).unwrap().canonicalize().unwrap(),
-                   f.bins[1].canonicalize().unwrap());
-    }
-
-    #[test]
-    #[cfg(windows)]
-    fn test_which_relative_extension_case() {
-        // Test that a relative path with an uppercase extension
-        // is accepted.
-        let f = TestFixture::new();
-        let b = Path::new("b/bin").with_extension("EXE");
-        assert_eq!(_which(&f, &b).unwrap().canonicalize().unwrap(),
-                   f.bins[1].canonicalize().unwrap());
-    }
-
-    #[test]
-    fn test_which_relative_leading_dot() {
-        let f = TestFixture::new();
-        assert_eq!(_which(&f, "./b/bin").unwrap().canonicalize().unwrap(),
-                   f.bins[1].canonicalize().unwrap());
-    }
-
-    #[test]
-    #[cfg(unix)]
-    fn test_which_non_executable() {
-        // Shouldn't return non-executable files.
-        let f = TestFixture::new();
-        f.touch("b/another").unwrap();
-        assert!(_which(&f, "another").is_err());
-    }
-
-    #[test]
-    #[cfg(unix)]
-    fn test_which_absolute_non_executable() {
-        // Shouldn't return non-executable files, even if given an absolute path.
-        let f = TestFixture::new();
-        let b = f.touch("b/another").unwrap();
-        assert!(_which(&f, &b).is_err());
-    }
-
-    #[test]
-    #[cfg(unix)]
-    fn test_which_relative_non_executable() {
-        // Shouldn't return non-executable files.
-        let f = TestFixture::new();
-        f.touch("b/another").unwrap();
-        assert!(_which(&f, "b/another").is_err());
-    }
-}
